import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod2, isNodeMode, target) => {
  target = mod2 != null ? __create(__getProtoOf(mod2)) : {};
  const to = isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod2))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod2[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod2) => () => (mod2 || cb((mod2 = { exports: {} }).exports, mod2), mod2.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/graphql-request/build/legacy/classes/ClientError.js
var ClientError;
var init_ClientError = __esm(() => {
  ClientError = class ClientError extends Error {
    response;
    request;
    constructor(response, request) {
      const message = `${ClientError.extractMessage(response)}: ${JSON.stringify({
        response,
        request
      })}`;
      super(message);
      Object.setPrototypeOf(this, ClientError.prototype);
      this.response = response;
      this.request = request;
      if (typeof Error.captureStackTrace === `function`) {
        Error.captureStackTrace(this, ClientError);
      }
    }
    static extractMessage(response) {
      return response.errors?.[0]?.message ?? `GraphQL Error (Code: ${String(response.status)})`;
    }
  };
});

// node_modules/graphql-request/build/lib/prelude.js
var uppercase = (str) => str.toUpperCase(), callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
}, zip = (a, b) => a.map((k, i) => [k, b[i]]), HeadersInitToPlainObject = (headers) => {
  let oHeaders = {};
  if (headers instanceof Headers) {
    oHeaders = HeadersInstanceToPlainObject(headers);
  } else if (Array.isArray(headers)) {
    headers.forEach(([name, value]) => {
      if (name && value !== undefined) {
        oHeaders[name] = value;
      }
    });
  } else if (headers) {
    oHeaders = headers;
  }
  return oHeaders;
}, HeadersInstanceToPlainObject = (headers) => {
  const o = {};
  headers.forEach((v, k) => {
    o[k] = v;
  });
  return o;
}, tryCatch = (fn) => {
  try {
    const result = fn();
    if (isPromiseLikeValue(result)) {
      return result.catch((error) => {
        return errorFromMaybeError(error);
      });
    }
    return result;
  } catch (error) {
    return errorFromMaybeError(error);
  }
}, errorFromMaybeError = (maybeError) => {
  if (maybeError instanceof Error)
    return maybeError;
  return new Error(String(maybeError));
}, isPromiseLikeValue = (value) => {
  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;
}, casesExhausted = (value) => {
  throw new Error(`Unhandled case: ${String(value)}`);
}, isPlainObject = (value) => {
  return typeof value === `object` && value !== null && !Array.isArray(value);
};

// node_modules/graphql-request/build/legacy/functions/batchRequests.js
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: undefined
  };
};
var init_batchRequests = __esm(() => {
  init_GraphQLClient();
});

// node_modules/graphql-request/build/legacy/functions/rawRequest.js
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: undefined
  };
};
var init_rawRequest = __esm(() => {
  init_GraphQLClient();
});

// node_modules/graphql/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.versionInfo = exports.version = undefined;
  var version = "16.11.0";
  exports.version = version;
  var versionInfo = Object.freeze({
    major: 16,
    minor: 11,
    patch: 0,
    preReleaseTag: null
  });
  exports.versionInfo = versionInfo;
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.devAssert = devAssert;
  function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  }
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isPromise = isPromise;
  function isPromise(value) {
    return typeof (value === null || value === undefined ? undefined : value.then) === "function";
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isObjectLike = isObjectLike;
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.invariant = invariant;
  function invariant(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message != null ? message : "Unexpected invariant triggered.");
    }
  }
});

// node_modules/graphql/language/location.js
var require_location = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getLocation = getLocation;
  var _invariant = require_invariant();
  var LineRegExp = /\r\n|[\n\r]/g;
  function getLocation(source, position2) {
    let lastLineStart = 0;
    let line = 1;
    for (const match of source.body.matchAll(LineRegExp)) {
      typeof match.index === "number" || (0, _invariant.invariant)(false);
      if (match.index >= position2) {
        break;
      }
      lastLineStart = match.index + match[0].length;
      line += 1;
    }
    return {
      line,
      column: position2 + 1 - lastLineStart
    };
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printLocation = printLocation;
  exports.printSourceLocation = printSourceLocation;
  var _location = require_location();
  function printLocation(location) {
    return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
  }
  function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0;i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line]) => line !== undefined);
    const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
    return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join(`
`);
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLError = undefined;
  exports.formatError = formatError;
  exports.printError = printError;
  var _isObjectLike = require_isObjectLike();
  var _location = require_location();
  var _printLocation = require_printLocation();
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }

  class GraphQLError extends Error {
    constructor(message, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref;
      const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message);
      this.name = "GraphQLError";
      this.path = path !== null && path !== undefined ? path : undefined;
      this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
      this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
      const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node2) => node2.loc).filter((loc) => loc != null));
      this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
      this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => (0, _location.getLocation)(loc.source, loc.start));
      const originalExtensions = (0, _isObjectLike.isObjectLike)(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
      this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== undefined && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output = this.message;
      if (this.nodes) {
        for (const node2 of this.nodes) {
          if (node2.loc) {
            output += `

` + (0, _printLocation.printLocation)(node2.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location of this.locations) {
          output += `

` + (0, _printLocation.printSourceLocation)(this.source, location);
        }
      }
      return output;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  }
  exports.GraphQLError = GraphQLError;
  function undefinedIfEmpty(array) {
    return array === undefined || array.length === 0 ? undefined : array;
  }
  function printError(error) {
    return error.toString();
  }
  function formatError(error) {
    return error.toJSON();
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.syntaxError = syntaxError;
  var _GraphQLError = require_GraphQLError();
  function syntaxError(source, position2, description) {
    return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position2]
    });
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = undefined;
  exports.isNode = isNode;

  class Location {
    constructor(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  }
  exports.Location = Location;

  class Token {
    constructor(kind2, start, end, line, column, value) {
      this.kind = kind2;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  }
  exports.Token = Token;
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  exports.QueryDocumentKeys = QueryDocumentKeys;
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  function isNode(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  }
  var OperationTypeNode;
  exports.OperationTypeNode = OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (exports.OperationTypeNode = OperationTypeNode = {}));
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DirectiveLocation = undefined;
  var DirectiveLocation;
  exports.DirectiveLocation = DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (exports.DirectiveLocation = DirectiveLocation = {}));
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Kind = undefined;
  var Kind;
  exports.Kind = Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  })(Kind || (exports.Kind = Kind = {}));
});

// node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isDigit = isDigit;
  exports.isLetter = isLetter;
  exports.isNameContinue = isNameContinue;
  exports.isNameStart = isNameStart;
  exports.isWhiteSpace = isWhiteSpace;
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.dedentBlockStringLines = dedentBlockStringLines;
  exports.isPrintableAsBlockString = isPrintableAsBlockString;
  exports.printBlockString = printBlockString;
  var _characterClasses = require_characterClasses();
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0;i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line = lines[i];
      const indent = leadingWhitespace(line);
      if (indent === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent < commonIndent) {
        commonIndent = indent;
      }
    }
    return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  }
  function isPrintableAsBlockString(value) {
    if (value === "") {
      return true;
    }
    let isEmptyLine = true;
    let hasIndent = false;
    let hasCommonIndent = true;
    let seenNonEmptyLine = false;
    for (let i = 0;i < value.length; ++i) {
      switch (value.codePointAt(i)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 11:
        case 12:
        case 14:
        case 15:
          return false;
        case 13:
          return false;
        case 10:
          if (isEmptyLine && !seenNonEmptyLine) {
            return false;
          }
          seenNonEmptyLine = true;
          isEmptyLine = true;
          hasIndent = false;
          break;
        case 9:
        case 32:
          hasIndent || (hasIndent = isEmptyLine);
          break;
        default:
          hasCommonIndent && (hasCommonIndent = hasIndent);
          isEmptyLine = false;
      }
    }
    if (isEmptyLine) {
      return false;
    }
    if (hasCommonIndent && seenNonEmptyLine) {
      return false;
    }
    return true;
  }
  function printBlockString(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result = "";
    const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result += `
`;
    }
    result += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result += `
`;
    }
    return '"""' + result + '"""';
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TokenKind = undefined;
  var TokenKind;
  exports.TokenKind = TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (exports.TokenKind = TokenKind = {}));
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Lexer = undefined;
  exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
  var _syntaxError = require_syntaxError();
  var _ast = require_ast();
  var _blockString = require_blockString();
  var _characterClasses = require_characterClasses();
  var _tokenKind = require_tokenKind();

  class Lexer {
    constructor(source) {
      const startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    advance() {
      this.lastToken = this.token;
      const token = this.token = this.lookahead();
      return token;
    }
    lookahead() {
      let token = this.token;
      if (token.kind !== _tokenKind.TokenKind.EOF) {
        do {
          if (token.next) {
            token = token.next;
          } else {
            const nextToken = readNextToken(this, token.end);
            token.next = nextToken;
            nextToken.prev = token;
            token = nextToken;
          }
        } while (token.kind === _tokenKind.TokenKind.COMMENT);
      }
      return token;
    }
  }
  exports.Lexer = Lexer;
  function isPunctuatorTokenKind(kind2) {
    return kind2 === _tokenKind.TokenKind.BANG || kind2 === _tokenKind.TokenKind.DOLLAR || kind2 === _tokenKind.TokenKind.AMP || kind2 === _tokenKind.TokenKind.PAREN_L || kind2 === _tokenKind.TokenKind.PAREN_R || kind2 === _tokenKind.TokenKind.SPREAD || kind2 === _tokenKind.TokenKind.COLON || kind2 === _tokenKind.TokenKind.EQUALS || kind2 === _tokenKind.TokenKind.AT || kind2 === _tokenKind.TokenKind.BRACKET_L || kind2 === _tokenKind.TokenKind.BRACKET_R || kind2 === _tokenKind.TokenKind.BRACE_L || kind2 === _tokenKind.TokenKind.PIPE || kind2 === _tokenKind.TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === undefined) {
      return _tokenKind.TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? `'"'` : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind2, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new _ast.Token(kind2, start, end, line, col, value);
  }
  function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start;
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++position2;
          continue;
        case 10:
          ++position2;
          ++lexer.line;
          lexer.lineStart = position2;
          continue;
        case 13:
          if (body.charCodeAt(position2 + 1) === 10) {
            position2 += 2;
          } else {
            ++position2;
          }
          ++lexer.line;
          lexer.lineStart = position2;
          continue;
        case 35:
          return readComment(lexer, position2);
        case 33:
          return createToken(lexer, _tokenKind.TokenKind.BANG, position2, position2 + 1);
        case 36:
          return createToken(lexer, _tokenKind.TokenKind.DOLLAR, position2, position2 + 1);
        case 38:
          return createToken(lexer, _tokenKind.TokenKind.AMP, position2, position2 + 1);
        case 40:
          return createToken(lexer, _tokenKind.TokenKind.PAREN_L, position2, position2 + 1);
        case 41:
          return createToken(lexer, _tokenKind.TokenKind.PAREN_R, position2, position2 + 1);
        case 46:
          if (body.charCodeAt(position2 + 1) === 46 && body.charCodeAt(position2 + 2) === 46) {
            return createToken(lexer, _tokenKind.TokenKind.SPREAD, position2, position2 + 3);
          }
          break;
        case 58:
          return createToken(lexer, _tokenKind.TokenKind.COLON, position2, position2 + 1);
        case 61:
          return createToken(lexer, _tokenKind.TokenKind.EQUALS, position2, position2 + 1);
        case 64:
          return createToken(lexer, _tokenKind.TokenKind.AT, position2, position2 + 1);
        case 91:
          return createToken(lexer, _tokenKind.TokenKind.BRACKET_L, position2, position2 + 1);
        case 93:
          return createToken(lexer, _tokenKind.TokenKind.BRACKET_R, position2, position2 + 1);
        case 123:
          return createToken(lexer, _tokenKind.TokenKind.BRACE_L, position2, position2 + 1);
        case 124:
          return createToken(lexer, _tokenKind.TokenKind.PIPE, position2, position2 + 1);
        case 125:
          return createToken(lexer, _tokenKind.TokenKind.BRACE_R, position2, position2 + 1);
        case 34:
          if (body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
            return readBlockString(lexer, position2);
          }
          return readString(lexer, position2);
      }
      if ((0, _characterClasses.isDigit)(code) || code === 45) {
        return readNumber(lexer, position2, code);
      }
      if ((0, _characterClasses.isNameStart)(code)) {
        return readName(lexer, position2);
      }
      throw (0, _syntaxError.syntaxError)(lexer.source, position2, code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position2) ? `Unexpected character: ${printCodePointAt(lexer, position2)}.` : `Invalid character: ${printCodePointAt(lexer, position2)}.`);
    }
    return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start + 1;
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position2;
      } else if (isSupplementaryCodePoint(body, position2)) {
        position2 += 2;
      } else {
        break;
      }
    }
    return createToken(lexer, _tokenKind.TokenKind.COMMENT, start, position2, body.slice(start + 1, position2));
  }
  function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position2 = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position2);
    }
    if (code === 48) {
      code = body.charCodeAt(++position2);
      if ((0, _characterClasses.isDigit)(code)) {
        throw (0, _syntaxError.syntaxError)(lexer.source, position2, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position2)}.`);
      }
    } else {
      position2 = readDigits(lexer, position2, code);
      code = body.charCodeAt(position2);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position2);
      position2 = readDigits(lexer, position2, code);
      code = body.charCodeAt(position2);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position2);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position2);
      }
      position2 = readDigits(lexer, position2, code);
      code = body.charCodeAt(position2);
    }
    if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
      throw (0, _syntaxError.syntaxError)(lexer.source, position2, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position2)}.`);
    }
    return createToken(lexer, isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position2, body.slice(start, position2));
  }
  function readDigits(lexer, start, firstCode) {
    if (!(0, _characterClasses.isDigit)(firstCode)) {
      throw (0, _syntaxError.syntaxError)(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
    }
    const body = lexer.source.body;
    let position2 = start + 1;
    while ((0, _characterClasses.isDigit)(body.charCodeAt(position2))) {
      ++position2;
    }
    return position2;
  }
  function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start + 1;
    let chunkStart = position2;
    let value = "";
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if (code === 34) {
        value += body.slice(chunkStart, position2);
        return createToken(lexer, _tokenKind.TokenKind.STRING, start, position2 + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position2);
        const escape = body.charCodeAt(position2 + 1) === 117 ? body.charCodeAt(position2 + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position2) : readEscapedUnicodeFixedWidth(lexer, position2) : readEscapedCharacter(lexer, position2);
        value += escape.value;
        position2 += escape.size;
        chunkStart = position2;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position2;
      } else if (isSupplementaryCodePoint(body, position2)) {
        position2 += 2;
      } else {
        throw (0, _syntaxError.syntaxError)(lexer.source, position2, `Invalid character within String: ${printCodePointAt(lexer, position2)}.`);
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position2, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position2) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3;
    while (size < 12) {
      const code = body.charCodeAt(position2 + size++);
      if (code === 125) {
        if (size < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position2, `Invalid Unicode escape sequence: "${body.slice(position2, position2 + size)}".`);
  }
  function readEscapedUnicodeFixedWidth(lexer, position2) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position2 + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position2 + 6) === 92 && body.charCodeAt(position2 + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position2 + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position2, `Invalid Unicode escape sequence: "${body.slice(position2, position2 + 6)}".`);
  }
  function read16BitHexCode(body, position2) {
    return readHexDigit(body.charCodeAt(position2)) << 12 | readHexDigit(body.charCodeAt(position2 + 1)) << 8 | readHexDigit(body.charCodeAt(position2 + 2)) << 4 | readHexDigit(body.charCodeAt(position2 + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position2) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position2 + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: `
`,
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "\t",
          size: 2
        };
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position2, `Invalid character escape sequence: "${body.slice(position2, position2 + 2)}".`);
  }
  function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position2 = start + 3;
    let chunkStart = position2;
    let currentLine = "";
    const blockLines = [];
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if (code === 34 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
        currentLine += body.slice(chunkStart, position2);
        blockLines.push(currentLine);
        const token = createToken(lexer, _tokenKind.TokenKind.BLOCK_STRING, start, position2 + 3, (0, _blockString.dedentBlockStringLines)(blockLines).join(`
`));
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34 && body.charCodeAt(position2 + 3) === 34) {
        currentLine += body.slice(chunkStart, position2);
        chunkStart = position2 + 1;
        position2 += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position2);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position2 + 1) === 10) {
          position2 += 2;
        } else {
          ++position2;
        }
        currentLine = "";
        chunkStart = position2;
        lineStart = position2;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position2;
      } else if (isSupplementaryCodePoint(body, position2)) {
        position2 += 2;
      } else {
        throw (0, _syntaxError.syntaxError)(lexer.source, position2, `Invalid character within String: ${printCodePointAt(lexer, position2)}.`);
      }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position2, "Unterminated string.");
  }
  function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position2 = start + 1;
    while (position2 < bodyLength) {
      const code = body.charCodeAt(position2);
      if ((0, _characterClasses.isNameContinue)(code)) {
        ++position2;
      } else {
        break;
      }
    }
    return createToken(lexer, _tokenKind.TokenKind.NAME, start, position2, body.slice(start, position2));
  }
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.inspect = inspect;
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i = 0;i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name = object.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.instanceOf = undefined;
  var _inspect = require_inspect();
  var isProduction = globalThis.process && false;
  var instanceOf = isProduction ? function instanceOf(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
      if (className === valueClassName) {
        const stringifiedValue = (0, _inspect.inspect)(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  };
  exports.instanceOf = instanceOf;
});

// node_modules/graphql/language/source.js
var require_source = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Source = undefined;
  exports.isSource = isSource;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();

  class Source {
    constructor(body, name = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || (0, _devAssert.devAssert)(false, `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`);
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || (0, _devAssert.devAssert)(false, "line in locationOffset is 1-indexed and must be positive.");
      this.locationOffset.column > 0 || (0, _devAssert.devAssert)(false, "column in locationOffset is 1-indexed and must be positive.");
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  }
  exports.Source = Source;
  function isSource(source) {
    return (0, _instanceOf.instanceOf)(source, Source);
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Parser = undefined;
  exports.parse = parse;
  exports.parseConstValue = parseConstValue;
  exports.parseType = parseType;
  exports.parseValue = parseValue;
  var _syntaxError = require_syntaxError();
  var _ast = require_ast();
  var _directiveLocation = require_directiveLocation();
  var _kinds = require_kinds();
  var _lexer = require_lexer();
  var _source = require_source();
  var _tokenKind = require_tokenKind();
  function parse(source, options) {
    const parser = new Parser(source, options);
    const document2 = parser.parseDocument();
    Object.defineProperty(document2, "tokenCount", {
      enumerable: false,
      value: parser.tokenCount
    });
    return document2;
  }
  function parseValue(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const value = parser.parseValueLiteral(false);
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return value;
  }
  function parseConstValue(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const value = parser.parseConstValueLiteral();
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return value;
  }
  function parseType(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const type2 = parser.parseTypeReference();
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return type2;
  }

  class Parser {
    constructor(source, options = {}) {
      const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      this._lexer = new _lexer.Lexer(sourceObj);
      this._options = options;
      this._tokenCounter = 0;
    }
    get tokenCount() {
      return this._tokenCounter;
    }
    parseName() {
      const token = this.expectToken(_tokenKind.TokenKind.NAME);
      return this.node(token, {
        kind: _kinds.Kind.NAME,
        value: token.value
      });
    }
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.DOCUMENT,
        definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)
      });
    }
    parseDefinition() {
      if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (hasDescription) {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    parseOperationDefinition() {
      const start = this._lexer.token;
      if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation: _ast.OperationTypeNode.QUERY,
          name: undefined,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const operation = this.parseOperationType();
      let name;
      if (this.peek(_tokenKind.TokenKind.NAME)) {
        name = this.parseName();
      }
      return this.node(start, {
        kind: _kinds.Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseOperationType() {
      const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return _ast.OperationTypeNode.QUERY;
        case "mutation":
          return _ast.OperationTypeNode.MUTATION;
        case "subscription":
          return _ast.OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    parseVariableDefinitions() {
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
    }
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
        directives: this.parseConstDirectives()
      });
    }
    parseVariable() {
      const start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.DOLLAR);
      return this.node(start, {
        kind: _kinds.Kind.VARIABLE,
        name: this.parseName()
      });
    }
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.SELECTION_SET,
        selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)
      });
    }
    parseSelection() {
      return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    parseField() {
      const start = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name;
      if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return this.node(start, {
        kind: _kinds.Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
      });
    }
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
    }
    parseArgument(isConst = false) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      return this.node(start, {
        kind: _kinds.Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    parseFragment() {
      const start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start, {
        kind: _kinds.Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseFragmentDefinition() {
      const start = this._lexer.token;
      this.expectKeyword("fragment");
      if (this._options.allowLegacyFragmentVariables === true) {
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start, {
        kind: _kinds.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    parseValueLiteral(isConst) {
      const token = this._lexer.token;
      switch (token.kind) {
        case _tokenKind.TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case _tokenKind.TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case _tokenKind.TokenKind.INT:
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.INT,
            value: token.value
          });
        case _tokenKind.TokenKind.FLOAT:
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.FLOAT,
            value: token.value
          });
        case _tokenKind.TokenKind.STRING:
        case _tokenKind.TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case _tokenKind.TokenKind.NAME:
          this.advanceLexer();
          switch (token.value) {
            case "true":
              return this.node(token, {
                kind: _kinds.Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token, {
                kind: _kinds.Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token, {
                kind: _kinds.Kind.NULL
              });
            default:
              return this.node(token, {
                kind: _kinds.Kind.ENUM,
                value: token.value
              });
          }
        case _tokenKind.TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(_tokenKind.TokenKind.DOLLAR);
            if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
            } else {
              throw this.unexpected(token);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token = this._lexer.token;
      this.advanceLexer();
      return this.node(token, {
        kind: _kinds.Kind.STRING,
        value: token.value,
        block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
      });
    }
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.LIST,
        values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)
      });
    }
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.OBJECT,
        fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)
      });
    }
    parseObjectField(isConst) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      return this.node(start, {
        kind: _kinds.Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(_tokenKind.TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    parseDirective(isConst) {
      const start = this._lexer.token;
      this.expectToken(_tokenKind.TokenKind.AT);
      return this.node(start, {
        kind: _kinds.Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    parseTypeReference() {
      const start = this._lexer.token;
      let type2;
      if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(_tokenKind.TokenKind.BRACKET_R);
        type2 = this.node(start, {
          kind: _kinds.Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type2 = this.parseNamedType();
      }
      if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
        return this.node(start, {
          kind: _kinds.Kind.NON_NULL_TYPE,
          type: type2
        });
      }
      return type2;
    }
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: _kinds.Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    peekDescription() {
      return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
    }
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    parseSchemaDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
      return this.node(start, {
        kind: _kinds.Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    parseOperationTypeDefinition() {
      const start = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(_tokenKind.TokenKind.COLON);
      const type2 = this.parseNamedType();
      return this.node(start, {
        kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type: type2
      });
    }
    parseScalarTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives
      });
    }
    parseObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
    }
    parseFieldsDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
    }
    parseFieldDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(_tokenKind.TokenKind.COLON);
      const type2 = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type: type2,
        directives
      });
    }
    parseArgumentDefs() {
      return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
    }
    parseInputValueDef() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      this.expectToken(_tokenKind.TokenKind.COLON);
      const type2 = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type: type2,
        defaultValue,
        directives
      });
    }
    parseInterfaceTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseUnionTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      return this.node(start, {
        kind: _kinds.Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types
      });
    }
    parseUnionMemberTypes() {
      return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
    }
    parseEnumTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      return this.node(start, {
        kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values
      });
    }
    parseEnumValuesDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
    }
    parseEnumValueDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives
      });
    }
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
      }
      return this.parseName();
    }
    parseInputObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start, {
        kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields
      });
    }
    parseInputFieldsDefinition() {
      return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
    }
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    parseSchemaExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    parseScalarTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives
      });
    }
    parseObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseInterfaceTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseUnionTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      if (directives.length === 0 && types.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types
      });
    }
    parseEnumTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values
      });
    }
    parseInputObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields
      });
    }
    parseDirectiveDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(_tokenKind.TokenKind.AT);
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start, {
        kind: _kinds.Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations
      });
    }
    parseDirectiveLocations() {
      return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
    }
    parseDirectiveLocation() {
      const start = this._lexer.token;
      const name = this.parseName();
      if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {
        return name;
      }
      throw this.unexpected(start);
    }
    node(startToken, node2) {
      if (this._options.noLocation !== true) {
        node2.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
      }
      return node2;
    }
    peek(kind2) {
      return this._lexer.token.kind === kind2;
    }
    expectToken(kind2) {
      const token = this._lexer.token;
      if (token.kind === kind2) {
        this.advanceLexer();
        return token;
      }
      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind2)}, found ${getTokenDesc(token)}.`);
    }
    expectOptionalToken(kind2) {
      const token = this._lexer.token;
      if (token.kind === kind2) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    expectKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
        this.advanceLexer();
      } else {
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
      }
    }
    expectOptionalKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    unexpected(atToken) {
      const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
      return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
    }
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
    advanceLexer() {
      const { maxTokens } = this._options;
      const token = this._lexer.advance();
      if (token.kind !== _tokenKind.TokenKind.EOF) {
        ++this._tokenCounter;
        if (maxTokens !== undefined && this._tokenCounter > maxTokens) {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
        }
      }
    }
  }
  exports.Parser = Parser;
  function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind2) {
    return (0, _lexer.isPunctuatorTokenKind)(kind2) ? `"${kind2}"` : kind2;
  }
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.didYouMean = didYouMean;
  var MAX_SUGGESTIONS = 5;
  function didYouMean(firstArg, secondArg) {
    const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [undefined, firstArg];
    let message = " Did you mean ";
    if (subMessage) {
      message += subMessage + " ";
    }
    const suggestions = suggestionsArg.map((x) => `"${x}"`);
    switch (suggestions.length) {
      case 0:
        return "";
      case 1:
        return message + suggestions[0] + "?";
      case 2:
        return message + suggestions[0] + " or " + suggestions[1] + "?";
    }
    const selected = suggestions.slice(0, MAX_SUGGESTIONS);
    const lastItem = selected.pop();
    return message + selected.join(", ") + ", or " + lastItem + "?";
  }
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.identityFunc = identityFunc;
  function identityFunc(x) {
    return x;
  }
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.keyMap = keyMap;
  function keyMap(list, keyFn) {
    const result = Object.create(null);
    for (const item of list) {
      result[keyFn(item)] = item;
    }
    return result;
  }
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.keyValMap = keyValMap;
  function keyValMap(list, keyFn, valFn) {
    const result = Object.create(null);
    for (const item of list) {
      result[keyFn(item)] = valFn(item);
    }
    return result;
  }
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mapValue = mapValue;
  function mapValue(map, fn) {
    const result = Object.create(null);
    for (const key of Object.keys(map)) {
      result[key] = fn(map[key], key);
    }
    return result;
  }
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.naturalCompare = naturalCompare;
  function naturalCompare(aStr, bStr) {
    let aIndex = 0;
    let bIndex = 0;
    while (aIndex < aStr.length && bIndex < bStr.length) {
      let aChar = aStr.charCodeAt(aIndex);
      let bChar = bStr.charCodeAt(bIndex);
      if (isDigit(aChar) && isDigit(bChar)) {
        let aNum = 0;
        do {
          ++aIndex;
          aNum = aNum * 10 + aChar - DIGIT_0;
          aChar = aStr.charCodeAt(aIndex);
        } while (isDigit(aChar) && aNum > 0);
        let bNum = 0;
        do {
          ++bIndex;
          bNum = bNum * 10 + bChar - DIGIT_0;
          bChar = bStr.charCodeAt(bIndex);
        } while (isDigit(bChar) && bNum > 0);
        if (aNum < bNum) {
          return -1;
        }
        if (aNum > bNum) {
          return 1;
        }
      } else {
        if (aChar < bChar) {
          return -1;
        }
        if (aChar > bChar) {
          return 1;
        }
        ++aIndex;
        ++bIndex;
      }
    }
    return aStr.length - bStr.length;
  }
  var DIGIT_0 = 48;
  var DIGIT_9 = 57;
  function isDigit(code) {
    return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
  }
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.suggestionList = suggestionList;
  var _naturalCompare = require_naturalCompare();
  function suggestionList(input, options) {
    const optionsByDistance = Object.create(null);
    const lexicalDistance = new LexicalDistance(input);
    const threshold = Math.floor(input.length * 0.4) + 1;
    for (const option of options) {
      const distance = lexicalDistance.measure(option, threshold);
      if (distance !== undefined) {
        optionsByDistance[option] = distance;
      }
    }
    return Object.keys(optionsByDistance).sort((a, b) => {
      const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
      return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
    });
  }

  class LexicalDistance {
    constructor(input) {
      this._input = input;
      this._inputLowerCase = input.toLowerCase();
      this._inputArray = stringToArray(this._inputLowerCase);
      this._rows = [
        new Array(input.length + 1).fill(0),
        new Array(input.length + 1).fill(0),
        new Array(input.length + 1).fill(0)
      ];
    }
    measure(option, threshold) {
      if (this._input === option) {
        return 0;
      }
      const optionLowerCase = option.toLowerCase();
      if (this._inputLowerCase === optionLowerCase) {
        return 1;
      }
      let a = stringToArray(optionLowerCase);
      let b = this._inputArray;
      if (a.length < b.length) {
        const tmp = a;
        a = b;
        b = tmp;
      }
      const aLength = a.length;
      const bLength = b.length;
      if (aLength - bLength > threshold) {
        return;
      }
      const rows = this._rows;
      for (let j = 0;j <= bLength; j++) {
        rows[0][j] = j;
      }
      for (let i = 1;i <= aLength; i++) {
        const upRow = rows[(i - 1) % 3];
        const currentRow = rows[i % 3];
        let smallestCell = currentRow[0] = i;
        for (let j = 1;j <= bLength; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
            currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
          }
          if (currentCell < smallestCell) {
            smallestCell = currentCell;
          }
          currentRow[j] = currentCell;
        }
        if (smallestCell > threshold) {
          return;
        }
      }
      const distance = rows[aLength % 3][bLength];
      return distance <= threshold ? distance : undefined;
    }
  }
  function stringToArray(str) {
    const strLength = str.length;
    const array = new Array(strLength);
    for (let i = 0;i < strLength; ++i) {
      array[i] = str.charCodeAt(i);
    }
    return array;
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toObjMap = toObjMap;
  function toObjMap(obj) {
    if (obj == null) {
      return Object.create(null);
    }
    if (Object.getPrototypeOf(obj) === null) {
      return obj;
    }
    const map = Object.create(null);
    for (const [key, value] of Object.entries(obj)) {
      map[key] = value;
    }
    return map;
  }
});

// node_modules/graphql/language/printString.js
var require_printString = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printString = printString;
  function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  }
  var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
  }
  var escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    "\\\"",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BREAK = undefined;
  exports.getEnterLeaveForKind = getEnterLeaveForKind;
  exports.getVisitFn = getVisitFn;
  exports.visit = visit;
  exports.visitInParallel = visitInParallel;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _ast = require_ast();
  var _kinds = require_kinds();
  var BREAK = Object.freeze({});
  exports.BREAK = BREAK;
  function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
    const enterLeaveMap = new Map;
    for (const kind2 of Object.values(_kinds.Kind)) {
      enterLeaveMap.set(kind2, getEnterLeaveForKind(visitor, kind2));
    }
    let stack = undefined;
    let inArray = Array.isArray(root);
    let keys = [root];
    let index = -1;
    let edits = [];
    let node2 = root;
    let key = undefined;
    let parent = undefined;
    const path = [];
    const ancestors = [];
    do {
      index++;
      const isLeaving = index === keys.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? undefined : path[path.length - 1];
        node2 = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node2 = node2.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node2.splice(arrayKey, 1);
                editOffset++;
              } else {
                node2[arrayKey] = editValue;
              }
            }
          } else {
            node2 = { ...node2 };
            for (const [editKey, editValue] of edits) {
              node2[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index : keys[index];
        node2 = parent[key];
        if (node2 === null || node2 === undefined) {
          continue;
        }
        path.push(key);
      }
      let result;
      if (!Array.isArray(node2)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        (0, _ast.isNode)(node2) || (0, _devAssert.devAssert)(false, `Invalid AST Node: ${(0, _inspect.inspect)(node2)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
        result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node2, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);
          if (!isLeaving) {
            if ((0, _ast.isNode)(result)) {
              node2 = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result === undefined && isEdited) {
        edits.push([key, node2]);
      }
      if (isLeaving) {
        path.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node2);
        keys = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
        index = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node2;
      }
    } while (stack !== undefined);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root;
  }
  function visitInParallel(visitors) {
    const skipping = new Array(visitors.length).fill(null);
    const mergedVisitor = Object.create(null);
    for (const kind2 of Object.values(_kinds.Kind)) {
      let hasVisitor = false;
      const enterList = new Array(visitors.length).fill(undefined);
      const leaveList = new Array(visitors.length).fill(undefined);
      for (let i = 0;i < visitors.length; ++i) {
        const { enter, leave } = getEnterLeaveForKind(visitors[i], kind2);
        hasVisitor || (hasVisitor = enter != null || leave != null);
        enterList[i] = enter;
        leaveList[i] = leave;
      }
      if (!hasVisitor) {
        continue;
      }
      const mergedEnterLeave = {
        enter(...args) {
          const node2 = args[0];
          for (let i = 0;i < visitors.length; i++) {
            if (skipping[i] === null) {
              var _enterList$i;
              const result = (_enterList$i = enterList[i]) === null || _enterList$i === undefined ? undefined : _enterList$i.apply(visitors[i], args);
              if (result === false) {
                skipping[i] = node2;
              } else if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== undefined) {
                return result;
              }
            }
          }
        },
        leave(...args) {
          const node2 = args[0];
          for (let i = 0;i < visitors.length; i++) {
            if (skipping[i] === null) {
              var _leaveList$i;
              const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === undefined ? undefined : _leaveList$i.apply(visitors[i], args);
              if (result === BREAK) {
                skipping[i] = BREAK;
              } else if (result !== undefined && result !== false) {
                return result;
              }
            } else if (skipping[i] === node2) {
              skipping[i] = null;
            }
          }
        }
      };
      mergedVisitor[kind2] = mergedEnterLeave;
    }
    return mergedVisitor;
  }
  function getEnterLeaveForKind(visitor, kind2) {
    const kindVisitor = visitor[kind2];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: undefined
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  }
  function getVisitFn(visitor, kind2, isLeaving) {
    const { enter, leave } = getEnterLeaveForKind(visitor, kind2);
    return isLeaving ? leave : enter;
  }
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.print = print;
  var _blockString = require_blockString();
  var _printString = require_printString();
  var _visitor = require_visitor();
  function print(ast) {
    return (0, _visitor.visit)(ast, printDocASTReducer);
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: {
      leave: (node2) => node2.value
    },
    Variable: {
      leave: (node2) => "$" + node2.name
    },
    Document: {
      leave: (node2) => join(node2.definitions, `

`)
    },
    OperationDefinition: {
      leave(node2) {
        const varDefs = wrap("(", join(node2.variableDefinitions, ", "), ")");
        const prefix = join([
          node2.operation,
          join([node2.name, varDefs]),
          join(node2.directives, " ")
        ], " ");
        return (prefix === "query" ? "" : prefix + " ") + node2.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
    },
    SelectionSet: {
      leave: ({ selections }) => block(selections)
    },
    Field: {
      leave({ alias, name, arguments: args, directives, selectionSet }) {
        const prefix = wrap("", alias, ": ") + name;
        let argsLine = prefix + wrap("(", join(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap(`(
`, indent(join(args, `
`)), `
)`);
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      }
    },
    Argument: {
      leave: ({ name, value }) => name + ": " + value
    },
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join([
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ], " ")
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    },
    IntValue: {
      leave: ({ value }) => value
    },
    FloatValue: {
      leave: ({ value }) => value
    },
    StringValue: {
      leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
    },
    BooleanValue: {
      leave: ({ value }) => value ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value }) => value
    },
    ListValue: {
      leave: ({ values }) => "[" + join(values, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields }) => "{" + join(fields, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name, value }) => name + ": " + value
    },
    Directive: {
      leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
    },
    NamedType: {
      leave: ({ name }) => name
    },
    ListType: {
      leave: ({ type: type2 }) => "[" + type2 + "]"
    },
    NonNullType: {
      leave: ({ type: type2 }) => type2 + "!"
    },
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) => wrap("", description, `
`) + join(["schema", join(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type: type2 }) => operation + ": " + type2
    },
    ScalarTypeDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, `
`) + join(["scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, `
`) + join([
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    FieldDefinition: {
      leave: ({ description, name, arguments: args, type: type2, directives }) => wrap("", description, `
`) + name + (hasMultilineItems(args) ? wrap(`(
`, indent(join(args, `
`)), `
)`) : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ description, name, type: type2, defaultValue, directives }) => wrap("", description, `
`) + join([name + ": " + type2, wrap("= ", defaultValue), join(directives, " ")], " ")
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, `
`) + join([
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    UnionTypeDefinition: {
      leave: ({ description, name, directives, types }) => wrap("", description, `
`) + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
    },
    EnumTypeDefinition: {
      leave: ({ description, name, directives, values }) => wrap("", description, `
`) + join(["enum", name, join(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, `
`) + join([name, join(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name, directives, fields }) => wrap("", description, `
`) + join(["input", name, join(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, `
`) + "directive @" + name + (hasMultilineItems(args) ? wrap(`(
`, indent(join(args, `
`)), `
)`) : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join([
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join([
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types }) => join([
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ], " ")
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
    }
  };
  function join(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
  }
  function block(array) {
    return wrap(`{
`, indent(join(array, `
`)), `
}`);
  }
  function wrap(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap("  ", str.replace(/\n/g, `
  `));
  }
  function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes(`
`))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.valueFromASTUntyped = valueFromASTUntyped;
  var _keyValMap = require_keyValMap();
  var _kinds = require_kinds();
  function valueFromASTUntyped(valueNode, variables) {
    switch (valueNode.kind) {
      case _kinds.Kind.NULL:
        return null;
      case _kinds.Kind.INT:
        return parseInt(valueNode.value, 10);
      case _kinds.Kind.FLOAT:
        return parseFloat(valueNode.value);
      case _kinds.Kind.STRING:
      case _kinds.Kind.ENUM:
      case _kinds.Kind.BOOLEAN:
        return valueNode.value;
      case _kinds.Kind.LIST:
        return valueNode.values.map((node2) => valueFromASTUntyped(node2, variables));
      case _kinds.Kind.OBJECT:
        return (0, _keyValMap.keyValMap)(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
      case _kinds.Kind.VARIABLE:
        return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
    }
  }
});

// node_modules/graphql/type/assertName.js
var require_assertName = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertEnumValueName = assertEnumValueName;
  exports.assertName = assertName;
  var _devAssert = require_devAssert();
  var _GraphQLError = require_GraphQLError();
  var _characterClasses = require_characterClasses();
  function assertName(name) {
    name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
    typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
    if (name.length === 0) {
      throw new _GraphQLError.GraphQLError("Expected name to be a non-empty string.");
    }
    for (let i = 1;i < name.length; ++i) {
      if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
        throw new _GraphQLError.GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
      }
    }
    if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
      throw new _GraphQLError.GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
    }
    return name;
  }
  function assertEnumValueName(name) {
    if (name === "true" || name === "false" || name === "null") {
      throw new _GraphQLError.GraphQLError(`Enum values cannot be named: ${name}`);
    }
    return assertName(name);
  }
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = undefined;
  exports.argsToArgsConfig = argsToArgsConfig;
  exports.assertAbstractType = assertAbstractType;
  exports.assertCompositeType = assertCompositeType;
  exports.assertEnumType = assertEnumType;
  exports.assertInputObjectType = assertInputObjectType;
  exports.assertInputType = assertInputType;
  exports.assertInterfaceType = assertInterfaceType;
  exports.assertLeafType = assertLeafType;
  exports.assertListType = assertListType;
  exports.assertNamedType = assertNamedType;
  exports.assertNonNullType = assertNonNullType;
  exports.assertNullableType = assertNullableType;
  exports.assertObjectType = assertObjectType;
  exports.assertOutputType = assertOutputType;
  exports.assertScalarType = assertScalarType;
  exports.assertType = assertType;
  exports.assertUnionType = assertUnionType;
  exports.assertWrappingType = assertWrappingType;
  exports.defineArguments = defineArguments;
  exports.getNamedType = getNamedType;
  exports.getNullableType = getNullableType;
  exports.isAbstractType = isAbstractType;
  exports.isCompositeType = isCompositeType;
  exports.isEnumType = isEnumType;
  exports.isInputObjectType = isInputObjectType;
  exports.isInputType = isInputType;
  exports.isInterfaceType = isInterfaceType;
  exports.isLeafType = isLeafType;
  exports.isListType = isListType;
  exports.isNamedType = isNamedType;
  exports.isNonNullType = isNonNullType;
  exports.isNullableType = isNullableType;
  exports.isObjectType = isObjectType;
  exports.isOutputType = isOutputType;
  exports.isRequiredArgument = isRequiredArgument;
  exports.isRequiredInputField = isRequiredInputField;
  exports.isScalarType = isScalarType;
  exports.isType = isType;
  exports.isUnionType = isUnionType;
  exports.isWrappingType = isWrappingType;
  exports.resolveObjMapThunk = resolveObjMapThunk;
  exports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
  var _devAssert = require_devAssert();
  var _didYouMean = require_didYouMean();
  var _identityFunc = require_identityFunc();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();
  var _isObjectLike = require_isObjectLike();
  var _keyMap = require_keyMap();
  var _keyValMap = require_keyValMap();
  var _mapValue = require_mapValue();
  var _suggestionList = require_suggestionList();
  var _toObjMap = require_toObjMap();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _valueFromASTUntyped = require_valueFromASTUntyped();
  var _assertName = require_assertName();
  function isType(type2) {
    return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
  }
  function assertType(type2) {
    if (!isType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL type.`);
    }
    return type2;
  }
  function isScalarType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLScalarType);
  }
  function assertScalarType(type2) {
    if (!isScalarType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Scalar type.`);
    }
    return type2;
  }
  function isObjectType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLObjectType);
  }
  function assertObjectType(type2) {
    if (!isObjectType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Object type.`);
    }
    return type2;
  }
  function isInterfaceType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLInterfaceType);
  }
  function assertInterfaceType(type2) {
    if (!isInterfaceType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Interface type.`);
    }
    return type2;
  }
  function isUnionType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLUnionType);
  }
  function assertUnionType(type2) {
    if (!isUnionType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Union type.`);
    }
    return type2;
  }
  function isEnumType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLEnumType);
  }
  function assertEnumType(type2) {
    if (!isEnumType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Enum type.`);
    }
    return type2;
  }
  function isInputObjectType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLInputObjectType);
  }
  function assertInputObjectType(type2) {
    if (!isInputObjectType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Input Object type.`);
    }
    return type2;
  }
  function isListType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLList);
  }
  function assertListType(type2) {
    if (!isListType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL List type.`);
    }
    return type2;
  }
  function isNonNullType(type2) {
    return (0, _instanceOf.instanceOf)(type2, GraphQLNonNull);
  }
  function assertNonNullType(type2) {
    if (!isNonNullType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Non-Null type.`);
    }
    return type2;
  }
  function isInputType(type2) {
    return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
  }
  function assertInputType(type2) {
    if (!isInputType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL input type.`);
    }
    return type2;
  }
  function isOutputType(type2) {
    return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
  }
  function assertOutputType(type2) {
    if (!isOutputType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL output type.`);
    }
    return type2;
  }
  function isLeafType(type2) {
    return isScalarType(type2) || isEnumType(type2);
  }
  function assertLeafType(type2) {
    if (!isLeafType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL leaf type.`);
    }
    return type2;
  }
  function isCompositeType(type2) {
    return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
  }
  function assertCompositeType(type2) {
    if (!isCompositeType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL composite type.`);
    }
    return type2;
  }
  function isAbstractType(type2) {
    return isInterfaceType(type2) || isUnionType(type2);
  }
  function assertAbstractType(type2) {
    if (!isAbstractType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL abstract type.`);
    }
    return type2;
  }

  class GraphQLList {
    constructor(ofType) {
      isType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`);
      this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLList";
    }
    toString() {
      return "[" + String(this.ofType) + "]";
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLList = GraphQLList;

  class GraphQLNonNull {
    constructor(ofType) {
      isNullableType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL nullable type.`);
      this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLNonNull";
    }
    toString() {
      return String(this.ofType) + "!";
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLNonNull = GraphQLNonNull;
  function isWrappingType(type2) {
    return isListType(type2) || isNonNullType(type2);
  }
  function assertWrappingType(type2) {
    if (!isWrappingType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL wrapping type.`);
    }
    return type2;
  }
  function isNullableType(type2) {
    return isType(type2) && !isNonNullType(type2);
  }
  function assertNullableType(type2) {
    if (!isNullableType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL nullable type.`);
    }
    return type2;
  }
  function getNullableType(type2) {
    if (type2) {
      return isNonNullType(type2) ? type2.ofType : type2;
    }
  }
  function isNamedType(type2) {
    return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);
  }
  function assertNamedType(type2) {
    if (!isNamedType(type2)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL named type.`);
    }
    return type2;
  }
  function getNamedType(type2) {
    if (type2) {
      let unwrappedType = type2;
      while (isWrappingType(unwrappedType)) {
        unwrappedType = unwrappedType.ofType;
      }
      return unwrappedType;
    }
  }
  function resolveReadonlyArrayThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  }
  function resolveObjMapThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  }

  class GraphQLScalarType {
    constructor(config) {
      var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
      const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : _identityFunc.identityFunc;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.specifiedByURL = config.specifiedByURL;
      this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : _identityFunc.identityFunc;
      this.parseValue = parseValue;
      this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : (node2, variables) => parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node2, variables));
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
      config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`);
      config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
      if (config.parseLiteral) {
        typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLScalarType";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        specifiedByURL: this.specifiedByURL,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLScalarType = GraphQLScalarType;

  class GraphQLObjectType {
    constructor(config) {
      var _config$extensionASTN2;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.isTypeOf = config.isTypeOf;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== undefined ? _config$extensionASTN2 : [];
      this._fields = () => defineFieldMap(config);
      this._interfaces = () => defineInterfaces(config);
      config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLObjectType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLObjectType = GraphQLObjectType;
  function defineInterfaces(config) {
    var _config$interfaces;
    const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== undefined ? _config$interfaces : []);
    Array.isArray(interfaces) || (0, _devAssert.devAssert)(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
    return interfaces;
  }
  function defineFieldMap(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
    return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
      var _fieldConfig$args;
      isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field config must be an object.`);
      fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`);
      const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
      isPlainObj(argsConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
      return {
        name: (0, _assertName.assertName)(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        args: defineArguments(argsConfig),
        resolve: fieldConfig.resolve,
        subscribe: fieldConfig.subscribe,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function defineArguments(config) {
    return Object.entries(config).map(([argName, argConfig]) => ({
      name: (0, _assertName.assertName)(argName),
      description: argConfig.description,
      type: argConfig.type,
      defaultValue: argConfig.defaultValue,
      deprecationReason: argConfig.deprecationReason,
      extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
      astNode: argConfig.astNode
    }));
  }
  function isPlainObj(obj) {
    return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
  }
  function fieldsToFieldsConfig(fields) {
    return (0, _mapValue.mapValue)(fields, (field) => ({
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
  }
  function argsToArgsConfig(args) {
    return (0, _keyValMap.keyValMap)(args, (arg) => arg.name, (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    }));
  }
  function isRequiredArgument(arg) {
    return isNonNullType(arg.type) && arg.defaultValue === undefined;
  }

  class GraphQLInterfaceType {
    constructor(config) {
      var _config$extensionASTN3;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== undefined ? _config$extensionASTN3 : [];
      this._fields = defineFieldMap.bind(undefined, config);
      this._interfaces = defineInterfaces.bind(undefined, config);
      config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInterfaceType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    getInterfaces() {
      if (typeof this._interfaces === "function") {
        this._interfaces = this._interfaces();
      }
      return this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLInterfaceType = GraphQLInterfaceType;

  class GraphQLUnionType {
    constructor(config) {
      var _config$extensionASTN4;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.resolveType = config.resolveType;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== undefined ? _config$extensionASTN4 : [];
      this._types = defineTypes.bind(undefined, config);
      config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLUnionType";
    }
    getTypes() {
      if (typeof this._types === "function") {
        this._types = this._types();
      }
      return this._types;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLUnionType = GraphQLUnionType;
  function defineTypes(config) {
    const types = resolveReadonlyArrayThunk(config.types);
    Array.isArray(types) || (0, _devAssert.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
    return types;
  }

  class GraphQLEnumType {
    constructor(config) {
      var _config$extensionASTN5;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== undefined ? _config$extensionASTN5 : [];
      this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
      this._valueLookup = null;
      this._nameLookup = null;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLEnumType";
    }
    getValues() {
      if (typeof this._values === "function") {
        this._values = defineEnumValues(this.name, this._values());
      }
      return this._values;
    }
    getValue(name) {
      if (this._nameLookup === null) {
        this._nameLookup = (0, _keyMap.keyMap)(this.getValues(), (value) => value.name);
      }
      return this._nameLookup[name];
    }
    serialize(outputValue) {
      if (this._valueLookup === null) {
        this._valueLookup = new Map(this.getValues().map((enumValue2) => [enumValue2.value, enumValue2]));
      }
      const enumValue = this._valueLookup.get(outputValue);
      if (enumValue === undefined) {
        throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
      }
      return enumValue.name;
    }
    parseValue(inputValue) {
      if (typeof inputValue !== "string") {
        const valueStr = (0, _inspect.inspect)(inputValue);
        throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
      }
      const enumValue = this.getValue(inputValue);
      if (enumValue == null) {
        throw new _GraphQLError.GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
      }
      return enumValue.value;
    }
    parseLiteral(valueNode, _variables) {
      if (valueNode.kind !== _kinds.Kind.ENUM) {
        const valueStr = (0, _printer.print)(valueNode);
        throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
          nodes: valueNode
        });
      }
      const enumValue = this.getValue(valueNode.value);
      if (enumValue == null) {
        const valueStr = (0, _printer.print)(valueNode);
        throw new _GraphQLError.GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
          nodes: valueNode
        });
      }
      return enumValue.value;
    }
    toConfig() {
      const values = (0, _keyValMap.keyValMap)(this.getValues(), (value) => value.name, (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        values,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLEnumType = GraphQLEnumType;
  function didYouMeanEnumValue(enumType, unknownValueStr) {
    const allNames = enumType.getValues().map((value) => value.name);
    const suggestedValues = (0, _suggestionList.suggestionList)(unknownValueStr, allNames);
    return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
  }
  function defineEnumValues(typeName, valueMap) {
    isPlainObj(valueMap) || (0, _devAssert.devAssert)(false, `${typeName} values must be an object with value names as keys.`);
    return Object.entries(valueMap).map(([valueName, valueConfig]) => {
      isPlainObj(valueConfig) || (0, _devAssert.devAssert)(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${(0, _inspect.inspect)(valueConfig)}.`);
      return {
        name: (0, _assertName.assertEnumValueName)(valueName),
        description: valueConfig.description,
        value: valueConfig.value !== undefined ? valueConfig.value : valueName,
        deprecationReason: valueConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
        astNode: valueConfig.astNode
      };
    });
  }

  class GraphQLInputObjectType {
    constructor(config) {
      var _config$extensionASTN6, _config$isOneOf;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== undefined ? _config$extensionASTN6 : [];
      this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== undefined ? _config$isOneOf : false;
      this._fields = defineInputFieldMap.bind(undefined, config);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInputObjectType";
    }
    getFields() {
      if (typeof this._fields === "function") {
        this._fields = this._fields();
      }
      return this._fields;
    }
    toConfig() {
      const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        fields,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        isOneOf: this.isOneOf
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLInputObjectType = GraphQLInputObjectType;
  function defineInputFieldMap(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
    return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
      !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
      return {
        name: (0, _assertName.assertName)(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        defaultValue: fieldConfig.defaultValue,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function isRequiredInputField(field) {
    return isNonNullType(field.type) && field.defaultValue === undefined;
  }
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.doTypesOverlap = doTypesOverlap;
  exports.isEqualType = isEqualType;
  exports.isTypeSubTypeOf = isTypeSubTypeOf;
  var _definition = require_definition();
  function isEqualType(typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    return false;
  }
  function isTypeSubTypeOf(schema, maybeSubType, superType) {
    if (maybeSubType === superType) {
      return true;
    }
    if ((0, _definition.isNonNullType)(superType)) {
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if ((0, _definition.isNonNullType)(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
    }
    if ((0, _definition.isListType)(superType)) {
      if ((0, _definition.isListType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if ((0, _definition.isListType)(maybeSubType)) {
      return false;
    }
    return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
  }
  function doTypesOverlap(schema, typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if ((0, _definition.isAbstractType)(typeA)) {
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
      }
      return schema.isSubType(typeA, typeB);
    }
    if ((0, _definition.isAbstractType)(typeB)) {
      return schema.isSubType(typeB, typeA);
    }
    return false;
  }
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLString = exports.GraphQLInt = exports.GraphQLID = exports.GraphQLFloat = exports.GraphQLBoolean = exports.GRAPHQL_MIN_INT = exports.GRAPHQL_MAX_INT = undefined;
  exports.isSpecifiedScalarType = isSpecifiedScalarType;
  exports.specifiedScalarTypes = undefined;
  var _inspect = require_inspect();
  var _isObjectLike = require_isObjectLike();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var GRAPHQL_MAX_INT = 2147483647;
  exports.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
  var GRAPHQL_MIN_INT = -2147483648;
  exports.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
  var GraphQLInt = new _definition.GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      let num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (typeof num !== "number" || !Number.isInteger(num)) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(coercedValue)}`);
      }
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue));
      }
      return num;
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _printer.print)(valueNode)}`, {
          nodes: valueNode
        });
      }
      const num = parseInt(valueNode.value, 10);
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
          nodes: valueNode
        });
      }
      return num;
    }
  });
  exports.GraphQLInt = GraphQLInt;
  var GraphQLFloat = new _definition.GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      let num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (typeof num !== "number" || !Number.isFinite(num)) {
        throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(coercedValue)}`);
      }
      return num;
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
        throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _printer.print)(valueNode)}`, valueNode);
      }
      return parseFloat(valueNode.value);
    }
  });
  exports.GraphQLFloat = GraphQLFloat;
  var GraphQLString = new _definition.GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (typeof coercedValue === "boolean") {
        return coercedValue ? "true" : "false";
      }
      if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
        return coercedValue.toString();
      }
      throw new _GraphQLError.GraphQLError(`String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "string") {
        throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.STRING) {
        throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _printer.print)(valueNode)}`, {
          nodes: valueNode
        });
      }
      return valueNode.value;
    }
  });
  exports.GraphQLString = GraphQLString;
  var GraphQLBoolean = new _definition.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue;
      }
      if (Number.isFinite(coercedValue)) {
        return coercedValue !== 0;
      }
      throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(coercedValue)}`);
    },
    parseValue(inputValue) {
      if (typeof inputValue !== "boolean") {
        throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(inputValue)}`);
      }
      return inputValue;
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
        throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _printer.print)(valueNode)}`, {
          nodes: valueNode
        });
      }
      return valueNode.value;
    }
  });
  exports.GraphQLBoolean = GraphQLBoolean;
  var GraphQLID = new _definition.GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize(outputValue) {
      const coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (Number.isInteger(coercedValue)) {
        return String(coercedValue);
      }
      throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
    },
    parseValue(inputValue) {
      if (typeof inputValue === "string") {
        return inputValue;
      }
      if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
        return inputValue.toString();
      }
      throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`);
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
        throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), {
          nodes: valueNode
        });
      }
      return valueNode.value;
    }
  });
  exports.GraphQLID = GraphQLID;
  var specifiedScalarTypes = Object.freeze([
    GraphQLString,
    GraphQLInt,
    GraphQLFloat,
    GraphQLBoolean,
    GraphQLID
  ]);
  exports.specifiedScalarTypes = specifiedScalarTypes;
  function isSpecifiedScalarType(type2) {
    return specifiedScalarTypes.some(({ name }) => type2.name === name);
  }
  function serializeObject(outputValue) {
    if ((0, _isObjectLike.isObjectLike)(outputValue)) {
      if (typeof outputValue.valueOf === "function") {
        const valueOfResult = outputValue.valueOf();
        if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
          return valueOfResult;
        }
      }
      if (typeof outputValue.toJSON === "function") {
        return outputValue.toJSON();
      }
    }
    return outputValue;
  }
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLSpecifiedByDirective = exports.GraphQLSkipDirective = exports.GraphQLOneOfDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = undefined;
  exports.assertDirective = assertDirective;
  exports.isDirective = isDirective;
  exports.isSpecifiedDirective = isSpecifiedDirective;
  exports.specifiedDirectives = undefined;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();
  var _isObjectLike = require_isObjectLike();
  var _toObjMap = require_toObjMap();
  var _directiveLocation = require_directiveLocation();
  var _assertName = require_assertName();
  var _definition = require_definition();
  var _scalars = require_scalars();
  function isDirective(directive) {
    return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
  }
  function assertDirective(directive) {
    if (!isDirective(directive)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`);
    }
    return directive;
  }

  class GraphQLDirective {
    constructor(config) {
      var _config$isRepeatable, _config$args;
      this.name = (0, _assertName.assertName)(config.name);
      this.description = config.description;
      this.locations = config.locations;
      this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      Array.isArray(config.locations) || (0, _devAssert.devAssert)(false, `@${config.name} locations must be an Array.`);
      const args = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
      (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(false, `@${config.name} args must be an object with argument names as keys.`);
      this.args = (0, _definition.defineArguments)(args);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLDirective";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        locations: this.locations,
        args: (0, _definition.argsToArgsConfig)(this.args),
        isRepeatable: this.isRepeatable,
        extensions: this.extensions,
        astNode: this.astNode
      };
    }
    toString() {
      return "@" + this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.GraphQLDirective = GraphQLDirective;
  var GraphQLIncludeDirective = new GraphQLDirective({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
      _directiveLocation.DirectiveLocation.FIELD,
      _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
      _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        description: "Included when true."
      }
    }
  });
  exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
  var GraphQLSkipDirective = new GraphQLDirective({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
      _directiveLocation.DirectiveLocation.FIELD,
      _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
      _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        description: "Skipped when true."
      }
    }
  });
  exports.GraphQLSkipDirective = GraphQLSkipDirective;
  var DEFAULT_DEPRECATION_REASON = "No longer supported";
  exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
  var GraphQLDeprecatedDirective = new GraphQLDirective({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
      _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
      _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
      _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
      _directiveLocation.DirectiveLocation.ENUM_VALUE
    ],
    args: {
      reason: {
        type: _scalars.GraphQLString,
        description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: DEFAULT_DEPRECATION_REASON
      }
    }
  });
  exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
  var GraphQLSpecifiedByDirective = new GraphQLDirective({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behavior of this scalar.",
    locations: [_directiveLocation.DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The URL that specifies the behavior of this scalar."
      }
    }
  });
  exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
  var GraphQLOneOfDirective = new GraphQLDirective({
    name: "oneOf",
    description: "Indicates exactly one field must be supplied and this field must not be `null`.",
    locations: [_directiveLocation.DirectiveLocation.INPUT_OBJECT],
    args: {}
  });
  exports.GraphQLOneOfDirective = GraphQLOneOfDirective;
  var specifiedDirectives = Object.freeze([
    GraphQLIncludeDirective,
    GraphQLSkipDirective,
    GraphQLDeprecatedDirective,
    GraphQLSpecifiedByDirective,
    GraphQLOneOfDirective
  ]);
  exports.specifiedDirectives = specifiedDirectives;
  function isSpecifiedDirective(directive) {
    return specifiedDirectives.some(({ name }) => name === directive.name);
  }
});

// node_modules/graphql/jsutils/isIterableObject.js
var require_isIterableObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isIterableObject = isIterableObject;
  function isIterableObject(maybeIterable) {
    return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === undefined ? undefined : maybeIterable[Symbol.iterator]) === "function";
  }
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.astFromValue = astFromValue;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _isIterableObject = require_isIterableObject();
  var _isObjectLike = require_isObjectLike();
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _scalars = require_scalars();
  function astFromValue(value, type2) {
    if ((0, _definition.isNonNullType)(type2)) {
      const astValue = astFromValue(value, type2.ofType);
      if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === _kinds.Kind.NULL) {
        return null;
      }
      return astValue;
    }
    if (value === null) {
      return {
        kind: _kinds.Kind.NULL
      };
    }
    if (value === undefined) {
      return null;
    }
    if ((0, _definition.isListType)(type2)) {
      const itemType = type2.ofType;
      if ((0, _isIterableObject.isIterableObject)(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValue(item, itemType);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return {
          kind: _kinds.Kind.LIST,
          values: valuesNodes
        };
      }
      return astFromValue(value, itemType);
    }
    if ((0, _definition.isInputObjectType)(type2)) {
      if (!(0, _isObjectLike.isObjectLike)(value)) {
        return null;
      }
      const fieldNodes = [];
      for (const field of Object.values(type2.getFields())) {
        const fieldValue = astFromValue(value[field.name], field.type);
        if (fieldValue) {
          fieldNodes.push({
            kind: _kinds.Kind.OBJECT_FIELD,
            name: {
              kind: _kinds.Kind.NAME,
              value: field.name
            },
            value: fieldValue
          });
        }
      }
      return {
        kind: _kinds.Kind.OBJECT,
        fields: fieldNodes
      };
    }
    if ((0, _definition.isLeafType)(type2)) {
      const serialized = type2.serialize(value);
      if (serialized == null) {
        return null;
      }
      if (typeof serialized === "boolean") {
        return {
          kind: _kinds.Kind.BOOLEAN,
          value: serialized
        };
      }
      if (typeof serialized === "number" && Number.isFinite(serialized)) {
        const stringNum = String(serialized);
        return integerStringRegExp.test(stringNum) ? {
          kind: _kinds.Kind.INT,
          value: stringNum
        } : {
          kind: _kinds.Kind.FLOAT,
          value: stringNum
        };
      }
      if (typeof serialized === "string") {
        if ((0, _definition.isEnumType)(type2)) {
          return {
            kind: _kinds.Kind.ENUM,
            value: serialized
          };
        }
        if (type2 === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
          return {
            kind: _kinds.Kind.INT,
            value: serialized
          };
        }
        return {
          kind: _kinds.Kind.STRING,
          value: serialized
        };
      }
      throw new TypeError(`Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`);
    }
    (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type2));
  }
  var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.introspectionTypes = exports.__TypeKind = exports.__Type = exports.__Schema = exports.__InputValue = exports.__Field = exports.__EnumValue = exports.__DirectiveLocation = exports.__Directive = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.TypeKind = exports.SchemaMetaFieldDef = undefined;
  exports.isIntrospectionType = isIntrospectionType;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _directiveLocation = require_directiveLocation();
  var _printer = require_printer();
  var _astFromValue = require_astFromValue();
  var _definition = require_definition();
  var _scalars = require_scalars();
  var __Schema = new _definition.GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: () => ({
      description: {
        type: _scalars.GraphQLString,
        resolve: (schema) => schema.description
      },
      types: {
        description: "A list of all types supported by this server.",
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
        resolve(schema) {
          return Object.values(schema.getTypeMap());
        }
      },
      queryType: {
        description: "The type that query operations will be rooted at.",
        type: new _definition.GraphQLNonNull(__Type),
        resolve: (schema) => schema.getQueryType()
      },
      mutationType: {
        description: "If this server supports mutation, the type that mutation operations will be rooted at.",
        type: __Type,
        resolve: (schema) => schema.getMutationType()
      },
      subscriptionType: {
        description: "If this server support subscription, the type that subscription operations will be rooted at.",
        type: __Type,
        resolve: (schema) => schema.getSubscriptionType()
      },
      directives: {
        description: "A list of all directives supported by this server.",
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
        resolve: (schema) => schema.getDirectives()
      }
    })
  });
  exports.__Schema = __Schema;
  var __Directive = new _definition.GraphQLObjectType({
    name: "__Directive",
    description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (directive) => directive.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (directive) => directive.description
      },
      isRepeatable: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (directive) => directive.isRepeatable
      },
      locations: {
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
        resolve: (directive) => directive.locations
      },
      args: {
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
        }
      }
    })
  });
  exports.__Directive = __Directive;
  var __DirectiveLocation = new _definition.GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: _directiveLocation.DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation."
      },
      MUTATION: {
        value: _directiveLocation.DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation."
      },
      SUBSCRIPTION: {
        value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation."
      },
      FIELD: {
        value: _directiveLocation.DirectiveLocation.FIELD,
        description: "Location adjacent to a field."
      },
      FRAGMENT_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition."
      },
      FRAGMENT_SPREAD: {
        value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread."
      },
      INLINE_FRAGMENT: {
        value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment."
      },
      VARIABLE_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition."
      },
      SCHEMA: {
        value: _directiveLocation.DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition."
      },
      SCALAR: {
        value: _directiveLocation.DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition."
      },
      OBJECT: {
        value: _directiveLocation.DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition."
      },
      FIELD_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition."
      },
      ARGUMENT_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition."
      },
      INTERFACE: {
        value: _directiveLocation.DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition."
      },
      UNION: {
        value: _directiveLocation.DirectiveLocation.UNION,
        description: "Location adjacent to a union definition."
      },
      ENUM: {
        value: _directiveLocation.DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition."
      },
      ENUM_VALUE: {
        value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition."
      },
      INPUT_OBJECT: {
        value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition."
      },
      INPUT_FIELD_DEFINITION: {
        value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition."
      }
    }
  });
  exports.__DirectiveLocation = __DirectiveLocation;
  var __Type = new _definition.GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: () => ({
      kind: {
        type: new _definition.GraphQLNonNull(__TypeKind),
        resolve(type2) {
          if ((0, _definition.isScalarType)(type2)) {
            return TypeKind.SCALAR;
          }
          if ((0, _definition.isObjectType)(type2)) {
            return TypeKind.OBJECT;
          }
          if ((0, _definition.isInterfaceType)(type2)) {
            return TypeKind.INTERFACE;
          }
          if ((0, _definition.isUnionType)(type2)) {
            return TypeKind.UNION;
          }
          if ((0, _definition.isEnumType)(type2)) {
            return TypeKind.ENUM;
          }
          if ((0, _definition.isInputObjectType)(type2)) {
            return TypeKind.INPUT_OBJECT;
          }
          if ((0, _definition.isListType)(type2)) {
            return TypeKind.LIST;
          }
          if ((0, _definition.isNonNullType)(type2)) {
            return TypeKind.NON_NULL;
          }
          (0, _invariant.invariant)(false, `Unexpected type: "${(0, _inspect.inspect)(type2)}".`);
        }
      },
      name: {
        type: _scalars.GraphQLString,
        resolve: (type2) => ("name" in type2) ? type2.name : undefined
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (type2) => ("description" in type2) ? type2.description : undefined
      },
      specifiedByURL: {
        type: _scalars.GraphQLString,
        resolve: (obj) => ("specifiedByURL" in obj) ? obj.specifiedByURL : undefined
      },
      fields: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type2, { includeDeprecated }) {
          if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
            const fields = Object.values(type2.getFields());
            return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
          }
        }
      },
      interfaces: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
        resolve(type2) {
          if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
            return type2.getInterfaces();
          }
        }
      },
      possibleTypes: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
        resolve(type2, _args, _context, { schema }) {
          if ((0, _definition.isAbstractType)(type2)) {
            return schema.getPossibleTypes(type2);
          }
        }
      },
      enumValues: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type2, { includeDeprecated }) {
          if ((0, _definition.isEnumType)(type2)) {
            const values = type2.getValues();
            return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
          }
        }
      },
      inputFields: {
        type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(type2, { includeDeprecated }) {
          if ((0, _definition.isInputObjectType)(type2)) {
            const values = Object.values(type2.getFields());
            return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
          }
        }
      },
      ofType: {
        type: __Type,
        resolve: (type2) => ("ofType" in type2) ? type2.ofType : undefined
      },
      isOneOf: {
        type: _scalars.GraphQLBoolean,
        resolve: (type2) => {
          if ((0, _definition.isInputObjectType)(type2)) {
            return type2.isOneOf;
          }
        }
      }
    })
  });
  exports.__Type = __Type;
  var __Field = new _definition.GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (field) => field.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (field) => field.description
      },
      args: {
        type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
        args: {
          includeDeprecated: {
            type: _scalars.GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
        }
      },
      type: {
        type: new _definition.GraphQLNonNull(__Type),
        resolve: (field) => field.type
      },
      isDeprecated: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (field) => field.deprecationReason != null
      },
      deprecationReason: {
        type: _scalars.GraphQLString,
        resolve: (field) => field.deprecationReason
      }
    })
  });
  exports.__Field = __Field;
  var __InputValue = new _definition.GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (inputValue) => inputValue.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (inputValue) => inputValue.description
      },
      type: {
        type: new _definition.GraphQLNonNull(__Type),
        resolve: (inputValue) => inputValue.type
      },
      defaultValue: {
        type: _scalars.GraphQLString,
        description: "A GraphQL-formatted string representing the default value for this input value.",
        resolve(inputValue) {
          const { type: type2, defaultValue } = inputValue;
          const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type2);
          return valueAST ? (0, _printer.print)(valueAST) : null;
        }
      },
      isDeprecated: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (field) => field.deprecationReason != null
      },
      deprecationReason: {
        type: _scalars.GraphQLString,
        resolve: (obj) => obj.deprecationReason
      }
    })
  });
  exports.__InputValue = __InputValue;
  var __EnumValue = new _definition.GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: () => ({
      name: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        resolve: (enumValue) => enumValue.name
      },
      description: {
        type: _scalars.GraphQLString,
        resolve: (enumValue) => enumValue.description
      },
      isDeprecated: {
        type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
        resolve: (enumValue) => enumValue.deprecationReason != null
      },
      deprecationReason: {
        type: _scalars.GraphQLString,
        resolve: (enumValue) => enumValue.deprecationReason
      }
    })
  });
  exports.__EnumValue = __EnumValue;
  var TypeKind;
  exports.TypeKind = TypeKind;
  (function(TypeKind2) {
    TypeKind2["SCALAR"] = "SCALAR";
    TypeKind2["OBJECT"] = "OBJECT";
    TypeKind2["INTERFACE"] = "INTERFACE";
    TypeKind2["UNION"] = "UNION";
    TypeKind2["ENUM"] = "ENUM";
    TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
    TypeKind2["LIST"] = "LIST";
    TypeKind2["NON_NULL"] = "NON_NULL";
  })(TypeKind || (exports.TypeKind = TypeKind = {}));
  var __TypeKind = new _definition.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: TypeKind.SCALAR,
        description: "Indicates this type is a scalar."
      },
      OBJECT: {
        value: TypeKind.OBJECT,
        description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
      },
      INTERFACE: {
        value: TypeKind.INTERFACE,
        description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
      },
      UNION: {
        value: TypeKind.UNION,
        description: "Indicates this type is a union. `possibleTypes` is a valid field."
      },
      ENUM: {
        value: TypeKind.ENUM,
        description: "Indicates this type is an enum. `enumValues` is a valid field."
      },
      INPUT_OBJECT: {
        value: TypeKind.INPUT_OBJECT,
        description: "Indicates this type is an input object. `inputFields` is a valid field."
      },
      LIST: {
        value: TypeKind.LIST,
        description: "Indicates this type is a list. `ofType` is a valid field."
      },
      NON_NULL: {
        value: TypeKind.NON_NULL,
        description: "Indicates this type is a non-null. `ofType` is a valid field."
      }
    }
  });
  exports.__TypeKind = __TypeKind;
  var SchemaMetaFieldDef = {
    name: "__schema",
    type: new _definition.GraphQLNonNull(__Schema),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: (_source, _args, _context, { schema }) => schema,
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
  };
  exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
  var TypeMetaFieldDef = {
    name: "__type",
    type: __Type,
    description: "Request the type information of a single type.",
    args: [
      {
        name: "name",
        description: undefined,
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        defaultValue: undefined,
        deprecationReason: undefined,
        extensions: Object.create(null),
        astNode: undefined
      }
    ],
    resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
  };
  exports.TypeMetaFieldDef = TypeMetaFieldDef;
  var TypeNameMetaFieldDef = {
    name: "__typename",
    type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: (_source, _args, _context, { parentType }) => parentType.name,
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
  };
  exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
  var introspectionTypes = Object.freeze([
    __Schema,
    __Directive,
    __DirectiveLocation,
    __Type,
    __Field,
    __InputValue,
    __EnumValue,
    __TypeKind
  ]);
  exports.introspectionTypes = introspectionTypes;
  function isIntrospectionType(type2) {
    return introspectionTypes.some(({ name }) => type2.name === name);
  }
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GraphQLSchema = undefined;
  exports.assertSchema = assertSchema;
  exports.isSchema = isSchema;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _instanceOf = require_instanceOf();
  var _isObjectLike = require_isObjectLike();
  var _toObjMap = require_toObjMap();
  var _ast = require_ast();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  function isSchema(schema) {
    return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
  }
  function assertSchema(schema) {
    if (!isSchema(schema)) {
      throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);
    }
    return schema;
  }

  class GraphQLSchema {
    constructor(config) {
      var _config$extensionASTN, _config$directives;
      this.__validationErrors = config.assumeValid === true ? [] : undefined;
      (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
      !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(false, `"types" must be Array if provided but got: ${(0, _inspect.inspect)(config.types)}.`);
      !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(false, '"directives" must be Array if provided but got: ' + `${(0, _inspect.inspect)(config.directives)}.`);
      this.description = config.description;
      this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
      this.astNode = config.astNode;
      this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
      this._queryType = config.query;
      this._mutationType = config.mutation;
      this._subscriptionType = config.subscription;
      this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : _directives.specifiedDirectives;
      const allReferencedTypes = new Set(config.types);
      if (config.types != null) {
        for (const type2 of config.types) {
          allReferencedTypes.delete(type2);
          collectReferencedTypes(type2, allReferencedTypes);
        }
      }
      if (this._queryType != null) {
        collectReferencedTypes(this._queryType, allReferencedTypes);
      }
      if (this._mutationType != null) {
        collectReferencedTypes(this._mutationType, allReferencedTypes);
      }
      if (this._subscriptionType != null) {
        collectReferencedTypes(this._subscriptionType, allReferencedTypes);
      }
      for (const directive of this._directives) {
        if ((0, _directives.isDirective)(directive)) {
          for (const arg of directive.args) {
            collectReferencedTypes(arg.type, allReferencedTypes);
          }
        }
      }
      collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
      this._typeMap = Object.create(null);
      this._subTypeMap = Object.create(null);
      this._implementationsMap = Object.create(null);
      for (const namedType of allReferencedTypes) {
        if (namedType == null) {
          continue;
        }
        const typeName = namedType.name;
        typeName || (0, _devAssert.devAssert)(false, "One of the provided types for building the Schema is missing a name.");
        if (this._typeMap[typeName] !== undefined) {
          throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
        }
        this._typeMap[typeName] = namedType;
        if ((0, _definition.isInterfaceType)(namedType)) {
          for (const iface of namedType.getInterfaces()) {
            if ((0, _definition.isInterfaceType)(iface)) {
              let implementations = this._implementationsMap[iface.name];
              if (implementations === undefined) {
                implementations = this._implementationsMap[iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              implementations.interfaces.push(namedType);
            }
          }
        } else if ((0, _definition.isObjectType)(namedType)) {
          for (const iface of namedType.getInterfaces()) {
            if ((0, _definition.isInterfaceType)(iface)) {
              let implementations = this._implementationsMap[iface.name];
              if (implementations === undefined) {
                implementations = this._implementationsMap[iface.name] = {
                  objects: [],
                  interfaces: []
                };
              }
              implementations.objects.push(namedType);
            }
          }
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLSchema";
    }
    getQueryType() {
      return this._queryType;
    }
    getMutationType() {
      return this._mutationType;
    }
    getSubscriptionType() {
      return this._subscriptionType;
    }
    getRootType(operation) {
      switch (operation) {
        case _ast.OperationTypeNode.QUERY:
          return this.getQueryType();
        case _ast.OperationTypeNode.MUTATION:
          return this.getMutationType();
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return this.getSubscriptionType();
      }
    }
    getTypeMap() {
      return this._typeMap;
    }
    getType(name) {
      return this.getTypeMap()[name];
    }
    getPossibleTypes(abstractType) {
      return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
    }
    getImplementations(interfaceType) {
      const implementations = this._implementationsMap[interfaceType.name];
      return implementations !== null && implementations !== undefined ? implementations : {
        objects: [],
        interfaces: []
      };
    }
    isSubType(abstractType, maybeSubType) {
      let map = this._subTypeMap[abstractType.name];
      if (map === undefined) {
        map = Object.create(null);
        if ((0, _definition.isUnionType)(abstractType)) {
          for (const type2 of abstractType.getTypes()) {
            map[type2.name] = true;
          }
        } else {
          const implementations = this.getImplementations(abstractType);
          for (const type2 of implementations.objects) {
            map[type2.name] = true;
          }
          for (const type2 of implementations.interfaces) {
            map[type2.name] = true;
          }
        }
        this._subTypeMap[abstractType.name] = map;
      }
      return map[maybeSubType.name] !== undefined;
    }
    getDirectives() {
      return this._directives;
    }
    getDirective(name) {
      return this.getDirectives().find((directive) => directive.name === name);
    }
    toConfig() {
      return {
        description: this.description,
        query: this.getQueryType(),
        mutation: this.getMutationType(),
        subscription: this.getSubscriptionType(),
        types: Object.values(this.getTypeMap()),
        directives: this.getDirectives(),
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        assumeValid: this.__validationErrors !== undefined
      };
    }
  }
  exports.GraphQLSchema = GraphQLSchema;
  function collectReferencedTypes(type2, typeSet) {
    const namedType = (0, _definition.getNamedType)(type2);
    if (!typeSet.has(namedType)) {
      typeSet.add(namedType);
      if ((0, _definition.isUnionType)(namedType)) {
        for (const memberType of namedType.getTypes()) {
          collectReferencedTypes(memberType, typeSet);
        }
      } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
        for (const interfaceType of namedType.getInterfaces()) {
          collectReferencedTypes(interfaceType, typeSet);
        }
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
          for (const arg of field.args) {
            collectReferencedTypes(arg.type, typeSet);
          }
        }
      } else if ((0, _definition.isInputObjectType)(namedType)) {
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
        }
      }
    }
    return typeSet;
  }
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidSchema = assertValidSchema;
  exports.validateSchema = validateSchema;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _ast = require_ast();
  var _typeComparators = require_typeComparators();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _schema = require_schema();
  function validateSchema(schema) {
    (0, _schema.assertSchema)(schema);
    if (schema.__validationErrors) {
      return schema.__validationErrors;
    }
    const context = new SchemaValidationContext(schema);
    validateRootTypes(context);
    validateDirectives(context);
    validateTypes(context);
    const errors = context.getErrors();
    schema.__validationErrors = errors;
    return errors;
  }
  function assertValidSchema(schema) {
    const errors = validateSchema(schema);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join(`

`));
    }
  }

  class SchemaValidationContext {
    constructor(schema) {
      this._errors = [];
      this.schema = schema;
    }
    reportError(message, nodes) {
      const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
      this._errors.push(new _GraphQLError.GraphQLError(message, {
        nodes: _nodes
      }));
    }
    getErrors() {
      return this._errors;
    }
  }
  function validateRootTypes(context) {
    const schema = context.schema;
    const queryType = schema.getQueryType();
    if (!queryType) {
      context.reportError("Query root type must be provided.", schema.astNode);
    } else if (!(0, _definition.isObjectType)(queryType)) {
      var _getOperationTypeNode;
      context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
    }
    const mutationType = schema.getMutationType();
    if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
      var _getOperationTypeNode2;
      context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
      var _getOperationTypeNode3;
      context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
    }
  }
  function getOperationTypeNode(schema, operation) {
    var _flatMap$find;
    return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap((schemaNode) => {
      var _schemaNode$operation;
      return (_schemaNode$operation = schemaNode === null || schemaNode === undefined ? undefined : schemaNode.operationTypes) !== null && _schemaNode$operation !== undefined ? _schemaNode$operation : [];
    }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === undefined ? undefined : _flatMap$find.type;
  }
  function validateDirectives(context) {
    for (const directive of context.schema.getDirectives()) {
      if (!(0, _directives.isDirective)(directive)) {
        context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === undefined ? undefined : directive.astNode);
        continue;
      }
      validateName(context, directive);
      if (directive.locations.length === 0) {
        context.reportError(`Directive @${directive.name} must include 1 or more locations.`, directive.astNode);
      }
      for (const arg of directive.args) {
        validateName(context, arg);
        if (!(0, _definition.isInputType)(arg.type)) {
          context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);
        }
        if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
          var _arg$astNode;
          context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
          ]);
        }
      }
    }
  }
  function validateName(context, node2) {
    if (node2.name.startsWith("__")) {
      context.reportError(`Name "${node2.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node2.astNode);
    }
  }
  function validateTypes(context) {
    const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
    const typeMap = context.schema.getTypeMap();
    for (const type2 of Object.values(typeMap)) {
      if (!(0, _definition.isNamedType)(type2)) {
        context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type2)}.`, type2.astNode);
        continue;
      }
      if (!(0, _introspection.isIntrospectionType)(type2)) {
        validateName(context, type2);
      }
      if ((0, _definition.isObjectType)(type2)) {
        validateFields(context, type2);
        validateInterfaces(context, type2);
      } else if ((0, _definition.isInterfaceType)(type2)) {
        validateFields(context, type2);
        validateInterfaces(context, type2);
      } else if ((0, _definition.isUnionType)(type2)) {
        validateUnionMembers(context, type2);
      } else if ((0, _definition.isEnumType)(type2)) {
        validateEnumValues(context, type2);
      } else if ((0, _definition.isInputObjectType)(type2)) {
        validateInputFields(context, type2);
        validateInputObjectCircularRefs(type2);
      }
    }
  }
  function validateFields(context, type2) {
    const fields = Object.values(type2.getFields());
    if (fields.length === 0) {
      context.reportError(`Type ${type2.name} must define one or more fields.`, [
        type2.astNode,
        ...type2.extensionASTNodes
      ]);
    }
    for (const field of fields) {
      validateName(context, field);
      if (!(0, _definition.isOutputType)(field.type)) {
        var _field$astNode;
        context.reportError(`The type of ${type2.name}.${field.name} must be Output Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
      }
      for (const arg of field.args) {
        const argName = arg.name;
        validateName(context, arg);
        if (!(0, _definition.isInputType)(arg.type)) {
          var _arg$astNode2;
          context.reportError(`The type of ${type2.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
        }
        if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
          var _arg$astNode3;
          context.reportError(`Required argument ${type2.name}.${field.name}(${argName}:) cannot be deprecated.`, [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
          ]);
        }
      }
    }
  }
  function validateInterfaces(context, type2) {
    const ifaceTypeNames = Object.create(null);
    for (const iface of type2.getInterfaces()) {
      if (!(0, _definition.isInterfaceType)(iface)) {
        context.reportError(`Type ${(0, _inspect.inspect)(type2)} must only implement Interface types, ` + `it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type2, iface));
        continue;
      }
      if (type2 === iface) {
        context.reportError(`Type ${type2.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type2, iface));
        continue;
      }
      if (ifaceTypeNames[iface.name]) {
        context.reportError(`Type ${type2.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type2, iface));
        continue;
      }
      ifaceTypeNames[iface.name] = true;
      validateTypeImplementsAncestors(context, type2, iface);
      validateTypeImplementsInterface(context, type2, iface);
    }
  }
  function validateTypeImplementsInterface(context, type2, iface) {
    const typeFieldMap = type2.getFields();
    for (const ifaceField of Object.values(iface.getFields())) {
      const fieldName = ifaceField.name;
      const typeField = typeFieldMap[fieldName];
      if (!typeField) {
        context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type2.name} does not provide it.`, [ifaceField.astNode, type2.astNode, ...type2.extensionASTNodes]);
        continue;
      }
      if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
        var _ifaceField$astNode, _typeField$astNode;
        context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${(0, _inspect.inspect)(ifaceField.type)} but ${type2.name}.${fieldName} ` + `is type ${(0, _inspect.inspect)(typeField.type)}.`, [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
        ]);
      }
      for (const ifaceArg of ifaceField.args) {
        const argName = ifaceArg.name;
        const typeArg = typeField.args.find((arg) => arg.name === argName);
        if (!typeArg) {
          context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type2.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
          continue;
        }
        if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
          var _ifaceArg$astNode, _typeArg$astNode;
          context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` + `${type2.name}.${fieldName}(${argName}:) is type ` + `${(0, _inspect.inspect)(typeArg.type)}.`, [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
          ]);
        }
      }
      for (const typeArg of typeField.args) {
        const argName = typeArg.name;
        const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
        if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
          context.reportError(`Object field ${type2.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
        }
      }
    }
  }
  function validateTypeImplementsAncestors(context, type2, iface) {
    const ifaceInterfaces = type2.getInterfaces();
    for (const transitive of iface.getInterfaces()) {
      if (!ifaceInterfaces.includes(transitive)) {
        context.reportError(transitive === type2 ? `Type ${type2.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type2.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type2, iface)
        ]);
      }
    }
  }
  function validateUnionMembers(context, union) {
    const memberTypes = union.getTypes();
    if (memberTypes.length === 0) {
      context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
    }
    const includedTypeNames = Object.create(null);
    for (const memberType of memberTypes) {
      if (includedTypeNames[memberType.name]) {
        context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
        continue;
      }
      includedTypeNames[memberType.name] = true;
      if (!(0, _definition.isObjectType)(memberType)) {
        context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
      }
    }
  }
  function validateEnumValues(context, enumType) {
    const enumValues = enumType.getValues();
    if (enumValues.length === 0) {
      context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
    }
    for (const enumValue of enumValues) {
      validateName(context, enumValue);
    }
  }
  function validateInputFields(context, inputObj) {
    const fields = Object.values(inputObj.getFields());
    if (fields.length === 0) {
      context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
    }
    for (const field of fields) {
      validateName(context, field);
      if (!(0, _definition.isInputType)(field.type)) {
        var _field$astNode2;
        context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
      }
      if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
        var _field$astNode3;
        context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
        ]);
      }
      if (inputObj.isOneOf) {
        validateOneOfInputObjectField(inputObj, field, context);
      }
    }
  }
  function validateOneOfInputObjectField(type2, field, context) {
    if ((0, _definition.isNonNullType)(field.type)) {
      var _field$astNode4;
      context.reportError(`OneOf input field ${type2.name}.${field.name} must be nullable.`, (_field$astNode4 = field.astNode) === null || _field$astNode4 === undefined ? undefined : _field$astNode4.type);
    }
    if (field.defaultValue !== undefined) {
      context.reportError(`OneOf input field ${type2.name}.${field.name} cannot have a default value.`, field.astNode);
    }
  }
  function createInputObjectCircularRefsValidator(context) {
    const visitedTypes = Object.create(null);
    const fieldPath = [];
    const fieldPathIndexByTypeName = Object.create(null);
    return detectCycleRecursive;
    function detectCycleRecursive(inputObj) {
      if (visitedTypes[inputObj.name]) {
        return;
      }
      visitedTypes[inputObj.name] = true;
      fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
      const fields = Object.values(inputObj.getFields());
      for (const field of fields) {
        if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
          const fieldType = field.type.ofType;
          const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
          fieldPath.push(field);
          if (cycleIndex === undefined) {
            detectCycleRecursive(fieldType);
          } else {
            const cyclePath = fieldPath.slice(cycleIndex);
            const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
            context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
          }
          fieldPath.pop();
        }
      }
      fieldPathIndexByTypeName[inputObj.name] = undefined;
    }
  }
  function getAllImplementsInterfaceNodes(type2, iface) {
    const { astNode, extensionASTNodes } = type2;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((typeNode) => {
      var _typeNode$interfaces;
      return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== undefined ? _typeNode$interfaces : [];
    }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
  }
  function getUnionMemberTypeNodes(union, typeName) {
    const { astNode, extensionASTNodes } = union;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((unionNode) => {
      var _unionNode$types;
      return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== undefined ? _unionNode$types : [];
    }).filter((typeNode) => typeNode.name.value === typeName);
  }
  function getDeprecatedDirectiveNode(definitionNode) {
    var _definitionNode$direc;
    return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find((node2) => node2.name.value === _directives.GraphQLDeprecatedDirective.name);
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.typeFromAST = typeFromAST;
  var _kinds = require_kinds();
  var _definition = require_definition();
  function typeFromAST(schema, typeNode) {
    switch (typeNode.kind) {
      case _kinds.Kind.LIST_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLList(innerType);
      }
      case _kinds.Kind.NON_NULL_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLNonNull(innerType);
      }
      case _kinds.Kind.NAMED_TYPE:
        return schema.getType(typeNode.name.value);
    }
  }
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TypeInfo = undefined;
  exports.visitWithTypeInfo = visitWithTypeInfo;
  var _ast = require_ast();
  var _kinds = require_kinds();
  var _visitor = require_visitor();
  var _definition = require_definition();
  var _introspection = require_introspection();
  var _typeFromAST = require_typeFromAST();

  class TypeInfo {
    constructor(schema, initialType, getFieldDefFn) {
      this._schema = schema;
      this._typeStack = [];
      this._parentTypeStack = [];
      this._inputTypeStack = [];
      this._fieldDefStack = [];
      this._defaultValueStack = [];
      this._directive = null;
      this._argument = null;
      this._enumValue = null;
      this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
      if (initialType) {
        if ((0, _definition.isInputType)(initialType)) {
          this._inputTypeStack.push(initialType);
        }
        if ((0, _definition.isCompositeType)(initialType)) {
          this._parentTypeStack.push(initialType);
        }
        if ((0, _definition.isOutputType)(initialType)) {
          this._typeStack.push(initialType);
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "TypeInfo";
    }
    getType() {
      if (this._typeStack.length > 0) {
        return this._typeStack[this._typeStack.length - 1];
      }
    }
    getParentType() {
      if (this._parentTypeStack.length > 0) {
        return this._parentTypeStack[this._parentTypeStack.length - 1];
      }
    }
    getInputType() {
      if (this._inputTypeStack.length > 0) {
        return this._inputTypeStack[this._inputTypeStack.length - 1];
      }
    }
    getParentInputType() {
      if (this._inputTypeStack.length > 1) {
        return this._inputTypeStack[this._inputTypeStack.length - 2];
      }
    }
    getFieldDef() {
      if (this._fieldDefStack.length > 0) {
        return this._fieldDefStack[this._fieldDefStack.length - 1];
      }
    }
    getDefaultValue() {
      if (this._defaultValueStack.length > 0) {
        return this._defaultValueStack[this._defaultValueStack.length - 1];
      }
    }
    getDirective() {
      return this._directive;
    }
    getArgument() {
      return this._argument;
    }
    getEnumValue() {
      return this._enumValue;
    }
    enter(node2) {
      const schema = this._schema;
      switch (node2.kind) {
        case _kinds.Kind.SELECTION_SET: {
          const namedType = (0, _definition.getNamedType)(this.getType());
          this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);
          break;
        }
        case _kinds.Kind.FIELD: {
          const parentType = this.getParentType();
          let fieldDef;
          let fieldType;
          if (parentType) {
            fieldDef = this._getFieldDef(schema, parentType, node2);
            if (fieldDef) {
              fieldType = fieldDef.type;
            }
          }
          this._fieldDefStack.push(fieldDef);
          this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);
          break;
        }
        case _kinds.Kind.DIRECTIVE:
          this._directive = schema.getDirective(node2.name.value);
          break;
        case _kinds.Kind.OPERATION_DEFINITION: {
          const rootType = schema.getRootType(node2.operation);
          this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : undefined);
          break;
        }
        case _kinds.Kind.INLINE_FRAGMENT:
        case _kinds.Kind.FRAGMENT_DEFINITION: {
          const typeConditionAST = node2.typeCondition;
          const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
          this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);
          break;
        }
        case _kinds.Kind.VARIABLE_DEFINITION: {
          const inputType = (0, _typeFromAST.typeFromAST)(schema, node2.type);
          this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);
          break;
        }
        case _kinds.Kind.ARGUMENT: {
          var _this$getDirective;
          let argDef;
          let argType;
          const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
          if (fieldOrDirective) {
            argDef = fieldOrDirective.args.find((arg) => arg.name === node2.name.value);
            if (argDef) {
              argType = argDef.type;
            }
          }
          this._argument = argDef;
          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);
          break;
        }
        case _kinds.Kind.LIST: {
          const listType = (0, _definition.getNullableType)(this.getInputType());
          const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
          this._defaultValueStack.push(undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);
          break;
        }
        case _kinds.Kind.OBJECT_FIELD: {
          const objectType = (0, _definition.getNamedType)(this.getInputType());
          let inputFieldType;
          let inputField;
          if ((0, _definition.isInputObjectType)(objectType)) {
            inputField = objectType.getFields()[node2.name.value];
            if (inputField) {
              inputFieldType = inputField.type;
            }
          }
          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
          this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);
          break;
        }
        case _kinds.Kind.ENUM: {
          const enumType = (0, _definition.getNamedType)(this.getInputType());
          let enumValue;
          if ((0, _definition.isEnumType)(enumType)) {
            enumValue = enumType.getValue(node2.value);
          }
          this._enumValue = enumValue;
          break;
        }
        default:
      }
    }
    leave(node2) {
      switch (node2.kind) {
        case _kinds.Kind.SELECTION_SET:
          this._parentTypeStack.pop();
          break;
        case _kinds.Kind.FIELD:
          this._fieldDefStack.pop();
          this._typeStack.pop();
          break;
        case _kinds.Kind.DIRECTIVE:
          this._directive = null;
          break;
        case _kinds.Kind.OPERATION_DEFINITION:
        case _kinds.Kind.INLINE_FRAGMENT:
        case _kinds.Kind.FRAGMENT_DEFINITION:
          this._typeStack.pop();
          break;
        case _kinds.Kind.VARIABLE_DEFINITION:
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.ARGUMENT:
          this._argument = null;
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.LIST:
        case _kinds.Kind.OBJECT_FIELD:
          this._defaultValueStack.pop();
          this._inputTypeStack.pop();
          break;
        case _kinds.Kind.ENUM:
          this._enumValue = null;
          break;
        default:
      }
    }
  }
  exports.TypeInfo = TypeInfo;
  function getFieldDef(schema, parentType, fieldNode) {
    const name = fieldNode.name.value;
    if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.SchemaMetaFieldDef;
    }
    if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.TypeMetaFieldDef;
    }
    if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
      return _introspection.TypeNameMetaFieldDef;
    }
    if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
      return parentType.getFields()[name];
    }
  }
  function visitWithTypeInfo(typeInfo, visitor) {
    return {
      enter(...args) {
        const node2 = args[0];
        typeInfo.enter(node2);
        const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node2.kind).enter;
        if (fn) {
          const result = fn.apply(visitor, args);
          if (result !== undefined) {
            typeInfo.leave(node2);
            if ((0, _ast.isNode)(result)) {
              typeInfo.enter(result);
            }
          }
          return result;
        }
      },
      leave(...args) {
        const node2 = args[0];
        const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node2.kind).leave;
        let result;
        if (fn) {
          result = fn.apply(visitor, args);
        }
        typeInfo.leave(node2);
        return result;
      }
    };
  }
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isConstValueNode = isConstValueNode;
  exports.isDefinitionNode = isDefinitionNode;
  exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
  exports.isSelectionNode = isSelectionNode;
  exports.isTypeDefinitionNode = isTypeDefinitionNode;
  exports.isTypeExtensionNode = isTypeExtensionNode;
  exports.isTypeNode = isTypeNode;
  exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
  exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
  exports.isValueNode = isValueNode;
  var _kinds = require_kinds();
  function isDefinitionNode(node2) {
    return isExecutableDefinitionNode(node2) || isTypeSystemDefinitionNode(node2) || isTypeSystemExtensionNode(node2);
  }
  function isExecutableDefinitionNode(node2) {
    return node2.kind === _kinds.Kind.OPERATION_DEFINITION || node2.kind === _kinds.Kind.FRAGMENT_DEFINITION;
  }
  function isSelectionNode(node2) {
    return node2.kind === _kinds.Kind.FIELD || node2.kind === _kinds.Kind.FRAGMENT_SPREAD || node2.kind === _kinds.Kind.INLINE_FRAGMENT;
  }
  function isValueNode(node2) {
    return node2.kind === _kinds.Kind.VARIABLE || node2.kind === _kinds.Kind.INT || node2.kind === _kinds.Kind.FLOAT || node2.kind === _kinds.Kind.STRING || node2.kind === _kinds.Kind.BOOLEAN || node2.kind === _kinds.Kind.NULL || node2.kind === _kinds.Kind.ENUM || node2.kind === _kinds.Kind.LIST || node2.kind === _kinds.Kind.OBJECT;
  }
  function isConstValueNode(node2) {
    return isValueNode(node2) && (node2.kind === _kinds.Kind.LIST ? node2.values.some(isConstValueNode) : node2.kind === _kinds.Kind.OBJECT ? node2.fields.some((field) => isConstValueNode(field.value)) : node2.kind !== _kinds.Kind.VARIABLE);
  }
  function isTypeNode(node2) {
    return node2.kind === _kinds.Kind.NAMED_TYPE || node2.kind === _kinds.Kind.LIST_TYPE || node2.kind === _kinds.Kind.NON_NULL_TYPE;
  }
  function isTypeSystemDefinitionNode(node2) {
    return node2.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node2) || node2.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
  }
  function isTypeDefinitionNode(node2) {
    return node2.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node2.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node2.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node2.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node2.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node2.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
  }
  function isTypeSystemExtensionNode(node2) {
    return node2.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node2);
  }
  function isTypeExtensionNode(node2) {
    return node2.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node2.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node2.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node2.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node2.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node2.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  function ExecutableDefinitionsRule(context) {
    return {
      Document(node2) {
        for (const definition of node2.definitions) {
          if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
            const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
            context.reportError(new _GraphQLError.GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            }));
          }
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
  var _didYouMean = require_didYouMean();
  var _naturalCompare = require_naturalCompare();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function FieldsOnCorrectTypeRule(context) {
    return {
      Field(node2) {
        const type2 = context.getParentType();
        if (type2) {
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            const schema = context.getSchema();
            const fieldName = node2.name.value;
            let suggestion = (0, _didYouMean.didYouMean)("to use an inline fragment on", getSuggestedTypeNames(schema, type2, fieldName));
            if (suggestion === "") {
              suggestion = (0, _didYouMean.didYouMean)(getSuggestedFieldNames(type2, fieldName));
            }
            context.reportError(new _GraphQLError.GraphQLError(`Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion, {
              nodes: node2
            }));
          }
        }
      }
    };
  }
  function getSuggestedTypeNames(schema, type2, fieldName) {
    if (!(0, _definition.isAbstractType)(type2)) {
      return [];
    }
    const suggestedTypes = new Set;
    const usageCount = Object.create(null);
    for (const possibleType of schema.getPossibleTypes(type2)) {
      if (!possibleType.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleType);
      usageCount[possibleType.name] = 1;
      for (const possibleInterface of possibleType.getInterfaces()) {
        var _usageCount$possibleI;
        if (!possibleInterface.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleInterface);
        usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
      }
    }
    return [...suggestedTypes].sort((typeA, typeB) => {
      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
      if (usageCountDiff !== 0) {
        return usageCountDiff;
      }
      if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
        return -1;
      }
      if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
        return 1;
      }
      return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
    }).map((x) => x.name);
  }
  function getSuggestedFieldNames(type2, fieldName) {
    if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
      const possibleFieldNames = Object.keys(type2.getFields());
      return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
    }
    return [];
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  function FragmentsOnCompositeTypesRule(context) {
    return {
      InlineFragment(node2) {
        const typeCondition = node2.typeCondition;
        if (typeCondition) {
          const type2 = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
          if (type2 && !(0, _definition.isCompositeType)(type2)) {
            const typeStr = (0, _printer.print)(typeCondition);
            context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
              nodes: typeCondition
            }));
          }
        }
      },
      FragmentDefinition(node2) {
        const type2 = (0, _typeFromAST.typeFromAST)(context.getSchema(), node2.typeCondition);
        if (type2 && !(0, _definition.isCompositeType)(type2)) {
          const typeStr = (0, _printer.print)(node2.typeCondition);
          context.reportError(new _GraphQLError.GraphQLError(`Fragment "${node2.name.value}" cannot condition on non composite type "${typeStr}".`, {
            nodes: node2.typeCondition
          }));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
  exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
  var _didYouMean = require_didYouMean();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _directives = require_directives();
  function KnownArgumentNamesRule(context) {
    return {
      ...KnownArgumentNamesOnDirectivesRule(context),
      Argument(argNode) {
        const argDef = context.getArgument();
        const fieldDef = context.getFieldDef();
        const parentType = context.getParentType();
        if (!argDef && fieldDef && parentType) {
          const argName = argNode.name.value;
          const knownArgsNames = fieldDef.args.map((arg) => arg.name);
          const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgsNames);
          context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
            nodes: argNode
          }));
        }
      }
    };
  }
  function KnownArgumentNamesOnDirectivesRule(context) {
    const directiveArgs = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
        directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
      }
    }
    return {
      Directive(directiveNode) {
        const directiveName = directiveNode.name.value;
        const knownArgs = directiveArgs[directiveName];
        if (directiveNode.arguments && knownArgs) {
          for (const argNode of directiveNode.arguments) {
            const argName = argNode.name.value;
            if (!knownArgs.includes(argName)) {
              const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgs);
              context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions), {
                nodes: argNode
              }));
            }
          }
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownDirectivesRule = KnownDirectivesRule;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _GraphQLError = require_GraphQLError();
  var _ast = require_ast();
  var _directiveLocation = require_directiveLocation();
  var _kinds = require_kinds();
  var _directives = require_directives();
  function KnownDirectivesRule(context) {
    const locationsMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      locationsMap[directive.name] = directive.locations;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        locationsMap[def.name.value] = def.locations.map((name) => name.value);
      }
    }
    return {
      Directive(node2, _key, _parent, _path, ancestors) {
        const name = node2.name.value;
        const locations = locationsMap[name];
        if (!locations) {
          context.reportError(new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node2
          }));
          return;
        }
        const candidateLocation = getDirectiveLocationForASTPath(ancestors);
        if (candidateLocation && !locations.includes(candidateLocation)) {
          context.reportError(new _GraphQLError.GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
            nodes: node2
          }));
        }
      }
    };
  }
  function getDirectiveLocationForASTPath(ancestors) {
    const appliedTo = ancestors[ancestors.length - 1];
    "kind" in appliedTo || (0, _invariant.invariant)(false);
    switch (appliedTo.kind) {
      case _kinds.Kind.OPERATION_DEFINITION:
        return getDirectiveLocationForOperation(appliedTo.operation);
      case _kinds.Kind.FIELD:
        return _directiveLocation.DirectiveLocation.FIELD;
      case _kinds.Kind.FRAGMENT_SPREAD:
        return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
      case _kinds.Kind.INLINE_FRAGMENT:
        return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
      case _kinds.Kind.FRAGMENT_DEFINITION:
        return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
      case _kinds.Kind.VARIABLE_DEFINITION:
        return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
      case _kinds.Kind.SCHEMA_DEFINITION:
      case _kinds.Kind.SCHEMA_EXTENSION:
        return _directiveLocation.DirectiveLocation.SCHEMA;
      case _kinds.Kind.SCALAR_TYPE_DEFINITION:
      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.SCALAR;
      case _kinds.Kind.OBJECT_TYPE_DEFINITION:
      case _kinds.Kind.OBJECT_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.OBJECT;
      case _kinds.Kind.FIELD_DEFINITION:
        return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.INTERFACE;
      case _kinds.Kind.UNION_TYPE_DEFINITION:
      case _kinds.Kind.UNION_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.UNION;
      case _kinds.Kind.ENUM_TYPE_DEFINITION:
      case _kinds.Kind.ENUM_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.ENUM;
      case _kinds.Kind.ENUM_VALUE_DEFINITION:
        return _directiveLocation.DirectiveLocation.ENUM_VALUE;
      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
      case _kinds.Kind.INPUT_VALUE_DEFINITION: {
        const parentNode = ancestors[ancestors.length - 3];
        "kind" in parentNode || (0, _invariant.invariant)(false);
        return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
      }
      default:
        (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind));
    }
  }
  function getDirectiveLocationForOperation(operation) {
    switch (operation) {
      case _ast.OperationTypeNode.QUERY:
        return _directiveLocation.DirectiveLocation.QUERY;
      case _ast.OperationTypeNode.MUTATION:
        return _directiveLocation.DirectiveLocation.MUTATION;
      case _ast.OperationTypeNode.SUBSCRIPTION:
        return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
    }
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
  var _GraphQLError = require_GraphQLError();
  function KnownFragmentNamesRule(context) {
    return {
      FragmentSpread(node2) {
        const fragmentName = node2.name.value;
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          context.reportError(new _GraphQLError.GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node2.name
          }));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.KnownTypeNamesRule = KnownTypeNamesRule;
  var _didYouMean = require_didYouMean();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _predicates = require_predicates();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  function KnownTypeNamesRule(context) {
    const schema = context.getSchema();
    const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
    const definedTypes = Object.create(null);
    for (const def of context.getDocument().definitions) {
      if ((0, _predicates.isTypeDefinitionNode)(def)) {
        definedTypes[def.name.value] = true;
      }
    }
    const typeNames = [
      ...Object.keys(existingTypesMap),
      ...Object.keys(definedTypes)
    ];
    return {
      NamedType(node2, _1, parent, _2, ancestors) {
        const typeName = node2.name.value;
        if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
          var _ancestors$;
          const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
          const isSDL = definitionNode != null && isSDLNode(definitionNode);
          if (isSDL && standardTypeNames.includes(typeName)) {
            return;
          }
          const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
          context.reportError(new _GraphQLError.GraphQLError(`Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes), {
            nodes: node2
          }));
        }
      }
    };
  }
  var standardTypeNames = [
    ..._scalars.specifiedScalarTypes,
    ..._introspection.introspectionTypes
  ].map((type2) => type2.name);
  function isSDLNode(value) {
    return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  function LoneAnonymousOperationRule(context) {
    let operationCount = 0;
    return {
      Document(node2) {
        operationCount = node2.definitions.filter((definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION).length;
      },
      OperationDefinition(node2) {
        if (!node2.name && operationCount > 1) {
          context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", {
            nodes: node2
          }));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
  var _GraphQLError = require_GraphQLError();
  function LoneSchemaDefinitionRule(context) {
    var _ref, _ref2, _oldSchema$astNode;
    const oldSchema = context.getSchema();
    const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
    let schemaDefinitionsCount = 0;
    return {
      SchemaDefinition(node2) {
        if (alreadyDefined) {
          context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", {
            nodes: node2
          }));
          return;
        }
        if (schemaDefinitionsCount > 0) {
          context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", {
            nodes: node2
          }));
        }
        ++schemaDefinitionsCount;
      }
    };
  }
});

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js
var require_MaxIntrospectionDepthRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MaxIntrospectionDepthRule = MaxIntrospectionDepthRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var MAX_LISTS_DEPTH = 3;
  function MaxIntrospectionDepthRule(context) {
    function checkDepth(node2, visitedFragments = Object.create(null), depth = 0) {
      if (node2.kind === _kinds.Kind.FRAGMENT_SPREAD) {
        const fragmentName = node2.name.value;
        if (visitedFragments[fragmentName] === true) {
          return false;
        }
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          return false;
        }
        try {
          visitedFragments[fragmentName] = true;
          return checkDepth(fragment, visitedFragments, depth);
        } finally {
          visitedFragments[fragmentName] = undefined;
        }
      }
      if (node2.kind === _kinds.Kind.FIELD && (node2.name.value === "fields" || node2.name.value === "interfaces" || node2.name.value === "possibleTypes" || node2.name.value === "inputFields")) {
        depth++;
        if (depth >= MAX_LISTS_DEPTH) {
          return true;
        }
      }
      if ("selectionSet" in node2 && node2.selectionSet) {
        for (const child of node2.selectionSet.selections) {
          if (checkDepth(child, visitedFragments, depth)) {
            return true;
          }
        }
      }
      return false;
    }
    return {
      Field(node2) {
        if (node2.name.value === "__schema" || node2.name.value === "__type") {
          if (checkDepth(node2)) {
            context.reportError(new _GraphQLError.GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node2]
            }));
            return false;
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
  var _GraphQLError = require_GraphQLError();
  function NoFragmentCyclesRule(context) {
    const visitedFrags = Object.create(null);
    const spreadPath = [];
    const spreadPathIndexByName = Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node2) {
        detectCycleRecursive(node2);
        return false;
      }
    };
    function detectCycleRecursive(fragment) {
      if (visitedFrags[fragment.name.value]) {
        return;
      }
      const fragmentName = fragment.name.value;
      visitedFrags[fragmentName] = true;
      const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
      if (spreadNodes.length === 0) {
        return;
      }
      spreadPathIndexByName[fragmentName] = spreadPath.length;
      for (const spreadNode of spreadNodes) {
        const spreadName = spreadNode.name.value;
        const cycleIndex = spreadPathIndexByName[spreadName];
        spreadPath.push(spreadNode);
        if (cycleIndex === undefined) {
          const spreadFragment = context.getFragment(spreadName);
          if (spreadFragment) {
            detectCycleRecursive(spreadFragment);
          }
        } else {
          const cyclePath = spreadPath.slice(cycleIndex);
          const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
          context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
            nodes: cyclePath
          }));
        }
        spreadPath.pop();
      }
      spreadPathIndexByName[fragmentName] = undefined;
    }
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
  var _GraphQLError = require_GraphQLError();
  function NoUndefinedVariablesRule(context) {
    let variableNameDefined = Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          variableNameDefined = Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node: node2 } of usages) {
            const varName = node2.name.value;
            if (variableNameDefined[varName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`, {
                nodes: [node2, operation]
              }));
            }
          }
        }
      },
      VariableDefinition(node2) {
        variableNameDefined[node2.variable.name.value] = true;
      }
    };
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
  var _GraphQLError = require_GraphQLError();
  function NoUnusedFragmentsRule(context) {
    const operationDefs = [];
    const fragmentDefs = [];
    return {
      OperationDefinition(node2) {
        operationDefs.push(node2);
        return false;
      },
      FragmentDefinition(node2) {
        fragmentDefs.push(node2);
        return false;
      },
      Document: {
        leave() {
          const fragmentNameUsed = Object.create(null);
          for (const operation of operationDefs) {
            for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
              fragmentNameUsed[fragment.name.value] = true;
            }
          }
          for (const fragmentDef of fragmentDefs) {
            const fragName = fragmentDef.name.value;
            if (fragmentNameUsed[fragName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              }));
            }
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
  var _GraphQLError = require_GraphQLError();
  function NoUnusedVariablesRule(context) {
    let variableDefs = [];
    return {
      OperationDefinition: {
        enter() {
          variableDefs = [];
        },
        leave(operation) {
          const variableNameUsed = Object.create(null);
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node: node2 } of usages) {
            variableNameUsed[node2.name.value] = true;
          }
          for (const variableDef of variableDefs) {
            const variableName = variableDef.variable.name.value;
            if (variableNameUsed[variableName] !== true) {
              context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`, {
                nodes: variableDef
              }));
            }
          }
        }
      },
      VariableDefinition(def) {
        variableDefs.push(def);
      }
    };
  }
});

// node_modules/graphql/utilities/sortValueNode.js
var require_sortValueNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.sortValueNode = sortValueNode;
  var _naturalCompare = require_naturalCompare();
  var _kinds = require_kinds();
  function sortValueNode(valueNode) {
    switch (valueNode.kind) {
      case _kinds.Kind.OBJECT:
        return { ...valueNode, fields: sortFields(valueNode.fields) };
      case _kinds.Kind.LIST:
        return { ...valueNode, values: valueNode.values.map(sortValueNode) };
      case _kinds.Kind.INT:
      case _kinds.Kind.FLOAT:
      case _kinds.Kind.STRING:
      case _kinds.Kind.BOOLEAN:
      case _kinds.Kind.NULL:
      case _kinds.Kind.ENUM:
      case _kinds.Kind.VARIABLE:
        return valueNode;
    }
  }
  function sortFields(fields) {
    return fields.map((fieldNode) => ({
      ...fieldNode,
      value: sortValueNode(fieldNode.value)
    })).sort((fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value));
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _sortValueNode = require_sortValueNode();
  var _typeFromAST = require_typeFromAST();
  function reasonMessage(reason) {
    if (Array.isArray(reason)) {
      return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
    }
    return reason;
  }
  function OverlappingFieldsCanBeMergedRule(context) {
    const comparedFieldsAndFragmentPairs = new OrderedPairSet;
    const comparedFragmentPairs = new PairSet;
    const cachedFieldsAndFragmentNames = new Map;
    return {
      SelectionSet(selectionSet) {
        const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, context.getParentType(), selectionSet);
        for (const [[responseName, reason], fields1, fields2] of conflicts) {
          const reasonMsg = reasonMessage(reason);
          context.reportError(new _GraphQLError.GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
            nodes: fields1.concat(fields2)
          }));
        }
      }
    };
  }
  function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
    const conflicts = [];
    const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
    collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap);
    if (fragmentNames.length !== 0) {
      for (let i = 0;i < fragmentNames.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
        for (let j = i + 1;j < fragmentNames.length; j++) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
        }
      }
    }
    return conflicts;
  }
  function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    if (comparedFieldsAndFragmentPairs.has(fieldMap, fragmentName, areMutuallyExclusive)) {
      return;
    }
    comparedFieldsAndFragmentPairs.add(fieldMap, fragmentName, areMutuallyExclusive);
    const fragment = context.getFragment(fragmentName);
    if (!fragment) {
      return;
    }
    const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
    if (fieldMap === fieldMap2) {
      return;
    }
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
    for (const referencedFragmentName of referencedFragmentNames) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
    }
  }
  function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    if (fragmentName1 === fragmentName2) {
      return;
    }
    if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
      return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    const fragment1 = context.getFragment(fragmentName1);
    const fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
      return;
    }
    const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
    const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    for (const referencedFragmentName2 of referencedFragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
    }
    for (const referencedFragmentName1 of referencedFragmentNames1) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
    }
  }
  function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    const conflicts = [];
    const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
    const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
    }
    for (const fragmentName1 of fragmentNames1) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
    }
    for (const fragmentName1 of fragmentNames1) {
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
      }
    }
    return conflicts;
  }
  function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
    for (const [responseName, fields] of Object.entries(fieldMap)) {
      if (fields.length > 1) {
        for (let i = 0;i < fields.length; i++) {
          for (let j = i + 1;j < fields.length; j++) {
            const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    for (const [responseName, fields1] of Object.entries(fieldMap1)) {
      const fields2 = fieldMap2[responseName];
      if (fields2) {
        for (const field1 of fields1) {
          for (const field2 of fields2) {
            const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    const [parentType1, node1, def1] = field1;
    const [parentType2, node2, def2] = field2;
    const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
    if (!areMutuallyExclusive) {
      const name1 = node1.name.value;
      const name2 = node2.name.value;
      if (name1 !== name2) {
        return [
          [responseName, `"${name1}" and "${name2}" are different fields`],
          [node1],
          [node2]
        ];
      }
      if (!sameArguments(node1, node2)) {
        return [
          [responseName, "they have differing arguments"],
          [node1],
          [node2]
        ];
      }
    }
    const type1 = def1 === null || def1 === undefined ? undefined : def1.type;
    const type2 = def2 === null || def2 === undefined ? undefined : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
      return [
        [
          responseName,
          `they return conflicting types "${(0, _inspect.inspect)(type1)}" and "${(0, _inspect.inspect)(type2)}"`
        ],
        [node1],
        [node2]
      ];
    }
    const selectionSet1 = node1.selectionSet;
    const selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
      const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
      return subfieldConflicts(conflicts, responseName, node1, node2);
    }
  }
  function sameArguments(node1, node2) {
    const args1 = node1.arguments;
    const args2 = node2.arguments;
    if (args1 === undefined || args1.length === 0) {
      return args2 === undefined || args2.length === 0;
    }
    if (args2 === undefined || args2.length === 0) {
      return false;
    }
    if (args1.length !== args2.length) {
      return false;
    }
    const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
    return args1.every((arg1) => {
      const value1 = arg1.value;
      const value2 = values2.get(arg1.name.value);
      if (value2 === undefined) {
        return false;
      }
      return stringifyValue(value1) === stringifyValue(value2);
    });
  }
  function stringifyValue(value) {
    return (0, _printer.print)((0, _sortValueNode.sortValueNode)(value));
  }
  function doTypesConflict(type1, type2) {
    if ((0, _definition.isListType)(type1)) {
      return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isListType)(type2)) {
      return true;
    }
    if ((0, _definition.isNonNullType)(type1)) {
      return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isNonNullType)(type2)) {
      return true;
    }
    if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
      return type1 !== type2;
    }
    return false;
  }
  function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    const cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (cached) {
      return cached;
    }
    const nodeAndDefs = Object.create(null);
    const fragmentNames = Object.create(null);
    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
    const result = [nodeAndDefs, Object.keys(fragmentNames)];
    cachedFieldsAndFragmentNames.set(selectionSet, result);
    return result;
  }
  function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
      return cached;
    }
    const fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
  }
  function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case _kinds.Kind.FIELD: {
          const fieldName = selection.name.value;
          let fieldDef;
          if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
            fieldDef = parentType.getFields()[fieldName];
          }
          const responseName = selection.alias ? selection.alias.value : fieldName;
          if (!nodeAndDefs[responseName]) {
            nodeAndDefs[responseName] = [];
          }
          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
          break;
        }
        case _kinds.Kind.FRAGMENT_SPREAD:
          fragmentNames[selection.name.value] = true;
          break;
        case _kinds.Kind.INLINE_FRAGMENT: {
          const typeCondition = selection.typeCondition;
          const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
          break;
        }
      }
    }
  }
  function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
      return [
        [responseName, conflicts.map(([reason]) => reason)],
        [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
        [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
      ];
    }
  }

  class OrderedPairSet {
    constructor() {
      this._data = new Map;
    }
    has(a, b, weaklyPresent) {
      var _this$_data$get;
      const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === undefined ? undefined : _this$_data$get.get(b);
      if (result === undefined) {
        return false;
      }
      return weaklyPresent ? true : weaklyPresent === result;
    }
    add(a, b, weaklyPresent) {
      const map = this._data.get(a);
      if (map === undefined) {
        this._data.set(a, new Map([[b, weaklyPresent]]));
      } else {
        map.set(b, weaklyPresent);
      }
    }
  }

  class PairSet {
    constructor() {
      this._orderedPairSet = new OrderedPairSet;
    }
    has(a, b, weaklyPresent) {
      return a < b ? this._orderedPairSet.has(a, b, weaklyPresent) : this._orderedPairSet.has(b, a, weaklyPresent);
    }
    add(a, b, weaklyPresent) {
      if (a < b) {
        this._orderedPairSet.add(a, b, weaklyPresent);
      } else {
        this._orderedPairSet.add(b, a, weaklyPresent);
      }
    }
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  var _typeComparators = require_typeComparators();
  var _typeFromAST = require_typeFromAST();
  function PossibleFragmentSpreadsRule(context) {
    return {
      InlineFragment(node2) {
        const fragType = context.getType();
        const parentType = context.getParentType();
        if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = (0, _inspect.inspect)(parentType);
          const fragTypeStr = (0, _inspect.inspect)(fragType);
          context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
            nodes: node2
          }));
        }
      },
      FragmentSpread(node2) {
        const fragName = node2.name.value;
        const fragType = getFragmentType(context, fragName);
        const parentType = context.getParentType();
        if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = (0, _inspect.inspect)(parentType);
          const fragTypeStr = (0, _inspect.inspect)(fragType);
          context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
            nodes: node2
          }));
        }
      }
    };
  }
  function getFragmentType(context, name) {
    const frag = context.getFragment(name);
    if (frag) {
      const type2 = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
      if ((0, _definition.isCompositeType)(type2)) {
        return type2;
      }
    }
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
  var _didYouMean = require_didYouMean();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _definition = require_definition();
  function PossibleTypeExtensionsRule(context) {
    const schema = context.getSchema();
    const definedTypes = Object.create(null);
    for (const def of context.getDocument().definitions) {
      if ((0, _predicates.isTypeDefinitionNode)(def)) {
        definedTypes[def.name.value] = def;
      }
    }
    return {
      ScalarTypeExtension: checkExtension,
      ObjectTypeExtension: checkExtension,
      InterfaceTypeExtension: checkExtension,
      UnionTypeExtension: checkExtension,
      EnumTypeExtension: checkExtension,
      InputObjectTypeExtension: checkExtension
    };
    function checkExtension(node2) {
      const typeName = node2.name.value;
      const defNode = definedTypes[typeName];
      const existingType = schema === null || schema === undefined ? undefined : schema.getType(typeName);
      let expectedKind;
      if (defNode) {
        expectedKind = defKindToExtKind[defNode.kind];
      } else if (existingType) {
        expectedKind = typeToExtKind(existingType);
      }
      if (expectedKind) {
        if (expectedKind !== node2.kind) {
          const kindStr = extensionKindToTypeName(node2.kind);
          context.reportError(new _GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node2] : node2
          }));
        }
      } else {
        const allTypeNames = Object.keys({
          ...definedTypes,
          ...schema === null || schema === undefined ? undefined : schema.getTypeMap()
        });
        const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, allTypeNames);
        context.reportError(new _GraphQLError.GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes), {
          nodes: node2.name
        }));
      }
    }
  }
  var defKindToExtKind = {
    [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
    [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
    [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
    [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
    [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
    [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
  };
  function typeToExtKind(type2) {
    if ((0, _definition.isScalarType)(type2)) {
      return _kinds.Kind.SCALAR_TYPE_EXTENSION;
    }
    if ((0, _definition.isObjectType)(type2)) {
      return _kinds.Kind.OBJECT_TYPE_EXTENSION;
    }
    if ((0, _definition.isInterfaceType)(type2)) {
      return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
    }
    if ((0, _definition.isUnionType)(type2)) {
      return _kinds.Kind.UNION_TYPE_EXTENSION;
    }
    if ((0, _definition.isEnumType)(type2)) {
      return _kinds.Kind.ENUM_TYPE_EXTENSION;
    }
    if ((0, _definition.isInputObjectType)(type2)) {
      return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type2));
  }
  function extensionKindToTypeName(kind2) {
    switch (kind2) {
      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case _kinds.Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case _kinds.Kind.UNION_TYPE_EXTENSION:
        return "union";
      case _kinds.Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
      default:
        (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(kind2));
    }
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
  exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
  var _inspect = require_inspect();
  var _keyMap = require_keyMap();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _directives = require_directives();
  function ProvidedRequiredArgumentsRule(context) {
    return {
      ...ProvidedRequiredArgumentsOnDirectivesRule(context),
      Field: {
        leave(fieldNode) {
          var _fieldNode$arguments;
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            return false;
          }
          const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === undefined ? undefined : _fieldNode$arguments.map((arg) => arg.name.value));
          for (const argDef of fieldDef.args) {
            if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
              const argTypeStr = (0, _inspect.inspect)(argDef.type);
              context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
                nodes: fieldNode
              }));
            }
          }
        }
      }
    };
  }
  function ProvidedRequiredArgumentsOnDirectivesRule(context) {
    var _schema$getDirectives;
    const requiredArgsMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = (_schema$getDirectives = schema === null || schema === undefined ? undefined : schema.getDirectives()) !== null && _schema$getDirectives !== undefined ? _schema$getDirectives : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(directive.args.filter(_definition.isRequiredArgument), (arg) => arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
        requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
      }
    }
    return {
      Directive: {
        leave(directiveNode) {
          const directiveName = directiveNode.name.value;
          const requiredArgs = requiredArgsMap[directiveName];
          if (requiredArgs) {
            var _directiveNode$argume;
            const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
            const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
            for (const [argName, argDef] of Object.entries(requiredArgs)) {
              if (!argNodeMap.has(argName)) {
                const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                  nodes: directiveNode
                }));
              }
            }
          }
        }
      }
    };
  }
  function isRequiredArgumentNode(arg) {
    return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ScalarLeafsRule = ScalarLeafsRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function ScalarLeafsRule(context) {
    return {
      Field(node2) {
        const type2 = context.getType();
        const selectionSet = node2.selectionSet;
        if (type2) {
          if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type2))) {
            if (selectionSet) {
              const fieldName = node2.name.value;
              const typeStr = (0, _inspect.inspect)(type2);
              context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
                nodes: selectionSet
              }));
            }
          } else if (!selectionSet) {
            const fieldName = node2.name.value;
            const typeStr = (0, _inspect.inspect)(type2);
            context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
              nodes: node2
            }));
          } else if (selectionSet.selections.length === 0) {
            const fieldName = node2.name.value;
            const typeStr = (0, _inspect.inspect)(type2);
            context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`, {
              nodes: node2
            }));
          }
        }
      }
    };
  }
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printPathArray = printPathArray;
  function printPathArray(path) {
    return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
  }
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addPath = addPath;
  exports.pathToArray = pathToArray;
  function addPath(prev, key, typename) {
    return {
      prev,
      key,
      typename
    };
  }
  function pathToArray(path) {
    const flattened = [];
    let curr = path;
    while (curr) {
      flattened.push(curr.key);
      curr = curr.prev;
    }
    return flattened.reverse();
  }
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.coerceInputValue = coerceInputValue;
  var _didYouMean = require_didYouMean();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _isIterableObject = require_isIterableObject();
  var _isObjectLike = require_isObjectLike();
  var _Path = require_Path();
  var _printPathArray = require_printPathArray();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function coerceInputValue(inputValue, type2, onError = defaultOnError) {
    return coerceInputValueImpl(inputValue, type2, onError, undefined);
  }
  function defaultOnError(path, invalidValue, error) {
    let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
    if (path.length > 0) {
      errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
    }
    error.message = errorPrefix + ": " + error.message;
    throw error;
  }
  function coerceInputValueImpl(inputValue, type2, onError, path) {
    if ((0, _definition.isNonNullType)(type2)) {
      if (inputValue != null) {
        return coerceInputValueImpl(inputValue, type2.ofType, onError, path);
      }
      onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected non-nullable type "${(0, _inspect.inspect)(type2)}" not to be null.`));
      return;
    }
    if (inputValue == null) {
      return null;
    }
    if ((0, _definition.isListType)(type2)) {
      const itemType = type2.ofType;
      if ((0, _isIterableObject.isIterableObject)(inputValue)) {
        return Array.from(inputValue, (itemValue, index) => {
          const itemPath = (0, _Path.addPath)(path, index, undefined);
          return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
        });
      }
      return [coerceInputValueImpl(inputValue, itemType, onError, path)];
    }
    if ((0, _definition.isInputObjectType)(type2)) {
      if (!(0, _isObjectLike.isObjectLike)(inputValue) || Array.isArray(inputValue)) {
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type2.name}" to be an object.`));
        return;
      }
      const coercedValue = {};
      const fieldDefs = type2.getFields();
      for (const field of Object.values(fieldDefs)) {
        const fieldValue = inputValue[field.name];
        if (fieldValue === undefined) {
          if (field.defaultValue !== undefined) {
            coercedValue[field.name] = field.defaultValue;
          } else if ((0, _definition.isNonNullType)(field.type)) {
            const typeStr = (0, _inspect.inspect)(field.type);
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
          }
          continue;
        }
        coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type2.name));
      }
      for (const fieldName of Object.keys(inputValue)) {
        if (!fieldDefs[fieldName]) {
          const suggestions = (0, _suggestionList.suggestionList)(fieldName, Object.keys(type2.getFields()));
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${fieldName}" is not defined by type "${type2.name}".` + (0, _didYouMean.didYouMean)(suggestions)));
        }
      }
      if (type2.isOneOf) {
        const keys = Object.keys(coercedValue);
        if (keys.length !== 1) {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Exactly one key must be specified for OneOf type "${type2.name}".`));
        }
        const key = keys[0];
        const value = coercedValue[key];
        if (value === null) {
          onError((0, _Path.pathToArray)(path).concat(key), value, new _GraphQLError.GraphQLError(`Field "${key}" must be non-null.`));
        }
      }
      return coercedValue;
    }
    if ((0, _definition.isLeafType)(type2)) {
      let parseResult;
      try {
        parseResult = type2.parseValue(inputValue);
      } catch (error) {
        if (error instanceof _GraphQLError.GraphQLError) {
          onError((0, _Path.pathToArray)(path), inputValue, error);
        } else {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type2.name}". ` + error.message, {
            originalError: error
          }));
        }
        return;
      }
      if (parseResult === undefined) {
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type2.name}".`));
      }
      return parseResult;
    }
    (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type2));
  }
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.valueFromAST = valueFromAST;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyMap = require_keyMap();
  var _kinds = require_kinds();
  var _definition = require_definition();
  function valueFromAST(valueNode, type2, variables) {
    if (!valueNode) {
      return;
    }
    if (valueNode.kind === _kinds.Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variables == null || variables[variableName] === undefined) {
        return;
      }
      const variableValue = variables[variableName];
      if (variableValue === null && (0, _definition.isNonNullType)(type2)) {
        return;
      }
      return variableValue;
    }
    if ((0, _definition.isNonNullType)(type2)) {
      if (valueNode.kind === _kinds.Kind.NULL) {
        return;
      }
      return valueFromAST(valueNode, type2.ofType, variables);
    }
    if (valueNode.kind === _kinds.Kind.NULL) {
      return null;
    }
    if ((0, _definition.isListType)(type2)) {
      const itemType = type2.ofType;
      if (valueNode.kind === _kinds.Kind.LIST) {
        const coercedValues = [];
        for (const itemNode of valueNode.values) {
          if (isMissingVariable(itemNode, variables)) {
            if ((0, _definition.isNonNullType)(itemType)) {
              return;
            }
            coercedValues.push(null);
          } else {
            const itemValue = valueFromAST(itemNode, itemType, variables);
            if (itemValue === undefined) {
              return;
            }
            coercedValues.push(itemValue);
          }
        }
        return coercedValues;
      }
      const coercedValue = valueFromAST(valueNode, itemType, variables);
      if (coercedValue === undefined) {
        return;
      }
      return [coercedValue];
    }
    if ((0, _definition.isInputObjectType)(type2)) {
      if (valueNode.kind !== _kinds.Kind.OBJECT) {
        return;
      }
      const coercedObj = Object.create(null);
      const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, (field) => field.name.value);
      for (const field of Object.values(type2.getFields())) {
        const fieldNode = fieldNodes[field.name];
        if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
          if (field.defaultValue !== undefined) {
            coercedObj[field.name] = field.defaultValue;
          } else if ((0, _definition.isNonNullType)(field.type)) {
            return;
          }
          continue;
        }
        const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
        if (fieldValue === undefined) {
          return;
        }
        coercedObj[field.name] = fieldValue;
      }
      if (type2.isOneOf) {
        const keys = Object.keys(coercedObj);
        if (keys.length !== 1) {
          return;
        }
        if (coercedObj[keys[0]] === null) {
          return;
        }
      }
      return coercedObj;
    }
    if ((0, _definition.isLeafType)(type2)) {
      let result;
      try {
        result = type2.parseLiteral(valueNode, variables);
      } catch (_error) {
        return;
      }
      if (result === undefined) {
        return;
      }
      return result;
    }
    (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type2));
  }
  function isMissingVariable(valueNode, variables) {
    return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
  }
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getArgumentValues = getArgumentValues;
  exports.getDirectiveValues = getDirectiveValues;
  exports.getVariableValues = getVariableValues;
  var _inspect = require_inspect();
  var _keyMap = require_keyMap();
  var _printPathArray = require_printPathArray();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _coerceInputValue = require_coerceInputValue();
  var _typeFromAST = require_typeFromAST();
  var _valueFromAST = require_valueFromAST();
  function getVariableValues(schema, varDefNodes, inputs, options) {
    const errors = [];
    const maxErrors = options === null || options === undefined ? undefined : options.maxErrors;
    try {
      const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error) => {
        if (maxErrors != null && errors.length >= maxErrors) {
          throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
        }
        errors.push(error);
      });
      if (errors.length === 0) {
        return {
          coerced
        };
      }
    } catch (error) {
      errors.push(error);
    }
    return {
      errors
    };
  }
  function coerceVariableValues(schema, varDefNodes, inputs, onError) {
    const coercedValues = {};
    for (const varDefNode of varDefNodes) {
      const varName = varDefNode.variable.name.value;
      const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
      if (!(0, _definition.isInputType)(varType)) {
        const varTypeStr = (0, _printer.print)(varDefNode.type);
        onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
          nodes: varDefNode.type
        }));
        continue;
      }
      if (!hasOwnProperty(inputs, varName)) {
        if (varDefNode.defaultValue) {
          coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
        } else if ((0, _definition.isNonNullType)(varType)) {
          const varTypeStr = (0, _inspect.inspect)(varType);
          onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
            nodes: varDefNode
          }));
        }
        continue;
      }
      const value = inputs[varName];
      if (value === null && (0, _definition.isNonNullType)(varType)) {
        const varTypeStr = (0, _inspect.inspect)(varType);
        onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
          nodes: varDefNode
        }));
        continue;
      }
      coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error) => {
        let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
        if (path.length > 0) {
          prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(path)}"`;
        }
        onError(new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
          nodes: varDefNode,
          originalError: error
        }));
      });
    }
    return coercedValues;
  }
  function getArgumentValues(def, node2, variableValues) {
    var _node$arguments;
    const coercedValues = {};
    const argumentNodes = (_node$arguments = node2.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
    const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, (arg) => arg.name.value);
    for (const argDef of def.args) {
      const name = argDef.name;
      const argType = argDef.type;
      const argumentNode = argNodeMap[name];
      if (!argumentNode) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if ((0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" ` + "was not provided.", {
            nodes: node2
          });
        }
        continue;
      }
      const valueNode = argumentNode.value;
      let isNull = valueNode.kind === _kinds.Kind.NULL;
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
          if (argDef.defaultValue !== undefined) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" ` + `was provided the variable "$${variableName}" which was not provided a runtime value.`, {
              nodes: valueNode
            });
          }
          continue;
        }
        isNull = variableValues[variableName] == null;
      }
      if (isNull && (0, _definition.isNonNullType)(argType)) {
        throw new _GraphQLError.GraphQLError(`Argument "${name}" of non-null type "${(0, _inspect.inspect)(argType)}" ` + "must not be null.", {
          nodes: valueNode
        });
      }
      const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
      if (coercedValue === undefined) {
        throw new _GraphQLError.GraphQLError(`Argument "${name}" has invalid value ${(0, _printer.print)(valueNode)}.`, {
          nodes: valueNode
        });
      }
      coercedValues[name] = coercedValue;
    }
    return coercedValues;
  }
  function getDirectiveValues(directiveDef, node2, variableValues) {
    var _node$directives;
    const directiveNode = (_node$directives = node2.directives) === null || _node$directives === undefined ? undefined : _node$directives.find((directive) => directive.name.value === directiveDef.name);
    if (directiveNode) {
      return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
});

// node_modules/graphql/execution/collectFields.js
var require_collectFields = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.collectFields = collectFields;
  exports.collectSubfields = collectSubfields;
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _directives = require_directives();
  var _typeFromAST = require_typeFromAST();
  var _values = require_values();
  function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
    const fields = new Map;
    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set);
    return fields;
  }
  function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
    const subFieldNodes = new Map;
    const visitedFragmentNames = new Set;
    for (const node2 of fieldNodes) {
      if (node2.selectionSet) {
        collectFieldsImpl(schema, fragments, variableValues, returnType, node2.selectionSet, subFieldNodes, visitedFragmentNames);
      }
    }
    return subFieldNodes;
  }
  function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case _kinds.Kind.FIELD: {
          if (!shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          const name = getFieldEntryKey(selection);
          const fieldList = fields.get(name);
          if (fieldList !== undefined) {
            fieldList.push(selection);
          } else {
            fields.set(name, [selection]);
          }
          break;
        }
        case _kinds.Kind.INLINE_FRAGMENT: {
          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
            continue;
          }
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        }
        case _kinds.Kind.FRAGMENT_SPREAD: {
          const fragName = selection.name.value;
          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          visitedFragmentNames.add(fragName);
          const fragment = fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
            continue;
          }
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
        }
      }
    }
  }
  function shouldIncludeNode(variableValues, node2) {
    const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node2, variableValues);
    if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
      return false;
    }
    const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node2, variableValues);
    if ((include === null || include === undefined ? undefined : include.if) === false) {
      return false;
    }
    return true;
  }
  function doesFragmentConditionMatch(schema, fragment, type2) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);
    if (conditionalType === type2) {
      return true;
    }
    if ((0, _definition.isAbstractType)(conditionalType)) {
      return schema.isSubType(conditionalType, type2);
    }
    return false;
  }
  function getFieldEntryKey(node2) {
    return node2.alias ? node2.alias.value : node2.name.value;
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _collectFields = require_collectFields();
  function SingleFieldSubscriptionsRule(context) {
    return {
      OperationDefinition(node2) {
        if (node2.operation === "subscription") {
          const schema = context.getSchema();
          const subscriptionType = schema.getSubscriptionType();
          if (subscriptionType) {
            const operationName = node2.name ? node2.name.value : null;
            const variableValues = Object.create(null);
            const document2 = context.getDocument();
            const fragments = Object.create(null);
            for (const definition of document2.definitions) {
              if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                fragments[definition.name.value] = definition;
              }
            }
            const fields = (0, _collectFields.collectFields)(schema, fragments, variableValues, subscriptionType, node2.selectionSet);
            if (fields.size > 1) {
              const fieldSelectionLists = [...fields.values()];
              const extraFieldSelectionLists = fieldSelectionLists.slice(1);
              const extraFieldSelections = extraFieldSelectionLists.flat();
              context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
                nodes: extraFieldSelections
              }));
            }
            for (const fieldNodes of fields.values()) {
              const field = fieldNodes[0];
              const fieldName = field.name.value;
              if (fieldName.startsWith("__")) {
                context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                  nodes: fieldNodes
                }));
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/graphql/jsutils/groupBy.js
var require_groupBy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.groupBy = groupBy;
  function groupBy(list, keyFn) {
    const result = new Map;
    for (const item of list) {
      const key = keyFn(item);
      const group = result.get(key);
      if (group === undefined) {
        result.set(key, [item]);
      } else {
        group.push(item);
      }
    }
    return result;
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
var require_UniqueArgumentDefinitionNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
  var _groupBy = require_groupBy();
  var _GraphQLError = require_GraphQLError();
  function UniqueArgumentDefinitionNamesRule(context) {
    return {
      DirectiveDefinition(directiveNode) {
        var _directiveNode$argume;
        const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
        return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
      },
      InterfaceTypeDefinition: checkArgUniquenessPerField,
      InterfaceTypeExtension: checkArgUniquenessPerField,
      ObjectTypeDefinition: checkArgUniquenessPerField,
      ObjectTypeExtension: checkArgUniquenessPerField
    };
    function checkArgUniquenessPerField(typeNode) {
      var _typeNode$fields;
      const typeName = typeNode.name.value;
      const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== undefined ? _typeNode$fields : [];
      for (const fieldDef of fieldNodes) {
        var _fieldDef$arguments;
        const fieldName = fieldDef.name.value;
        const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== undefined ? _fieldDef$arguments : [];
        checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
      }
      return false;
    }
    function checkArgUniqueness(parentName, argumentNodes) {
      const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(new _GraphQLError.GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
            nodes: argNodes.map((node2) => node2.name)
          }));
        }
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
  var _groupBy = require_groupBy();
  var _GraphQLError = require_GraphQLError();
  function UniqueArgumentNamesRule(context) {
    return {
      Field: checkArgUniqueness,
      Directive: checkArgUniqueness
    };
    function checkArgUniqueness(parentNode) {
      var _parentNode$arguments;
      const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== undefined ? _parentNode$arguments : [];
      const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one argument named "${argName}".`, {
            nodes: argNodes.map((node2) => node2.name)
          }));
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueDirectiveNamesRule(context) {
    const knownDirectiveNames = Object.create(null);
    const schema = context.getSchema();
    return {
      DirectiveDefinition(node2) {
        const directiveName = node2.name.value;
        if (schema !== null && schema !== undefined && schema.getDirective(directiveName)) {
          context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
            nodes: node2.name
          }));
          return;
        }
        if (knownDirectiveNames[directiveName]) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one directive named "@${directiveName}".`, {
            nodes: [knownDirectiveNames[directiveName], node2.name]
          }));
        } else {
          knownDirectiveNames[directiveName] = node2.name;
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _directives = require_directives();
  function UniqueDirectivesPerLocationRule(context) {
    const uniqueDirectiveMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives) {
      uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        uniqueDirectiveMap[def.name.value] = !def.repeatable;
      }
    }
    const schemaDirectives = Object.create(null);
    const typeDirectivesMap = Object.create(null);
    return {
      enter(node2) {
        if (!("directives" in node2) || !node2.directives) {
          return;
        }
        let seenDirectives;
        if (node2.kind === _kinds.Kind.SCHEMA_DEFINITION || node2.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          seenDirectives = schemaDirectives;
        } else if ((0, _predicates.isTypeDefinitionNode)(node2) || (0, _predicates.isTypeExtensionNode)(node2)) {
          const typeName = node2.name.value;
          seenDirectives = typeDirectivesMap[typeName];
          if (seenDirectives === undefined) {
            typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
          }
        } else {
          seenDirectives = Object.create(null);
        }
        for (const directive of node2.directives) {
          const directiveName = directive.name.value;
          if (uniqueDirectiveMap[directiveName]) {
            if (seenDirectives[directiveName]) {
              context.reportError(new _GraphQLError.GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                nodes: [seenDirectives[directiveName], directive]
              }));
            } else {
              seenDirectives[directiveName] = directive;
            }
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function UniqueEnumValueNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    const knownValueNames = Object.create(null);
    return {
      EnumTypeDefinition: checkValueUniqueness,
      EnumTypeExtension: checkValueUniqueness
    };
    function checkValueUniqueness(node2) {
      var _node$values;
      const typeName = node2.name.value;
      if (!knownValueNames[typeName]) {
        knownValueNames[typeName] = Object.create(null);
      }
      const valueNodes = (_node$values = node2.values) !== null && _node$values !== undefined ? _node$values : [];
      const valueNames = knownValueNames[typeName];
      for (const valueDef of valueNodes) {
        const valueName = valueDef.name.value;
        const existingType = existingTypeMap[typeName];
        if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
          context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
            nodes: valueDef.name
          }));
        } else if (valueNames[valueName]) {
          context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
            nodes: [valueNames[valueName], valueDef.name]
          }));
        } else {
          valueNames[valueName] = valueDef.name;
        }
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function UniqueFieldDefinitionNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    const knownFieldNames = Object.create(null);
    return {
      InputObjectTypeDefinition: checkFieldUniqueness,
      InputObjectTypeExtension: checkFieldUniqueness,
      InterfaceTypeDefinition: checkFieldUniqueness,
      InterfaceTypeExtension: checkFieldUniqueness,
      ObjectTypeDefinition: checkFieldUniqueness,
      ObjectTypeExtension: checkFieldUniqueness
    };
    function checkFieldUniqueness(node2) {
      var _node$fields;
      const typeName = node2.name.value;
      if (!knownFieldNames[typeName]) {
        knownFieldNames[typeName] = Object.create(null);
      }
      const fieldNodes = (_node$fields = node2.fields) !== null && _node$fields !== undefined ? _node$fields : [];
      const fieldNames = knownFieldNames[typeName];
      for (const fieldDef of fieldNodes) {
        const fieldName = fieldDef.name.value;
        if (hasField(existingTypeMap[typeName], fieldName)) {
          context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
            nodes: fieldDef.name
          }));
        } else if (fieldNames[fieldName]) {
          context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
            nodes: [fieldNames[fieldName], fieldDef.name]
          }));
        } else {
          fieldNames[fieldName] = fieldDef.name;
        }
      }
      return false;
    }
  }
  function hasField(type2, fieldName) {
    if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2) || (0, _definition.isInputObjectType)(type2)) {
      return type2.getFields()[fieldName] != null;
    }
    return false;
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueFragmentNamesRule(context) {
    const knownFragmentNames = Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node2) {
        const fragmentName = node2.name.value;
        if (knownFragmentNames[fragmentName]) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
            nodes: [knownFragmentNames[fragmentName], node2.name]
          }));
        } else {
          knownFragmentNames[fragmentName] = node2.name;
        }
        return false;
      }
    };
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
  var _invariant = require_invariant();
  var _GraphQLError = require_GraphQLError();
  function UniqueInputFieldNamesRule(context) {
    const knownNameStack = [];
    let knownNames = Object.create(null);
    return {
      ObjectValue: {
        enter() {
          knownNameStack.push(knownNames);
          knownNames = Object.create(null);
        },
        leave() {
          const prevKnownNames = knownNameStack.pop();
          prevKnownNames || (0, _invariant.invariant)(false);
          knownNames = prevKnownNames;
        }
      },
      ObjectField(node2) {
        const fieldName = node2.name.value;
        if (knownNames[fieldName]) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one input field named "${fieldName}".`, {
            nodes: [knownNames[fieldName], node2.name]
          }));
        } else {
          knownNames[fieldName] = node2.name;
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueOperationNamesRule(context) {
    const knownOperationNames = Object.create(null);
    return {
      OperationDefinition(node2) {
        const operationName = node2.name;
        if (operationName) {
          if (knownOperationNames[operationName.value]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one operation named "${operationName.value}".`, {
              nodes: [
                knownOperationNames[operationName.value],
                operationName
              ]
            }));
          } else {
            knownOperationNames[operationName.value] = operationName;
          }
        }
        return false;
      },
      FragmentDefinition: () => false
    };
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueOperationTypesRule(context) {
    const schema = context.getSchema();
    const definedOperationTypes = Object.create(null);
    const existingOperationTypes = schema ? {
      query: schema.getQueryType(),
      mutation: schema.getMutationType(),
      subscription: schema.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: checkOperationTypes,
      SchemaExtension: checkOperationTypes
    };
    function checkOperationTypes(node2) {
      var _node$operationTypes;
      const operationTypesNodes = (_node$operationTypes = node2.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
      for (const operationType of operationTypesNodes) {
        const operation = operationType.operation;
        const alreadyDefinedOperationType = definedOperationTypes[operation];
        if (existingOperationTypes[operation]) {
          context.reportError(new _GraphQLError.GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
            nodes: operationType
          }));
        } else if (alreadyDefinedOperationType) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one ${operation} type in schema.`, {
            nodes: [alreadyDefinedOperationType, operationType]
          }));
        } else {
          definedOperationTypes[operation] = operationType;
        }
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
  var _GraphQLError = require_GraphQLError();
  function UniqueTypeNamesRule(context) {
    const knownTypeNames = Object.create(null);
    const schema = context.getSchema();
    return {
      ScalarTypeDefinition: checkTypeName,
      ObjectTypeDefinition: checkTypeName,
      InterfaceTypeDefinition: checkTypeName,
      UnionTypeDefinition: checkTypeName,
      EnumTypeDefinition: checkTypeName,
      InputObjectTypeDefinition: checkTypeName
    };
    function checkTypeName(node2) {
      const typeName = node2.name.value;
      if (schema !== null && schema !== undefined && schema.getType(typeName)) {
        context.reportError(new _GraphQLError.GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
          nodes: node2.name
        }));
        return;
      }
      if (knownTypeNames[typeName]) {
        context.reportError(new _GraphQLError.GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node2.name]
        }));
      } else {
        knownTypeNames[typeName] = node2.name;
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
  var _groupBy = require_groupBy();
  var _GraphQLError = require_GraphQLError();
  function UniqueVariableNamesRule(context) {
    return {
      OperationDefinition(operationNode) {
        var _operationNode$variab;
        const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== undefined ? _operationNode$variab : [];
        const seenVariableDefinitions = (0, _groupBy.groupBy)(variableDefinitions, (node2) => node2.variable.name.value);
        for (const [variableName, variableNodes] of seenVariableDefinitions) {
          if (variableNodes.length > 1) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one variable named "$${variableName}".`, {
              nodes: variableNodes.map((node2) => node2.variable.name)
            }));
          }
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
  var _didYouMean = require_didYouMean();
  var _inspect = require_inspect();
  var _keyMap = require_keyMap();
  var _suggestionList = require_suggestionList();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  function ValuesOfCorrectTypeRule(context) {
    let variableDefinitions = {};
    return {
      OperationDefinition: {
        enter() {
          variableDefinitions = {};
        }
      },
      VariableDefinition(definition) {
        variableDefinitions[definition.variable.name.value] = definition;
      },
      ListValue(node2) {
        const type2 = (0, _definition.getNullableType)(context.getParentInputType());
        if (!(0, _definition.isListType)(type2)) {
          isValidValueNode(context, node2);
          return false;
        }
      },
      ObjectValue(node2) {
        const type2 = (0, _definition.getNamedType)(context.getInputType());
        if (!(0, _definition.isInputObjectType)(type2)) {
          isValidValueNode(context, node2);
          return false;
        }
        const fieldNodeMap = (0, _keyMap.keyMap)(node2.fields, (field) => field.name.value);
        for (const fieldDef of Object.values(type2.getFields())) {
          const fieldNode = fieldNodeMap[fieldDef.name];
          if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
            const typeStr = (0, _inspect.inspect)(fieldDef.type);
            context.reportError(new _GraphQLError.GraphQLError(`Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
              nodes: node2
            }));
          }
        }
        if (type2.isOneOf) {
          validateOneOfInputObject(context, node2, type2, fieldNodeMap, variableDefinitions);
        }
      },
      ObjectField(node2) {
        const parentType = (0, _definition.getNamedType)(context.getParentInputType());
        const fieldType = context.getInputType();
        if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
          const suggestions = (0, _suggestionList.suggestionList)(node2.name.value, Object.keys(parentType.getFields()));
          context.reportError(new _GraphQLError.GraphQLError(`Field "${node2.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
            nodes: node2
          }));
        }
      },
      NullValue(node2) {
        const type2 = context.getInputType();
        if ((0, _definition.isNonNullType)(type2)) {
          context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${(0, _inspect.inspect)(type2)}", found ${(0, _printer.print)(node2)}.`, {
            nodes: node2
          }));
        }
      },
      EnumValue: (node2) => isValidValueNode(context, node2),
      IntValue: (node2) => isValidValueNode(context, node2),
      FloatValue: (node2) => isValidValueNode(context, node2),
      StringValue: (node2) => isValidValueNode(context, node2),
      BooleanValue: (node2) => isValidValueNode(context, node2)
    };
  }
  function isValidValueNode(context, node2) {
    const locationType = context.getInputType();
    if (!locationType) {
      return;
    }
    const type2 = (0, _definition.getNamedType)(locationType);
    if (!(0, _definition.isLeafType)(type2)) {
      const typeStr = (0, _inspect.inspect)(locationType);
      context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node2)}.`, {
        nodes: node2
      }));
      return;
    }
    try {
      const parseResult = type2.parseLiteral(node2, undefined);
      if (parseResult === undefined) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node2)}.`, {
          nodes: node2
        }));
      }
    } catch (error) {
      const typeStr = (0, _inspect.inspect)(locationType);
      if (error instanceof _GraphQLError.GraphQLError) {
        context.reportError(error);
      } else {
        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node2)}; ` + error.message, {
          nodes: node2,
          originalError: error
        }));
      }
    }
  }
  function validateOneOfInputObject(context, node2, type2, fieldNodeMap, variableDefinitions) {
    var _fieldNodeMap$keys$;
    const keys = Object.keys(fieldNodeMap);
    const isNotExactlyOneField = keys.length !== 1;
    if (isNotExactlyOneField) {
      context.reportError(new _GraphQLError.GraphQLError(`OneOf Input Object "${type2.name}" must specify exactly one key.`, {
        nodes: [node2]
      }));
      return;
    }
    const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === undefined ? undefined : _fieldNodeMap$keys$.value;
    const isNullLiteral = !value || value.kind === _kinds.Kind.NULL;
    const isVariable = (value === null || value === undefined ? undefined : value.kind) === _kinds.Kind.VARIABLE;
    if (isNullLiteral) {
      context.reportError(new _GraphQLError.GraphQLError(`Field "${type2.name}.${keys[0]}" must be non-null.`, {
        nodes: [node2]
      }));
      return;
    }
    if (isVariable) {
      const variableName = value.name.value;
      const definition = variableDefinitions[variableName];
      const isNullableVariable = definition.type.kind !== _kinds.Kind.NON_NULL_TYPE;
      if (isNullableVariable) {
        context.reportError(new _GraphQLError.GraphQLError(`Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`, {
          nodes: [node2]
        }));
      }
    }
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
  var _GraphQLError = require_GraphQLError();
  var _printer = require_printer();
  var _definition = require_definition();
  var _typeFromAST = require_typeFromAST();
  function VariablesAreInputTypesRule(context) {
    return {
      VariableDefinition(node2) {
        const type2 = (0, _typeFromAST.typeFromAST)(context.getSchema(), node2.type);
        if (type2 !== undefined && !(0, _definition.isInputType)(type2)) {
          const variableName = node2.variable.name.value;
          const typeName = (0, _printer.print)(node2.type);
          context.reportError(new _GraphQLError.GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, {
            nodes: node2.type
          }));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
  var _inspect = require_inspect();
  var _GraphQLError = require_GraphQLError();
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _typeComparators = require_typeComparators();
  var _typeFromAST = require_typeFromAST();
  function VariablesInAllowedPositionRule(context) {
    let varDefMap = Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          varDefMap = Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node: node2, type: type2, defaultValue, parentType } of usages) {
            const varName = node2.name.value;
            const varDef = varDefMap[varName];
            if (varDef && type2) {
              const schema = context.getSchema();
              const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
              if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type2, defaultValue)) {
                const varTypeStr = (0, _inspect.inspect)(varType);
                const typeStr = (0, _inspect.inspect)(type2);
                context.reportError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                  nodes: [varDef, node2]
                }));
              }
              if ((0, _definition.isInputObjectType)(parentType) && parentType.isOneOf && (0, _definition.isNullableType)(varType)) {
                context.reportError(new _GraphQLError.GraphQLError(`Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`, {
                  nodes: [varDef, node2]
                }));
              }
            }
          }
        }
      },
      VariableDefinition(node2) {
        varDefMap[node2.variable.name.value] = node2;
      }
    };
  }
  function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
      const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
      const hasLocationDefaultValue = locationDefaultValue !== undefined;
      if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
        return false;
      }
      const nullableLocationType = locationType.ofType;
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
    }
    return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
  }
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.specifiedSDLRules = exports.specifiedRules = exports.recommendedRules = undefined;
  var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
  var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
  var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
  var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
  var _KnownDirectivesRule = require_KnownDirectivesRule();
  var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
  var _KnownTypeNamesRule = require_KnownTypeNamesRule();
  var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
  var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
  var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
  var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
  var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
  var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
  var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
  var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
  var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
  var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
  var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
  var _ScalarLeafsRule = require_ScalarLeafsRule();
  var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
  var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
  var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
  var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
  var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
  var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
  var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
  var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
  var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
  var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
  var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
  var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
  var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
  var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
  var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
  var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
  var recommendedRules = Object.freeze([
    _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule
  ]);
  exports.recommendedRules = recommendedRules;
  var specifiedRules = Object.freeze([
    _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
    _UniqueOperationNamesRule.UniqueOperationNamesRule,
    _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
    _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
    _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
    _ScalarLeafsRule.ScalarLeafsRule,
    _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
    _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
    _KnownFragmentNamesRule.KnownFragmentNamesRule,
    _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
    _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
    _NoFragmentCyclesRule.NoFragmentCyclesRule,
    _UniqueVariableNamesRule.UniqueVariableNamesRule,
    _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
    _NoUnusedVariablesRule.NoUnusedVariablesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _KnownArgumentNamesRule.KnownArgumentNamesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
    _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
    _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
    ...recommendedRules
  ]);
  exports.specifiedRules = specifiedRules;
  var specifiedSDLRules = Object.freeze([
    _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
    _UniqueOperationTypesRule.UniqueOperationTypesRule,
    _UniqueTypeNamesRule.UniqueTypeNamesRule,
    _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
    _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
    _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
    _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
    _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
  ]);
  exports.specifiedSDLRules = specifiedSDLRules;
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = undefined;
  var _kinds = require_kinds();
  var _visitor = require_visitor();
  var _TypeInfo = require_TypeInfo();

  class ASTValidationContext {
    constructor(ast, onError) {
      this._ast = ast;
      this._fragments = undefined;
      this._fragmentSpreads = new Map;
      this._recursivelyReferencedFragments = new Map;
      this._onError = onError;
    }
    get [Symbol.toStringTag]() {
      return "ASTValidationContext";
    }
    reportError(error) {
      this._onError(error);
    }
    getDocument() {
      return this._ast;
    }
    getFragment(name) {
      let fragments;
      if (this._fragments) {
        fragments = this._fragments;
      } else {
        fragments = Object.create(null);
        for (const defNode of this.getDocument().definitions) {
          if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
            fragments[defNode.name.value] = defNode;
          }
        }
        this._fragments = fragments;
      }
      return fragments[name];
    }
    getFragmentSpreads(node2) {
      let spreads = this._fragmentSpreads.get(node2);
      if (!spreads) {
        spreads = [];
        const setsToVisit = [node2];
        let set;
        while (set = setsToVisit.pop()) {
          for (const selection of set.selections) {
            if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
              spreads.push(selection);
            } else if (selection.selectionSet) {
              setsToVisit.push(selection.selectionSet);
            }
          }
        }
        this._fragmentSpreads.set(node2, spreads);
      }
      return spreads;
    }
    getRecursivelyReferencedFragments(operation) {
      let fragments = this._recursivelyReferencedFragments.get(operation);
      if (!fragments) {
        fragments = [];
        const collectedNames = Object.create(null);
        const nodesToVisit = [operation.selectionSet];
        let node2;
        while (node2 = nodesToVisit.pop()) {
          for (const spread of this.getFragmentSpreads(node2)) {
            const fragName = spread.name.value;
            if (collectedNames[fragName] !== true) {
              collectedNames[fragName] = true;
              const fragment = this.getFragment(fragName);
              if (fragment) {
                fragments.push(fragment);
                nodesToVisit.push(fragment.selectionSet);
              }
            }
          }
        }
        this._recursivelyReferencedFragments.set(operation, fragments);
      }
      return fragments;
    }
  }
  exports.ASTValidationContext = ASTValidationContext;

  class SDLValidationContext extends ASTValidationContext {
    constructor(ast, schema, onError) {
      super(ast, onError);
      this._schema = schema;
    }
    get [Symbol.toStringTag]() {
      return "SDLValidationContext";
    }
    getSchema() {
      return this._schema;
    }
  }
  exports.SDLValidationContext = SDLValidationContext;

  class ValidationContext extends ASTValidationContext {
    constructor(schema, ast, typeInfo, onError) {
      super(ast, onError);
      this._schema = schema;
      this._typeInfo = typeInfo;
      this._variableUsages = new Map;
      this._recursiveVariableUsages = new Map;
    }
    get [Symbol.toStringTag]() {
      return "ValidationContext";
    }
    getSchema() {
      return this._schema;
    }
    getVariableUsages(node2) {
      let usages = this._variableUsages.get(node2);
      if (!usages) {
        const newUsages = [];
        const typeInfo = new _TypeInfo.TypeInfo(this._schema);
        (0, _visitor.visit)(node2, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
          VariableDefinition: () => false,
          Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue(),
              parentType: typeInfo.getParentInputType()
            });
          }
        }));
        usages = newUsages;
        this._variableUsages.set(node2, usages);
      }
      return usages;
    }
    getRecursiveVariableUsages(operation) {
      let usages = this._recursiveVariableUsages.get(operation);
      if (!usages) {
        usages = this.getVariableUsages(operation);
        for (const frag of this.getRecursivelyReferencedFragments(operation)) {
          usages = usages.concat(this.getVariableUsages(frag));
        }
        this._recursiveVariableUsages.set(operation, usages);
      }
      return usages;
    }
    getType() {
      return this._typeInfo.getType();
    }
    getParentType() {
      return this._typeInfo.getParentType();
    }
    getInputType() {
      return this._typeInfo.getInputType();
    }
    getParentInputType() {
      return this._typeInfo.getParentInputType();
    }
    getFieldDef() {
      return this._typeInfo.getFieldDef();
    }
    getDirective() {
      return this._typeInfo.getDirective();
    }
    getArgument() {
      return this._typeInfo.getArgument();
    }
    getEnumValue() {
      return this._typeInfo.getEnumValue();
    }
  }
  exports.ValidationContext = ValidationContext;
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidSDL = assertValidSDL;
  exports.assertValidSDLExtension = assertValidSDLExtension;
  exports.validate = validate;
  exports.validateSDL = validateSDL;
  var _devAssert = require_devAssert();
  var _GraphQLError = require_GraphQLError();
  var _visitor = require_visitor();
  var _validate = require_validate();
  var _TypeInfo = require_TypeInfo();
  var _specifiedRules = require_specifiedRules();
  var _ValidationContext = require_ValidationContext();
  function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
    var _options$maxErrors;
    const maxErrors = (_options$maxErrors = options === null || options === undefined ? undefined : options.maxErrors) !== null && _options$maxErrors !== undefined ? _options$maxErrors : 100;
    documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
    (0, _validate.assertValidSchema)(schema);
    const abortObj = Object.freeze({});
    const errors = [];
    const context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, (error) => {
      if (errors.length >= maxErrors) {
        errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
        throw abortObj;
      }
      errors.push(error);
    });
    const visitor = (0, _visitor.visitInParallel)(rules.map((rule) => rule(context)));
    try {
      (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
    } catch (e) {
      if (e !== abortObj) {
        throw e;
      }
    }
    return errors;
  }
  function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
    const errors = [];
    const context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, (error) => {
      errors.push(error);
    });
    const visitors = rules.map((rule) => rule(context));
    (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
    return errors;
  }
  function assertValidSDL(documentAST) {
    const errors = validateSDL(documentAST);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join(`

`));
    }
  }
  function assertValidSDLExtension(documentAST, schema) {
    const errors = validateSDL(documentAST, schema);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join(`

`));
    }
  }
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.memoize3 = memoize3;
  function memoize3(fn) {
    let cache0;
    return function memoized(a1, a2, a3) {
      if (cache0 === undefined) {
        cache0 = new WeakMap;
      }
      let cache1 = cache0.get(a1);
      if (cache1 === undefined) {
        cache1 = new WeakMap;
        cache0.set(a1, cache1);
      }
      let cache2 = cache1.get(a2);
      if (cache2 === undefined) {
        cache2 = new WeakMap;
        cache1.set(a2, cache2);
      }
      let fnResult = cache2.get(a3);
      if (fnResult === undefined) {
        fnResult = fn(a1, a2, a3);
        cache2.set(a3, fnResult);
      }
      return fnResult;
    };
  }
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.promiseForObject = promiseForObject;
  function promiseForObject(object) {
    return Promise.all(Object.values(object)).then((resolvedValues) => {
      const resolvedObject = Object.create(null);
      for (const [i, key] of Object.keys(object).entries()) {
        resolvedObject[key] = resolvedValues[i];
      }
      return resolvedObject;
    });
  }
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.promiseReduce = promiseReduce;
  var _isPromise = require_isPromise();
  function promiseReduce(values, callbackFn, initialValue) {
    let accumulator = initialValue;
    for (const value of values) {
      accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
    }
    return accumulator;
  }
});

// node_modules/graphql/jsutils/toError.js
var require_toError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toError = toError;
  var _inspect = require_inspect();
  function toError(thrownValue) {
    return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
  }

  class NonErrorThrown extends Error {
    constructor(thrownValue) {
      super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
      this.name = "NonErrorThrown";
      this.thrownValue = thrownValue;
    }
  }
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.locatedError = locatedError;
  var _toError = require_toError();
  var _GraphQLError = require_GraphQLError();
  function locatedError(rawOriginalError, nodes, path) {
    var _nodes;
    const originalError = (0, _toError.toError)(rawOriginalError);
    if (isLocatedGraphQLError(originalError)) {
      return originalError;
    }
    return new _GraphQLError.GraphQLError(originalError.message, {
      nodes: (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes,
      source: originalError.source,
      positions: originalError.positions,
      path,
      originalError
    });
  }
  function isLocatedGraphQLError(error) {
    return Array.isArray(error.path);
  }
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidExecutionArguments = assertValidExecutionArguments;
  exports.buildExecutionContext = buildExecutionContext;
  exports.buildResolveInfo = buildResolveInfo;
  exports.defaultTypeResolver = exports.defaultFieldResolver = undefined;
  exports.execute = execute;
  exports.executeSync = executeSync;
  exports.getFieldDef = getFieldDef;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _isIterableObject = require_isIterableObject();
  var _isObjectLike = require_isObjectLike();
  var _isPromise = require_isPromise();
  var _memoize = require_memoize3();
  var _Path = require_Path();
  var _promiseForObject = require_promiseForObject();
  var _promiseReduce = require_promiseReduce();
  var _GraphQLError = require_GraphQLError();
  var _locatedError = require_locatedError();
  var _ast = require_ast();
  var _kinds = require_kinds();
  var _definition = require_definition();
  var _introspection = require_introspection();
  var _validate = require_validate();
  var _collectFields = require_collectFields();
  var _values = require_values();
  var collectSubfields = (0, _memoize.memoize3)((exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
  function execute(args) {
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const { schema, document: document2, variableValues, rootValue } = args;
    assertValidExecutionArguments(schema, document2, variableValues);
    const exeContext = buildExecutionContext(args);
    if (!("schema" in exeContext)) {
      return {
        errors: exeContext
      };
    }
    try {
      const { operation } = exeContext;
      const result = executeOperation(exeContext, operation, rootValue);
      if ((0, _isPromise.isPromise)(result)) {
        return result.then((data) => buildResponse(data, exeContext.errors), (error) => {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        });
      }
      return buildResponse(result, exeContext.errors);
    } catch (error) {
      exeContext.errors.push(error);
      return buildResponse(null, exeContext.errors);
    }
  }
  function executeSync(args) {
    const result = execute(args);
    if ((0, _isPromise.isPromise)(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  }
  function buildResponse(data, errors) {
    return errors.length === 0 ? {
      data
    } : {
      errors,
      data
    };
  }
  function assertValidExecutionArguments(schema, document2, rawVariableValues) {
    document2 || (0, _devAssert.devAssert)(false, "Must provide document.");
    (0, _validate.assertValidSchema)(schema);
    rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(false, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
  }
  function buildExecutionContext(args) {
    var _definition$name, _operation$variableDe, _options$maxCoercionE;
    const {
      schema,
      document: document2,
      rootValue,
      contextValue,
      variableValues: rawVariableValues,
      operationName,
      fieldResolver,
      typeResolver,
      subscribeFieldResolver,
      options
    } = args;
    let operation;
    const fragments = Object.create(null);
    for (const definition of document2.definitions) {
      switch (definition.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          if (operationName == null) {
            if (operation !== undefined) {
              return [
                new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")
              ];
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
            operation = definition;
          }
          break;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          fragments[definition.name.value] = definition;
          break;
        default:
      }
    }
    if (!operation) {
      if (operationName != null) {
        return [
          new _GraphQLError.GraphQLError(`Unknown operation named "${operationName}".`)
        ];
      }
      return [new _GraphQLError.GraphQLError("Must provide an operation.")];
    }
    const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== undefined ? _operation$variableDe : [];
    const coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== undefined ? rawVariableValues : {}, {
      maxErrors: (_options$maxCoercionE = options === null || options === undefined ? undefined : options.maxCoercionErrors) !== null && _options$maxCoercionE !== undefined ? _options$maxCoercionE : 50
    });
    if (coercedVariableValues.errors) {
      return coercedVariableValues.errors;
    }
    return {
      schema,
      fragments,
      rootValue,
      contextValue,
      operation,
      variableValues: coercedVariableValues.coerced,
      fieldResolver: fieldResolver !== null && fieldResolver !== undefined ? fieldResolver : defaultFieldResolver,
      typeResolver: typeResolver !== null && typeResolver !== undefined ? typeResolver : defaultTypeResolver,
      subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== undefined ? subscribeFieldResolver : defaultFieldResolver,
      errors: []
    };
  }
  function executeOperation(exeContext, operation, rootValue) {
    const rootType = exeContext.schema.getRootType(operation.operation);
    if (rootType == null) {
      throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
        nodes: operation
      });
    }
    const rootFields = (0, _collectFields.collectFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
    const path = undefined;
    switch (operation.operation) {
      case _ast.OperationTypeNode.QUERY:
        return executeFields(exeContext, rootType, rootValue, path, rootFields);
      case _ast.OperationTypeNode.MUTATION:
        return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
      case _ast.OperationTypeNode.SUBSCRIPTION:
        return executeFields(exeContext, rootType, rootValue, path, rootFields);
    }
  }
  function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return (0, _promiseReduce.promiseReduce)(fields.entries(), (results, [responseName, fieldNodes]) => {
      const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
      if (result === undefined) {
        return results;
      }
      if ((0, _isPromise.isPromise)(result)) {
        return result.then((resolvedResult) => {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    }, Object.create(null));
  }
  function executeFields(exeContext, parentType, sourceValue, path, fields) {
    const results = Object.create(null);
    let containsPromise = false;
    try {
      for (const [responseName, fieldNodes] of fields.entries()) {
        const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== undefined) {
          results[responseName] = result;
          if ((0, _isPromise.isPromise)(result)) {
            containsPromise = true;
          }
        }
      }
    } catch (error) {
      if (containsPromise) {
        return (0, _promiseForObject.promiseForObject)(results).finally(() => {
          throw error;
        });
      }
      throw error;
    }
    if (!containsPromise) {
      return results;
    }
    return (0, _promiseForObject.promiseForObject)(results);
  }
  function executeField(exeContext, parentType, source, fieldNodes, path) {
    var _fieldDef$resolve;
    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
    if (!fieldDef) {
      return;
    }
    const returnType = fieldDef.type;
    const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== undefined ? _fieldDef$resolve : exeContext.fieldResolver;
    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
    try {
      const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
      const contextValue = exeContext.contextValue;
      const result = resolveFn(source, args, contextValue, info);
      let completed;
      if ((0, _isPromise.isPromise)(result)) {
        completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
      } else {
        completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _isPromise.isPromise)(completed)) {
        return completed.then(undefined, (rawError) => {
          const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
          return handleFieldError(error, returnType, exeContext);
        });
      }
      return completed;
    } catch (rawError) {
      const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
      return handleFieldError(error, returnType, exeContext);
    }
  }
  function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    return {
      fieldName: fieldDef.name,
      fieldNodes,
      returnType: fieldDef.type,
      parentType,
      path,
      schema: exeContext.schema,
      fragments: exeContext.fragments,
      rootValue: exeContext.rootValue,
      operation: exeContext.operation,
      variableValues: exeContext.variableValues
    };
  }
  function handleFieldError(error, returnType, exeContext) {
    if ((0, _definition.isNonNullType)(returnType)) {
      throw error;
    }
    exeContext.errors.push(error);
    return null;
  }
  function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (result instanceof Error) {
      throw result;
    }
    if ((0, _definition.isNonNullType)(returnType)) {
      const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
      if (completed === null) {
        throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
      }
      return completed;
    }
    if (result == null) {
      return null;
    }
    if ((0, _definition.isListType)(returnType)) {
      return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isLeafType)(returnType)) {
      return completeLeafValue(returnType, result);
    }
    if ((0, _definition.isAbstractType)(returnType)) {
      return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if ((0, _definition.isObjectType)(returnType)) {
      return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    (0, _invariant.invariant)(false, "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType));
  }
  function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (!(0, _isIterableObject.isIterableObject)(result)) {
      throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
    }
    const itemType = returnType.ofType;
    let containsPromise = false;
    const completedResults = Array.from(result, (item, index) => {
      const itemPath = (0, _Path.addPath)(path, index, undefined);
      try {
        let completedItem;
        if ((0, _isPromise.isPromise)(item)) {
          completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
        } else {
          completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
        }
        if ((0, _isPromise.isPromise)(completedItem)) {
          containsPromise = true;
          return completedItem.then(undefined, (rawError) => {
            const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
            return handleFieldError(error, itemType, exeContext);
          });
        }
        return completedItem;
      } catch (rawError) {
        const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
        return handleFieldError(error, itemType, exeContext);
      }
    });
    return containsPromise ? Promise.all(completedResults) : completedResults;
  }
  function completeLeafValue(returnType, result) {
    const serializedResult = returnType.serialize(result);
    if (serializedResult == null) {
      throw new Error(`Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to ` + `return non-nullable value, returned: ${(0, _inspect.inspect)(serializedResult)}`);
    }
    return serializedResult;
  }
  function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
    var _returnType$resolveTy;
    const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== undefined ? _returnType$resolveTy : exeContext.typeResolver;
    const contextValue = exeContext.contextValue;
    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if ((0, _isPromise.isPromise)(runtimeType)) {
      return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
  }
  function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
    if (runtimeTypeName == null) {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
    }
    if ((0, _definition.isObjectType)(runtimeTypeName)) {
      throw new _GraphQLError.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
    }
    if (typeof runtimeTypeName !== "string") {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`);
    }
    const runtimeType = exeContext.schema.getType(runtimeTypeName);
    if (runtimeType == null) {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
        nodes: fieldNodes
      });
    }
    if (!(0, _definition.isObjectType)(runtimeType)) {
      throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
        nodes: fieldNodes
      });
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
      throw new _GraphQLError.GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
        nodes: fieldNodes
      });
    }
    return runtimeType;
  }
  function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
    const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
    if (returnType.isTypeOf) {
      const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
      if ((0, _isPromise.isPromise)(isTypeOf)) {
        return isTypeOf.then((resolvedIsTypeOf) => {
          if (!resolvedIsTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
          return executeFields(exeContext, returnType, result, path, subFieldNodes);
        });
      }
      if (!isTypeOf) {
        throw invalidReturnTypeError(returnType, result, fieldNodes);
      }
    }
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
  }
  function invalidReturnTypeError(returnType, result, fieldNodes) {
    return new _GraphQLError.GraphQLError(`Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`, {
      nodes: fieldNodes
    });
  }
  var defaultTypeResolver = function(value, contextValue, info, abstractType) {
    if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
      return value.__typename;
    }
    const possibleTypes = info.schema.getPossibleTypes(abstractType);
    const promisedIsTypeOfResults = [];
    for (let i = 0;i < possibleTypes.length; i++) {
      const type2 = possibleTypes[i];
      if (type2.isTypeOf) {
        const isTypeOfResult = type2.isTypeOf(value, contextValue, info);
        if ((0, _isPromise.isPromise)(isTypeOfResult)) {
          promisedIsTypeOfResults[i] = isTypeOfResult;
        } else if (isTypeOfResult) {
          return type2.name;
        }
      }
    }
    if (promisedIsTypeOfResults.length) {
      return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
        for (let i = 0;i < isTypeOfResults.length; i++) {
          if (isTypeOfResults[i]) {
            return possibleTypes[i].name;
          }
        }
      });
    }
  };
  exports.defaultTypeResolver = defaultTypeResolver;
  var defaultFieldResolver = function(source, args, contextValue, info) {
    if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
      const property = source[info.fieldName];
      if (typeof property === "function") {
        return source[info.fieldName](args, contextValue, info);
      }
      return property;
    }
  };
  exports.defaultFieldResolver = defaultFieldResolver;
  function getFieldDef(schema, parentType, fieldNode) {
    const fieldName = fieldNode.name.value;
    if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.SchemaMetaFieldDef;
    } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return _introspection.TypeMetaFieldDef;
    } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
      return _introspection.TypeNameMetaFieldDef;
    }
    return parentType.getFields()[fieldName];
  }
});

// node_modules/graphql/graphql.js
var require_graphql = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.graphql = graphql;
  exports.graphqlSync = graphqlSync;
  var _devAssert = require_devAssert();
  var _isPromise = require_isPromise();
  var _parser = require_parser();
  var _validate = require_validate();
  var _validate2 = require_validate2();
  var _execute = require_execute();
  function graphql(args) {
    return new Promise((resolve) => resolve(graphqlImpl(args)));
  }
  function graphqlSync(args) {
    const result = graphqlImpl(args);
    if ((0, _isPromise.isPromise)(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  }
  function graphqlImpl(args) {
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const {
      schema,
      source,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    } = args;
    const schemaValidationErrors = (0, _validate.validateSchema)(schema);
    if (schemaValidationErrors.length > 0) {
      return {
        errors: schemaValidationErrors
      };
    }
    let document2;
    try {
      document2 = (0, _parser.parse)(source);
    } catch (syntaxError) {
      return {
        errors: [syntaxError]
      };
    }
    const validationErrors = (0, _validate2.validate)(schema, document2);
    if (validationErrors.length > 0) {
      return {
        errors: validationErrors
      };
    }
    return (0, _execute.execute)({
      schema,
      document: document2,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    });
  }
});

// node_modules/graphql/type/index.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
    enumerable: true,
    get: function() {
      return _directives.DEFAULT_DEPRECATION_REASON;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
    enumerable: true,
    get: function() {
      return _scalars.GRAPHQL_MAX_INT;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
    enumerable: true,
    get: function() {
      return _scalars.GRAPHQL_MIN_INT;
    }
  });
  Object.defineProperty(exports, "GraphQLBoolean", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLBoolean;
    }
  });
  Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLDeprecatedDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLEnumType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLEnumType;
    }
  });
  Object.defineProperty(exports, "GraphQLFloat", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLFloat;
    }
  });
  Object.defineProperty(exports, "GraphQLID", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLID;
    }
  });
  Object.defineProperty(exports, "GraphQLIncludeDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLIncludeDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLInputObjectType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLInputObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLInt", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLInt;
    }
  });
  Object.defineProperty(exports, "GraphQLInterfaceType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLInterfaceType;
    }
  });
  Object.defineProperty(exports, "GraphQLList", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLList;
    }
  });
  Object.defineProperty(exports, "GraphQLNonNull", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLNonNull;
    }
  });
  Object.defineProperty(exports, "GraphQLObjectType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLOneOfDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLOneOfDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLScalarType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLScalarType;
    }
  });
  Object.defineProperty(exports, "GraphQLSchema", {
    enumerable: true,
    get: function() {
      return _schema.GraphQLSchema;
    }
  });
  Object.defineProperty(exports, "GraphQLSkipDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLSkipDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
    enumerable: true,
    get: function() {
      return _directives.GraphQLSpecifiedByDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLString", {
    enumerable: true,
    get: function() {
      return _scalars.GraphQLString;
    }
  });
  Object.defineProperty(exports, "GraphQLUnionType", {
    enumerable: true,
    get: function() {
      return _definition.GraphQLUnionType;
    }
  });
  Object.defineProperty(exports, "SchemaMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _introspection.SchemaMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeKind", {
    enumerable: true,
    get: function() {
      return _introspection.TypeKind;
    }
  });
  Object.defineProperty(exports, "TypeMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _introspection.TypeMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeNameMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _introspection.TypeNameMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "__Directive", {
    enumerable: true,
    get: function() {
      return _introspection.__Directive;
    }
  });
  Object.defineProperty(exports, "__DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _introspection.__DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "__EnumValue", {
    enumerable: true,
    get: function() {
      return _introspection.__EnumValue;
    }
  });
  Object.defineProperty(exports, "__Field", {
    enumerable: true,
    get: function() {
      return _introspection.__Field;
    }
  });
  Object.defineProperty(exports, "__InputValue", {
    enumerable: true,
    get: function() {
      return _introspection.__InputValue;
    }
  });
  Object.defineProperty(exports, "__Schema", {
    enumerable: true,
    get: function() {
      return _introspection.__Schema;
    }
  });
  Object.defineProperty(exports, "__Type", {
    enumerable: true,
    get: function() {
      return _introspection.__Type;
    }
  });
  Object.defineProperty(exports, "__TypeKind", {
    enumerable: true,
    get: function() {
      return _introspection.__TypeKind;
    }
  });
  Object.defineProperty(exports, "assertAbstractType", {
    enumerable: true,
    get: function() {
      return _definition.assertAbstractType;
    }
  });
  Object.defineProperty(exports, "assertCompositeType", {
    enumerable: true,
    get: function() {
      return _definition.assertCompositeType;
    }
  });
  Object.defineProperty(exports, "assertDirective", {
    enumerable: true,
    get: function() {
      return _directives.assertDirective;
    }
  });
  Object.defineProperty(exports, "assertEnumType", {
    enumerable: true,
    get: function() {
      return _definition.assertEnumType;
    }
  });
  Object.defineProperty(exports, "assertEnumValueName", {
    enumerable: true,
    get: function() {
      return _assertName.assertEnumValueName;
    }
  });
  Object.defineProperty(exports, "assertInputObjectType", {
    enumerable: true,
    get: function() {
      return _definition.assertInputObjectType;
    }
  });
  Object.defineProperty(exports, "assertInputType", {
    enumerable: true,
    get: function() {
      return _definition.assertInputType;
    }
  });
  Object.defineProperty(exports, "assertInterfaceType", {
    enumerable: true,
    get: function() {
      return _definition.assertInterfaceType;
    }
  });
  Object.defineProperty(exports, "assertLeafType", {
    enumerable: true,
    get: function() {
      return _definition.assertLeafType;
    }
  });
  Object.defineProperty(exports, "assertListType", {
    enumerable: true,
    get: function() {
      return _definition.assertListType;
    }
  });
  Object.defineProperty(exports, "assertName", {
    enumerable: true,
    get: function() {
      return _assertName.assertName;
    }
  });
  Object.defineProperty(exports, "assertNamedType", {
    enumerable: true,
    get: function() {
      return _definition.assertNamedType;
    }
  });
  Object.defineProperty(exports, "assertNonNullType", {
    enumerable: true,
    get: function() {
      return _definition.assertNonNullType;
    }
  });
  Object.defineProperty(exports, "assertNullableType", {
    enumerable: true,
    get: function() {
      return _definition.assertNullableType;
    }
  });
  Object.defineProperty(exports, "assertObjectType", {
    enumerable: true,
    get: function() {
      return _definition.assertObjectType;
    }
  });
  Object.defineProperty(exports, "assertOutputType", {
    enumerable: true,
    get: function() {
      return _definition.assertOutputType;
    }
  });
  Object.defineProperty(exports, "assertScalarType", {
    enumerable: true,
    get: function() {
      return _definition.assertScalarType;
    }
  });
  Object.defineProperty(exports, "assertSchema", {
    enumerable: true,
    get: function() {
      return _schema.assertSchema;
    }
  });
  Object.defineProperty(exports, "assertType", {
    enumerable: true,
    get: function() {
      return _definition.assertType;
    }
  });
  Object.defineProperty(exports, "assertUnionType", {
    enumerable: true,
    get: function() {
      return _definition.assertUnionType;
    }
  });
  Object.defineProperty(exports, "assertValidSchema", {
    enumerable: true,
    get: function() {
      return _validate.assertValidSchema;
    }
  });
  Object.defineProperty(exports, "assertWrappingType", {
    enumerable: true,
    get: function() {
      return _definition.assertWrappingType;
    }
  });
  Object.defineProperty(exports, "getNamedType", {
    enumerable: true,
    get: function() {
      return _definition.getNamedType;
    }
  });
  Object.defineProperty(exports, "getNullableType", {
    enumerable: true,
    get: function() {
      return _definition.getNullableType;
    }
  });
  Object.defineProperty(exports, "introspectionTypes", {
    enumerable: true,
    get: function() {
      return _introspection.introspectionTypes;
    }
  });
  Object.defineProperty(exports, "isAbstractType", {
    enumerable: true,
    get: function() {
      return _definition.isAbstractType;
    }
  });
  Object.defineProperty(exports, "isCompositeType", {
    enumerable: true,
    get: function() {
      return _definition.isCompositeType;
    }
  });
  Object.defineProperty(exports, "isDirective", {
    enumerable: true,
    get: function() {
      return _directives.isDirective;
    }
  });
  Object.defineProperty(exports, "isEnumType", {
    enumerable: true,
    get: function() {
      return _definition.isEnumType;
    }
  });
  Object.defineProperty(exports, "isInputObjectType", {
    enumerable: true,
    get: function() {
      return _definition.isInputObjectType;
    }
  });
  Object.defineProperty(exports, "isInputType", {
    enumerable: true,
    get: function() {
      return _definition.isInputType;
    }
  });
  Object.defineProperty(exports, "isInterfaceType", {
    enumerable: true,
    get: function() {
      return _definition.isInterfaceType;
    }
  });
  Object.defineProperty(exports, "isIntrospectionType", {
    enumerable: true,
    get: function() {
      return _introspection.isIntrospectionType;
    }
  });
  Object.defineProperty(exports, "isLeafType", {
    enumerable: true,
    get: function() {
      return _definition.isLeafType;
    }
  });
  Object.defineProperty(exports, "isListType", {
    enumerable: true,
    get: function() {
      return _definition.isListType;
    }
  });
  Object.defineProperty(exports, "isNamedType", {
    enumerable: true,
    get: function() {
      return _definition.isNamedType;
    }
  });
  Object.defineProperty(exports, "isNonNullType", {
    enumerable: true,
    get: function() {
      return _definition.isNonNullType;
    }
  });
  Object.defineProperty(exports, "isNullableType", {
    enumerable: true,
    get: function() {
      return _definition.isNullableType;
    }
  });
  Object.defineProperty(exports, "isObjectType", {
    enumerable: true,
    get: function() {
      return _definition.isObjectType;
    }
  });
  Object.defineProperty(exports, "isOutputType", {
    enumerable: true,
    get: function() {
      return _definition.isOutputType;
    }
  });
  Object.defineProperty(exports, "isRequiredArgument", {
    enumerable: true,
    get: function() {
      return _definition.isRequiredArgument;
    }
  });
  Object.defineProperty(exports, "isRequiredInputField", {
    enumerable: true,
    get: function() {
      return _definition.isRequiredInputField;
    }
  });
  Object.defineProperty(exports, "isScalarType", {
    enumerable: true,
    get: function() {
      return _definition.isScalarType;
    }
  });
  Object.defineProperty(exports, "isSchema", {
    enumerable: true,
    get: function() {
      return _schema.isSchema;
    }
  });
  Object.defineProperty(exports, "isSpecifiedDirective", {
    enumerable: true,
    get: function() {
      return _directives.isSpecifiedDirective;
    }
  });
  Object.defineProperty(exports, "isSpecifiedScalarType", {
    enumerable: true,
    get: function() {
      return _scalars.isSpecifiedScalarType;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
      return _definition.isType;
    }
  });
  Object.defineProperty(exports, "isUnionType", {
    enumerable: true,
    get: function() {
      return _definition.isUnionType;
    }
  });
  Object.defineProperty(exports, "isWrappingType", {
    enumerable: true,
    get: function() {
      return _definition.isWrappingType;
    }
  });
  Object.defineProperty(exports, "resolveObjMapThunk", {
    enumerable: true,
    get: function() {
      return _definition.resolveObjMapThunk;
    }
  });
  Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
    enumerable: true,
    get: function() {
      return _definition.resolveReadonlyArrayThunk;
    }
  });
  Object.defineProperty(exports, "specifiedDirectives", {
    enumerable: true,
    get: function() {
      return _directives.specifiedDirectives;
    }
  });
  Object.defineProperty(exports, "specifiedScalarTypes", {
    enumerable: true,
    get: function() {
      return _scalars.specifiedScalarTypes;
    }
  });
  Object.defineProperty(exports, "validateSchema", {
    enumerable: true,
    get: function() {
      return _validate.validateSchema;
    }
  });
  var _schema = require_schema();
  var _definition = require_definition();
  var _directives = require_directives();
  var _scalars = require_scalars();
  var _introspection = require_introspection();
  var _validate = require_validate();
  var _assertName = require_assertName();
});

// node_modules/graphql/language/index.js
var require_language = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BREAK", {
    enumerable: true,
    get: function() {
      return _visitor.BREAK;
    }
  });
  Object.defineProperty(exports, "DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _directiveLocation.DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "Kind", {
    enumerable: true,
    get: function() {
      return _kinds.Kind;
    }
  });
  Object.defineProperty(exports, "Lexer", {
    enumerable: true,
    get: function() {
      return _lexer.Lexer;
    }
  });
  Object.defineProperty(exports, "Location", {
    enumerable: true,
    get: function() {
      return _ast.Location;
    }
  });
  Object.defineProperty(exports, "OperationTypeNode", {
    enumerable: true,
    get: function() {
      return _ast.OperationTypeNode;
    }
  });
  Object.defineProperty(exports, "Source", {
    enumerable: true,
    get: function() {
      return _source.Source;
    }
  });
  Object.defineProperty(exports, "Token", {
    enumerable: true,
    get: function() {
      return _ast.Token;
    }
  });
  Object.defineProperty(exports, "TokenKind", {
    enumerable: true,
    get: function() {
      return _tokenKind.TokenKind;
    }
  });
  Object.defineProperty(exports, "getEnterLeaveForKind", {
    enumerable: true,
    get: function() {
      return _visitor.getEnterLeaveForKind;
    }
  });
  Object.defineProperty(exports, "getLocation", {
    enumerable: true,
    get: function() {
      return _location.getLocation;
    }
  });
  Object.defineProperty(exports, "getVisitFn", {
    enumerable: true,
    get: function() {
      return _visitor.getVisitFn;
    }
  });
  Object.defineProperty(exports, "isConstValueNode", {
    enumerable: true,
    get: function() {
      return _predicates.isConstValueNode;
    }
  });
  Object.defineProperty(exports, "isDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isExecutableDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isExecutableDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isSelectionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isSelectionNode;
    }
  });
  Object.defineProperty(exports, "isTypeDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeExtensionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeExtensionNode;
    }
  });
  Object.defineProperty(exports, "isTypeNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeSystemDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemExtensionNode", {
    enumerable: true,
    get: function() {
      return _predicates.isTypeSystemExtensionNode;
    }
  });
  Object.defineProperty(exports, "isValueNode", {
    enumerable: true,
    get: function() {
      return _predicates.isValueNode;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parser.parse;
    }
  });
  Object.defineProperty(exports, "parseConstValue", {
    enumerable: true,
    get: function() {
      return _parser.parseConstValue;
    }
  });
  Object.defineProperty(exports, "parseType", {
    enumerable: true,
    get: function() {
      return _parser.parseType;
    }
  });
  Object.defineProperty(exports, "parseValue", {
    enumerable: true,
    get: function() {
      return _parser.parseValue;
    }
  });
  Object.defineProperty(exports, "print", {
    enumerable: true,
    get: function() {
      return _printer.print;
    }
  });
  Object.defineProperty(exports, "printLocation", {
    enumerable: true,
    get: function() {
      return _printLocation.printLocation;
    }
  });
  Object.defineProperty(exports, "printSourceLocation", {
    enumerable: true,
    get: function() {
      return _printLocation.printSourceLocation;
    }
  });
  Object.defineProperty(exports, "visit", {
    enumerable: true,
    get: function() {
      return _visitor.visit;
    }
  });
  Object.defineProperty(exports, "visitInParallel", {
    enumerable: true,
    get: function() {
      return _visitor.visitInParallel;
    }
  });
  var _source = require_source();
  var _location = require_location();
  var _printLocation = require_printLocation();
  var _kinds = require_kinds();
  var _tokenKind = require_tokenKind();
  var _lexer = require_lexer();
  var _parser = require_parser();
  var _printer = require_printer();
  var _visitor = require_visitor();
  var _ast = require_ast();
  var _predicates = require_predicates();
  var _directiveLocation = require_directiveLocation();
});

// node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAsyncIterable = isAsyncIterable;
  function isAsyncIterable(maybeAsyncIterable) {
    return typeof (maybeAsyncIterable === null || maybeAsyncIterable === undefined ? undefined : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
  }
});

// node_modules/graphql/execution/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mapAsyncIterator = mapAsyncIterator;
  function mapAsyncIterator(iterable, callback) {
    const iterator = iterable[Symbol.asyncIterator]();
    async function mapResult(result) {
      if (result.done) {
        return result;
      }
      try {
        return {
          value: await callback(result.value),
          done: false
        };
      } catch (error) {
        if (typeof iterator.return === "function") {
          try {
            await iterator.return();
          } catch (_e) {
          }
        }
        throw error;
      }
    }
    return {
      async next() {
        return mapResult(await iterator.next());
      },
      async return() {
        return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
          value: undefined,
          done: true
        };
      },
      async throw(error) {
        if (typeof iterator.throw === "function") {
          return mapResult(await iterator.throw(error));
        }
        throw error;
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
});

// node_modules/graphql/execution/subscribe.js
var require_subscribe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createSourceEventStream = createSourceEventStream;
  exports.subscribe = subscribe;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _isAsyncIterable = require_isAsyncIterable();
  var _Path = require_Path();
  var _GraphQLError = require_GraphQLError();
  var _locatedError = require_locatedError();
  var _collectFields = require_collectFields();
  var _execute = require_execute();
  var _mapAsyncIterator = require_mapAsyncIterator();
  var _values = require_values();
  async function subscribe(args) {
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const resultOrStream = await createSourceEventStream(args);
    if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
      return resultOrStream;
    }
    const mapSourceToResponse = (payload) => (0, _execute.execute)({ ...args, rootValue: payload });
    return (0, _mapAsyncIterator.mapAsyncIterator)(resultOrStream, mapSourceToResponse);
  }
  function toNormalizedArgs(args) {
    const firstArg = args[0];
    if (firstArg && "document" in firstArg) {
      return firstArg;
    }
    return {
      schema: firstArg,
      document: args[1],
      rootValue: args[2],
      contextValue: args[3],
      variableValues: args[4],
      operationName: args[5],
      subscribeFieldResolver: args[6]
    };
  }
  async function createSourceEventStream(...rawArgs) {
    const args = toNormalizedArgs(rawArgs);
    const { schema, document: document2, variableValues } = args;
    (0, _execute.assertValidExecutionArguments)(schema, document2, variableValues);
    const exeContext = (0, _execute.buildExecutionContext)(args);
    if (!("schema" in exeContext)) {
      return {
        errors: exeContext
      };
    }
    try {
      const eventStream = await executeSubscription(exeContext);
      if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
        throw new Error("Subscription field must return Async Iterable. " + `Received: ${(0, _inspect.inspect)(eventStream)}.`);
      }
      return eventStream;
    } catch (error) {
      if (error instanceof _GraphQLError.GraphQLError) {
        return {
          errors: [error]
        };
      }
      throw error;
    }
  }
  async function executeSubscription(exeContext) {
    const { schema, fragments, operation, variableValues, rootValue } = exeContext;
    const rootType = schema.getSubscriptionType();
    if (rootType == null) {
      throw new _GraphQLError.GraphQLError("Schema is not configured to execute subscription operation.", {
        nodes: operation
      });
    }
    const rootFields = (0, _collectFields.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
    const [responseName, fieldNodes] = [...rootFields.entries()][0];
    const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
    if (!fieldDef) {
      const fieldName = fieldNodes[0].name.value;
      throw new _GraphQLError.GraphQLError(`The subscription field "${fieldName}" is not defined.`, {
        nodes: fieldNodes
      });
    }
    const path = (0, _Path.addPath)(undefined, responseName, rootType.name);
    const info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, rootType, path);
    try {
      var _fieldDef$subscribe;
      const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
      const contextValue = exeContext.contextValue;
      const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== undefined ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
      const eventStream = await resolveFn(rootValue, args, contextValue, info);
      if (eventStream instanceof Error) {
        throw eventStream;
      }
      return eventStream;
    } catch (error) {
      throw (0, _locatedError.locatedError)(error, fieldNodes, (0, _Path.pathToArray)(path));
    }
  }
});

// node_modules/graphql/execution/index.js
var require_execution = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "createSourceEventStream", {
    enumerable: true,
    get: function() {
      return _subscribe.createSourceEventStream;
    }
  });
  Object.defineProperty(exports, "defaultFieldResolver", {
    enumerable: true,
    get: function() {
      return _execute.defaultFieldResolver;
    }
  });
  Object.defineProperty(exports, "defaultTypeResolver", {
    enumerable: true,
    get: function() {
      return _execute.defaultTypeResolver;
    }
  });
  Object.defineProperty(exports, "execute", {
    enumerable: true,
    get: function() {
      return _execute.execute;
    }
  });
  Object.defineProperty(exports, "executeSync", {
    enumerable: true,
    get: function() {
      return _execute.executeSync;
    }
  });
  Object.defineProperty(exports, "getArgumentValues", {
    enumerable: true,
    get: function() {
      return _values.getArgumentValues;
    }
  });
  Object.defineProperty(exports, "getDirectiveValues", {
    enumerable: true,
    get: function() {
      return _values.getDirectiveValues;
    }
  });
  Object.defineProperty(exports, "getVariableValues", {
    enumerable: true,
    get: function() {
      return _values.getVariableValues;
    }
  });
  Object.defineProperty(exports, "responsePathAsArray", {
    enumerable: true,
    get: function() {
      return _Path.pathToArray;
    }
  });
  Object.defineProperty(exports, "subscribe", {
    enumerable: true,
    get: function() {
      return _subscribe.subscribe;
    }
  });
  var _Path = require_Path();
  var _execute = require_execute();
  var _subscribe = require_subscribe();
  var _values = require_values();
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
  var _invariant = require_invariant();
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  function NoDeprecatedCustomRule(context) {
    return {
      Field(node2) {
        const fieldDef = context.getFieldDef();
        const deprecationReason = fieldDef === null || fieldDef === undefined ? undefined : fieldDef.deprecationReason;
        if (fieldDef && deprecationReason != null) {
          const parentType = context.getParentType();
          parentType != null || (0, _invariant.invariant)(false);
          context.reportError(new _GraphQLError.GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, {
            nodes: node2
          }));
        }
      },
      Argument(node2) {
        const argDef = context.getArgument();
        const deprecationReason = argDef === null || argDef === undefined ? undefined : argDef.deprecationReason;
        if (argDef && deprecationReason != null) {
          const directiveDef = context.getDirective();
          if (directiveDef != null) {
            context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
              nodes: node2
            }));
          } else {
            const parentType = context.getParentType();
            const fieldDef = context.getFieldDef();
            parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
            context.reportError(new _GraphQLError.GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
              nodes: node2
            }));
          }
        }
      },
      ObjectField(node2) {
        const inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
        if ((0, _definition.isInputObjectType)(inputObjectDef)) {
          const inputFieldDef = inputObjectDef.getFields()[node2.name.value];
          const deprecationReason = inputFieldDef === null || inputFieldDef === undefined ? undefined : inputFieldDef.deprecationReason;
          if (deprecationReason != null) {
            context.reportError(new _GraphQLError.GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, {
              nodes: node2
            }));
          }
        }
      },
      EnumValue(node2) {
        const enumValueDef = context.getEnumValue();
        const deprecationReason = enumValueDef === null || enumValueDef === undefined ? undefined : enumValueDef.deprecationReason;
        if (enumValueDef && deprecationReason != null) {
          const enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
          enumTypeDef != null || (0, _invariant.invariant)(false);
          context.reportError(new _GraphQLError.GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, {
            nodes: node2
          }));
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
  var _GraphQLError = require_GraphQLError();
  var _definition = require_definition();
  var _introspection = require_introspection();
  function NoSchemaIntrospectionCustomRule(context) {
    return {
      Field(node2) {
        const type2 = (0, _definition.getNamedType)(context.getType());
        if (type2 && (0, _introspection.isIntrospectionType)(type2)) {
          context.reportError(new _GraphQLError.GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node2.name.value}".`, {
            nodes: node2
          }));
        }
      }
    };
  }
});

// node_modules/graphql/validation/index.js
var require_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ExecutableDefinitionsRule", {
    enumerable: true,
    get: function() {
      return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
    }
  });
  Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
    enumerable: true,
    get: function() {
      return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
    }
  });
  Object.defineProperty(exports, "KnownArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _KnownArgumentNamesRule.KnownArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownDirectivesRule", {
    enumerable: true,
    get: function() {
      return _KnownDirectivesRule.KnownDirectivesRule;
    }
  });
  Object.defineProperty(exports, "KnownFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _KnownFragmentNamesRule.KnownFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _KnownTypeNamesRule.KnownTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "LoneAnonymousOperationRule", {
    enumerable: true,
    get: function() {
      return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
    }
  });
  Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
    enumerable: true,
    get: function() {
      return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
    }
  });
  Object.defineProperty(exports, "MaxIntrospectionDepthRule", {
    enumerable: true,
    get: function() {
      return _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule;
    }
  });
  Object.defineProperty(exports, "NoDeprecatedCustomRule", {
    enumerable: true,
    get: function() {
      return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
    }
  });
  Object.defineProperty(exports, "NoFragmentCyclesRule", {
    enumerable: true,
    get: function() {
      return _NoFragmentCyclesRule.NoFragmentCyclesRule;
    }
  });
  Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
    enumerable: true,
    get: function() {
      return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
    }
  });
  Object.defineProperty(exports, "NoUndefinedVariablesRule", {
    enumerable: true,
    get: function() {
      return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedFragmentsRule", {
    enumerable: true,
    get: function() {
      return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedVariablesRule", {
    enumerable: true,
    get: function() {
      return _NoUnusedVariablesRule.NoUnusedVariablesRule;
    }
  });
  Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
    enumerable: true,
    get: function() {
      return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
    }
  });
  Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
    enumerable: true,
    get: function() {
      return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
    }
  });
  Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
    enumerable: true,
    get: function() {
      return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
    }
  });
  Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
    enumerable: true,
    get: function() {
      return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
    }
  });
  Object.defineProperty(exports, "ScalarLeafsRule", {
    enumerable: true,
    get: function() {
      return _ScalarLeafsRule.ScalarLeafsRule;
    }
  });
  Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
    enumerable: true,
    get: function() {
      return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
    enumerable: true,
    get: function() {
      return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
    }
  });
  Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueOperationNamesRule.UniqueOperationNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationTypesRule", {
    enumerable: true,
    get: function() {
      return _UniqueOperationTypesRule.UniqueOperationTypesRule;
    }
  });
  Object.defineProperty(exports, "UniqueTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueTypeNamesRule.UniqueTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueVariableNamesRule", {
    enumerable: true,
    get: function() {
      return _UniqueVariableNamesRule.UniqueVariableNamesRule;
    }
  });
  Object.defineProperty(exports, "ValidationContext", {
    enumerable: true,
    get: function() {
      return _ValidationContext.ValidationContext;
    }
  });
  Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "VariablesAreInputTypesRule", {
    enumerable: true,
    get: function() {
      return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
    }
  });
  Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
    enumerable: true,
    get: function() {
      return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
    }
  });
  Object.defineProperty(exports, "recommendedRules", {
    enumerable: true,
    get: function() {
      return _specifiedRules.recommendedRules;
    }
  });
  Object.defineProperty(exports, "specifiedRules", {
    enumerable: true,
    get: function() {
      return _specifiedRules.specifiedRules;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.validate;
    }
  });
  var _validate = require_validate2();
  var _ValidationContext = require_ValidationContext();
  var _specifiedRules = require_specifiedRules();
  var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
  var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
  var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
  var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
  var _KnownDirectivesRule = require_KnownDirectivesRule();
  var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
  var _KnownTypeNamesRule = require_KnownTypeNamesRule();
  var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
  var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
  var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
  var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
  var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
  var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
  var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
  var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
  var _ScalarLeafsRule = require_ScalarLeafsRule();
  var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
  var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
  var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
  var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
  var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
  var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
  var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
  var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
  var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
  var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
  var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
  var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
  var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
  var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
  var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
  var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
  var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
  var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
  var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
  var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
  var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
});

// node_modules/graphql/error/index.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "GraphQLError", {
    enumerable: true,
    get: function() {
      return _GraphQLError.GraphQLError;
    }
  });
  Object.defineProperty(exports, "formatError", {
    enumerable: true,
    get: function() {
      return _GraphQLError.formatError;
    }
  });
  Object.defineProperty(exports, "locatedError", {
    enumerable: true,
    get: function() {
      return _locatedError.locatedError;
    }
  });
  Object.defineProperty(exports, "printError", {
    enumerable: true,
    get: function() {
      return _GraphQLError.printError;
    }
  });
  Object.defineProperty(exports, "syntaxError", {
    enumerable: true,
    get: function() {
      return _syntaxError.syntaxError;
    }
  });
  var _GraphQLError = require_GraphQLError();
  var _syntaxError = require_syntaxError();
  var _locatedError = require_locatedError();
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getIntrospectionQuery = getIntrospectionQuery;
  function getIntrospectionQuery(options) {
    const optionsWithDefault = {
      descriptions: true,
      specifiedByUrl: false,
      directiveIsRepeatable: false,
      schemaDescription: false,
      inputValueDeprecation: false,
      oneOf: false,
      ...options
    };
    const descriptions = optionsWithDefault.descriptions ? "description" : "";
    const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
    const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
    const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
    function inputDeprecation(str) {
      return optionsWithDefault.inputValueDeprecation ? str : "";
    }
    const oneOf = optionsWithDefault.oneOf ? "isOneOf" : "";
    return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      ${oneOf}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
  }
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getOperationAST = getOperationAST;
  var _kinds = require_kinds();
  function getOperationAST(documentAST, operationName) {
    let operation = null;
    for (const definition of documentAST.definitions) {
      if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
        var _definition$name;
        if (operationName == null) {
          if (operation) {
            return null;
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
          return definition;
        }
      }
    }
    return operation;
  }
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getOperationRootType = getOperationRootType;
  var _GraphQLError = require_GraphQLError();
  function getOperationRootType(schema, operation) {
    if (operation.operation === "query") {
      const queryType = schema.getQueryType();
      if (!queryType) {
        throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", {
          nodes: operation
        });
      }
      return queryType;
    }
    if (operation.operation === "mutation") {
      const mutationType = schema.getMutationType();
      if (!mutationType) {
        throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", {
          nodes: operation
        });
      }
      return mutationType;
    }
    if (operation.operation === "subscription") {
      const subscriptionType = schema.getSubscriptionType();
      if (!subscriptionType) {
        throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", {
          nodes: operation
        });
      }
      return subscriptionType;
    }
    throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", {
      nodes: operation
    });
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.introspectionFromSchema = introspectionFromSchema;
  var _invariant = require_invariant();
  var _parser = require_parser();
  var _execute = require_execute();
  var _getIntrospectionQuery = require_getIntrospectionQuery();
  function introspectionFromSchema(schema, options) {
    const optionsWithDefaults = {
      specifiedByUrl: true,
      directiveIsRepeatable: true,
      schemaDescription: true,
      inputValueDeprecation: true,
      oneOf: true,
      ...options
    };
    const document2 = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
    const result = (0, _execute.executeSync)({
      schema,
      document: document2
    });
    !result.errors && result.data || (0, _invariant.invariant)(false);
    return result.data;
  }
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildClientSchema = buildClientSchema;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _isObjectLike = require_isObjectLike();
  var _keyValMap = require_keyValMap();
  var _parser = require_parser();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var _schema = require_schema();
  var _valueFromAST = require_valueFromAST();
  function buildClientSchema(introspection, options) {
    (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`);
    const schemaIntrospection = introspection.__schema;
    const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, (typeIntrospection) => typeIntrospection.name, (typeIntrospection) => buildType(typeIntrospection));
    for (const stdType of [
      ..._scalars.specifiedScalarTypes,
      ..._introspection.introspectionTypes
    ]) {
      if (typeMap[stdType.name]) {
        typeMap[stdType.name] = stdType;
      }
    }
    const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
    const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
    const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
    const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
    return new _schema.GraphQLSchema({
      description: schemaIntrospection.description,
      query: queryType,
      mutation: mutationType,
      subscription: subscriptionType,
      types: Object.values(typeMap),
      directives,
      assumeValid: options === null || options === undefined ? undefined : options.assumeValid
    });
    function getType(typeRef) {
      if (typeRef.kind === _introspection.TypeKind.LIST) {
        const itemRef = typeRef.ofType;
        if (!itemRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        return new _definition.GraphQLList(getType(itemRef));
      }
      if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
        const nullableRef = typeRef.ofType;
        if (!nullableRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        const nullableType = getType(nullableRef);
        return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
      }
      return getNamedType(typeRef);
    }
    function getNamedType(typeRef) {
      const typeName = typeRef.name;
      if (!typeName) {
        throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);
      }
      const type2 = typeMap[typeName];
      if (!type2) {
        throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
      }
      return type2;
    }
    function getObjectType(typeRef) {
      return (0, _definition.assertObjectType)(getNamedType(typeRef));
    }
    function getInterfaceType(typeRef) {
      return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
    }
    function buildType(type2) {
      if (type2 != null && type2.name != null && type2.kind != null) {
        switch (type2.kind) {
          case _introspection.TypeKind.SCALAR:
            return buildScalarDef(type2);
          case _introspection.TypeKind.OBJECT:
            return buildObjectDef(type2);
          case _introspection.TypeKind.INTERFACE:
            return buildInterfaceDef(type2);
          case _introspection.TypeKind.UNION:
            return buildUnionDef(type2);
          case _introspection.TypeKind.ENUM:
            return buildEnumDef(type2);
          case _introspection.TypeKind.INPUT_OBJECT:
            return buildInputObjectDef(type2);
        }
      }
      const typeStr = (0, _inspect.inspect)(type2);
      throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
    }
    function buildScalarDef(scalarIntrospection) {
      return new _definition.GraphQLScalarType({
        name: scalarIntrospection.name,
        description: scalarIntrospection.description,
        specifiedByURL: scalarIntrospection.specifiedByURL
      });
    }
    function buildImplementationsList(implementingIntrospection) {
      if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
        return [];
      }
      if (!implementingIntrospection.interfaces) {
        const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);
        throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
      }
      return implementingIntrospection.interfaces.map(getInterfaceType);
    }
    function buildObjectDef(objectIntrospection) {
      return new _definition.GraphQLObjectType({
        name: objectIntrospection.name,
        description: objectIntrospection.description,
        interfaces: () => buildImplementationsList(objectIntrospection),
        fields: () => buildFieldDefMap(objectIntrospection)
      });
    }
    function buildInterfaceDef(interfaceIntrospection) {
      return new _definition.GraphQLInterfaceType({
        name: interfaceIntrospection.name,
        description: interfaceIntrospection.description,
        interfaces: () => buildImplementationsList(interfaceIntrospection),
        fields: () => buildFieldDefMap(interfaceIntrospection)
      });
    }
    function buildUnionDef(unionIntrospection) {
      if (!unionIntrospection.possibleTypes) {
        const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
        throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
      }
      return new _definition.GraphQLUnionType({
        name: unionIntrospection.name,
        description: unionIntrospection.description,
        types: () => unionIntrospection.possibleTypes.map(getObjectType)
      });
    }
    function buildEnumDef(enumIntrospection) {
      if (!enumIntrospection.enumValues) {
        const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
        throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
      }
      return new _definition.GraphQLEnumType({
        name: enumIntrospection.name,
        description: enumIntrospection.description,
        values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, (valueIntrospection) => valueIntrospection.name, (valueIntrospection) => ({
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        }))
      });
    }
    function buildInputObjectDef(inputObjectIntrospection) {
      if (!inputObjectIntrospection.inputFields) {
        const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);
        throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
      }
      return new _definition.GraphQLInputObjectType({
        name: inputObjectIntrospection.name,
        description: inputObjectIntrospection.description,
        fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),
        isOneOf: inputObjectIntrospection.isOneOf
      });
    }
    function buildFieldDefMap(typeIntrospection) {
      if (!typeIntrospection.fields) {
        throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);
      }
      return (0, _keyValMap.keyValMap)(typeIntrospection.fields, (fieldIntrospection) => fieldIntrospection.name, buildField);
    }
    function buildField(fieldIntrospection) {
      const type2 = getType(fieldIntrospection.type);
      if (!(0, _definition.isOutputType)(type2)) {
        const typeStr = (0, _inspect.inspect)(type2);
        throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
      }
      if (!fieldIntrospection.args) {
        const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
        throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
      }
      return {
        description: fieldIntrospection.description,
        deprecationReason: fieldIntrospection.deprecationReason,
        type: type2,
        args: buildInputValueDefMap(fieldIntrospection.args)
      };
    }
    function buildInputValueDefMap(inputValueIntrospections) {
      return (0, _keyValMap.keyValMap)(inputValueIntrospections, (inputValue) => inputValue.name, buildInputValue);
    }
    function buildInputValue(inputValueIntrospection) {
      const type2 = getType(inputValueIntrospection.type);
      if (!(0, _definition.isInputType)(type2)) {
        const typeStr = (0, _inspect.inspect)(type2);
        throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
      }
      const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type2) : undefined;
      return {
        description: inputValueIntrospection.description,
        type: type2,
        defaultValue,
        deprecationReason: inputValueIntrospection.deprecationReason
      };
    }
    function buildDirective(directiveIntrospection) {
      if (!directiveIntrospection.args) {
        const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
        throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
      }
      if (!directiveIntrospection.locations) {
        const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
        throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
      }
      return new _directives.GraphQLDirective({
        name: directiveIntrospection.name,
        description: directiveIntrospection.description,
        isRepeatable: directiveIntrospection.isRepeatable,
        locations: directiveIntrospection.locations.slice(),
        args: buildInputValueDefMap(directiveIntrospection.args)
      });
    }
  }
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.extendSchema = extendSchema;
  exports.extendSchemaImpl = extendSchemaImpl;
  var _devAssert = require_devAssert();
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyMap = require_keyMap();
  var _mapValue = require_mapValue();
  var _kinds = require_kinds();
  var _predicates = require_predicates();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var _schema = require_schema();
  var _validate = require_validate2();
  var _values = require_values();
  var _valueFromAST = require_valueFromAST();
  function extendSchema(schema, documentAST, options) {
    (0, _schema.assertSchema)(schema);
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
    if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
      (0, _validate.assertValidSDLExtension)(documentAST, schema);
    }
    const schemaConfig = schema.toConfig();
    const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
    return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
  }
  function extendSchemaImpl(schemaConfig, documentAST, options) {
    var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
    const typeDefs = [];
    const typeExtensionsMap = Object.create(null);
    const directiveDefs = [];
    let schemaDef;
    const schemaExtensions = [];
    for (const def of documentAST.definitions) {
      if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
        schemaDef = def;
      } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
        schemaExtensions.push(def);
      } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
        typeDefs.push(def);
      } else if ((0, _predicates.isTypeExtensionNode)(def)) {
        const extendedTypeName = def.name.value;
        const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
      } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
        directiveDefs.push(def);
      }
    }
    if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
      return schemaConfig;
    }
    const typeMap = Object.create(null);
    for (const existingType of schemaConfig.types) {
      typeMap[existingType.name] = extendNamedType(existingType);
    }
    for (const typeNode of typeDefs) {
      var _stdTypeMap$name;
      const name = typeNode.name.value;
      typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== undefined ? _stdTypeMap$name : buildType(typeNode);
    }
    const operationTypes = {
      query: schemaConfig.query && replaceNamedType(schemaConfig.query),
      mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
      subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
      ...schemaDef && getOperationTypes([schemaDef]),
      ...getOperationTypes(schemaExtensions)
    };
    return {
      description: (_schemaDef = schemaDef) === null || _schemaDef === undefined ? undefined : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === undefined ? undefined : _schemaDef$descriptio.value,
      ...operationTypes,
      types: Object.values(typeMap),
      directives: [
        ...schemaConfig.directives.map(replaceDirective),
        ...directiveDefs.map(buildDirective)
      ],
      extensions: Object.create(null),
      astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== undefined ? _schemaDef2 : schemaConfig.astNode,
      extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
      assumeValid: (_options$assumeValid = options === null || options === undefined ? undefined : options.assumeValid) !== null && _options$assumeValid !== undefined ? _options$assumeValid : false
    };
    function replaceType(type2) {
      if ((0, _definition.isListType)(type2)) {
        return new _definition.GraphQLList(replaceType(type2.ofType));
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return new _definition.GraphQLNonNull(replaceType(type2.ofType));
      }
      return replaceNamedType(type2);
    }
    function replaceNamedType(type2) {
      return typeMap[type2.name];
    }
    function replaceDirective(directive) {
      const config = directive.toConfig();
      return new _directives.GraphQLDirective({
        ...config,
        args: (0, _mapValue.mapValue)(config.args, extendArg)
      });
    }
    function extendNamedType(type2) {
      if ((0, _introspection.isIntrospectionType)(type2) || (0, _scalars.isSpecifiedScalarType)(type2)) {
        return type2;
      }
      if ((0, _definition.isScalarType)(type2)) {
        return extendScalarType(type2);
      }
      if ((0, _definition.isObjectType)(type2)) {
        return extendObjectType(type2);
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        return extendInterfaceType(type2);
      }
      if ((0, _definition.isUnionType)(type2)) {
        return extendUnionType(type2);
      }
      if ((0, _definition.isEnumType)(type2)) {
        return extendEnumType(type2);
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        return extendInputObjectType(type2);
      }
      (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type2));
    }
    function extendInputObjectType(type2) {
      var _typeExtensionsMap$co;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== undefined ? _typeExtensionsMap$co : [];
      return new _definition.GraphQLInputObjectType({
        ...config,
        fields: () => ({
          ...(0, _mapValue.mapValue)(config.fields, (field) => ({
            ...field,
            type: replaceType(field.type)
          })),
          ...buildInputFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendEnumType(type2) {
      var _typeExtensionsMap$ty;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== undefined ? _typeExtensionsMap$ty : [];
      return new _definition.GraphQLEnumType({
        ...config,
        values: { ...config.values, ...buildEnumValueMap(extensions) },
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendScalarType(type2) {
      var _typeExtensionsMap$co2;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== undefined ? _typeExtensionsMap$co2 : [];
      let specifiedByURL = config.specifiedByURL;
      for (const extensionNode of extensions) {
        var _getSpecifiedByURL;
        specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== undefined ? _getSpecifiedByURL : specifiedByURL;
      }
      return new _definition.GraphQLScalarType({
        ...config,
        specifiedByURL,
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendObjectType(type2) {
      var _typeExtensionsMap$co3;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== undefined ? _typeExtensionsMap$co3 : [];
      return new _definition.GraphQLObjectType({
        ...config,
        interfaces: () => [
          ...type2.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => ({
          ...(0, _mapValue.mapValue)(config.fields, extendField),
          ...buildFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendInterfaceType(type2) {
      var _typeExtensionsMap$co4;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== undefined ? _typeExtensionsMap$co4 : [];
      return new _definition.GraphQLInterfaceType({
        ...config,
        interfaces: () => [
          ...type2.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => ({
          ...(0, _mapValue.mapValue)(config.fields, extendField),
          ...buildFieldMap(extensions)
        }),
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendUnionType(type2) {
      var _typeExtensionsMap$co5;
      const config = type2.toConfig();
      const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== undefined ? _typeExtensionsMap$co5 : [];
      return new _definition.GraphQLUnionType({
        ...config,
        types: () => [
          ...type2.getTypes().map(replaceNamedType),
          ...buildUnionTypes(extensions)
        ],
        extensionASTNodes: config.extensionASTNodes.concat(extensions)
      });
    }
    function extendField(field) {
      return {
        ...field,
        type: replaceType(field.type),
        args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
      };
    }
    function extendArg(arg) {
      return { ...arg, type: replaceType(arg.type) };
    }
    function getOperationTypes(nodes) {
      const opTypes = {};
      for (const node2 of nodes) {
        var _node$operationTypes;
        const operationTypesNodes = (_node$operationTypes = node2.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes) {
          opTypes[operationType.operation] = getNamedType(operationType.type);
        }
      }
      return opTypes;
    }
    function getNamedType(node2) {
      var _stdTypeMap$name2;
      const name = node2.name.value;
      const type2 = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== undefined ? _stdTypeMap$name2 : typeMap[name];
      if (type2 === undefined) {
        throw new Error(`Unknown type: "${name}".`);
      }
      return type2;
    }
    function getWrappedType(node2) {
      if (node2.kind === _kinds.Kind.LIST_TYPE) {
        return new _definition.GraphQLList(getWrappedType(node2.type));
      }
      if (node2.kind === _kinds.Kind.NON_NULL_TYPE) {
        return new _definition.GraphQLNonNull(getWrappedType(node2.type));
      }
      return getNamedType(node2);
    }
    function buildDirective(node2) {
      var _node$description;
      return new _directives.GraphQLDirective({
        name: node2.name.value,
        description: (_node$description = node2.description) === null || _node$description === undefined ? undefined : _node$description.value,
        locations: node2.locations.map(({ value }) => value),
        isRepeatable: node2.repeatable,
        args: buildArgumentMap(node2.arguments),
        astNode: node2
      });
    }
    function buildFieldMap(nodes) {
      const fieldConfigMap = Object.create(null);
      for (const node2 of nodes) {
        var _node$fields;
        const nodeFields = (_node$fields = node2.fields) !== null && _node$fields !== undefined ? _node$fields : [];
        for (const field of nodeFields) {
          var _field$description;
          fieldConfigMap[field.name.value] = {
            type: getWrappedType(field.type),
            description: (_field$description = field.description) === null || _field$description === undefined ? undefined : _field$description.value,
            args: buildArgumentMap(field.arguments),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return fieldConfigMap;
    }
    function buildArgumentMap(args) {
      const argsNodes = args !== null && args !== undefined ? args : [];
      const argConfigMap = Object.create(null);
      for (const arg of argsNodes) {
        var _arg$description;
        const type2 = getWrappedType(arg.type);
        argConfigMap[arg.name.value] = {
          type: type2,
          description: (_arg$description = arg.description) === null || _arg$description === undefined ? undefined : _arg$description.value,
          defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type2),
          deprecationReason: getDeprecationReason(arg),
          astNode: arg
        };
      }
      return argConfigMap;
    }
    function buildInputFieldMap(nodes) {
      const inputFieldMap = Object.create(null);
      for (const node2 of nodes) {
        var _node$fields2;
        const fieldsNodes = (_node$fields2 = node2.fields) !== null && _node$fields2 !== undefined ? _node$fields2 : [];
        for (const field of fieldsNodes) {
          var _field$description2;
          const type2 = getWrappedType(field.type);
          inputFieldMap[field.name.value] = {
            type: type2,
            description: (_field$description2 = field.description) === null || _field$description2 === undefined ? undefined : _field$description2.value,
            defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type2),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return inputFieldMap;
    }
    function buildEnumValueMap(nodes) {
      const enumValueMap = Object.create(null);
      for (const node2 of nodes) {
        var _node$values;
        const valuesNodes = (_node$values = node2.values) !== null && _node$values !== undefined ? _node$values : [];
        for (const value of valuesNodes) {
          var _value$description;
          enumValueMap[value.name.value] = {
            description: (_value$description = value.description) === null || _value$description === undefined ? undefined : _value$description.value,
            deprecationReason: getDeprecationReason(value),
            astNode: value
          };
        }
      }
      return enumValueMap;
    }
    function buildInterfaces(nodes) {
      return nodes.flatMap((node2) => {
        var _node$interfaces$map, _node$interfaces;
        return (_node$interfaces$map = (_node$interfaces = node2.interfaces) === null || _node$interfaces === undefined ? undefined : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== undefined ? _node$interfaces$map : [];
      });
    }
    function buildUnionTypes(nodes) {
      return nodes.flatMap((node2) => {
        var _node$types$map, _node$types;
        return (_node$types$map = (_node$types = node2.types) === null || _node$types === undefined ? undefined : _node$types.map(getNamedType)) !== null && _node$types$map !== undefined ? _node$types$map : [];
      });
    }
    function buildType(astNode) {
      var _typeExtensionsMap$na;
      const name = astNode.name.value;
      const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== undefined ? _typeExtensionsMap$na : [];
      switch (astNode.kind) {
        case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
          var _astNode$description;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLObjectType({
            name,
            description: (_astNode$description = astNode.description) === null || _astNode$description === undefined ? undefined : _astNode$description.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
          var _astNode$description2;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLInterfaceType({
            name,
            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === undefined ? undefined : _astNode$description2.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.ENUM_TYPE_DEFINITION: {
          var _astNode$description3;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLEnumType({
            name,
            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === undefined ? undefined : _astNode$description3.value,
            values: buildEnumValueMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.UNION_TYPE_DEFINITION: {
          var _astNode$description4;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLUnionType({
            name,
            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === undefined ? undefined : _astNode$description4.value,
            types: () => buildUnionTypes(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
          var _astNode$description5;
          return new _definition.GraphQLScalarType({
            name,
            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === undefined ? undefined : _astNode$description5.value,
            specifiedByURL: getSpecifiedByURL(astNode),
            astNode,
            extensionASTNodes
          });
        }
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var _astNode$description6;
          const allNodes = [astNode, ...extensionASTNodes];
          return new _definition.GraphQLInputObjectType({
            name,
            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === undefined ? undefined : _astNode$description6.value,
            fields: () => buildInputFieldMap(allNodes),
            astNode,
            extensionASTNodes,
            isOneOf: isOneOf(astNode)
          });
        }
      }
    }
  }
  var stdTypeMap = (0, _keyMap.keyMap)([..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes], (type2) => type2.name);
  function getDeprecationReason(node2) {
    const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node2);
    return deprecated === null || deprecated === undefined ? undefined : deprecated.reason;
  }
  function getSpecifiedByURL(node2) {
    const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node2);
    return specifiedBy === null || specifiedBy === undefined ? undefined : specifiedBy.url;
  }
  function isOneOf(node2) {
    return Boolean((0, _values.getDirectiveValues)(_directives.GraphQLOneOfDirective, node2));
  }
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildASTSchema = buildASTSchema;
  exports.buildSchema = buildSchema;
  var _devAssert = require_devAssert();
  var _kinds = require_kinds();
  var _parser = require_parser();
  var _directives = require_directives();
  var _schema = require_schema();
  var _validate = require_validate2();
  var _extendSchema = require_extendSchema();
  function buildASTSchema(documentAST, options) {
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
    if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
      (0, _validate.assertValidSDL)(documentAST);
    }
    const emptySchemaConfig = {
      description: undefined,
      types: [],
      directives: [],
      extensions: Object.create(null),
      extensionASTNodes: [],
      assumeValid: false
    };
    const config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
    if (config.astNode == null) {
      for (const type2 of config.types) {
        switch (type2.name) {
          case "Query":
            config.query = type2;
            break;
          case "Mutation":
            config.mutation = type2;
            break;
          case "Subscription":
            config.subscription = type2;
            break;
        }
      }
    }
    const directives = [
      ...config.directives,
      ..._directives.specifiedDirectives.filter((stdDirective) => config.directives.every((directive) => directive.name !== stdDirective.name))
    ];
    return new _schema.GraphQLSchema({ ...config, directives });
  }
  function buildSchema(source, options) {
    const document2 = (0, _parser.parse)(source, {
      noLocation: options === null || options === undefined ? undefined : options.noLocation,
      allowLegacyFragmentVariables: options === null || options === undefined ? undefined : options.allowLegacyFragmentVariables
    });
    return buildASTSchema(document2, {
      assumeValidSDL: options === null || options === undefined ? undefined : options.assumeValidSDL,
      assumeValid: options === null || options === undefined ? undefined : options.assumeValid
    });
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.lexicographicSortSchema = lexicographicSortSchema;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyValMap = require_keyValMap();
  var _naturalCompare = require_naturalCompare();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _schema = require_schema();
  function lexicographicSortSchema(schema) {
    const schemaConfig = schema.toConfig();
    const typeMap = (0, _keyValMap.keyValMap)(sortByName(schemaConfig.types), (type2) => type2.name, sortNamedType);
    return new _schema.GraphQLSchema({
      ...schemaConfig,
      types: Object.values(typeMap),
      directives: sortByName(schemaConfig.directives).map(sortDirective),
      query: replaceMaybeType(schemaConfig.query),
      mutation: replaceMaybeType(schemaConfig.mutation),
      subscription: replaceMaybeType(schemaConfig.subscription)
    });
    function replaceType(type2) {
      if ((0, _definition.isListType)(type2)) {
        return new _definition.GraphQLList(replaceType(type2.ofType));
      } else if ((0, _definition.isNonNullType)(type2)) {
        return new _definition.GraphQLNonNull(replaceType(type2.ofType));
      }
      return replaceNamedType(type2);
    }
    function replaceNamedType(type2) {
      return typeMap[type2.name];
    }
    function replaceMaybeType(maybeType) {
      return maybeType && replaceNamedType(maybeType);
    }
    function sortDirective(directive) {
      const config = directive.toConfig();
      return new _directives.GraphQLDirective({
        ...config,
        locations: sortBy(config.locations, (x) => x),
        args: sortArgs(config.args)
      });
    }
    function sortArgs(args) {
      return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
    }
    function sortFields(fieldsMap) {
      return sortObjMap(fieldsMap, (field) => ({
        ...field,
        type: replaceType(field.type),
        args: field.args && sortArgs(field.args)
      }));
    }
    function sortInputFields(fieldsMap) {
      return sortObjMap(fieldsMap, (field) => ({
        ...field,
        type: replaceType(field.type)
      }));
    }
    function sortTypes(array) {
      return sortByName(array).map(replaceNamedType);
    }
    function sortNamedType(type2) {
      if ((0, _definition.isScalarType)(type2) || (0, _introspection.isIntrospectionType)(type2)) {
        return type2;
      }
      if ((0, _definition.isObjectType)(type2)) {
        const config = type2.toConfig();
        return new _definition.GraphQLObjectType({
          ...config,
          interfaces: () => sortTypes(config.interfaces),
          fields: () => sortFields(config.fields)
        });
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        const config = type2.toConfig();
        return new _definition.GraphQLInterfaceType({
          ...config,
          interfaces: () => sortTypes(config.interfaces),
          fields: () => sortFields(config.fields)
        });
      }
      if ((0, _definition.isUnionType)(type2)) {
        const config = type2.toConfig();
        return new _definition.GraphQLUnionType({
          ...config,
          types: () => sortTypes(config.types)
        });
      }
      if ((0, _definition.isEnumType)(type2)) {
        const config = type2.toConfig();
        return new _definition.GraphQLEnumType({
          ...config,
          values: sortObjMap(config.values, (value) => value)
        });
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        const config = type2.toConfig();
        return new _definition.GraphQLInputObjectType({
          ...config,
          fields: () => sortInputFields(config.fields)
        });
      }
      (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type2));
    }
  }
  function sortObjMap(map, sortValueFn) {
    const sortedMap = Object.create(null);
    for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
      sortedMap[key] = sortValueFn(map[key]);
    }
    return sortedMap;
  }
  function sortByName(array) {
    return sortBy(array, (obj) => obj.name);
  }
  function sortBy(array, mapToKey) {
    return array.slice().sort((obj1, obj2) => {
      const key1 = mapToKey(obj1);
      const key2 = mapToKey(obj2);
      return (0, _naturalCompare.naturalCompare)(key1, key2);
    });
  }
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.printIntrospectionSchema = printIntrospectionSchema;
  exports.printSchema = printSchema;
  exports.printType = printType;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _blockString = require_blockString();
  var _kinds = require_kinds();
  var _printer = require_printer();
  var _definition = require_definition();
  var _directives = require_directives();
  var _introspection = require_introspection();
  var _scalars = require_scalars();
  var _astFromValue = require_astFromValue();
  function printSchema(schema) {
    return printFilteredSchema(schema, (n) => !(0, _directives.isSpecifiedDirective)(n), isDefinedType);
  }
  function printIntrospectionSchema(schema) {
    return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType);
  }
  function isDefinedType(type2) {
    return !(0, _scalars.isSpecifiedScalarType)(type2) && !(0, _introspection.isIntrospectionType)(type2);
  }
  function printFilteredSchema(schema, directiveFilter, typeFilter) {
    const directives = schema.getDirectives().filter(directiveFilter);
    const types = Object.values(schema.getTypeMap()).filter(typeFilter);
    return [
      printSchemaDefinition(schema),
      ...directives.map((directive) => printDirective(directive)),
      ...types.map((type2) => printType(type2))
    ].filter(Boolean).join(`

`);
  }
  function printSchemaDefinition(schema) {
    if (schema.description == null && isSchemaOfCommonNames(schema)) {
      return;
    }
    const operationTypes = [];
    const queryType = schema.getQueryType();
    if (queryType) {
      operationTypes.push(`  query: ${queryType.name}`);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
      operationTypes.push(`  mutation: ${mutationType.name}`);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
      operationTypes.push(`  subscription: ${subscriptionType.name}`);
    }
    return printDescription(schema) + `schema {
${operationTypes.join(`
`)}
}`;
  }
  function isSchemaOfCommonNames(schema) {
    const queryType = schema.getQueryType();
    if (queryType && queryType.name !== "Query") {
      return false;
    }
    const mutationType = schema.getMutationType();
    if (mutationType && mutationType.name !== "Mutation") {
      return false;
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && subscriptionType.name !== "Subscription") {
      return false;
    }
    return true;
  }
  function printType(type2) {
    if ((0, _definition.isScalarType)(type2)) {
      return printScalar(type2);
    }
    if ((0, _definition.isObjectType)(type2)) {
      return printObject(type2);
    }
    if ((0, _definition.isInterfaceType)(type2)) {
      return printInterface(type2);
    }
    if ((0, _definition.isUnionType)(type2)) {
      return printUnion(type2);
    }
    if ((0, _definition.isEnumType)(type2)) {
      return printEnum(type2);
    }
    if ((0, _definition.isInputObjectType)(type2)) {
      return printInputObject(type2);
    }
    (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type2));
  }
  function printScalar(type2) {
    return printDescription(type2) + `scalar ${type2.name}` + printSpecifiedByURL(type2);
  }
  function printImplementedInterfaces(type2) {
    const interfaces = type2.getInterfaces();
    return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
  }
  function printObject(type2) {
    return printDescription(type2) + `type ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
  }
  function printInterface(type2) {
    return printDescription(type2) + `interface ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
  }
  function printUnion(type2) {
    const types = type2.getTypes();
    const possibleTypes = types.length ? " = " + types.join(" | ") : "";
    return printDescription(type2) + "union " + type2.name + possibleTypes;
  }
  function printEnum(type2) {
    const values = type2.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
    return printDescription(type2) + `enum ${type2.name}` + printBlock(values);
  }
  function printInputObject(type2) {
    const fields = Object.values(type2.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
    return printDescription(type2) + `input ${type2.name}` + (type2.isOneOf ? " @oneOf" : "") + printBlock(fields);
  }
  function printFields(type2) {
    const fields = Object.values(type2.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
    return printBlock(fields);
  }
  function printBlock(items) {
    return items.length !== 0 ? ` {
` + items.join(`
`) + `
}` : "";
  }
  function printArgs(args, indentation = "") {
    if (args.length === 0) {
      return "";
    }
    if (args.every((arg) => !arg.description)) {
      return "(" + args.map(printInputValue).join(", ") + ")";
    }
    return `(
` + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join(`
`) + `
` + indentation + ")";
  }
  function printInputValue(arg) {
    const defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
    let argDecl = arg.name + ": " + String(arg.type);
    if (defaultAST) {
      argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
    }
    return argDecl + printDeprecated(arg.deprecationReason);
  }
  function printDirective(directive) {
    return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
  }
  function printDeprecated(reason) {
    if (reason == null) {
      return "";
    }
    if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
      const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: reason
      });
      return ` @deprecated(reason: ${astValue})`;
    }
    return " @deprecated";
  }
  function printSpecifiedByURL(scalar) {
    if (scalar.specifiedByURL == null) {
      return "";
    }
    const astValue = (0, _printer.print)({
      kind: _kinds.Kind.STRING,
      value: scalar.specifiedByURL
    });
    return ` @specifiedBy(url: ${astValue})`;
  }
  function printDescription(def, indentation = "", firstInBlock = true) {
    const { description } = def;
    if (description == null) {
      return "";
    }
    const blockString = (0, _printer.print)({
      kind: _kinds.Kind.STRING,
      value: description,
      block: (0, _blockString.isPrintableAsBlockString)(description)
    });
    const prefix = indentation && !firstInBlock ? `
` + indentation : indentation;
    return prefix + blockString.replace(/\n/g, `
` + indentation) + `
`;
  }
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.concatAST = concatAST;
  var _kinds = require_kinds();
  function concatAST(documents) {
    const definitions = [];
    for (const doc of documents) {
      definitions.push(...doc.definitions);
    }
    return {
      kind: _kinds.Kind.DOCUMENT,
      definitions
    };
  }
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.separateOperations = separateOperations;
  var _kinds = require_kinds();
  var _visitor = require_visitor();
  function separateOperations(documentAST) {
    const operations = [];
    const depGraph = Object.create(null);
    for (const definitionNode of documentAST.definitions) {
      switch (definitionNode.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          operations.push(definitionNode);
          break;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
          break;
        default:
      }
    }
    const separatedDocumentASTs = Object.create(null);
    for (const operation of operations) {
      const dependencies = new Set;
      for (const fragmentName of collectDependencies(operation.selectionSet)) {
        collectTransitiveDependencies(dependencies, depGraph, fragmentName);
      }
      const operationName = operation.name ? operation.name.value : "";
      separatedDocumentASTs[operationName] = {
        kind: _kinds.Kind.DOCUMENT,
        definitions: documentAST.definitions.filter((node2) => node2 === operation || node2.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node2.name.value))
      };
    }
    return separatedDocumentASTs;
  }
  function collectTransitiveDependencies(collected, depGraph, fromName) {
    if (!collected.has(fromName)) {
      collected.add(fromName);
      const immediateDeps = depGraph[fromName];
      if (immediateDeps !== undefined) {
        for (const toName of immediateDeps) {
          collectTransitiveDependencies(collected, depGraph, toName);
        }
      }
    }
  }
  function collectDependencies(selectionSet) {
    const dependencies = [];
    (0, _visitor.visit)(selectionSet, {
      FragmentSpread(node2) {
        dependencies.push(node2.name.value);
      }
    });
    return dependencies;
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.stripIgnoredCharacters = stripIgnoredCharacters;
  var _blockString = require_blockString();
  var _lexer = require_lexer();
  var _source = require_source();
  var _tokenKind = require_tokenKind();
  function stripIgnoredCharacters(source) {
    const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
    const body = sourceObj.body;
    const lexer = new _lexer.Lexer(sourceObj);
    let strippedBody = "";
    let wasLastAddedTokenNonPunctuator = false;
    while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
      const currentToken = lexer.token;
      const tokenKind = currentToken.kind;
      const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
      if (wasLastAddedTokenNonPunctuator) {
        if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
          strippedBody += " ";
        }
      }
      const tokenBody = body.slice(currentToken.start, currentToken.end);
      if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
        strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
          minimize: true
        });
      } else {
        strippedBody += tokenBody;
      }
      wasLastAddedTokenNonPunctuator = isNonPunctuator;
    }
    return strippedBody;
  }
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertValidName = assertValidName;
  exports.isValidNameError = isValidNameError;
  var _devAssert = require_devAssert();
  var _GraphQLError = require_GraphQLError();
  var _assertName = require_assertName();
  function assertValidName(name) {
    const error = isValidNameError(name);
    if (error) {
      throw error;
    }
    return name;
  }
  function isValidNameError(name) {
    typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
    if (name.startsWith("__")) {
      return new _GraphQLError.GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
    }
    try {
      (0, _assertName.assertName)(name);
    } catch (error) {
      return error;
    }
  }
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DangerousChangeType = exports.BreakingChangeType = undefined;
  exports.findBreakingChanges = findBreakingChanges;
  exports.findDangerousChanges = findDangerousChanges;
  var _inspect = require_inspect();
  var _invariant = require_invariant();
  var _keyMap = require_keyMap();
  var _printer = require_printer();
  var _definition = require_definition();
  var _scalars = require_scalars();
  var _astFromValue = require_astFromValue();
  var _sortValueNode = require_sortValueNode();
  var BreakingChangeType;
  exports.BreakingChangeType = BreakingChangeType;
  (function(BreakingChangeType2) {
    BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
    BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
    BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
    BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
    BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
    BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
    BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
    BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
    BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
    BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
    BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
    BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
    BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
    BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
    BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
    BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
  })(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));
  var DangerousChangeType;
  exports.DangerousChangeType = DangerousChangeType;
  (function(DangerousChangeType2) {
    DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
    DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
    DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
    DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
    DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
    DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
  })(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));
  function findBreakingChanges(oldSchema, newSchema) {
    return findSchemaChanges(oldSchema, newSchema).filter((change) => (change.type in BreakingChangeType));
  }
  function findDangerousChanges(oldSchema, newSchema) {
    return findSchemaChanges(oldSchema, newSchema).filter((change) => (change.type in DangerousChangeType));
  }
  function findSchemaChanges(oldSchema, newSchema) {
    return [
      ...findTypeChanges(oldSchema, newSchema),
      ...findDirectiveChanges(oldSchema, newSchema)
    ];
  }
  function findDirectiveChanges(oldSchema, newSchema) {
    const schemaChanges = [];
    const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
    for (const oldDirective of directivesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REMOVED,
        description: `${oldDirective.name} was removed.`
      });
    }
    for (const [oldDirective, newDirective] of directivesDiff.persisted) {
      const argsDiff = diff(oldDirective.args, newDirective.args);
      for (const newArg of argsDiff.added) {
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
            description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
          });
        }
      }
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
          description: `${oldArg.name} was removed from ${oldDirective.name}.`
        });
      }
      if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
          description: `Repeatable flag was removed from ${oldDirective.name}.`
        });
      }
      for (const location of oldDirective.locations) {
        if (!newDirective.locations.includes(location)) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
            description: `${location} was removed from ${oldDirective.name}.`
          });
        }
      }
    }
    return schemaChanges;
  }
  function findTypeChanges(oldSchema, newSchema) {
    const schemaChanges = [];
    const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
    for (const oldType of typesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED,
        description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
      });
    }
    for (const [oldType, newType] of typesDiff.persisted) {
      if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
        schemaChanges.push(...findEnumTypeChanges(oldType, newType));
      } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
        schemaChanges.push(...findUnionTypeChanges(oldType, newType));
      } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
        schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
      } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
        schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
      } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
        schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
      } else if (oldType.constructor !== newType.constructor) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_CHANGED_KIND,
          description: `${oldType.name} changed from ` + `${typeKindName(oldType)} to ${typeKindName(newType)}.`
        });
      }
    }
    return schemaChanges;
  }
  function findInputObjectTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
    for (const newField of fieldsDiff.added) {
      if ((0, _definition.isRequiredInputField)(newField)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
          description: `A required field ${newField.name} on input type ${oldType.name} was added.`
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
          description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
        });
      }
    }
    for (const oldField of fieldsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: `${oldType.name}.${oldField.name} was removed.`
      });
    }
    for (const [oldField, newField] of fieldsDiff.persisted) {
      const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
        });
      }
    }
    return schemaChanges;
  }
  function findUnionTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
    for (const newPossibleType of possibleTypesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.TYPE_ADDED_TO_UNION,
        description: `${newPossibleType.name} was added to union type ${oldType.name}.`
      });
    }
    for (const oldPossibleType of possibleTypesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
        description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
      });
    }
    return schemaChanges;
  }
  function findEnumTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const valuesDiff = diff(oldType.getValues(), newType.getValues());
    for (const newValue of valuesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
        description: `${newValue.name} was added to enum type ${oldType.name}.`
      });
    }
    for (const oldValue of valuesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
        description: `${oldValue.name} was removed from enum type ${oldType.name}.`
      });
    }
    return schemaChanges;
  }
  function findImplementedInterfacesChanges(oldType, newType) {
    const schemaChanges = [];
    const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
    for (const newInterface of interfacesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
        description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
      });
    }
    for (const oldInterface of interfacesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
        description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
      });
    }
    return schemaChanges;
  }
  function findFieldChanges(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
    for (const oldField of fieldsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: `${oldType.name}.${oldField.name} was removed.`
      });
    }
    for (const [oldField, newField] of fieldsDiff.persisted) {
      schemaChanges.push(...findArgChanges(oldType, oldField, newField));
      const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
        });
      }
    }
    return schemaChanges;
  }
  function findArgChanges(oldType, oldField, newField) {
    const schemaChanges = [];
    const argsDiff = diff(oldField.args, newField.args);
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_REMOVED,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
      });
    }
    for (const [oldArg, newArg] of argsDiff.persisted) {
      const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` + `${String(oldArg.type)} to ${String(newArg.type)}.`
        });
      } else if (oldArg.defaultValue !== undefined) {
        if (newArg.defaultValue === undefined) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
          });
        } else {
          const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
          const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
          if (oldValueStr !== newValueStr) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
            });
          }
        }
      }
    }
    for (const newArg of argsDiff.added) {
      if ((0, _definition.isRequiredArgument)(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_ARG_ADDED,
          description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_ARG_ADDED,
          description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
        });
      }
    }
    return schemaChanges;
  }
  function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
      return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
    }
    if ((0, _definition.isNonNullType)(oldType)) {
      return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
    }
    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
  }
  function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
      return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
    }
    if ((0, _definition.isNonNullType)(oldType)) {
      return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
    }
    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
  }
  function typeKindName(type2) {
    if ((0, _definition.isScalarType)(type2)) {
      return "a Scalar type";
    }
    if ((0, _definition.isObjectType)(type2)) {
      return "an Object type";
    }
    if ((0, _definition.isInterfaceType)(type2)) {
      return "an Interface type";
    }
    if ((0, _definition.isUnionType)(type2)) {
      return "a Union type";
    }
    if ((0, _definition.isEnumType)(type2)) {
      return "an Enum type";
    }
    if ((0, _definition.isInputObjectType)(type2)) {
      return "an Input type";
    }
    (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type2));
  }
  function stringifyValue(value, type2) {
    const ast = (0, _astFromValue.astFromValue)(value, type2);
    ast != null || (0, _invariant.invariant)(false);
    return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
  }
  function diff(oldArray, newArray) {
    const added = [];
    const removed = [];
    const persisted = [];
    const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
    const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
    for (const oldItem of oldArray) {
      const newItem = newMap[oldItem.name];
      if (newItem === undefined) {
        removed.push(oldItem);
      } else {
        persisted.push([oldItem, newItem]);
      }
    }
    for (const newItem of newArray) {
      if (oldMap[newItem.name] === undefined) {
        added.push(newItem);
      }
    }
    return {
      added,
      persisted,
      removed
    };
  }
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BreakingChangeType", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.BreakingChangeType;
    }
  });
  Object.defineProperty(exports, "DangerousChangeType", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.DangerousChangeType;
    }
  });
  Object.defineProperty(exports, "TypeInfo", {
    enumerable: true,
    get: function() {
      return _TypeInfo.TypeInfo;
    }
  });
  Object.defineProperty(exports, "assertValidName", {
    enumerable: true,
    get: function() {
      return _assertValidName.assertValidName;
    }
  });
  Object.defineProperty(exports, "astFromValue", {
    enumerable: true,
    get: function() {
      return _astFromValue.astFromValue;
    }
  });
  Object.defineProperty(exports, "buildASTSchema", {
    enumerable: true,
    get: function() {
      return _buildASTSchema.buildASTSchema;
    }
  });
  Object.defineProperty(exports, "buildClientSchema", {
    enumerable: true,
    get: function() {
      return _buildClientSchema.buildClientSchema;
    }
  });
  Object.defineProperty(exports, "buildSchema", {
    enumerable: true,
    get: function() {
      return _buildASTSchema.buildSchema;
    }
  });
  Object.defineProperty(exports, "coerceInputValue", {
    enumerable: true,
    get: function() {
      return _coerceInputValue.coerceInputValue;
    }
  });
  Object.defineProperty(exports, "concatAST", {
    enumerable: true,
    get: function() {
      return _concatAST.concatAST;
    }
  });
  Object.defineProperty(exports, "doTypesOverlap", {
    enumerable: true,
    get: function() {
      return _typeComparators.doTypesOverlap;
    }
  });
  Object.defineProperty(exports, "extendSchema", {
    enumerable: true,
    get: function() {
      return _extendSchema.extendSchema;
    }
  });
  Object.defineProperty(exports, "findBreakingChanges", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.findBreakingChanges;
    }
  });
  Object.defineProperty(exports, "findDangerousChanges", {
    enumerable: true,
    get: function() {
      return _findBreakingChanges.findDangerousChanges;
    }
  });
  Object.defineProperty(exports, "getIntrospectionQuery", {
    enumerable: true,
    get: function() {
      return _getIntrospectionQuery.getIntrospectionQuery;
    }
  });
  Object.defineProperty(exports, "getOperationAST", {
    enumerable: true,
    get: function() {
      return _getOperationAST.getOperationAST;
    }
  });
  Object.defineProperty(exports, "getOperationRootType", {
    enumerable: true,
    get: function() {
      return _getOperationRootType.getOperationRootType;
    }
  });
  Object.defineProperty(exports, "introspectionFromSchema", {
    enumerable: true,
    get: function() {
      return _introspectionFromSchema.introspectionFromSchema;
    }
  });
  Object.defineProperty(exports, "isEqualType", {
    enumerable: true,
    get: function() {
      return _typeComparators.isEqualType;
    }
  });
  Object.defineProperty(exports, "isTypeSubTypeOf", {
    enumerable: true,
    get: function() {
      return _typeComparators.isTypeSubTypeOf;
    }
  });
  Object.defineProperty(exports, "isValidNameError", {
    enumerable: true,
    get: function() {
      return _assertValidName.isValidNameError;
    }
  });
  Object.defineProperty(exports, "lexicographicSortSchema", {
    enumerable: true,
    get: function() {
      return _lexicographicSortSchema.lexicographicSortSchema;
    }
  });
  Object.defineProperty(exports, "printIntrospectionSchema", {
    enumerable: true,
    get: function() {
      return _printSchema.printIntrospectionSchema;
    }
  });
  Object.defineProperty(exports, "printSchema", {
    enumerable: true,
    get: function() {
      return _printSchema.printSchema;
    }
  });
  Object.defineProperty(exports, "printType", {
    enumerable: true,
    get: function() {
      return _printSchema.printType;
    }
  });
  Object.defineProperty(exports, "separateOperations", {
    enumerable: true,
    get: function() {
      return _separateOperations.separateOperations;
    }
  });
  Object.defineProperty(exports, "stripIgnoredCharacters", {
    enumerable: true,
    get: function() {
      return _stripIgnoredCharacters.stripIgnoredCharacters;
    }
  });
  Object.defineProperty(exports, "typeFromAST", {
    enumerable: true,
    get: function() {
      return _typeFromAST.typeFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromAST", {
    enumerable: true,
    get: function() {
      return _valueFromAST.valueFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromASTUntyped", {
    enumerable: true,
    get: function() {
      return _valueFromASTUntyped.valueFromASTUntyped;
    }
  });
  Object.defineProperty(exports, "visitWithTypeInfo", {
    enumerable: true,
    get: function() {
      return _TypeInfo.visitWithTypeInfo;
    }
  });
  var _getIntrospectionQuery = require_getIntrospectionQuery();
  var _getOperationAST = require_getOperationAST();
  var _getOperationRootType = require_getOperationRootType();
  var _introspectionFromSchema = require_introspectionFromSchema();
  var _buildClientSchema = require_buildClientSchema();
  var _buildASTSchema = require_buildASTSchema();
  var _extendSchema = require_extendSchema();
  var _lexicographicSortSchema = require_lexicographicSortSchema();
  var _printSchema = require_printSchema();
  var _typeFromAST = require_typeFromAST();
  var _valueFromAST = require_valueFromAST();
  var _valueFromASTUntyped = require_valueFromASTUntyped();
  var _astFromValue = require_astFromValue();
  var _TypeInfo = require_TypeInfo();
  var _coerceInputValue = require_coerceInputValue();
  var _concatAST = require_concatAST();
  var _separateOperations = require_separateOperations();
  var _stripIgnoredCharacters = require_stripIgnoredCharacters();
  var _typeComparators = require_typeComparators();
  var _assertValidName = require_assertValidName();
  var _findBreakingChanges = require_findBreakingChanges();
});

// node_modules/graphql/index.js
var require_graphql2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BREAK", {
    enumerable: true,
    get: function() {
      return _index2.BREAK;
    }
  });
  Object.defineProperty(exports, "BreakingChangeType", {
    enumerable: true,
    get: function() {
      return _index6.BreakingChangeType;
    }
  });
  Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
    enumerable: true,
    get: function() {
      return _index.DEFAULT_DEPRECATION_REASON;
    }
  });
  Object.defineProperty(exports, "DangerousChangeType", {
    enumerable: true,
    get: function() {
      return _index6.DangerousChangeType;
    }
  });
  Object.defineProperty(exports, "DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _index2.DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "ExecutableDefinitionsRule", {
    enumerable: true,
    get: function() {
      return _index4.ExecutableDefinitionsRule;
    }
  });
  Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _index4.FieldsOnCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
    enumerable: true,
    get: function() {
      return _index4.FragmentsOnCompositeTypesRule;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
    enumerable: true,
    get: function() {
      return _index.GRAPHQL_MAX_INT;
    }
  });
  Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
    enumerable: true,
    get: function() {
      return _index.GRAPHQL_MIN_INT;
    }
  });
  Object.defineProperty(exports, "GraphQLBoolean", {
    enumerable: true,
    get: function() {
      return _index.GraphQLBoolean;
    }
  });
  Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLDeprecatedDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLEnumType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLEnumType;
    }
  });
  Object.defineProperty(exports, "GraphQLError", {
    enumerable: true,
    get: function() {
      return _index5.GraphQLError;
    }
  });
  Object.defineProperty(exports, "GraphQLFloat", {
    enumerable: true,
    get: function() {
      return _index.GraphQLFloat;
    }
  });
  Object.defineProperty(exports, "GraphQLID", {
    enumerable: true,
    get: function() {
      return _index.GraphQLID;
    }
  });
  Object.defineProperty(exports, "GraphQLIncludeDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLIncludeDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLInputObjectType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLInputObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLInt", {
    enumerable: true,
    get: function() {
      return _index.GraphQLInt;
    }
  });
  Object.defineProperty(exports, "GraphQLInterfaceType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLInterfaceType;
    }
  });
  Object.defineProperty(exports, "GraphQLList", {
    enumerable: true,
    get: function() {
      return _index.GraphQLList;
    }
  });
  Object.defineProperty(exports, "GraphQLNonNull", {
    enumerable: true,
    get: function() {
      return _index.GraphQLNonNull;
    }
  });
  Object.defineProperty(exports, "GraphQLObjectType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLObjectType;
    }
  });
  Object.defineProperty(exports, "GraphQLOneOfDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLOneOfDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLScalarType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLScalarType;
    }
  });
  Object.defineProperty(exports, "GraphQLSchema", {
    enumerable: true,
    get: function() {
      return _index.GraphQLSchema;
    }
  });
  Object.defineProperty(exports, "GraphQLSkipDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLSkipDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
    enumerable: true,
    get: function() {
      return _index.GraphQLSpecifiedByDirective;
    }
  });
  Object.defineProperty(exports, "GraphQLString", {
    enumerable: true,
    get: function() {
      return _index.GraphQLString;
    }
  });
  Object.defineProperty(exports, "GraphQLUnionType", {
    enumerable: true,
    get: function() {
      return _index.GraphQLUnionType;
    }
  });
  Object.defineProperty(exports, "Kind", {
    enumerable: true,
    get: function() {
      return _index2.Kind;
    }
  });
  Object.defineProperty(exports, "KnownArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownDirectivesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownDirectivesRule;
    }
  });
  Object.defineProperty(exports, "KnownFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "KnownTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.KnownTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "Lexer", {
    enumerable: true,
    get: function() {
      return _index2.Lexer;
    }
  });
  Object.defineProperty(exports, "Location", {
    enumerable: true,
    get: function() {
      return _index2.Location;
    }
  });
  Object.defineProperty(exports, "LoneAnonymousOperationRule", {
    enumerable: true,
    get: function() {
      return _index4.LoneAnonymousOperationRule;
    }
  });
  Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
    enumerable: true,
    get: function() {
      return _index4.LoneSchemaDefinitionRule;
    }
  });
  Object.defineProperty(exports, "MaxIntrospectionDepthRule", {
    enumerable: true,
    get: function() {
      return _index4.MaxIntrospectionDepthRule;
    }
  });
  Object.defineProperty(exports, "NoDeprecatedCustomRule", {
    enumerable: true,
    get: function() {
      return _index4.NoDeprecatedCustomRule;
    }
  });
  Object.defineProperty(exports, "NoFragmentCyclesRule", {
    enumerable: true,
    get: function() {
      return _index4.NoFragmentCyclesRule;
    }
  });
  Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
    enumerable: true,
    get: function() {
      return _index4.NoSchemaIntrospectionCustomRule;
    }
  });
  Object.defineProperty(exports, "NoUndefinedVariablesRule", {
    enumerable: true,
    get: function() {
      return _index4.NoUndefinedVariablesRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedFragmentsRule", {
    enumerable: true,
    get: function() {
      return _index4.NoUnusedFragmentsRule;
    }
  });
  Object.defineProperty(exports, "NoUnusedVariablesRule", {
    enumerable: true,
    get: function() {
      return _index4.NoUnusedVariablesRule;
    }
  });
  Object.defineProperty(exports, "OperationTypeNode", {
    enumerable: true,
    get: function() {
      return _index2.OperationTypeNode;
    }
  });
  Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
    enumerable: true,
    get: function() {
      return _index4.OverlappingFieldsCanBeMergedRule;
    }
  });
  Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
    enumerable: true,
    get: function() {
      return _index4.PossibleFragmentSpreadsRule;
    }
  });
  Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
    enumerable: true,
    get: function() {
      return _index4.PossibleTypeExtensionsRule;
    }
  });
  Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
    enumerable: true,
    get: function() {
      return _index4.ProvidedRequiredArgumentsRule;
    }
  });
  Object.defineProperty(exports, "ScalarLeafsRule", {
    enumerable: true,
    get: function() {
      return _index4.ScalarLeafsRule;
    }
  });
  Object.defineProperty(exports, "SchemaMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _index.SchemaMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
    enumerable: true,
    get: function() {
      return _index4.SingleFieldSubscriptionsRule;
    }
  });
  Object.defineProperty(exports, "Source", {
    enumerable: true,
    get: function() {
      return _index2.Source;
    }
  });
  Object.defineProperty(exports, "Token", {
    enumerable: true,
    get: function() {
      return _index2.Token;
    }
  });
  Object.defineProperty(exports, "TokenKind", {
    enumerable: true,
    get: function() {
      return _index2.TokenKind;
    }
  });
  Object.defineProperty(exports, "TypeInfo", {
    enumerable: true,
    get: function() {
      return _index6.TypeInfo;
    }
  });
  Object.defineProperty(exports, "TypeKind", {
    enumerable: true,
    get: function() {
      return _index.TypeKind;
    }
  });
  Object.defineProperty(exports, "TypeMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _index.TypeMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "TypeNameMetaFieldDef", {
    enumerable: true,
    get: function() {
      return _index.TypeNameMetaFieldDef;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueArgumentDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueArgumentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueArgumentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueDirectiveNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueDirectivesPerLocationRule;
    }
  });
  Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueEnumValueNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueFieldDefinitionNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueFragmentNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueFragmentNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueInputFieldNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueOperationNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueOperationTypesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueOperationTypesRule;
    }
  });
  Object.defineProperty(exports, "UniqueTypeNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueTypeNamesRule;
    }
  });
  Object.defineProperty(exports, "UniqueVariableNamesRule", {
    enumerable: true,
    get: function() {
      return _index4.UniqueVariableNamesRule;
    }
  });
  Object.defineProperty(exports, "ValidationContext", {
    enumerable: true,
    get: function() {
      return _index4.ValidationContext;
    }
  });
  Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
    enumerable: true,
    get: function() {
      return _index4.ValuesOfCorrectTypeRule;
    }
  });
  Object.defineProperty(exports, "VariablesAreInputTypesRule", {
    enumerable: true,
    get: function() {
      return _index4.VariablesAreInputTypesRule;
    }
  });
  Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
    enumerable: true,
    get: function() {
      return _index4.VariablesInAllowedPositionRule;
    }
  });
  Object.defineProperty(exports, "__Directive", {
    enumerable: true,
    get: function() {
      return _index.__Directive;
    }
  });
  Object.defineProperty(exports, "__DirectiveLocation", {
    enumerable: true,
    get: function() {
      return _index.__DirectiveLocation;
    }
  });
  Object.defineProperty(exports, "__EnumValue", {
    enumerable: true,
    get: function() {
      return _index.__EnumValue;
    }
  });
  Object.defineProperty(exports, "__Field", {
    enumerable: true,
    get: function() {
      return _index.__Field;
    }
  });
  Object.defineProperty(exports, "__InputValue", {
    enumerable: true,
    get: function() {
      return _index.__InputValue;
    }
  });
  Object.defineProperty(exports, "__Schema", {
    enumerable: true,
    get: function() {
      return _index.__Schema;
    }
  });
  Object.defineProperty(exports, "__Type", {
    enumerable: true,
    get: function() {
      return _index.__Type;
    }
  });
  Object.defineProperty(exports, "__TypeKind", {
    enumerable: true,
    get: function() {
      return _index.__TypeKind;
    }
  });
  Object.defineProperty(exports, "assertAbstractType", {
    enumerable: true,
    get: function() {
      return _index.assertAbstractType;
    }
  });
  Object.defineProperty(exports, "assertCompositeType", {
    enumerable: true,
    get: function() {
      return _index.assertCompositeType;
    }
  });
  Object.defineProperty(exports, "assertDirective", {
    enumerable: true,
    get: function() {
      return _index.assertDirective;
    }
  });
  Object.defineProperty(exports, "assertEnumType", {
    enumerable: true,
    get: function() {
      return _index.assertEnumType;
    }
  });
  Object.defineProperty(exports, "assertEnumValueName", {
    enumerable: true,
    get: function() {
      return _index.assertEnumValueName;
    }
  });
  Object.defineProperty(exports, "assertInputObjectType", {
    enumerable: true,
    get: function() {
      return _index.assertInputObjectType;
    }
  });
  Object.defineProperty(exports, "assertInputType", {
    enumerable: true,
    get: function() {
      return _index.assertInputType;
    }
  });
  Object.defineProperty(exports, "assertInterfaceType", {
    enumerable: true,
    get: function() {
      return _index.assertInterfaceType;
    }
  });
  Object.defineProperty(exports, "assertLeafType", {
    enumerable: true,
    get: function() {
      return _index.assertLeafType;
    }
  });
  Object.defineProperty(exports, "assertListType", {
    enumerable: true,
    get: function() {
      return _index.assertListType;
    }
  });
  Object.defineProperty(exports, "assertName", {
    enumerable: true,
    get: function() {
      return _index.assertName;
    }
  });
  Object.defineProperty(exports, "assertNamedType", {
    enumerable: true,
    get: function() {
      return _index.assertNamedType;
    }
  });
  Object.defineProperty(exports, "assertNonNullType", {
    enumerable: true,
    get: function() {
      return _index.assertNonNullType;
    }
  });
  Object.defineProperty(exports, "assertNullableType", {
    enumerable: true,
    get: function() {
      return _index.assertNullableType;
    }
  });
  Object.defineProperty(exports, "assertObjectType", {
    enumerable: true,
    get: function() {
      return _index.assertObjectType;
    }
  });
  Object.defineProperty(exports, "assertOutputType", {
    enumerable: true,
    get: function() {
      return _index.assertOutputType;
    }
  });
  Object.defineProperty(exports, "assertScalarType", {
    enumerable: true,
    get: function() {
      return _index.assertScalarType;
    }
  });
  Object.defineProperty(exports, "assertSchema", {
    enumerable: true,
    get: function() {
      return _index.assertSchema;
    }
  });
  Object.defineProperty(exports, "assertType", {
    enumerable: true,
    get: function() {
      return _index.assertType;
    }
  });
  Object.defineProperty(exports, "assertUnionType", {
    enumerable: true,
    get: function() {
      return _index.assertUnionType;
    }
  });
  Object.defineProperty(exports, "assertValidName", {
    enumerable: true,
    get: function() {
      return _index6.assertValidName;
    }
  });
  Object.defineProperty(exports, "assertValidSchema", {
    enumerable: true,
    get: function() {
      return _index.assertValidSchema;
    }
  });
  Object.defineProperty(exports, "assertWrappingType", {
    enumerable: true,
    get: function() {
      return _index.assertWrappingType;
    }
  });
  Object.defineProperty(exports, "astFromValue", {
    enumerable: true,
    get: function() {
      return _index6.astFromValue;
    }
  });
  Object.defineProperty(exports, "buildASTSchema", {
    enumerable: true,
    get: function() {
      return _index6.buildASTSchema;
    }
  });
  Object.defineProperty(exports, "buildClientSchema", {
    enumerable: true,
    get: function() {
      return _index6.buildClientSchema;
    }
  });
  Object.defineProperty(exports, "buildSchema", {
    enumerable: true,
    get: function() {
      return _index6.buildSchema;
    }
  });
  Object.defineProperty(exports, "coerceInputValue", {
    enumerable: true,
    get: function() {
      return _index6.coerceInputValue;
    }
  });
  Object.defineProperty(exports, "concatAST", {
    enumerable: true,
    get: function() {
      return _index6.concatAST;
    }
  });
  Object.defineProperty(exports, "createSourceEventStream", {
    enumerable: true,
    get: function() {
      return _index3.createSourceEventStream;
    }
  });
  Object.defineProperty(exports, "defaultFieldResolver", {
    enumerable: true,
    get: function() {
      return _index3.defaultFieldResolver;
    }
  });
  Object.defineProperty(exports, "defaultTypeResolver", {
    enumerable: true,
    get: function() {
      return _index3.defaultTypeResolver;
    }
  });
  Object.defineProperty(exports, "doTypesOverlap", {
    enumerable: true,
    get: function() {
      return _index6.doTypesOverlap;
    }
  });
  Object.defineProperty(exports, "execute", {
    enumerable: true,
    get: function() {
      return _index3.execute;
    }
  });
  Object.defineProperty(exports, "executeSync", {
    enumerable: true,
    get: function() {
      return _index3.executeSync;
    }
  });
  Object.defineProperty(exports, "extendSchema", {
    enumerable: true,
    get: function() {
      return _index6.extendSchema;
    }
  });
  Object.defineProperty(exports, "findBreakingChanges", {
    enumerable: true,
    get: function() {
      return _index6.findBreakingChanges;
    }
  });
  Object.defineProperty(exports, "findDangerousChanges", {
    enumerable: true,
    get: function() {
      return _index6.findDangerousChanges;
    }
  });
  Object.defineProperty(exports, "formatError", {
    enumerable: true,
    get: function() {
      return _index5.formatError;
    }
  });
  Object.defineProperty(exports, "getArgumentValues", {
    enumerable: true,
    get: function() {
      return _index3.getArgumentValues;
    }
  });
  Object.defineProperty(exports, "getDirectiveValues", {
    enumerable: true,
    get: function() {
      return _index3.getDirectiveValues;
    }
  });
  Object.defineProperty(exports, "getEnterLeaveForKind", {
    enumerable: true,
    get: function() {
      return _index2.getEnterLeaveForKind;
    }
  });
  Object.defineProperty(exports, "getIntrospectionQuery", {
    enumerable: true,
    get: function() {
      return _index6.getIntrospectionQuery;
    }
  });
  Object.defineProperty(exports, "getLocation", {
    enumerable: true,
    get: function() {
      return _index2.getLocation;
    }
  });
  Object.defineProperty(exports, "getNamedType", {
    enumerable: true,
    get: function() {
      return _index.getNamedType;
    }
  });
  Object.defineProperty(exports, "getNullableType", {
    enumerable: true,
    get: function() {
      return _index.getNullableType;
    }
  });
  Object.defineProperty(exports, "getOperationAST", {
    enumerable: true,
    get: function() {
      return _index6.getOperationAST;
    }
  });
  Object.defineProperty(exports, "getOperationRootType", {
    enumerable: true,
    get: function() {
      return _index6.getOperationRootType;
    }
  });
  Object.defineProperty(exports, "getVariableValues", {
    enumerable: true,
    get: function() {
      return _index3.getVariableValues;
    }
  });
  Object.defineProperty(exports, "getVisitFn", {
    enumerable: true,
    get: function() {
      return _index2.getVisitFn;
    }
  });
  Object.defineProperty(exports, "graphql", {
    enumerable: true,
    get: function() {
      return _graphql.graphql;
    }
  });
  Object.defineProperty(exports, "graphqlSync", {
    enumerable: true,
    get: function() {
      return _graphql.graphqlSync;
    }
  });
  Object.defineProperty(exports, "introspectionFromSchema", {
    enumerable: true,
    get: function() {
      return _index6.introspectionFromSchema;
    }
  });
  Object.defineProperty(exports, "introspectionTypes", {
    enumerable: true,
    get: function() {
      return _index.introspectionTypes;
    }
  });
  Object.defineProperty(exports, "isAbstractType", {
    enumerable: true,
    get: function() {
      return _index.isAbstractType;
    }
  });
  Object.defineProperty(exports, "isCompositeType", {
    enumerable: true,
    get: function() {
      return _index.isCompositeType;
    }
  });
  Object.defineProperty(exports, "isConstValueNode", {
    enumerable: true,
    get: function() {
      return _index2.isConstValueNode;
    }
  });
  Object.defineProperty(exports, "isDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isDirective", {
    enumerable: true,
    get: function() {
      return _index.isDirective;
    }
  });
  Object.defineProperty(exports, "isEnumType", {
    enumerable: true,
    get: function() {
      return _index.isEnumType;
    }
  });
  Object.defineProperty(exports, "isEqualType", {
    enumerable: true,
    get: function() {
      return _index6.isEqualType;
    }
  });
  Object.defineProperty(exports, "isExecutableDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isExecutableDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isInputObjectType", {
    enumerable: true,
    get: function() {
      return _index.isInputObjectType;
    }
  });
  Object.defineProperty(exports, "isInputType", {
    enumerable: true,
    get: function() {
      return _index.isInputType;
    }
  });
  Object.defineProperty(exports, "isInterfaceType", {
    enumerable: true,
    get: function() {
      return _index.isInterfaceType;
    }
  });
  Object.defineProperty(exports, "isIntrospectionType", {
    enumerable: true,
    get: function() {
      return _index.isIntrospectionType;
    }
  });
  Object.defineProperty(exports, "isLeafType", {
    enumerable: true,
    get: function() {
      return _index.isLeafType;
    }
  });
  Object.defineProperty(exports, "isListType", {
    enumerable: true,
    get: function() {
      return _index.isListType;
    }
  });
  Object.defineProperty(exports, "isNamedType", {
    enumerable: true,
    get: function() {
      return _index.isNamedType;
    }
  });
  Object.defineProperty(exports, "isNonNullType", {
    enumerable: true,
    get: function() {
      return _index.isNonNullType;
    }
  });
  Object.defineProperty(exports, "isNullableType", {
    enumerable: true,
    get: function() {
      return _index.isNullableType;
    }
  });
  Object.defineProperty(exports, "isObjectType", {
    enumerable: true,
    get: function() {
      return _index.isObjectType;
    }
  });
  Object.defineProperty(exports, "isOutputType", {
    enumerable: true,
    get: function() {
      return _index.isOutputType;
    }
  });
  Object.defineProperty(exports, "isRequiredArgument", {
    enumerable: true,
    get: function() {
      return _index.isRequiredArgument;
    }
  });
  Object.defineProperty(exports, "isRequiredInputField", {
    enumerable: true,
    get: function() {
      return _index.isRequiredInputField;
    }
  });
  Object.defineProperty(exports, "isScalarType", {
    enumerable: true,
    get: function() {
      return _index.isScalarType;
    }
  });
  Object.defineProperty(exports, "isSchema", {
    enumerable: true,
    get: function() {
      return _index.isSchema;
    }
  });
  Object.defineProperty(exports, "isSelectionNode", {
    enumerable: true,
    get: function() {
      return _index2.isSelectionNode;
    }
  });
  Object.defineProperty(exports, "isSpecifiedDirective", {
    enumerable: true,
    get: function() {
      return _index.isSpecifiedDirective;
    }
  });
  Object.defineProperty(exports, "isSpecifiedScalarType", {
    enumerable: true,
    get: function() {
      return _index.isSpecifiedScalarType;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
      return _index.isType;
    }
  });
  Object.defineProperty(exports, "isTypeDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeExtensionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeExtensionNode;
    }
  });
  Object.defineProperty(exports, "isTypeNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeNode;
    }
  });
  Object.defineProperty(exports, "isTypeSubTypeOf", {
    enumerable: true,
    get: function() {
      return _index6.isTypeSubTypeOf;
    }
  });
  Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeSystemDefinitionNode;
    }
  });
  Object.defineProperty(exports, "isTypeSystemExtensionNode", {
    enumerable: true,
    get: function() {
      return _index2.isTypeSystemExtensionNode;
    }
  });
  Object.defineProperty(exports, "isUnionType", {
    enumerable: true,
    get: function() {
      return _index.isUnionType;
    }
  });
  Object.defineProperty(exports, "isValidNameError", {
    enumerable: true,
    get: function() {
      return _index6.isValidNameError;
    }
  });
  Object.defineProperty(exports, "isValueNode", {
    enumerable: true,
    get: function() {
      return _index2.isValueNode;
    }
  });
  Object.defineProperty(exports, "isWrappingType", {
    enumerable: true,
    get: function() {
      return _index.isWrappingType;
    }
  });
  Object.defineProperty(exports, "lexicographicSortSchema", {
    enumerable: true,
    get: function() {
      return _index6.lexicographicSortSchema;
    }
  });
  Object.defineProperty(exports, "locatedError", {
    enumerable: true,
    get: function() {
      return _index5.locatedError;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _index2.parse;
    }
  });
  Object.defineProperty(exports, "parseConstValue", {
    enumerable: true,
    get: function() {
      return _index2.parseConstValue;
    }
  });
  Object.defineProperty(exports, "parseType", {
    enumerable: true,
    get: function() {
      return _index2.parseType;
    }
  });
  Object.defineProperty(exports, "parseValue", {
    enumerable: true,
    get: function() {
      return _index2.parseValue;
    }
  });
  Object.defineProperty(exports, "print", {
    enumerable: true,
    get: function() {
      return _index2.print;
    }
  });
  Object.defineProperty(exports, "printError", {
    enumerable: true,
    get: function() {
      return _index5.printError;
    }
  });
  Object.defineProperty(exports, "printIntrospectionSchema", {
    enumerable: true,
    get: function() {
      return _index6.printIntrospectionSchema;
    }
  });
  Object.defineProperty(exports, "printLocation", {
    enumerable: true,
    get: function() {
      return _index2.printLocation;
    }
  });
  Object.defineProperty(exports, "printSchema", {
    enumerable: true,
    get: function() {
      return _index6.printSchema;
    }
  });
  Object.defineProperty(exports, "printSourceLocation", {
    enumerable: true,
    get: function() {
      return _index2.printSourceLocation;
    }
  });
  Object.defineProperty(exports, "printType", {
    enumerable: true,
    get: function() {
      return _index6.printType;
    }
  });
  Object.defineProperty(exports, "recommendedRules", {
    enumerable: true,
    get: function() {
      return _index4.recommendedRules;
    }
  });
  Object.defineProperty(exports, "resolveObjMapThunk", {
    enumerable: true,
    get: function() {
      return _index.resolveObjMapThunk;
    }
  });
  Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
    enumerable: true,
    get: function() {
      return _index.resolveReadonlyArrayThunk;
    }
  });
  Object.defineProperty(exports, "responsePathAsArray", {
    enumerable: true,
    get: function() {
      return _index3.responsePathAsArray;
    }
  });
  Object.defineProperty(exports, "separateOperations", {
    enumerable: true,
    get: function() {
      return _index6.separateOperations;
    }
  });
  Object.defineProperty(exports, "specifiedDirectives", {
    enumerable: true,
    get: function() {
      return _index.specifiedDirectives;
    }
  });
  Object.defineProperty(exports, "specifiedRules", {
    enumerable: true,
    get: function() {
      return _index4.specifiedRules;
    }
  });
  Object.defineProperty(exports, "specifiedScalarTypes", {
    enumerable: true,
    get: function() {
      return _index.specifiedScalarTypes;
    }
  });
  Object.defineProperty(exports, "stripIgnoredCharacters", {
    enumerable: true,
    get: function() {
      return _index6.stripIgnoredCharacters;
    }
  });
  Object.defineProperty(exports, "subscribe", {
    enumerable: true,
    get: function() {
      return _index3.subscribe;
    }
  });
  Object.defineProperty(exports, "syntaxError", {
    enumerable: true,
    get: function() {
      return _index5.syntaxError;
    }
  });
  Object.defineProperty(exports, "typeFromAST", {
    enumerable: true,
    get: function() {
      return _index6.typeFromAST;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _index4.validate;
    }
  });
  Object.defineProperty(exports, "validateSchema", {
    enumerable: true,
    get: function() {
      return _index.validateSchema;
    }
  });
  Object.defineProperty(exports, "valueFromAST", {
    enumerable: true,
    get: function() {
      return _index6.valueFromAST;
    }
  });
  Object.defineProperty(exports, "valueFromASTUntyped", {
    enumerable: true,
    get: function() {
      return _index6.valueFromASTUntyped;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.version;
    }
  });
  Object.defineProperty(exports, "versionInfo", {
    enumerable: true,
    get: function() {
      return _version.versionInfo;
    }
  });
  Object.defineProperty(exports, "visit", {
    enumerable: true,
    get: function() {
      return _index2.visit;
    }
  });
  Object.defineProperty(exports, "visitInParallel", {
    enumerable: true,
    get: function() {
      return _index2.visitInParallel;
    }
  });
  Object.defineProperty(exports, "visitWithTypeInfo", {
    enumerable: true,
    get: function() {
      return _index6.visitWithTypeInfo;
    }
  });
  var _version = require_version();
  var _graphql = require_graphql();
  var _index = require_type();
  var _index2 = require_language();
  var _index3 = require_execution();
  var _index4 = require_validation();
  var _index5 = require_error();
  var _index6 = require_utilities();
});

// node_modules/graphql-request/build/lib/http.js
var ACCEPT_HEADER = `Accept`, CONTENT_TYPE_HEADER = `Content-Type`, CONTENT_TYPE_JSON = `application/json`, CONTENT_TYPE_GQL = `application/graphql-response+json`;
var init_http = () => {
};

// node_modules/graphql-request/build/legacy/lib/graphql.js
var import_graphql, cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim(), isGraphQLContentType = (contentType) => {
  const contentTypeLower = contentType.toLowerCase();
  return contentTypeLower.includes(CONTENT_TYPE_GQL) || contentTypeLower.includes(CONTENT_TYPE_JSON);
}, parseGraphQLExecutionResult = (result) => {
  try {
    if (Array.isArray(result)) {
      return {
        _tag: `Batch`,
        executionResults: result.map(parseExecutionResult)
      };
    } else if (isPlainObject(result)) {
      return {
        _tag: `Single`,
        executionResult: parseExecutionResult(result)
      };
    } else {
      throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(result)}`);
    }
  } catch (e) {
    return e;
  }
}, parseExecutionResult = (result) => {
  if (typeof result !== `object` || result === null) {
    throw new Error(`Invalid execution result: result is not object`);
  }
  let errors = undefined;
  let data = undefined;
  let extensions = undefined;
  if (`errors` in result) {
    if (!isPlainObject(result.errors) && !Array.isArray(result.errors)) {
      throw new Error(`Invalid execution result: errors is not plain object OR array`);
    }
    errors = result.errors;
  }
  if (`data` in result) {
    if (!isPlainObject(result.data) && result.data !== null) {
      throw new Error(`Invalid execution result: data is not plain object`);
    }
    data = result.data;
  }
  if (`extensions` in result) {
    if (!isPlainObject(result.extensions))
      throw new Error(`Invalid execution result: extensions is not plain object`);
    extensions = result.extensions;
  }
  return {
    data,
    errors,
    extensions
  };
}, isRequestResultHaveErrors = (result) => result._tag === `Batch` ? result.executionResults.some(isExecutionResultHaveErrors) : isExecutionResultHaveErrors(result.executionResult), isExecutionResultHaveErrors = (result) => Array.isArray(result.errors) ? result.errors.length > 0 : Boolean(result.errors), isOperationDefinitionNode = (definition) => {
  return typeof definition === `object` && definition !== null && `kind` in definition && definition.kind === import_graphql.Kind.OPERATION_DEFINITION;
};
var init_graphql = __esm(() => {
  import_graphql = __toESM(require_graphql2(), 1);
  init_http();
});

// node_modules/graphql-request/build/legacy/helpers/analyzeDocument.js
var import_graphql3, import_graphql4, extractOperationName = (document2) => {
  let operationName = undefined;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    operationName = defs[0].name?.value;
  }
  return operationName;
}, extractIsMutation = (document2) => {
  let isMutation = false;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    isMutation = defs[0].operation === `mutation`;
  }
  return isMutation;
}, analyzeDocument = (document2, excludeOperationName) => {
  const expression2 = typeof document2 === `string` ? document2 : import_graphql4.print(document2);
  let isMutation = false;
  let operationName = undefined;
  if (excludeOperationName) {
    return { expression: expression2, isMutation, operationName };
  }
  const docNode = tryCatch(() => typeof document2 === `string` ? import_graphql3.parse(document2) : document2);
  if (docNode instanceof Error) {
    return { expression: expression2, isMutation, operationName };
  }
  operationName = extractOperationName(docNode);
  isMutation = extractIsMutation(docNode);
  return { expression: expression2, operationName, isMutation };
};
var init_analyzeDocument = __esm(() => {
  init_graphql();
  import_graphql3 = __toESM(require_graphql2(), 1);
  import_graphql4 = __toESM(require_graphql2(), 1);
});

// node_modules/graphql-request/build/legacy/helpers/defaultJsonSerializer.js
var defaultJsonSerializer;
var init_defaultJsonSerializer = __esm(() => {
  defaultJsonSerializer = JSON;
});

// node_modules/graphql-request/build/legacy/helpers/runRequest.js
var runRequest = async (input) => {
  const config = {
    ...input,
    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),
    fetchOptions: {
      ...input.fetchOptions,
      errorPolicy: input.fetchOptions.errorPolicy ?? `none`
    }
  };
  const fetcher = createFetcher(config.method);
  const fetchResponse = await fetcher(config);
  if (!fetchResponse.ok) {
    return new ClientError({ status: fetchResponse.status, headers: fetchResponse.headers }, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  const result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);
  if (result instanceof Error)
    throw result;
  const clientResponseBase = {
    status: fetchResponse.status,
    headers: fetchResponse.headers
  };
  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {
    const clientResponse = result._tag === `Batch` ? { ...result.executionResults, ...clientResponseBase } : {
      ...result.executionResult,
      ...clientResponseBase
    };
    return new ClientError(clientResponse, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  switch (result._tag) {
    case `Single`:
      return {
        ...clientResponseBase,
        ...executionResultClientResponseFields(config)(result.executionResult)
      };
    case `Batch`:
      return {
        ...clientResponseBase,
        data: result.executionResults.map(executionResultClientResponseFields(config))
      };
    default:
      casesExhausted(result);
  }
}, executionResultClientResponseFields = ($params) => (executionResult) => {
  return {
    extensions: executionResult.extensions,
    data: executionResult.data,
    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined
  };
}, parseResultFromResponse = async (response, jsonSerializer) => {
  const contentType = response.headers.get(CONTENT_TYPE_HEADER);
  const text = await response.text();
  if (contentType && isGraphQLContentType(contentType)) {
    return parseGraphQLExecutionResult(jsonSerializer.parse(text));
  } else {
    return parseGraphQLExecutionResult(text);
  }
}, createFetcher = (method) => async (params) => {
  const headers = new Headers(params.headers);
  let searchParams = null;
  let body = undefined;
  if (!headers.has(ACCEPT_HEADER)) {
    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));
  }
  if (method === `POST`) {
    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
    body = $jsonSerializer.stringify(buildBody(params));
    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {
      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);
    }
  } else {
    searchParams = buildQueryParams(params);
  }
  const init = { method, headers, body, ...params.fetchOptions };
  let url = new URL(params.url);
  let initResolved = init;
  if (params.middleware) {
    const result = await Promise.resolve(params.middleware({
      ...init,
      url: params.url,
      operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,
      variables: params.request.variables
    }));
    const { url: urlNew, ...initNew } = result;
    url = new URL(urlNew);
    initResolved = initNew;
  }
  if (searchParams) {
    searchParams.forEach((value, name) => {
      url.searchParams.append(name, value);
    });
  }
  const $fetch = params.fetch ?? fetch;
  return await $fetch(url, initResolved);
}, buildBody = (params) => {
  switch (params.request._tag) {
    case `Single`:
      return {
        query: params.request.document.expression,
        variables: params.request.variables,
        operationName: params.request.document.operationName
      };
    case `Batch`:
      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({
        query,
        variables
      }));
    default:
      throw casesExhausted(params.request);
  }
}, buildQueryParams = (params) => {
  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
  const searchParams = new URLSearchParams;
  switch (params.request._tag) {
    case `Single`: {
      searchParams.append(`query`, cleanQuery(params.request.document.expression));
      if (params.request.variables) {
        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));
      }
      if (params.request.document.operationName) {
        searchParams.append(`operationName`, params.request.document.operationName);
      }
      return searchParams;
    }
    case `Batch`: {
      const variablesSerialized = params.request.variables?.map((v) => $jsonSerializer.stringify(v)) ?? [];
      const queriesCleaned = params.request.query.map(cleanQuery);
      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({
        query,
        variables
      }));
      searchParams.append(`query`, $jsonSerializer.stringify(payload));
      return searchParams;
    }
    default:
      throw casesExhausted(params.request);
  }
};
var init_runRequest = __esm(() => {
  init_http();
  init_ClientError();
  init_graphql();
  init_defaultJsonSerializer();
});

// node_modules/graphql-request/build/legacy/classes/GraphQLClient.js
class GraphQLClient {
  url;
  requestConfig;
  constructor(url, requestConfig = {}) {
    this.url = url;
    this.requestConfig = requestConfig;
  }
  rawRequest = async (...args) => {
    const [queryOrOptions, variables, requestHeaders] = args;
    const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (rawRequestOptions.signal !== undefined) {
      fetchOptions.signal = rawRequestOptions.signal;
    }
    const document2 = analyzeDocument(rawRequestOptions.query, excludeOperationName);
    const response = await runRequest({
      url,
      request: {
        _tag: `Single`,
        document: document2,
        variables: rawRequestOptions.variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)
      },
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    });
    if (responseMiddleware) {
      await responseMiddleware(response, {
        operationName: document2.operationName,
        variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response;
  };
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== undefined) {
      fetchOptions.signal = requestOptions.signal;
    }
    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);
    const response = await runRequest({
      url,
      request: {
        _tag: `Single`,
        document: analyzedDocument,
        variables: requestOptions.variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(requestOptions.requestHeaders)
      },
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    });
    if (responseMiddleware) {
      await responseMiddleware(response, {
        operationName: analyzedDocument.operationName,
        variables: requestOptions.variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  async batchRequests(documentsOrOptions, requestHeaders) {
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== undefined) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const analyzedDocuments = batchRequestOptions.documents.map(({ document: document2 }) => analyzeDocument(document2, excludeOperationName));
    const expressions = analyzedDocuments.map(({ expression: expression2 }) => expression2);
    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    const response = await runRequest({
      url: this.url,
      request: {
        _tag: `Batch`,
        operationName: undefined,
        query: expressions,
        hasMutations,
        variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware) {
      await this.requestConfig.responseMiddleware(response, {
        operationName: undefined,
        variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  setEndpoint(value) {
    this.url = value;
    return this;
  }
}
var init_GraphQLClient = __esm(() => {
  init_batchRequests();
  init_rawRequest();
  init_request();
  init_analyzeDocument();
  init_runRequest();
});

// node_modules/graphql-request/build/legacy/functions/request.js
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: undefined
  };
};
var init_request = __esm(() => {
  init_GraphQLClient();
});

// node_modules/graphql-request/build/legacy/functions/gql.js
var gql = (chunks, ...variables) => {
  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);
};

// node_modules/graphql-request/build/entrypoints/main.js
var init_main = __esm(() => {
  init_ClientError();
  init_request();
  init_GraphQLClient();
  init_batchRequests();
  init_rawRequest();
  init_analyzeDocument();
});

// node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version2();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version2();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  function registerGlobal(type2, instance, diag, allowOverride = false) {
    var _a;
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type2]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type2}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type2} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type2] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type2} v${version_1.VERSION}.`);
    return true;
  }
  exports.registerGlobal = registerGlobal;
  function getGlobal(type2) {
    var _a, _b;
    const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type2];
  }
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type2, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type2} v${version_1.VERSION}.`);
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type2];
    }
  }
  exports.unregisterGlobal = unregisterGlobal;
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args) {
    const logger = (0, global_utils_1.getGlobal)("diag");
    if (!logger) {
      return;
    }
    args.unshift(namespace);
    return logger[funcName](...args);
  }
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger = (0, global_utils_1.getGlobal)("diag");
          if (!logger)
            return;
          return logger[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a, _b, _c;
        if (logger === self2) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : types_1.DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  function createBaggage(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  }
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {
    }
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {
    }
    removeBatchObservableCallback(_callback) {
    }
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {
    }
    removeCallback(_callback) {
    }
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  exports.createNoopMeter = createNoopMeter;
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value;
    }
  };
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {
    }
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {
    }
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
  }
  exports.getSpan = getSpan;
  function getActiveSpan() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  }
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  exports.setSpan = setSpan;
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
  }
  exports.getSpanContext = getSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  exports.wrapSpanContext = wrapSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  exports.createTraceState = createTraceState;
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {
    }
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  }
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  }
  exports.setBaggage = setBaggage;
  function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
  }
  exports.deleteBaggage = deleteBaggage;
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = undefined;
  var api_1 = require_src();
  var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
  function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
  }
  exports.suppressTracing = suppressTracing;
  function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
  }
  exports.unsuppressTracing = unsuppressTracing;
  function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
  }
  exports.isTracingSuppressed = isTracingSuppressed;
});

// node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = undefined;
  exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
  exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
  exports.BAGGAGE_ITEMS_SEPARATOR = ",";
  exports.BAGGAGE_HEADER = "baggage";
  exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
  exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
  exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
});

// node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = undefined;
  var api_1 = require_src();
  var constants_1 = require_constants();
  function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce((hValue, current) => {
      const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
      return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, "");
  }
  exports.serializeKeyPairs = serializeKeyPairs;
  function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(([key, value]) => {
      let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
      if (value.metadata !== undefined) {
        entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
      }
      return entry;
    });
  }
  exports.getKeyPairs = getKeyPairs;
  function parsePairKeyValue(entry) {
    const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
      return;
    const keyPairPart = valueProps.shift();
    if (!keyPairPart)
      return;
    const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
    if (separatorIndex <= 0)
      return;
    const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    let metadata;
    if (valueProps.length > 0) {
      metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key, value, metadata };
  }
  exports.parsePairKeyValue = parsePairKeyValue;
  function parseKeyPairsIntoRecord(value) {
    const result = {};
    if (typeof value === "string" && value.length > 0) {
      value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).forEach((entry) => {
        const keyPair = parsePairKeyValue(entry);
        if (keyPair !== undefined && keyPair.value.length > 0) {
          result[keyPair.key] = keyPair.value;
        }
      });
    }
    return result;
  }
  exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
});

// node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CBaggagePropagator = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var constants_1 = require_constants();
  var utils_1 = require_utils3();

  class W3CBaggagePropagator {
    inject(context, carrier, setter) {
      const baggage = api_1.propagation.getBaggage(context);
      if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context))
        return;
      const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
        return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
      }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
      const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
      if (headerValue.length > 0) {
        setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
    }
    extract(context, carrier, getter) {
      const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
      const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
      if (!baggageString)
        return context;
      const baggage = {};
      if (baggageString.length === 0) {
        return context;
      }
      const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
      pairs.forEach((entry) => {
        const keyPair = (0, utils_1.parsePairKeyValue)(entry);
        if (keyPair) {
          const baggageEntry = { value: keyPair.value };
          if (keyPair.metadata) {
            baggageEntry.metadata = keyPair.metadata;
          }
          baggage[keyPair.key] = baggageEntry;
        }
      });
      if (Object.entries(baggage).length === 0) {
        return context;
      }
      return api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
    }
    fields() {
      return [constants_1.BAGGAGE_HEADER];
    }
  }
  exports.W3CBaggagePropagator = W3CBaggagePropagator;
});

// node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnchoredClock = undefined;

  class AnchoredClock {
    _monotonicClock;
    _epochMillis;
    _performanceMillis;
    constructor(systemClock, monotonicClock) {
      this._monotonicClock = monotonicClock;
      this._epochMillis = systemClock.now();
      this._performanceMillis = monotonicClock.now();
    }
    now() {
      const delta = this._monotonicClock.now() - this._performanceMillis;
      return this._epochMillis + delta;
    }
  }
  exports.AnchoredClock = AnchoredClock;
});

// node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = undefined;
  var api_1 = require_src();
  function sanitizeAttributes(attributes) {
    const out = {};
    if (typeof attributes !== "object" || attributes == null) {
      return out;
    }
    for (const [key, val] of Object.entries(attributes)) {
      if (!isAttributeKey(key)) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        continue;
      }
      if (!isAttributeValue(val)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        continue;
      }
      if (Array.isArray(val)) {
        out[key] = val.slice();
      } else {
        out[key] = val;
      }
    }
    return out;
  }
  exports.sanitizeAttributes = sanitizeAttributes;
  function isAttributeKey(key) {
    return typeof key === "string" && key.length > 0;
  }
  exports.isAttributeKey = isAttributeKey;
  function isAttributeValue(val) {
    if (val == null) {
      return true;
    }
    if (Array.isArray(val)) {
      return isHomogeneousAttributeValueArray(val);
    }
    return isValidPrimitiveAttributeValue(val);
  }
  exports.isAttributeValue = isAttributeValue;
  function isHomogeneousAttributeValueArray(arr) {
    let type2;
    for (const element of arr) {
      if (element == null)
        continue;
      if (!type2) {
        if (isValidPrimitiveAttributeValue(element)) {
          type2 = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type2) {
        continue;
      }
      return false;
    }
    return true;
  }
  function isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
      case "number":
      case "boolean":
      case "string":
        return true;
    }
    return false;
  }
});

// node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loggingErrorHandler = undefined;
  var api_1 = require_src();
  function loggingErrorHandler() {
    return (ex) => {
      api_1.diag.error(stringifyException(ex));
    };
  }
  exports.loggingErrorHandler = loggingErrorHandler;
  function stringifyException(ex) {
    if (typeof ex === "string") {
      return ex;
    } else {
      return JSON.stringify(flattenException(ex));
    }
  }
  function flattenException(ex) {
    const result = {};
    let current = ex;
    while (current !== null) {
      Object.getOwnPropertyNames(current).forEach((propertyName) => {
        if (result[propertyName])
          return;
        const value = current[propertyName];
        if (value) {
          result[propertyName] = String(value);
        }
      });
      current = Object.getPrototypeOf(current);
    }
    return result;
  }
});

// node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalErrorHandler = exports.setGlobalErrorHandler = undefined;
  var logging_error_handler_1 = require_logging_error_handler();
  var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
  function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
  }
  exports.setGlobalErrorHandler = setGlobalErrorHandler;
  function globalErrorHandler(ex) {
    try {
      delegateHandler(ex);
    } catch {
    }
  }
  exports.globalErrorHandler = globalErrorHandler;
});

// node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStringListFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = exports.getNumberFromEnv = undefined;
  var api_1 = require_src();
  var util_1 = __require("util");
  function getNumberFromEnv(key) {
    const raw = process.env[key];
    if (raw == null || raw.trim() === "") {
      return;
    }
    const value = Number(raw);
    if (isNaN(value)) {
      api_1.diag.warn(`Unknown value ${(0, util_1.inspect)(raw)} for ${key}, expected a number, using defaults`);
      return;
    }
    return value;
  }
  exports.getNumberFromEnv = getNumberFromEnv;
  function getStringFromEnv(key) {
    const raw = process.env[key];
    if (raw == null || raw.trim() === "") {
      return;
    }
    return raw;
  }
  exports.getStringFromEnv = getStringFromEnv;
  function getBooleanFromEnv(key) {
    const raw = process.env[key]?.trim().toLowerCase();
    if (raw == null || raw === "") {
      return false;
    }
    if (raw === "true") {
      return true;
    } else if (raw === "false") {
      return false;
    } else {
      api_1.diag.warn(`Unknown value ${(0, util_1.inspect)(raw)} for ${key}, expected 'true' or 'false', falling back to 'false' (default)`);
      return false;
    }
  }
  exports.getBooleanFromEnv = getBooleanFromEnv;
  function getStringListFromEnv(key) {
    return getStringFromEnv(key)?.split(",").map((v) => v.trim()).filter((s) => s !== "");
  }
  exports.getStringListFromEnv = getStringListFromEnv;
});

// node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.otperformance = undefined;
  var perf_hooks_1 = __require("perf_hooks");
  exports.otperformance = perf_hooks_1.performance;
});

// node_modules/@opentelemetry/core/build/src/version.js
var require_version3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "2.0.1";
});

// node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConstMap = undefined;
  function createConstMap(values) {
    let res = {};
    const len = values.length;
    for (let lp = 0;lp < len; lp++) {
      const val = values[lp];
      if (val) {
        res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
      }
    }
    return res;
  }
  exports.createConstMap = createConstMap;
});

// node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = undefined;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = undefined;
  exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = undefined;
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = undefined;
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = undefined;
  exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = undefined;
  var utils_1 = require_utils4();
  var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
  var TMP_DB_SYSTEM = "db.system";
  var TMP_DB_CONNECTION_STRING = "db.connection_string";
  var TMP_DB_USER = "db.user";
  var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
  var TMP_DB_NAME = "db.name";
  var TMP_DB_STATEMENT = "db.statement";
  var TMP_DB_OPERATION = "db.operation";
  var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
  var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
  var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
  var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
  var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
  var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
  var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
  var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
  var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
  var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
  var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
  var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
  var TMP_DB_SQL_TABLE = "db.sql.table";
  var TMP_EXCEPTION_TYPE = "exception.type";
  var TMP_EXCEPTION_MESSAGE = "exception.message";
  var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
  var TMP_EXCEPTION_ESCAPED = "exception.escaped";
  var TMP_FAAS_TRIGGER = "faas.trigger";
  var TMP_FAAS_EXECUTION = "faas.execution";
  var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
  var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
  var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
  var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
  var TMP_FAAS_TIME = "faas.time";
  var TMP_FAAS_CRON = "faas.cron";
  var TMP_FAAS_COLDSTART = "faas.coldstart";
  var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
  var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
  var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
  var TMP_NET_TRANSPORT = "net.transport";
  var TMP_NET_PEER_IP = "net.peer.ip";
  var TMP_NET_PEER_PORT = "net.peer.port";
  var TMP_NET_PEER_NAME = "net.peer.name";
  var TMP_NET_HOST_IP = "net.host.ip";
  var TMP_NET_HOST_PORT = "net.host.port";
  var TMP_NET_HOST_NAME = "net.host.name";
  var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
  var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
  var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
  var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
  var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
  var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
  var TMP_PEER_SERVICE = "peer.service";
  var TMP_ENDUSER_ID = "enduser.id";
  var TMP_ENDUSER_ROLE = "enduser.role";
  var TMP_ENDUSER_SCOPE = "enduser.scope";
  var TMP_THREAD_ID = "thread.id";
  var TMP_THREAD_NAME = "thread.name";
  var TMP_CODE_FUNCTION = "code.function";
  var TMP_CODE_NAMESPACE = "code.namespace";
  var TMP_CODE_FILEPATH = "code.filepath";
  var TMP_CODE_LINENO = "code.lineno";
  var TMP_HTTP_METHOD = "http.method";
  var TMP_HTTP_URL = "http.url";
  var TMP_HTTP_TARGET = "http.target";
  var TMP_HTTP_HOST = "http.host";
  var TMP_HTTP_SCHEME = "http.scheme";
  var TMP_HTTP_STATUS_CODE = "http.status_code";
  var TMP_HTTP_FLAVOR = "http.flavor";
  var TMP_HTTP_USER_AGENT = "http.user_agent";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  var TMP_HTTP_SERVER_NAME = "http.server_name";
  var TMP_HTTP_ROUTE = "http.route";
  var TMP_HTTP_CLIENT_IP = "http.client_ip";
  var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
  var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
  var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
  var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
  var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
  var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
  var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
  var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
  var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
  var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
  var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
  var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
  var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
  var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
  var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
  var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
  var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
  var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
  var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
  var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
  var TMP_MESSAGING_SYSTEM = "messaging.system";
  var TMP_MESSAGING_DESTINATION = "messaging.destination";
  var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
  var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
  var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
  var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
  var TMP_MESSAGING_URL = "messaging.url";
  var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
  var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
  var TMP_MESSAGING_OPERATION = "messaging.operation";
  var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
  var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
  var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
  var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
  var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
  var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
  var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
  var TMP_RPC_SYSTEM = "rpc.system";
  var TMP_RPC_SERVICE = "rpc.service";
  var TMP_RPC_METHOD = "rpc.method";
  var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
  var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
  var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
  var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
  var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
  var TMP_MESSAGE_TYPE = "message.type";
  var TMP_MESSAGE_ID = "message.id";
  var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
  var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
  exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
  exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
  exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
  exports.SEMATTRS_DB_USER = TMP_DB_USER;
  exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
  exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
  exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
  exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
  exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
  exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
  exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
  exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
  exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
  exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
  exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
  exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
  exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
  exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
  exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
  exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
  exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
  exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
  exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
  exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
  exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
  exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
  exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
  exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
  exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
  exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
  exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
  exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
  exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
  exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
  exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
  exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
  exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
  exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
  exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
  exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
  exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
  exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
  exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
  exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
  exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
  exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
  exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
  exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
  exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
  exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
  exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
  exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
  exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
  exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
  exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
  exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
  exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
  exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
  exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
  exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
  exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
  exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
  exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
  exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
  exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
  exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
  exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
  exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
  exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
  exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
  exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
  exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
  exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
  exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
  exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
  exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
  exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
  exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
  exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
  exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
  exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
  exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
  exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
  exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
  exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
  exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
  exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
  exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
  exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
  exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
  exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
  exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
  exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
  exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
  exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
  exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
  exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
  exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
  exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
  ]);
  var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
  var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
  var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
  var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
  var TMP_DBSYSTEMVALUES_DB2 = "db2";
  var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
  var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
  var TMP_DBSYSTEMVALUES_HIVE = "hive";
  var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
  var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
  var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
  var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
  var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
  var TMP_DBSYSTEMVALUES_INGRES = "ingres";
  var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
  var TMP_DBSYSTEMVALUES_EDB = "edb";
  var TMP_DBSYSTEMVALUES_CACHE = "cache";
  var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
  var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
  var TMP_DBSYSTEMVALUES_DERBY = "derby";
  var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
  var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
  var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
  var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
  var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
  var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
  var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
  var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
  var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
  var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
  var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
  var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
  var TMP_DBSYSTEMVALUES_H2 = "h2";
  var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
  var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
  var TMP_DBSYSTEMVALUES_HBASE = "hbase";
  var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
  var TMP_DBSYSTEMVALUES_REDIS = "redis";
  var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
  var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
  var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
  var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
  var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
  var TMP_DBSYSTEMVALUES_GEODE = "geode";
  var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
  var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
  var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
  exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
  exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
  exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
  exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
  exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
  exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
  exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
  exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
  exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
  exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
  exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
  exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
  exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
  exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
  exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
  exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
  exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
  exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
  exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
  exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
  exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
  exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
  exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
  exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
  exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
  exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
  exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
  exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
  exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
  exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
  exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
  exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
  exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
  exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
  exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
  exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
  exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
  exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
  exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
  exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
  exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
  exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
  exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
  exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
  exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
  exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
  exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
  exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
  ]);
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
  exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
  ]);
  var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
  var TMP_FAASTRIGGERVALUES_HTTP = "http";
  var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
  var TMP_FAASTRIGGERVALUES_TIMER = "timer";
  var TMP_FAASTRIGGERVALUES_OTHER = "other";
  exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
  exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
  exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
  exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
  exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
  exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
  ]);
  var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
  var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
  var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
  exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
  exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
  exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
  exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
  ]);
  var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
  var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
  var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
  exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
  exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
  exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
  ]);
  var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
  var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
  var TMP_NETTRANSPORTVALUES_IP = "ip";
  var TMP_NETTRANSPORTVALUES_UNIX = "unix";
  var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
  var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
  var TMP_NETTRANSPORTVALUES_OTHER = "other";
  exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
  exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
  exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
  exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
  exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
  exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
  exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
  exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
  ]);
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
  exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
  exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
  exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
  exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
  ]);
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
  exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
  ]);
  var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
  var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
  var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
  var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
  var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
  exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
  exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
  exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
  exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
  exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
  exports.HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
  };
  var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
  var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
  exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
  exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
  exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
  ]);
  var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
  var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
  exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
  exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
  ]);
  var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
  var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
  var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
  var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
  var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
  var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
  var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
  var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
  var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
  var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
  var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
  var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
  var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
  exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
  exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
  exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
  exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
  exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
  exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
  exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
  exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
  exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
  exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
  exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
  exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
  exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
  exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
  exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
  exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
  exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
  exports.RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
  };
  var TMP_MESSAGETYPEVALUES_SENT = "SENT";
  var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
  exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
  exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
  exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
  ]);
});

// node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_SemanticAttributes(), exports);
});

// node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = undefined;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = undefined;
  exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = undefined;
  var utils_1 = require_utils4();
  var TMP_CLOUD_PROVIDER = "cloud.provider";
  var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
  var TMP_CLOUD_REGION = "cloud.region";
  var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  var TMP_CLOUD_PLATFORM = "cloud.platform";
  var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
  var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
  var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
  var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
  var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
  var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
  var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
  var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
  var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
  var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
  var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
  var TMP_CONTAINER_NAME = "container.name";
  var TMP_CONTAINER_ID = "container.id";
  var TMP_CONTAINER_RUNTIME = "container.runtime";
  var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
  var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
  var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
  var TMP_DEVICE_ID = "device.id";
  var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
  var TMP_DEVICE_MODEL_NAME = "device.model.name";
  var TMP_FAAS_NAME = "faas.name";
  var TMP_FAAS_ID = "faas.id";
  var TMP_FAAS_VERSION = "faas.version";
  var TMP_FAAS_INSTANCE = "faas.instance";
  var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
  var TMP_HOST_ID = "host.id";
  var TMP_HOST_NAME = "host.name";
  var TMP_HOST_TYPE = "host.type";
  var TMP_HOST_ARCH = "host.arch";
  var TMP_HOST_IMAGE_NAME = "host.image.name";
  var TMP_HOST_IMAGE_ID = "host.image.id";
  var TMP_HOST_IMAGE_VERSION = "host.image.version";
  var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
  var TMP_K8S_NODE_NAME = "k8s.node.name";
  var TMP_K8S_NODE_UID = "k8s.node.uid";
  var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  var TMP_K8S_POD_UID = "k8s.pod.uid";
  var TMP_K8S_POD_NAME = "k8s.pod.name";
  var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
  var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
  var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
  var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
  var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
  var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
  var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
  var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
  var TMP_K8S_JOB_UID = "k8s.job.uid";
  var TMP_K8S_JOB_NAME = "k8s.job.name";
  var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
  var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
  var TMP_OS_TYPE = "os.type";
  var TMP_OS_DESCRIPTION = "os.description";
  var TMP_OS_NAME = "os.name";
  var TMP_OS_VERSION = "os.version";
  var TMP_PROCESS_PID = "process.pid";
  var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  var TMP_PROCESS_COMMAND = "process.command";
  var TMP_PROCESS_COMMAND_LINE = "process.command_line";
  var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
  var TMP_PROCESS_OWNER = "process.owner";
  var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
  var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  var TMP_SERVICE_NAME = "service.name";
  var TMP_SERVICE_NAMESPACE = "service.namespace";
  var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
  var TMP_SERVICE_VERSION = "service.version";
  var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
  var TMP_WEBENGINE_NAME = "webengine.name";
  var TMP_WEBENGINE_VERSION = "webengine.version";
  var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
  exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
  exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
  exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
  exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
  exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
  exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
  exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
  exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
  exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
  exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
  exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
  exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
  exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
  exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
  exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
  exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
  exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
  exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
  exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
  exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
  exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
  exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
  exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
  exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
  exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
  exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
  exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
  exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
  exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
  exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
  exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
  exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
  exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
  exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
  exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
  exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
  exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
  exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
  exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
  exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
  exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
  exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
  exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
  exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
  exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
  exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
  exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
  exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
  exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
  exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
  exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
  exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
  exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
  exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
  exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
  exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
  exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
  exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
  exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
  exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
  exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
  exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
  exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
  exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
  exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
  exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
  exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
  exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
  exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
  exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
  exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
  exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
  ]);
  var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
  var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
  var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
  exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
  exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
  exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
  exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
  ]);
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
  var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
  var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
  var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
  var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
  var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
  var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
  var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
  var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
  var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
  var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
  var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
  var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
  var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
  exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
  exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
  exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
  exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
  exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
  exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
  exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
  exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
  exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
  exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
  exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
  ]);
  var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
  var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
  exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
  exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
  exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
  ]);
  var TMP_HOSTARCHVALUES_AMD64 = "amd64";
  var TMP_HOSTARCHVALUES_ARM32 = "arm32";
  var TMP_HOSTARCHVALUES_ARM64 = "arm64";
  var TMP_HOSTARCHVALUES_IA64 = "ia64";
  var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
  var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
  var TMP_HOSTARCHVALUES_X86 = "x86";
  exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
  exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
  exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
  exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
  exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
  exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
  exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
  exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
  ]);
  var TMP_OSTYPEVALUES_WINDOWS = "windows";
  var TMP_OSTYPEVALUES_LINUX = "linux";
  var TMP_OSTYPEVALUES_DARWIN = "darwin";
  var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
  var TMP_OSTYPEVALUES_NETBSD = "netbsd";
  var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
  var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
  var TMP_OSTYPEVALUES_HPUX = "hpux";
  var TMP_OSTYPEVALUES_AIX = "aix";
  var TMP_OSTYPEVALUES_SOLARIS = "solaris";
  var TMP_OSTYPEVALUES_Z_OS = "z_os";
  exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
  exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
  exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
  exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
  exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
  exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
  exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
  exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
  exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
  exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
  exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
  exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
  ]);
  var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
  exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
  exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
  exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
  exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
  exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
  exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
  exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
  exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
  exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
  exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
  exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
  ]);
});

// node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_SemanticResourceAttributes(), exports);
});

// node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js
var require_stable_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ATTR_HTTP_REQUEST_HEADER = exports.ATTR_EXCEPTION_TYPE = exports.ATTR_EXCEPTION_STACKTRACE = exports.ATTR_EXCEPTION_MESSAGE = exports.ATTR_EXCEPTION_ESCAPED = exports.ERROR_TYPE_VALUE_OTHER = exports.ATTR_ERROR_TYPE = exports.DOTNET_GC_HEAP_GENERATION_VALUE_POH = exports.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = exports.ATTR_DOTNET_GC_HEAP_GENERATION = exports.DB_SYSTEM_NAME_VALUE_POSTGRESQL = exports.DB_SYSTEM_NAME_VALUE_MYSQL = exports.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = exports.DB_SYSTEM_NAME_VALUE_MARIADB = exports.ATTR_DB_SYSTEM_NAME = exports.ATTR_DB_STORED_PROCEDURE_NAME = exports.ATTR_DB_RESPONSE_STATUS_CODE = exports.ATTR_DB_QUERY_TEXT = exports.ATTR_DB_QUERY_SUMMARY = exports.ATTR_DB_OPERATION_NAME = exports.ATTR_DB_OPERATION_BATCH_SIZE = exports.ATTR_DB_NAMESPACE = exports.ATTR_DB_COLLECTION_NAME = exports.ATTR_CODE_STACKTRACE = exports.ATTR_CODE_LINE_NUMBER = exports.ATTR_CODE_FUNCTION_NAME = exports.ATTR_CODE_FILE_PATH = exports.ATTR_CODE_COLUMN_NUMBER = exports.ATTR_CLIENT_PORT = exports.ATTR_CLIENT_ADDRESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = undefined;
  exports.OTEL_STATUS_CODE_VALUE_OK = exports.OTEL_STATUS_CODE_VALUE_ERROR = exports.ATTR_OTEL_STATUS_CODE = exports.ATTR_OTEL_SCOPE_VERSION = exports.ATTR_OTEL_SCOPE_NAME = exports.NETWORK_TYPE_VALUE_IPV6 = exports.NETWORK_TYPE_VALUE_IPV4 = exports.ATTR_NETWORK_TYPE = exports.NETWORK_TRANSPORT_VALUE_UNIX = exports.NETWORK_TRANSPORT_VALUE_UDP = exports.NETWORK_TRANSPORT_VALUE_TCP = exports.NETWORK_TRANSPORT_VALUE_QUIC = exports.NETWORK_TRANSPORT_VALUE_PIPE = exports.ATTR_NETWORK_TRANSPORT = exports.ATTR_NETWORK_PROTOCOL_VERSION = exports.ATTR_NETWORK_PROTOCOL_NAME = exports.ATTR_NETWORK_PEER_PORT = exports.ATTR_NETWORK_PEER_ADDRESS = exports.ATTR_NETWORK_LOCAL_PORT = exports.ATTR_NETWORK_LOCAL_ADDRESS = exports.JVM_THREAD_STATE_VALUE_WAITING = exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = exports.JVM_THREAD_STATE_VALUE_TERMINATED = exports.JVM_THREAD_STATE_VALUE_RUNNABLE = exports.JVM_THREAD_STATE_VALUE_NEW = exports.JVM_THREAD_STATE_VALUE_BLOCKED = exports.ATTR_JVM_THREAD_STATE = exports.ATTR_JVM_THREAD_DAEMON = exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = exports.JVM_MEMORY_TYPE_VALUE_HEAP = exports.ATTR_JVM_MEMORY_TYPE = exports.ATTR_JVM_MEMORY_POOL_NAME = exports.ATTR_JVM_GC_NAME = exports.ATTR_JVM_GC_ACTION = exports.ATTR_HTTP_ROUTE = exports.ATTR_HTTP_RESPONSE_STATUS_CODE = exports.ATTR_HTTP_RESPONSE_HEADER = exports.ATTR_HTTP_REQUEST_RESEND_COUNT = exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = exports.HTTP_REQUEST_METHOD_VALUE_TRACE = exports.HTTP_REQUEST_METHOD_VALUE_PUT = exports.HTTP_REQUEST_METHOD_VALUE_POST = exports.HTTP_REQUEST_METHOD_VALUE_PATCH = exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = exports.HTTP_REQUEST_METHOD_VALUE_HEAD = exports.HTTP_REQUEST_METHOD_VALUE_GET = exports.HTTP_REQUEST_METHOD_VALUE_DELETE = exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = exports.HTTP_REQUEST_METHOD_VALUE_OTHER = exports.ATTR_HTTP_REQUEST_METHOD = undefined;
  exports.ATTR_USER_AGENT_ORIGINAL = exports.ATTR_URL_SCHEME = exports.ATTR_URL_QUERY = exports.ATTR_URL_PATH = exports.ATTR_URL_FULL = exports.ATTR_URL_FRAGMENT = exports.ATTR_TELEMETRY_SDK_VERSION = exports.ATTR_TELEMETRY_SDK_NAME = exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = exports.ATTR_TELEMETRY_SDK_LANGUAGE = exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = exports.ATTR_SIGNALR_TRANSPORT = exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = exports.ATTR_SIGNALR_CONNECTION_STATUS = exports.ATTR_SERVICE_VERSION = exports.ATTR_SERVICE_NAME = exports.ATTR_SERVER_PORT = exports.ATTR_SERVER_ADDRESS = exports.ATTR_OTEL_STATUS_DESCRIPTION = undefined;
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
  exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
  exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
  exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
  exports.ATTR_CLIENT_ADDRESS = "client.address";
  exports.ATTR_CLIENT_PORT = "client.port";
  exports.ATTR_CODE_COLUMN_NUMBER = "code.column.number";
  exports.ATTR_CODE_FILE_PATH = "code.file.path";
  exports.ATTR_CODE_FUNCTION_NAME = "code.function.name";
  exports.ATTR_CODE_LINE_NUMBER = "code.line.number";
  exports.ATTR_CODE_STACKTRACE = "code.stacktrace";
  exports.ATTR_DB_COLLECTION_NAME = "db.collection.name";
  exports.ATTR_DB_NAMESPACE = "db.namespace";
  exports.ATTR_DB_OPERATION_BATCH_SIZE = "db.operation.batch.size";
  exports.ATTR_DB_OPERATION_NAME = "db.operation.name";
  exports.ATTR_DB_QUERY_SUMMARY = "db.query.summary";
  exports.ATTR_DB_QUERY_TEXT = "db.query.text";
  exports.ATTR_DB_RESPONSE_STATUS_CODE = "db.response.status_code";
  exports.ATTR_DB_STORED_PROCEDURE_NAME = "db.stored_procedure.name";
  exports.ATTR_DB_SYSTEM_NAME = "db.system.name";
  exports.DB_SYSTEM_NAME_VALUE_MARIADB = "mariadb";
  exports.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = "microsoft.sql_server";
  exports.DB_SYSTEM_NAME_VALUE_MYSQL = "mysql";
  exports.DB_SYSTEM_NAME_VALUE_POSTGRESQL = "postgresql";
  exports.ATTR_DOTNET_GC_HEAP_GENERATION = "dotnet.gc.heap.generation";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = "gen0";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = "gen1";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = "gen2";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = "loh";
  exports.DOTNET_GC_HEAP_GENERATION_VALUE_POH = "poh";
  exports.ATTR_ERROR_TYPE = "error.type";
  exports.ERROR_TYPE_VALUE_OTHER = "_OTHER";
  exports.ATTR_EXCEPTION_ESCAPED = "exception.escaped";
  exports.ATTR_EXCEPTION_MESSAGE = "exception.message";
  exports.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
  exports.ATTR_EXCEPTION_TYPE = "exception.type";
  var ATTR_HTTP_REQUEST_HEADER = (key) => `http.request.header.${key}`;
  exports.ATTR_HTTP_REQUEST_HEADER = ATTR_HTTP_REQUEST_HEADER;
  exports.ATTR_HTTP_REQUEST_METHOD = "http.request.method";
  exports.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
  exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
  exports.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
  exports.HTTP_REQUEST_METHOD_VALUE_GET = "GET";
  exports.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
  exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
  exports.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
  exports.HTTP_REQUEST_METHOD_VALUE_POST = "POST";
  exports.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
  exports.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
  exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
  exports.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
  var ATTR_HTTP_RESPONSE_HEADER = (key) => `http.response.header.${key}`;
  exports.ATTR_HTTP_RESPONSE_HEADER = ATTR_HTTP_RESPONSE_HEADER;
  exports.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
  exports.ATTR_HTTP_ROUTE = "http.route";
  exports.ATTR_JVM_GC_ACTION = "jvm.gc.action";
  exports.ATTR_JVM_GC_NAME = "jvm.gc.name";
  exports.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
  exports.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
  exports.JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
  exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
  exports.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
  exports.ATTR_JVM_THREAD_STATE = "jvm.thread.state";
  exports.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
  exports.JVM_THREAD_STATE_VALUE_NEW = "new";
  exports.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
  exports.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
  exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
  exports.JVM_THREAD_STATE_VALUE_WAITING = "waiting";
  exports.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
  exports.ATTR_NETWORK_LOCAL_PORT = "network.local.port";
  exports.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
  exports.ATTR_NETWORK_PEER_PORT = "network.peer.port";
  exports.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
  exports.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
  exports.ATTR_NETWORK_TRANSPORT = "network.transport";
  exports.NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
  exports.NETWORK_TRANSPORT_VALUE_QUIC = "quic";
  exports.NETWORK_TRANSPORT_VALUE_TCP = "tcp";
  exports.NETWORK_TRANSPORT_VALUE_UDP = "udp";
  exports.NETWORK_TRANSPORT_VALUE_UNIX = "unix";
  exports.ATTR_NETWORK_TYPE = "network.type";
  exports.NETWORK_TYPE_VALUE_IPV4 = "ipv4";
  exports.NETWORK_TYPE_VALUE_IPV6 = "ipv6";
  exports.ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
  exports.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
  exports.ATTR_OTEL_STATUS_CODE = "otel.status_code";
  exports.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
  exports.OTEL_STATUS_CODE_VALUE_OK = "OK";
  exports.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
  exports.ATTR_SERVER_ADDRESS = "server.address";
  exports.ATTR_SERVER_PORT = "server.port";
  exports.ATTR_SERVICE_NAME = "service.name";
  exports.ATTR_SERVICE_VERSION = "service.version";
  exports.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
  exports.ATTR_SIGNALR_TRANSPORT = "signalr.transport";
  exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
  exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
  exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
  exports.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
  exports.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  exports.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  exports.ATTR_URL_FRAGMENT = "url.fragment";
  exports.ATTR_URL_FULL = "url.full";
  exports.ATTR_URL_PATH = "url.path";
  exports.ATTR_URL_QUERY = "url.query";
  exports.ATTR_URL_SCHEME = "url.scheme";
  exports.ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
});

// node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js
var require_stable_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = exports.METRIC_KESTREL_REJECTED_CONNECTIONS = exports.METRIC_KESTREL_QUEUED_REQUESTS = exports.METRIC_KESTREL_QUEUED_CONNECTIONS = exports.METRIC_KESTREL_CONNECTION_DURATION = exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = exports.METRIC_JVM_THREAD_COUNT = exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = exports.METRIC_JVM_MEMORY_USED = exports.METRIC_JVM_MEMORY_LIMIT = exports.METRIC_JVM_MEMORY_COMMITTED = exports.METRIC_JVM_GC_DURATION = exports.METRIC_JVM_CPU_TIME = exports.METRIC_JVM_CPU_RECENT_UTILIZATION = exports.METRIC_JVM_CPU_COUNT = exports.METRIC_JVM_CLASS_UNLOADED = exports.METRIC_JVM_CLASS_LOADED = exports.METRIC_JVM_CLASS_COUNT = exports.METRIC_HTTP_SERVER_REQUEST_DURATION = exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = exports.METRIC_DOTNET_TIMER_COUNT = exports.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = exports.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = exports.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = exports.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = exports.METRIC_DOTNET_PROCESS_CPU_TIME = exports.METRIC_DOTNET_PROCESS_CPU_COUNT = exports.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = exports.METRIC_DOTNET_JIT_COMPILED_METHODS = exports.METRIC_DOTNET_JIT_COMPILED_IL_SIZE = exports.METRIC_DOTNET_JIT_COMPILATION_TIME = exports.METRIC_DOTNET_GC_PAUSE_TIME = exports.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = exports.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = exports.METRIC_DOTNET_GC_COLLECTIONS = exports.METRIC_DOTNET_EXCEPTIONS = exports.METRIC_DOTNET_ASSEMBLY_COUNT = exports.METRIC_DB_CLIENT_OPERATION_DURATION = exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = undefined;
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = undefined;
  exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
  exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
  exports.METRIC_DB_CLIENT_OPERATION_DURATION = "db.client.operation.duration";
  exports.METRIC_DOTNET_ASSEMBLY_COUNT = "dotnet.assembly.count";
  exports.METRIC_DOTNET_EXCEPTIONS = "dotnet.exceptions";
  exports.METRIC_DOTNET_GC_COLLECTIONS = "dotnet.gc.collections";
  exports.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = "dotnet.gc.heap.total_allocated";
  exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = "dotnet.gc.last_collection.heap.fragmentation.size";
  exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = "dotnet.gc.last_collection.heap.size";
  exports.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = "dotnet.gc.last_collection.memory.committed_size";
  exports.METRIC_DOTNET_GC_PAUSE_TIME = "dotnet.gc.pause.time";
  exports.METRIC_DOTNET_JIT_COMPILATION_TIME = "dotnet.jit.compilation.time";
  exports.METRIC_DOTNET_JIT_COMPILED_IL_SIZE = "dotnet.jit.compiled_il.size";
  exports.METRIC_DOTNET_JIT_COMPILED_METHODS = "dotnet.jit.compiled_methods";
  exports.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = "dotnet.monitor.lock_contentions";
  exports.METRIC_DOTNET_PROCESS_CPU_COUNT = "dotnet.process.cpu.count";
  exports.METRIC_DOTNET_PROCESS_CPU_TIME = "dotnet.process.cpu.time";
  exports.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = "dotnet.process.memory.working_set";
  exports.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = "dotnet.thread_pool.queue.length";
  exports.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = "dotnet.thread_pool.thread.count";
  exports.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = "dotnet.thread_pool.work_item.count";
  exports.METRIC_DOTNET_TIMER_COUNT = "dotnet.timer.count";
  exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
  exports.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
  exports.METRIC_JVM_CLASS_COUNT = "jvm.class.count";
  exports.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
  exports.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
  exports.METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
  exports.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
  exports.METRIC_JVM_CPU_TIME = "jvm.cpu.time";
  exports.METRIC_JVM_GC_DURATION = "jvm.gc.duration";
  exports.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
  exports.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
  exports.METRIC_JVM_MEMORY_USED = "jvm.memory.used";
  exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
  exports.METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
  exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
  exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
  exports.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
  exports.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
  exports.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
  exports.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
  exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
  exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
});

// node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_trace2(), exports);
  __exportStar(require_resource(), exports);
  __exportStar(require_stable_attributes(), exports);
  __exportStar(require_stable_metrics(), exports);
});

// node_modules/@opentelemetry/core/build/src/semconv.js
var require_semconv = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ATTR_PROCESS_RUNTIME_NAME = undefined;
  exports.ATTR_PROCESS_RUNTIME_NAME = "process.runtime.name";
});

// node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SDK_INFO = undefined;
  var version_1 = require_version3();
  var semantic_conventions_1 = require_src2();
  var semconv_1 = require_semconv();
  exports.SDK_INFO = {
    [semantic_conventions_1.ATTR_TELEMETRY_SDK_NAME]: "opentelemetry",
    [semconv_1.ATTR_PROCESS_RUNTIME_NAME]: "node",
    [semantic_conventions_1.ATTR_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
    [semantic_conventions_1.ATTR_TELEMETRY_SDK_VERSION]: version_1.VERSION
  };
});

// node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = undefined;
  function unrefTimer(timer) {
    timer.unref();
  }
  exports.unrefTimer = unrefTimer;
});

// node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = exports.SDK_INFO = exports.otperformance = exports._globalThis = exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = undefined;
  var environment_1 = require_environment();
  Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: function() {
    return environment_1.getStringFromEnv;
  } });
  Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: function() {
    return environment_1.getBooleanFromEnv;
  } });
  Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: function() {
    return environment_1.getNumberFromEnv;
  } });
  Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: function() {
    return environment_1.getStringListFromEnv;
  } });
  var globalThis_1 = require_globalThis2();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
  var performance_1 = require_performance();
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return performance_1.otperformance;
  } });
  var sdk_info_1 = require_sdk_info();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return sdk_info_1.SDK_INFO;
  } });
  var timer_util_1 = require_timer_util();
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return timer_util_1.unrefTimer;
  } });
});

// node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getStringFromEnv = exports.getBooleanFromEnv = exports.unrefTimer = exports.otperformance = exports._globalThis = exports.SDK_INFO = undefined;
  var node_1 = require_node2();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return node_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return node_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return node_1.unrefTimer;
  } });
  Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: function() {
    return node_1.getBooleanFromEnv;
  } });
  Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: function() {
    return node_1.getStringFromEnv;
  } });
  Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: function() {
    return node_1.getNumberFromEnv;
  } });
  Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: function() {
    return node_1.getStringListFromEnv;
  } });
});

// node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = undefined;
  var platform_1 = require_platform2();
  var NANOSECOND_DIGITS = 9;
  var NANOSECOND_DIGITS_IN_MILLIS = 6;
  var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
  var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
  function millisToHrTime(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    const seconds = Math.trunc(epochSeconds);
    const nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [seconds, nanos];
  }
  exports.millisToHrTime = millisToHrTime;
  function getTimeOrigin() {
    let timeOrigin = platform_1.otperformance.timeOrigin;
    if (typeof timeOrigin !== "number") {
      const perf = platform_1.otperformance;
      timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
  }
  exports.getTimeOrigin = getTimeOrigin;
  function hrTime(performanceNow) {
    const timeOrigin = millisToHrTime(getTimeOrigin());
    const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
    return addHrTimes(timeOrigin, now);
  }
  exports.hrTime = hrTime;
  function timeInputToHrTime(time) {
    if (isTimeInputHrTime(time)) {
      return time;
    } else if (typeof time === "number") {
      if (time < getTimeOrigin()) {
        return hrTime(time);
      } else {
        return millisToHrTime(time);
      }
    } else if (time instanceof Date) {
      return millisToHrTime(time.getTime());
    } else {
      throw TypeError("Invalid input type");
    }
  }
  exports.timeInputToHrTime = timeInputToHrTime;
  function hrTimeDuration(startTime, endTime) {
    let seconds = endTime[0] - startTime[0];
    let nanos = endTime[1] - startTime[1];
    if (nanos < 0) {
      seconds -= 1;
      nanos += SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
  }
  exports.hrTimeDuration = hrTimeDuration;
  function hrTimeToTimeStamp(time) {
    const precision = NANOSECOND_DIGITS;
    const tmp = `${"0".repeat(precision)}${time[1]}Z`;
    const nanoString = tmp.substring(tmp.length - precision - 1);
    const date = new Date(time[0] * 1000).toISOString();
    return date.replace("000Z", nanoString);
  }
  exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
  function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
  }
  exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
  function hrTimeToMilliseconds(time) {
    return time[0] * 1000 + time[1] / 1e6;
  }
  exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
  function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1000;
  }
  exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
  function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
  }
  exports.isTimeInputHrTime = isTimeInputHrTime;
  function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
  }
  exports.isTimeInput = isTimeInput;
  function addHrTimes(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    if (out[1] >= SECOND_TO_NANOSECONDS) {
      out[1] -= SECOND_TO_NANOSECONDS;
      out[0] += 1;
    }
    return out;
  }
  exports.addHrTimes = addHrTimes;
});

// node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExportResultCode = undefined;
  var ExportResultCode;
  (function(ExportResultCode2) {
    ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
  })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
});

// node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompositePropagator = undefined;
  var api_1 = require_src();

  class CompositePropagator {
    _propagators;
    _fields;
    constructor(config = {}) {
      this._propagators = config.propagators ?? [];
      this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields === "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
    }
    inject(context, carrier, setter) {
      for (const propagator of this._propagators) {
        try {
          propagator.inject(context, carrier, setter);
        } catch (err) {
          api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
        }
      }
    }
    extract(context, carrier, getter) {
      return this._propagators.reduce((ctx, propagator) => {
        try {
          return propagator.extract(ctx, carrier, getter);
        } catch (err) {
          api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
        }
        return ctx;
      }, context);
    }
    fields() {
      return this._fields.slice();
    }
  }
  exports.CompositePropagator = CompositePropagator;
});

// node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceState = undefined;
  var validators_1 = require_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceState {
    _internalState = new Map;
    constructor(rawTraceState) {
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceState;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceState = TraceState;
});

// node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var TraceState_1 = require_TraceState();
  exports.TRACE_PARENT_HEADER = "traceparent";
  exports.TRACE_STATE_HEADER = "tracestate";
  var VERSION = "00";
  var VERSION_PART = "(?!ff)[\\da-f]{2}";
  var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
  var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
  var FLAGS_PART = "[\\da-f]{2}";
  var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
  function parseTraceParent(traceParent) {
    const match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
      return null;
    if (match[1] === "00" && match[5])
      return null;
    return {
      traceId: match[2],
      spanId: match[3],
      traceFlags: parseInt(match[4], 16)
    };
  }
  exports.parseTraceParent = parseTraceParent;

  class W3CTraceContextPropagator {
    inject(context, carrier, setter) {
      const spanContext = api_1.trace.getSpanContext(context);
      if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext))
        return;
      const traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
      setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
      if (spanContext.traceState) {
        setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
    }
    extract(context, carrier, getter) {
      const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
      if (!traceParentHeader)
        return context;
      const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
      if (typeof traceParent !== "string")
        return context;
      const spanContext = parseTraceParent(traceParent);
      if (!spanContext)
        return context;
      spanContext.isRemote = true;
      const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
      if (traceStateHeader) {
        const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
        spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : undefined);
      }
      return api_1.trace.setSpanContext(context, spanContext);
    }
    fields() {
      return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
    }
  }
  exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
});

// node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = undefined;
  var api_1 = require_src();
  var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
  var RPCType;
  (function(RPCType2) {
    RPCType2["HTTP"] = "http";
  })(RPCType = exports.RPCType || (exports.RPCType = {}));
  function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
  }
  exports.setRPCMetadata = setRPCMetadata;
  function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
  }
  exports.deleteRPCMetadata = deleteRPCMetadata;
  function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
  }
  exports.getRPCMetadata = getRPCMetadata;
});

// node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPlainObject = undefined;
  var objectTag = "[object Object]";
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  var objectCtorString = funcToString.call(Object);
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  var nativeObjectToString = objectProto.toString;
  function isPlainObject2(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
      return false;
    }
    const proto = getPrototypeOf(value);
    if (proto === null) {
      return true;
    }
    const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
  }
  exports.isPlainObject = isPlainObject2;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function getRawTag(value) {
    const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    let unmasked = false;
    try {
      value[symToStringTag] = undefined;
      unmasked = true;
    } catch (e) {
    }
    const result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
});

// node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lodash_merge_1 = require_lodash_merge();
  var MAX_LEVEL = 20;
  function merge(...args) {
    let result = args.shift();
    const objects = new WeakMap;
    while (args.length > 0) {
      result = mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
  }
  exports.merge = merge;
  function takeValue(value) {
    if (isArray(value)) {
      return value.slice();
    }
    return value;
  }
  function mergeTwoObjects(one, two, level = 0, objects) {
    let result;
    if (level > MAX_LEVEL) {
      return;
    }
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
      result = takeValue(two);
    } else if (isArray(one)) {
      result = one.slice();
      if (isArray(two)) {
        for (let i = 0, j = two.length;i < j; i++) {
          result.push(takeValue(two[i]));
        }
      } else if (isObject(two)) {
        const keys = Object.keys(two);
        for (let i = 0, j = keys.length;i < j; i++) {
          const key = keys[i];
          result[key] = takeValue(two[key]);
        }
      }
    } else if (isObject(one)) {
      if (isObject(two)) {
        if (!shouldMerge(one, two)) {
          return two;
        }
        result = Object.assign({}, one);
        const keys = Object.keys(two);
        for (let i = 0, j = keys.length;i < j; i++) {
          const key = keys[i];
          const twoValue = two[key];
          if (isPrimitive(twoValue)) {
            if (typeof twoValue === "undefined") {
              delete result[key];
            } else {
              result[key] = twoValue;
            }
          } else {
            const obj1 = result[key];
            const obj2 = twoValue;
            if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
              delete result[key];
            } else {
              if (isObject(obj1) && isObject(obj2)) {
                const arr1 = objects.get(obj1) || [];
                const arr2 = objects.get(obj2) || [];
                arr1.push({ obj: one, key });
                arr2.push({ obj: two, key });
                objects.set(obj1, arr1);
                objects.set(obj2, arr2);
              }
              result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
            }
          }
        }
      } else {
        result = two;
      }
    }
    return result;
  }
  function wasObjectReferenced(obj, key, objects) {
    const arr = objects.get(obj[key]) || [];
    for (let i = 0, j = arr.length;i < j; i++) {
      const info = arr[i];
      if (info.key === key && info.obj === obj) {
        return true;
      }
    }
    return false;
  }
  function isArray(value) {
    return Array.isArray(value);
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isObject(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
  }
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
  }
  function shouldMerge(one, two) {
    if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
      return false;
    }
    return true;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callWithTimeout = exports.TimeoutError = undefined;

  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, TimeoutError.prototype);
    }
  }
  exports.TimeoutError = TimeoutError;
  function callWithTimeout(promise, timeout) {
    let timeoutHandle;
    const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
      timeoutHandle = setTimeout(function timeoutHandler() {
        reject(new TimeoutError("Operation timed out."));
      }, timeout);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    }, (reason) => {
      clearTimeout(timeoutHandle);
      throw reason;
    });
  }
  exports.callWithTimeout = callWithTimeout;
});

// node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isUrlIgnored = exports.urlMatches = undefined;
  function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === "string") {
      return url === urlToMatch;
    } else {
      return !!url.match(urlToMatch);
    }
  }
  exports.urlMatches = urlMatches;
  function isUrlIgnored(url, ignoredUrls) {
    if (!ignoredUrls) {
      return false;
    }
    for (const ignoreUrl of ignoredUrls) {
      if (urlMatches(url, ignoreUrl)) {
        return true;
      }
    }
    return false;
  }
  exports.isUrlIgnored = isUrlIgnored;
});

// node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = undefined;

  class Deferred {
    _promise;
    _resolve;
    _reject;
    constructor() {
      this._promise = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
    }
    get promise() {
      return this._promise;
    }
    resolve(val) {
      this._resolve(val);
    }
    reject(err) {
      this._reject(err);
    }
  }
  exports.Deferred = Deferred;
});

// node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BindOnceFuture = undefined;
  var promise_1 = require_promise();

  class BindOnceFuture {
    _callback;
    _that;
    _isCalled = false;
    _deferred = new promise_1.Deferred;
    constructor(_callback, _that) {
      this._callback = _callback;
      this._that = _that;
    }
    get isCalled() {
      return this._isCalled;
    }
    get promise() {
      return this._deferred.promise;
    }
    call(...args) {
      if (!this._isCalled) {
        this._isCalled = true;
        try {
          Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
        } catch (err) {
          this._deferred.reject(err);
        }
      }
      return this._deferred.promise;
    }
  }
  exports.BindOnceFuture = BindOnceFuture;
});

// node_modules/@opentelemetry/core/build/src/utils/configuration.js
var require_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diagLogLevelFromString = undefined;
  var api_1 = require_src();
  var logLevelMap = {
    ALL: api_1.DiagLogLevel.ALL,
    VERBOSE: api_1.DiagLogLevel.VERBOSE,
    DEBUG: api_1.DiagLogLevel.DEBUG,
    INFO: api_1.DiagLogLevel.INFO,
    WARN: api_1.DiagLogLevel.WARN,
    ERROR: api_1.DiagLogLevel.ERROR,
    NONE: api_1.DiagLogLevel.NONE
  };
  function diagLogLevelFromString(value) {
    if (value == null) {
      return;
    }
    const resolvedLogLevel = logLevelMap[value.toUpperCase()];
    if (resolvedLogLevel == null) {
      api_1.diag.warn(`Unknown log level "${value}", expected one of ${Object.keys(logLevelMap)}, using default`);
      return api_1.DiagLogLevel.INFO;
    }
    return resolvedLogLevel;
  }
  exports.diagLogLevelFromString = diagLogLevelFromString;
});

// node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._export = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  function _export(exporter, arg) {
    return new Promise((resolve) => {
      api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
        exporter.export(arg, (result) => {
          resolve(result);
        });
      });
    });
  }
  exports._export = _export;
});

// node_modules/@opentelemetry/core/build/src/index.js
var require_src3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.internal = exports.diagLogLevelFromString = exports.BindOnceFuture = exports.urlMatches = exports.isUrlIgnored = exports.callWithTimeout = exports.TimeoutError = exports.merge = exports.TraceState = exports.unsuppressTracing = exports.suppressTracing = exports.isTracingSuppressed = exports.setRPCMetadata = exports.getRPCMetadata = exports.deleteRPCMetadata = exports.RPCType = exports.parseTraceParent = exports.W3CTraceContextPropagator = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = exports.CompositePropagator = exports.unrefTimer = exports.otperformance = exports.getStringListFromEnv = exports.getNumberFromEnv = exports.getBooleanFromEnv = exports.getStringFromEnv = exports._globalThis = exports.SDK_INFO = exports.parseKeyPairsIntoRecord = exports.ExportResultCode = exports.timeInputToHrTime = exports.millisToHrTime = exports.isTimeInputHrTime = exports.isTimeInput = exports.hrTimeToTimeStamp = exports.hrTimeToNanoseconds = exports.hrTimeToMilliseconds = exports.hrTimeToMicroseconds = exports.hrTimeDuration = exports.hrTime = exports.getTimeOrigin = exports.addHrTimes = exports.loggingErrorHandler = exports.setGlobalErrorHandler = exports.globalErrorHandler = exports.sanitizeAttributes = exports.isAttributeValue = exports.AnchoredClock = exports.W3CBaggagePropagator = undefined;
  var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
  Object.defineProperty(exports, "W3CBaggagePropagator", { enumerable: true, get: function() {
    return W3CBaggagePropagator_1.W3CBaggagePropagator;
  } });
  var anchored_clock_1 = require_anchored_clock();
  Object.defineProperty(exports, "AnchoredClock", { enumerable: true, get: function() {
    return anchored_clock_1.AnchoredClock;
  } });
  var attributes_1 = require_attributes();
  Object.defineProperty(exports, "isAttributeValue", { enumerable: true, get: function() {
    return attributes_1.isAttributeValue;
  } });
  Object.defineProperty(exports, "sanitizeAttributes", { enumerable: true, get: function() {
    return attributes_1.sanitizeAttributes;
  } });
  var global_error_handler_1 = require_global_error_handler();
  Object.defineProperty(exports, "globalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.globalErrorHandler;
  } });
  Object.defineProperty(exports, "setGlobalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.setGlobalErrorHandler;
  } });
  var logging_error_handler_1 = require_logging_error_handler();
  Object.defineProperty(exports, "loggingErrorHandler", { enumerable: true, get: function() {
    return logging_error_handler_1.loggingErrorHandler;
  } });
  var time_1 = require_time();
  Object.defineProperty(exports, "addHrTimes", { enumerable: true, get: function() {
    return time_1.addHrTimes;
  } });
  Object.defineProperty(exports, "getTimeOrigin", { enumerable: true, get: function() {
    return time_1.getTimeOrigin;
  } });
  Object.defineProperty(exports, "hrTime", { enumerable: true, get: function() {
    return time_1.hrTime;
  } });
  Object.defineProperty(exports, "hrTimeDuration", { enumerable: true, get: function() {
    return time_1.hrTimeDuration;
  } });
  Object.defineProperty(exports, "hrTimeToMicroseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMicroseconds;
  } });
  Object.defineProperty(exports, "hrTimeToMilliseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMilliseconds;
  } });
  Object.defineProperty(exports, "hrTimeToNanoseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToNanoseconds;
  } });
  Object.defineProperty(exports, "hrTimeToTimeStamp", { enumerable: true, get: function() {
    return time_1.hrTimeToTimeStamp;
  } });
  Object.defineProperty(exports, "isTimeInput", { enumerable: true, get: function() {
    return time_1.isTimeInput;
  } });
  Object.defineProperty(exports, "isTimeInputHrTime", { enumerable: true, get: function() {
    return time_1.isTimeInputHrTime;
  } });
  Object.defineProperty(exports, "millisToHrTime", { enumerable: true, get: function() {
    return time_1.millisToHrTime;
  } });
  Object.defineProperty(exports, "timeInputToHrTime", { enumerable: true, get: function() {
    return time_1.timeInputToHrTime;
  } });
  var ExportResult_1 = require_ExportResult();
  Object.defineProperty(exports, "ExportResultCode", { enumerable: true, get: function() {
    return ExportResult_1.ExportResultCode;
  } });
  var utils_1 = require_utils3();
  Object.defineProperty(exports, "parseKeyPairsIntoRecord", { enumerable: true, get: function() {
    return utils_1.parseKeyPairsIntoRecord;
  } });
  var platform_1 = require_platform2();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return platform_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return platform_1._globalThis;
  } });
  Object.defineProperty(exports, "getStringFromEnv", { enumerable: true, get: function() {
    return platform_1.getStringFromEnv;
  } });
  Object.defineProperty(exports, "getBooleanFromEnv", { enumerable: true, get: function() {
    return platform_1.getBooleanFromEnv;
  } });
  Object.defineProperty(exports, "getNumberFromEnv", { enumerable: true, get: function() {
    return platform_1.getNumberFromEnv;
  } });
  Object.defineProperty(exports, "getStringListFromEnv", { enumerable: true, get: function() {
    return platform_1.getStringListFromEnv;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return platform_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return platform_1.unrefTimer;
  } });
  var composite_1 = require_composite();
  Object.defineProperty(exports, "CompositePropagator", { enumerable: true, get: function() {
    return composite_1.CompositePropagator;
  } });
  var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
  Object.defineProperty(exports, "TRACE_PARENT_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
  } });
  Object.defineProperty(exports, "TRACE_STATE_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
  } });
  Object.defineProperty(exports, "W3CTraceContextPropagator", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
  } });
  Object.defineProperty(exports, "parseTraceParent", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.parseTraceParent;
  } });
  var rpc_metadata_1 = require_rpc_metadata();
  Object.defineProperty(exports, "RPCType", { enumerable: true, get: function() {
    return rpc_metadata_1.RPCType;
  } });
  Object.defineProperty(exports, "deleteRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.deleteRPCMetadata;
  } });
  Object.defineProperty(exports, "getRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.getRPCMetadata;
  } });
  Object.defineProperty(exports, "setRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.setRPCMetadata;
  } });
  var suppress_tracing_1 = require_suppress_tracing();
  Object.defineProperty(exports, "isTracingSuppressed", { enumerable: true, get: function() {
    return suppress_tracing_1.isTracingSuppressed;
  } });
  Object.defineProperty(exports, "suppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.suppressTracing;
  } });
  Object.defineProperty(exports, "unsuppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.unsuppressTracing;
  } });
  var TraceState_1 = require_TraceState();
  Object.defineProperty(exports, "TraceState", { enumerable: true, get: function() {
    return TraceState_1.TraceState;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  Object.defineProperty(exports, "callWithTimeout", { enumerable: true, get: function() {
    return timeout_1.callWithTimeout;
  } });
  var url_1 = require_url();
  Object.defineProperty(exports, "isUrlIgnored", { enumerable: true, get: function() {
    return url_1.isUrlIgnored;
  } });
  Object.defineProperty(exports, "urlMatches", { enumerable: true, get: function() {
    return url_1.urlMatches;
  } });
  var callback_1 = require_callback();
  Object.defineProperty(exports, "BindOnceFuture", { enumerable: true, get: function() {
    return callback_1.BindOnceFuture;
  } });
  var configuration_1 = require_configuration();
  Object.defineProperty(exports, "diagLogLevelFromString", { enumerable: true, get: function() {
    return configuration_1.diagLogLevelFromString;
  } });
  var exporter_1 = require_exporter();
  exports.internal = {
    _export: exporter_1._export
  };
});

// node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeverityNumber = undefined;
  var SeverityNumber;
  (function(SeverityNumber2) {
    SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
    SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
    SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
    SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
    SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
    SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
    SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
    SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
    SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
    SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
    SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
    SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
    SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
    SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
    SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
    SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
    SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
    SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
    SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
    SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
    SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
    SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
    SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
    SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
  })(SeverityNumber = exports.SeverityNumber || (exports.SeverityNumber = {}));
});

// node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER = exports.NoopLogger = undefined;

  class NoopLogger {
    emit(_logRecord) {
    }
  }
  exports.NoopLogger = NoopLogger;
  exports.NOOP_LOGGER = new NoopLogger;
});

// node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER_PROVIDER = exports.NoopLoggerProvider = undefined;
  var NoopLogger_1 = require_NoopLogger();

  class NoopLoggerProvider {
    getLogger(_name, _version, _options) {
      return new NoopLogger_1.NoopLogger;
    }
  }
  exports.NoopLoggerProvider = NoopLoggerProvider;
  exports.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider;
});

// node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js
var require_ProxyLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyLogger = undefined;
  var NoopLogger_1 = require_NoopLogger();

  class ProxyLogger {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    emit(logRecord) {
      this._getLogger().emit(logRecord);
    }
    _getLogger() {
      if (this._delegate) {
        return this._delegate;
      }
      const logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
      if (!logger) {
        return NoopLogger_1.NOOP_LOGGER;
      }
      this._delegate = logger;
      return this._delegate;
    }
  }
  exports.ProxyLogger = ProxyLogger;
});

// node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js
var require_ProxyLoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyLoggerProvider = undefined;
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  var ProxyLogger_1 = require_ProxyLogger();

  class ProxyLoggerProvider {
    getLogger(name, version, options) {
      var _a;
      return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== undefined ? _a : new ProxyLogger_1.ProxyLogger(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateLogger(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getLogger(name, version, options);
    }
  }
  exports.ProxyLoggerProvider = ProxyLoggerProvider;
});

// node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var globalThis_1 = require_globalThis3();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
});

// node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var node_1 = require_node3();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
});

// node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_LOGS_API_KEY = undefined;
  var platform_1 = require_platform3();
  exports.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
  exports._global = platform_1._globalThis;
  function makeGetter(requiredVersion, instance, fallback) {
    return (version) => version === requiredVersion ? instance : fallback;
  }
  exports.makeGetter = makeGetter;
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
});

// node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogsAPI = undefined;
  var global_utils_1 = require_global_utils2();
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();

  class LogsAPI {
    constructor() {
      this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new LogsAPI;
      }
      return this._instance;
    }
    setGlobalLoggerProvider(provider) {
      if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
        return this.getLoggerProvider();
      }
      global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
      this._proxyLoggerProvider.setDelegate(provider);
      return provider;
    }
    getLoggerProvider() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a === undefined ? undefined : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== undefined ? _b : this._proxyLoggerProvider;
    }
    getLogger(name, version, options) {
      return this.getLoggerProvider().getLogger(name, version, options);
    }
    disable() {
      delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
      this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider;
    }
  }
  exports.LogsAPI = LogsAPI;
});

// node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logs = exports.ProxyLoggerProvider = exports.ProxyLogger = exports.NoopLoggerProvider = exports.NOOP_LOGGER_PROVIDER = exports.NoopLogger = exports.NOOP_LOGGER = exports.SeverityNumber = undefined;
  var LogRecord_1 = require_LogRecord();
  Object.defineProperty(exports, "SeverityNumber", { enumerable: true, get: function() {
    return LogRecord_1.SeverityNumber;
  } });
  var NoopLogger_1 = require_NoopLogger();
  Object.defineProperty(exports, "NOOP_LOGGER", { enumerable: true, get: function() {
    return NoopLogger_1.NOOP_LOGGER;
  } });
  Object.defineProperty(exports, "NoopLogger", { enumerable: true, get: function() {
    return NoopLogger_1.NoopLogger;
  } });
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  Object.defineProperty(exports, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
  } });
  Object.defineProperty(exports, "NoopLoggerProvider", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NoopLoggerProvider;
  } });
  var ProxyLogger_1 = require_ProxyLogger();
  Object.defineProperty(exports, "ProxyLogger", { enumerable: true, get: function() {
    return ProxyLogger_1.ProxyLogger;
  } });
  var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
  Object.defineProperty(exports, "ProxyLoggerProvider", { enumerable: true, get: function() {
    return ProxyLoggerProvider_1.ProxyLoggerProvider;
  } });
  var logs_1 = require_logs();
  exports.logs = logs_1.LogsAPI.getInstance();
});

// node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  function defaultServiceName() {
    return `unknown_service:${process.argv0}`;
  }
  exports.defaultServiceName = defaultServiceName;
});

// node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  var default_service_name_1 = require_default_service_name();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return default_service_name_1.defaultServiceName;
  } });
});

// node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  var node_1 = require_node4();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return node_1.defaultServiceName;
  } });
});

// node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.identity = exports.isPromiseLike = undefined;
  var isPromiseLike = (val) => {
    return val !== null && typeof val === "object" && typeof val.then === "function";
  };
  exports.isPromiseLike = isPromiseLike;
  function identity(_) {
    return _;
  }
  exports.identity = identity;
});

// node_modules/@opentelemetry/resources/build/src/ResourceImpl.js
var require_ResourceImpl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultResource = exports.emptyResource = exports.resourceFromDetectedResource = exports.resourceFromAttributes = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var semantic_conventions_1 = require_src2();
  var platform_1 = require_platform4();
  var utils_1 = require_utils5();

  class ResourceImpl {
    _rawAttributes;
    _asyncAttributesPending = false;
    _memoizedAttributes;
    static FromAttributeList(attributes) {
      const res = new ResourceImpl({});
      res._rawAttributes = guardedRawAttributes(attributes);
      res._asyncAttributesPending = attributes.filter(([_, val]) => (0, utils_1.isPromiseLike)(val)).length > 0;
      return res;
    }
    constructor(resource) {
      const attributes = resource.attributes ?? {};
      this._rawAttributes = Object.entries(attributes).map(([k, v]) => {
        if ((0, utils_1.isPromiseLike)(v)) {
          this._asyncAttributesPending = true;
        }
        return [k, v];
      });
      this._rawAttributes = guardedRawAttributes(this._rawAttributes);
    }
    get asyncAttributesPending() {
      return this._asyncAttributesPending;
    }
    async waitForAsyncAttributes() {
      if (!this.asyncAttributesPending) {
        return;
      }
      for (let i = 0;i < this._rawAttributes.length; i++) {
        const [k, v] = this._rawAttributes[i];
        this._rawAttributes[i] = [k, (0, utils_1.isPromiseLike)(v) ? await v : v];
      }
      this._asyncAttributesPending = false;
    }
    get attributes() {
      if (this.asyncAttributesPending) {
        api_1.diag.error("Accessing resource attributes before async attributes settled");
      }
      if (this._memoizedAttributes) {
        return this._memoizedAttributes;
      }
      const attrs = {};
      for (const [k, v] of this._rawAttributes) {
        if ((0, utils_1.isPromiseLike)(v)) {
          api_1.diag.debug(`Unsettled resource attribute ${k} skipped`);
          continue;
        }
        if (v != null) {
          attrs[k] ??= v;
        }
      }
      if (!this._asyncAttributesPending) {
        this._memoizedAttributes = attrs;
      }
      return attrs;
    }
    getRawAttributes() {
      return this._rawAttributes;
    }
    merge(resource) {
      if (resource == null)
        return this;
      return ResourceImpl.FromAttributeList([
        ...resource.getRawAttributes(),
        ...this.getRawAttributes()
      ]);
    }
  }
  function resourceFromAttributes(attributes) {
    return ResourceImpl.FromAttributeList(Object.entries(attributes));
  }
  exports.resourceFromAttributes = resourceFromAttributes;
  function resourceFromDetectedResource(detectedResource) {
    return new ResourceImpl(detectedResource);
  }
  exports.resourceFromDetectedResource = resourceFromDetectedResource;
  function emptyResource() {
    return resourceFromAttributes({});
  }
  exports.emptyResource = emptyResource;
  function defaultResource() {
    return resourceFromAttributes({
      [semantic_conventions_1.ATTR_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.ATTR_TELEMETRY_SDK_LANGUAGE],
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.ATTR_TELEMETRY_SDK_NAME],
      [semantic_conventions_1.ATTR_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.ATTR_TELEMETRY_SDK_VERSION]
    });
  }
  exports.defaultResource = defaultResource;
  function guardedRawAttributes(attributes) {
    return attributes.map(([k, v]) => {
      if ((0, utils_1.isPromiseLike)(v)) {
        return [
          k,
          v.catch((err) => {
            api_1.diag.debug("promise rejection for resource attribute: %s - %s", k, err);
            return;
          })
        ];
      }
      return [k, v];
    });
  }
});

// node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.detectResources = undefined;
  var api_1 = require_src();
  var ResourceImpl_1 = require_ResourceImpl();
  var detectResources = (config = {}) => {
    const resources = (config.detectors || []).map((d) => {
      try {
        const resource = (0, ResourceImpl_1.resourceFromDetectedResource)(d.detect(config));
        api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
        return resource;
      } catch (e) {
        api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`);
        return (0, ResourceImpl_1.emptyResource)();
      }
    });
    return resources.reduce((acc, resource) => acc.merge(resource), (0, ResourceImpl_1.emptyResource)());
  };
  exports.detectResources = detectResources;
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.envDetector = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src2();
  var core_1 = require_src3();

  class EnvDetector {
    _MAX_LENGTH = 255;
    _COMMA_SEPARATOR = ",";
    _LABEL_KEY_VALUE_SPLITTER = "=";
    _ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
    _ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
    detect(_config) {
      const attributes = {};
      const rawAttributes = (0, core_1.getStringFromEnv)("OTEL_RESOURCE_ATTRIBUTES");
      const serviceName = (0, core_1.getStringFromEnv)("OTEL_SERVICE_NAME");
      if (rawAttributes) {
        try {
          const parsedAttributes = this._parseResourceAttributes(rawAttributes);
          Object.assign(attributes, parsedAttributes);
        } catch (e) {
          api_1.diag.debug(`EnvDetector failed: ${e.message}`);
        }
      }
      if (serviceName) {
        attributes[semantic_conventions_1.ATTR_SERVICE_NAME] = serviceName;
      }
      return { attributes };
    }
    _parseResourceAttributes(rawEnvAttributes) {
      if (!rawEnvAttributes)
        return {};
      const attributes = {};
      const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
      for (const rawAttribute of rawAttributes) {
        const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
        if (keyValuePair.length !== 2) {
          continue;
        }
        let [key, value] = keyValuePair;
        key = key.trim();
        value = value.trim().split(/^"|"$/).join("");
        if (!this._isValidAndNotEmpty(key)) {
          throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
        }
        if (!this._isValid(value)) {
          throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
        }
        attributes[key] = decodeURIComponent(value);
      }
      return attributes;
    }
    _isValid(name) {
      return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
    }
    _isBaggageOctetString(str) {
      for (let i = 0;i < str.length; i++) {
        const ch = str.charCodeAt(i);
        if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {
          return false;
        }
      }
      return true;
    }
    _isValidAndNotEmpty(str) {
      return str.length > 0 && this._isValid(str);
    }
  }
  exports.envDetector = new EnvDetector;
});

// node_modules/@opentelemetry/resources/build/src/semconv.js
var require_semconv2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ATTR_WEBENGINE_VERSION = exports.ATTR_WEBENGINE_NAME = exports.ATTR_WEBENGINE_DESCRIPTION = exports.ATTR_SERVICE_NAMESPACE = exports.ATTR_SERVICE_INSTANCE_ID = exports.ATTR_PROCESS_RUNTIME_VERSION = exports.ATTR_PROCESS_RUNTIME_NAME = exports.ATTR_PROCESS_RUNTIME_DESCRIPTION = exports.ATTR_PROCESS_PID = exports.ATTR_PROCESS_OWNER = exports.ATTR_PROCESS_EXECUTABLE_PATH = exports.ATTR_PROCESS_EXECUTABLE_NAME = exports.ATTR_PROCESS_COMMAND_ARGS = exports.ATTR_PROCESS_COMMAND = exports.ATTR_OS_VERSION = exports.ATTR_OS_TYPE = exports.ATTR_K8S_POD_NAME = exports.ATTR_K8S_NAMESPACE_NAME = exports.ATTR_K8S_DEPLOYMENT_NAME = exports.ATTR_K8S_CLUSTER_NAME = exports.ATTR_HOST_TYPE = exports.ATTR_HOST_NAME = exports.ATTR_HOST_IMAGE_VERSION = exports.ATTR_HOST_IMAGE_NAME = exports.ATTR_HOST_IMAGE_ID = exports.ATTR_HOST_ID = exports.ATTR_HOST_ARCH = exports.ATTR_CONTAINER_NAME = exports.ATTR_CONTAINER_IMAGE_TAGS = exports.ATTR_CONTAINER_IMAGE_NAME = exports.ATTR_CONTAINER_ID = exports.ATTR_CLOUD_REGION = exports.ATTR_CLOUD_PROVIDER = exports.ATTR_CLOUD_AVAILABILITY_ZONE = exports.ATTR_CLOUD_ACCOUNT_ID = undefined;
  exports.ATTR_CLOUD_ACCOUNT_ID = "cloud.account.id";
  exports.ATTR_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  exports.ATTR_CLOUD_PROVIDER = "cloud.provider";
  exports.ATTR_CLOUD_REGION = "cloud.region";
  exports.ATTR_CONTAINER_ID = "container.id";
  exports.ATTR_CONTAINER_IMAGE_NAME = "container.image.name";
  exports.ATTR_CONTAINER_IMAGE_TAGS = "container.image.tags";
  exports.ATTR_CONTAINER_NAME = "container.name";
  exports.ATTR_HOST_ARCH = "host.arch";
  exports.ATTR_HOST_ID = "host.id";
  exports.ATTR_HOST_IMAGE_ID = "host.image.id";
  exports.ATTR_HOST_IMAGE_NAME = "host.image.name";
  exports.ATTR_HOST_IMAGE_VERSION = "host.image.version";
  exports.ATTR_HOST_NAME = "host.name";
  exports.ATTR_HOST_TYPE = "host.type";
  exports.ATTR_K8S_CLUSTER_NAME = "k8s.cluster.name";
  exports.ATTR_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  exports.ATTR_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  exports.ATTR_K8S_POD_NAME = "k8s.pod.name";
  exports.ATTR_OS_TYPE = "os.type";
  exports.ATTR_OS_VERSION = "os.version";
  exports.ATTR_PROCESS_COMMAND = "process.command";
  exports.ATTR_PROCESS_COMMAND_ARGS = "process.command_args";
  exports.ATTR_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  exports.ATTR_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  exports.ATTR_PROCESS_OWNER = "process.owner";
  exports.ATTR_PROCESS_PID = "process.pid";
  exports.ATTR_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  exports.ATTR_PROCESS_RUNTIME_NAME = "process.runtime.name";
  exports.ATTR_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  exports.ATTR_SERVICE_INSTANCE_ID = "service.instance.id";
  exports.ATTR_SERVICE_NAMESPACE = "service.namespace";
  exports.ATTR_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.ATTR_WEBENGINE_NAME = "webengine.name";
  exports.ATTR_WEBENGINE_VERSION = "webengine.version";
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.execAsync = undefined;
  var child_process = __require("child_process");
  var util = __require("util");
  exports.execAsync = util.promisify(child_process.exec);
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    try {
      const result = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
      const idLine = result.stdout.split(`
`).find((line) => line.includes("IOPlatformUUID"));
      if (!idLine) {
        return;
      }
      const parts = idLine.split('" = "');
      if (parts.length === 2) {
        return parts[1].slice(0, -1);
      }
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var fs_1 = __require("fs");
  var api_1 = require_src();
  async function getMachineId() {
    const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
    for (const path of paths) {
      try {
        const result = await fs_1.promises.readFile(path, { encoding: "utf8" });
        return result.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var fs_1 = __require("fs");
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    try {
      const result = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
      return result.trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    try {
      const result = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
      return result.stdout.trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var process2 = __require("process");
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
    let command = "%windir%\\System32\\REG.exe";
    if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
      command = "%windir%\\sysnative\\cmd.exe /c " + command;
    }
    try {
      const result = await (0, execAsync_1.execAsync)(`${command} ${args}`);
      const parts = result.stdout.split("REG_SZ");
      if (parts.length === 2) {
        return parts[1].trim();
      }
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return;
  }
  exports.getMachineId = getMachineId;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var api_1 = require_src();
  async function getMachineId() {
    api_1.diag.debug("could not read machine-id: unsupported platform");
    return;
  }
  exports.getMachineId = getMachineId;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var process2 = __require("process");
  var getMachineIdImpl;
  async function getMachineId() {
    if (!getMachineIdImpl) {
      switch (process2.platform) {
        case "darwin":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_darwin(), 1))).getMachineId;
          break;
        case "linux":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_linux(), 1))).getMachineId;
          break;
        case "freebsd":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_bsd(), 1))).getMachineId;
          break;
        case "win32":
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_win(), 1))).getMachineId;
          break;
        default:
          getMachineIdImpl = (await Promise.resolve().then(() => __toESM(require_getMachineId_unsupported(), 1))).getMachineId;
          break;
      }
    }
    return getMachineIdImpl();
  }
  exports.getMachineId = getMachineId;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizeType = exports.normalizeArch = undefined;
  var normalizeArch = (nodeArchString) => {
    switch (nodeArchString) {
      case "arm":
        return "arm32";
      case "ppc":
        return "ppc32";
      case "x64":
        return "amd64";
      default:
        return nodeArchString;
    }
  };
  exports.normalizeArch = normalizeArch;
  var normalizeType = (nodePlatform) => {
    switch (nodePlatform) {
      case "sunos":
        return "solaris";
      case "win32":
        return "windows";
      default:
        return nodePlatform;
    }
  };
  exports.normalizeType = normalizeType;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hostDetector = undefined;
  var semconv_1 = require_semconv2();
  var os_1 = __require("os");
  var getMachineId_1 = require_getMachineId();
  var utils_1 = require_utils6();

  class HostDetector {
    detect(_config) {
      const attributes = {
        [semconv_1.ATTR_HOST_NAME]: (0, os_1.hostname)(),
        [semconv_1.ATTR_HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)()),
        [semconv_1.ATTR_HOST_ID]: (0, getMachineId_1.getMachineId)()
      };
      return { attributes };
    }
  }
  exports.hostDetector = new HostDetector;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.osDetector = undefined;
  var semconv_1 = require_semconv2();
  var os_1 = __require("os");
  var utils_1 = require_utils6();

  class OSDetector {
    detect(_config) {
      const attributes = {
        [semconv_1.ATTR_OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
        [semconv_1.ATTR_OS_VERSION]: (0, os_1.release)()
      };
      return { attributes };
    }
  }
  exports.osDetector = new OSDetector;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.processDetector = undefined;
  var api_1 = require_src();
  var semconv_1 = require_semconv2();
  var os = __require("os");

  class ProcessDetector {
    detect(_config) {
      const attributes = {
        [semconv_1.ATTR_PROCESS_PID]: process.pid,
        [semconv_1.ATTR_PROCESS_EXECUTABLE_NAME]: process.title,
        [semconv_1.ATTR_PROCESS_EXECUTABLE_PATH]: process.execPath,
        [semconv_1.ATTR_PROCESS_COMMAND_ARGS]: [
          process.argv[0],
          ...process.execArgv,
          ...process.argv.slice(1)
        ],
        [semconv_1.ATTR_PROCESS_RUNTIME_VERSION]: process.versions.node,
        [semconv_1.ATTR_PROCESS_RUNTIME_NAME]: "nodejs",
        [semconv_1.ATTR_PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
      };
      if (process.argv.length > 1) {
        attributes[semconv_1.ATTR_PROCESS_COMMAND] = process.argv[1];
      }
      try {
        const userInfo = os.userInfo();
        attributes[semconv_1.ATTR_PROCESS_OWNER] = userInfo.username;
      } catch (e) {
        api_1.diag.debug(`error obtaining process owner: ${e}`);
      }
      return { attributes };
    }
  }
  exports.processDetector = new ProcessDetector;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetector.js
var require_ServiceInstanceIdDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetector = undefined;
  var semconv_1 = require_semconv2();
  var crypto_1 = __require("crypto");

  class ServiceInstanceIdDetector {
    detect(_config) {
      return {
        attributes: {
          [semconv_1.ATTR_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
        }
      };
    }
  }
  exports.serviceInstanceIdDetector = new ServiceInstanceIdDetector;
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = undefined;
  var HostDetector_1 = require_HostDetector();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return HostDetector_1.hostDetector;
  } });
  var OSDetector_1 = require_OSDetector();
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return OSDetector_1.osDetector;
  } });
  var ProcessDetector_1 = require_ProcessDetector();
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return ProcessDetector_1.processDetector;
  } });
  var ServiceInstanceIdDetector_1 = require_ServiceInstanceIdDetector();
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return ServiceInstanceIdDetector_1.serviceInstanceIdDetector;
  } });
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = undefined;
  var node_1 = require_node5();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return node_1.hostDetector;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return node_1.osDetector;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return node_1.processDetector;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return node_1.serviceInstanceIdDetector;
  } });
});

// node_modules/@opentelemetry/resources/build/src/detectors/NoopDetector.js
var require_NoopDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noopDetector = exports.NoopDetector = undefined;

  class NoopDetector {
    detect() {
      return {
        attributes: {}
      };
    }
  }
  exports.NoopDetector = NoopDetector;
  exports.noopDetector = new NoopDetector;
});

// node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noopDetector = exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = exports.envDetector = undefined;
  var EnvDetector_1 = require_EnvDetector();
  Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
    return EnvDetector_1.envDetector;
  } });
  var platform_1 = require_platform5();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return platform_1.hostDetector;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return platform_1.osDetector;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return platform_1.processDetector;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return platform_1.serviceInstanceIdDetector;
  } });
  var NoopDetector_1 = require_NoopDetector();
  Object.defineProperty(exports, "noopDetector", { enumerable: true, get: function() {
    return NoopDetector_1.noopDetector;
  } });
});

// node_modules/@opentelemetry/resources/build/src/index.js
var require_src5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = exports.emptyResource = exports.defaultResource = exports.resourceFromAttributes = exports.serviceInstanceIdDetector = exports.processDetector = exports.osDetector = exports.hostDetector = exports.envDetector = exports.detectResources = undefined;
  var detect_resources_1 = require_detect_resources();
  Object.defineProperty(exports, "detectResources", { enumerable: true, get: function() {
    return detect_resources_1.detectResources;
  } });
  var detectors_1 = require_detectors();
  Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
    return detectors_1.envDetector;
  } });
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return detectors_1.hostDetector;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return detectors_1.osDetector;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return detectors_1.processDetector;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetector", { enumerable: true, get: function() {
    return detectors_1.serviceInstanceIdDetector;
  } });
  var ResourceImpl_1 = require_ResourceImpl();
  Object.defineProperty(exports, "resourceFromAttributes", { enumerable: true, get: function() {
    return ResourceImpl_1.resourceFromAttributes;
  } });
  Object.defineProperty(exports, "defaultResource", { enumerable: true, get: function() {
    return ResourceImpl_1.defaultResource;
  } });
  Object.defineProperty(exports, "emptyResource", { enumerable: true, get: function() {
    return ResourceImpl_1.emptyResource;
  } });
  var platform_1 = require_platform4();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return platform_1.defaultServiceName;
  } });
});

// node_modules/@opentelemetry/sdk-logs/build/src/LogRecord.js
var require_LogRecord2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogRecord = undefined;
  var api_1 = require_src();
  var api = require_src();
  var core_1 = require_src3();

  class LogRecord {
    hrTime;
    hrTimeObserved;
    spanContext;
    resource;
    instrumentationScope;
    attributes = {};
    _severityText;
    _severityNumber;
    _body;
    totalAttributesCount = 0;
    _isReadonly = false;
    _logRecordLimits;
    set severityText(severityText) {
      if (this._isLogRecordReadonly()) {
        return;
      }
      this._severityText = severityText;
    }
    get severityText() {
      return this._severityText;
    }
    set severityNumber(severityNumber) {
      if (this._isLogRecordReadonly()) {
        return;
      }
      this._severityNumber = severityNumber;
    }
    get severityNumber() {
      return this._severityNumber;
    }
    set body(body) {
      if (this._isLogRecordReadonly()) {
        return;
      }
      this._body = body;
    }
    get body() {
      return this._body;
    }
    get droppedAttributesCount() {
      return this.totalAttributesCount - Object.keys(this.attributes).length;
    }
    constructor(_sharedState, instrumentationScope, logRecord) {
      const { timestamp, observedTimestamp, severityNumber, severityText, body, attributes = {}, context } = logRecord;
      const now = Date.now();
      this.hrTime = (0, core_1.timeInputToHrTime)(timestamp ?? now);
      this.hrTimeObserved = (0, core_1.timeInputToHrTime)(observedTimestamp ?? now);
      if (context) {
        const spanContext = api.trace.getSpanContext(context);
        if (spanContext && api.isSpanContextValid(spanContext)) {
          this.spanContext = spanContext;
        }
      }
      this.severityNumber = severityNumber;
      this.severityText = severityText;
      this.body = body;
      this.resource = _sharedState.resource;
      this.instrumentationScope = instrumentationScope;
      this._logRecordLimits = _sharedState.logRecordLimits;
      this.setAttributes(attributes);
    }
    setAttribute(key, value) {
      if (this._isLogRecordReadonly()) {
        return this;
      }
      if (value === null) {
        return this;
      }
      if (key.length === 0) {
        api.diag.warn(`Invalid attribute key: ${key}`);
        return this;
      }
      if (!(0, core_1.isAttributeValue)(value) && !(typeof value === "object" && !Array.isArray(value) && Object.keys(value).length > 0)) {
        api.diag.warn(`Invalid attribute value set for key: ${key}`);
        return this;
      }
      this.totalAttributesCount += 1;
      if (Object.keys(this.attributes).length >= this._logRecordLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
        if (this.droppedAttributesCount === 1) {
          api.diag.warn("Dropping extra attributes.");
        }
        return this;
      }
      if ((0, core_1.isAttributeValue)(value)) {
        this.attributes[key] = this._truncateToSize(value);
      } else {
        this.attributes[key] = value;
      }
      return this;
    }
    setAttributes(attributes) {
      for (const [k, v] of Object.entries(attributes)) {
        this.setAttribute(k, v);
      }
      return this;
    }
    setBody(body) {
      this.body = body;
      return this;
    }
    setSeverityNumber(severityNumber) {
      this.severityNumber = severityNumber;
      return this;
    }
    setSeverityText(severityText) {
      this.severityText = severityText;
      return this;
    }
    _makeReadonly() {
      this._isReadonly = true;
    }
    _truncateToSize(value) {
      const limit = this._logRecordLimits.attributeValueLengthLimit;
      if (limit <= 0) {
        api.diag.warn(`Attribute value limit must be positive, got ${limit}`);
        return value;
      }
      if (typeof value === "string") {
        return this._truncateToLimitUtil(value, limit);
      }
      if (Array.isArray(value)) {
        return value.map((val) => typeof val === "string" ? this._truncateToLimitUtil(val, limit) : val);
      }
      return value;
    }
    _truncateToLimitUtil(value, limit) {
      if (value.length <= limit) {
        return value;
      }
      return value.substring(0, limit);
    }
    _isLogRecordReadonly() {
      if (this._isReadonly) {
        api_1.diag.warn("Can not execute the operation on emitted log record");
      }
      return this._isReadonly;
    }
  }
  exports.LogRecord = LogRecord;
});

// node_modules/@opentelemetry/sdk-logs/build/src/Logger.js
var require_Logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Logger = undefined;
  var api_1 = require_src();
  var LogRecord_1 = require_LogRecord2();

  class Logger {
    instrumentationScope;
    _sharedState;
    constructor(instrumentationScope, _sharedState) {
      this.instrumentationScope = instrumentationScope;
      this._sharedState = _sharedState;
    }
    emit(logRecord) {
      const currentContext = logRecord.context || api_1.context.active();
      const logRecordInstance = new LogRecord_1.LogRecord(this._sharedState, this.instrumentationScope, {
        context: currentContext,
        ...logRecord
      });
      this._sharedState.activeProcessor.onEmit(logRecordInstance, currentContext);
      logRecordInstance._makeReadonly();
    }
  }
  exports.Logger = Logger;
});

// node_modules/@opentelemetry/sdk-logs/build/src/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconfigureLimits = exports.loadDefaultConfig = undefined;
  var core_1 = require_src3();
  function loadDefaultConfig() {
    return {
      forceFlushTimeoutMillis: 30000,
      logRecordLimits: {
        attributeValueLengthLimit: (0, core_1.getNumberFromEnv)("OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity,
        attributeCountLimit: (0, core_1.getNumberFromEnv)("OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT") ?? 128
      },
      includeTraceContext: true
    };
  }
  exports.loadDefaultConfig = loadDefaultConfig;
  function reconfigureLimits(logRecordLimits) {
    return {
      attributeCountLimit: logRecordLimits.attributeCountLimit ?? (0, core_1.getNumberFromEnv)("OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT") ?? (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? 128,
      attributeValueLengthLimit: logRecordLimits.attributeValueLengthLimit ?? (0, core_1.getNumberFromEnv)("OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity
    };
  }
  exports.reconfigureLimits = reconfigureLimits;
});

// node_modules/@opentelemetry/sdk-logs/build/src/export/NoopLogRecordProcessor.js
var require_NoopLogRecordProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopLogRecordProcessor = undefined;

  class NoopLogRecordProcessor {
    forceFlush() {
      return Promise.resolve();
    }
    onEmit(_logRecord, _context) {
    }
    shutdown() {
      return Promise.resolve();
    }
  }
  exports.NoopLogRecordProcessor = NoopLogRecordProcessor;
});

// node_modules/@opentelemetry/sdk-logs/build/src/MultiLogRecordProcessor.js
var require_MultiLogRecordProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiLogRecordProcessor = undefined;
  var core_1 = require_src3();

  class MultiLogRecordProcessor {
    processors;
    forceFlushTimeoutMillis;
    constructor(processors, forceFlushTimeoutMillis) {
      this.processors = processors;
      this.forceFlushTimeoutMillis = forceFlushTimeoutMillis;
    }
    async forceFlush() {
      const timeout = this.forceFlushTimeoutMillis;
      await Promise.all(this.processors.map((processor) => (0, core_1.callWithTimeout)(processor.forceFlush(), timeout)));
    }
    onEmit(logRecord, context) {
      this.processors.forEach((processors) => processors.onEmit(logRecord, context));
    }
    async shutdown() {
      await Promise.all(this.processors.map((processor) => processor.shutdown()));
    }
  }
  exports.MultiLogRecordProcessor = MultiLogRecordProcessor;
});

// node_modules/@opentelemetry/sdk-logs/build/src/internal/LoggerProviderSharedState.js
var require_LoggerProviderSharedState = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LoggerProviderSharedState = undefined;
  var NoopLogRecordProcessor_1 = require_NoopLogRecordProcessor();
  var MultiLogRecordProcessor_1 = require_MultiLogRecordProcessor();

  class LoggerProviderSharedState {
    resource;
    forceFlushTimeoutMillis;
    logRecordLimits;
    processors;
    loggers = new Map;
    activeProcessor;
    registeredLogRecordProcessors = [];
    constructor(resource, forceFlushTimeoutMillis, logRecordLimits, processors) {
      this.resource = resource;
      this.forceFlushTimeoutMillis = forceFlushTimeoutMillis;
      this.logRecordLimits = logRecordLimits;
      this.processors = processors;
      if (processors.length > 0) {
        this.registeredLogRecordProcessors = processors;
        this.activeProcessor = new MultiLogRecordProcessor_1.MultiLogRecordProcessor(this.registeredLogRecordProcessors, this.forceFlushTimeoutMillis);
      } else {
        this.activeProcessor = new NoopLogRecordProcessor_1.NoopLogRecordProcessor;
      }
    }
  }
  exports.LoggerProviderSharedState = LoggerProviderSharedState;
});

// node_modules/@opentelemetry/sdk-logs/build/src/LoggerProvider.js
var require_LoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LoggerProvider = exports.DEFAULT_LOGGER_NAME = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var resources_1 = require_src5();
  var core_1 = require_src3();
  var Logger_1 = require_Logger();
  var config_1 = require_config();
  var LoggerProviderSharedState_1 = require_LoggerProviderSharedState();
  var MultiLogRecordProcessor_1 = require_MultiLogRecordProcessor();
  exports.DEFAULT_LOGGER_NAME = "unknown";

  class LoggerProvider {
    _shutdownOnce;
    _sharedState;
    constructor(config = {}) {
      const mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), config);
      const resource = config.resource ?? (0, resources_1.defaultResource)();
      this._sharedState = new LoggerProviderSharedState_1.LoggerProviderSharedState(resource, mergedConfig.forceFlushTimeoutMillis, (0, config_1.reconfigureLimits)(mergedConfig.logRecordLimits), config?.processors ?? []);
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
    }
    getLogger(name, version, options) {
      if (this._shutdownOnce.isCalled) {
        api_1.diag.warn("A shutdown LoggerProvider cannot provide a Logger");
        return api_logs_1.NOOP_LOGGER;
      }
      if (!name) {
        api_1.diag.warn("Logger requested without instrumentation scope name.");
      }
      const loggerName = name || exports.DEFAULT_LOGGER_NAME;
      const key = `${loggerName}@${version || ""}:${options?.schemaUrl || ""}`;
      if (!this._sharedState.loggers.has(key)) {
        this._sharedState.loggers.set(key, new Logger_1.Logger({ name: loggerName, version, schemaUrl: options?.schemaUrl }, this._sharedState));
      }
      return this._sharedState.loggers.get(key);
    }
    addLogRecordProcessor(processor) {
      if (this._sharedState.registeredLogRecordProcessors.length === 0) {
        this._sharedState.activeProcessor.shutdown().catch((err) => api_1.diag.error("Error while trying to shutdown current log record processor", err));
      }
      this._sharedState.registeredLogRecordProcessors.push(processor);
      this._sharedState.activeProcessor = new MultiLogRecordProcessor_1.MultiLogRecordProcessor(this._sharedState.registeredLogRecordProcessors, this._sharedState.forceFlushTimeoutMillis);
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled) {
        api_1.diag.warn("invalid attempt to force flush after LoggerProvider shutdown");
        return this._shutdownOnce.promise;
      }
      return this._sharedState.activeProcessor.forceFlush();
    }
    shutdown() {
      if (this._shutdownOnce.isCalled) {
        api_1.diag.warn("shutdown may only be called once per LoggerProvider");
        return this._shutdownOnce.promise;
      }
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._sharedState.activeProcessor.shutdown();
    }
  }
  exports.LoggerProvider = LoggerProvider;
});

// node_modules/@opentelemetry/sdk-logs/build/src/export/ConsoleLogRecordExporter.js
var require_ConsoleLogRecordExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConsoleLogRecordExporter = undefined;
  var core_1 = require_src3();
  var core_2 = require_src3();

  class ConsoleLogRecordExporter {
    export(logs, resultCallback) {
      this._sendLogRecords(logs, resultCallback);
    }
    shutdown() {
      return Promise.resolve();
    }
    _exportInfo(logRecord) {
      return {
        resource: {
          attributes: logRecord.resource.attributes
        },
        instrumentationScope: logRecord.instrumentationScope,
        timestamp: (0, core_1.hrTimeToMicroseconds)(logRecord.hrTime),
        traceId: logRecord.spanContext?.traceId,
        spanId: logRecord.spanContext?.spanId,
        traceFlags: logRecord.spanContext?.traceFlags,
        severityText: logRecord.severityText,
        severityNumber: logRecord.severityNumber,
        body: logRecord.body,
        attributes: logRecord.attributes
      };
    }
    _sendLogRecords(logRecords, done) {
      for (const logRecord of logRecords) {
        console.dir(this._exportInfo(logRecord), { depth: 3 });
      }
      done?.({ code: core_2.ExportResultCode.SUCCESS });
    }
  }
  exports.ConsoleLogRecordExporter = ConsoleLogRecordExporter;
});

// node_modules/@opentelemetry/sdk-logs/build/src/export/SimpleLogRecordProcessor.js
var require_SimpleLogRecordProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SimpleLogRecordProcessor = undefined;
  var core_1 = require_src3();

  class SimpleLogRecordProcessor {
    _exporter;
    _shutdownOnce;
    _unresolvedExports;
    constructor(_exporter) {
      this._exporter = _exporter;
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
      this._unresolvedExports = new Set;
    }
    onEmit(logRecord) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      const doExport = () => core_1.internal._export(this._exporter, [logRecord]).then((result) => {
        if (result.code !== core_1.ExportResultCode.SUCCESS) {
          (0, core_1.globalErrorHandler)(result.error ?? new Error(`SimpleLogRecordProcessor: log record export failed (status ${result})`));
        }
      }).catch(core_1.globalErrorHandler);
      if (logRecord.resource.asyncAttributesPending) {
        const exportPromise = logRecord.resource.waitForAsyncAttributes?.().then(() => {
          this._unresolvedExports.delete(exportPromise);
          return doExport();
        }, core_1.globalErrorHandler);
        if (exportPromise != null) {
          this._unresolvedExports.add(exportPromise);
        }
      } else {
        doExport();
      }
    }
    async forceFlush() {
      await Promise.all(Array.from(this._unresolvedExports));
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._exporter.shutdown();
    }
  }
  exports.SimpleLogRecordProcessor = SimpleLogRecordProcessor;
});

// node_modules/@opentelemetry/sdk-logs/build/src/export/InMemoryLogRecordExporter.js
var require_InMemoryLogRecordExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InMemoryLogRecordExporter = undefined;
  var core_1 = require_src3();

  class InMemoryLogRecordExporter {
    _finishedLogRecords = [];
    _stopped = false;
    export(logs, resultCallback) {
      if (this._stopped) {
        return resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Exporter has been stopped")
        });
      }
      this._finishedLogRecords.push(...logs);
      resultCallback({ code: core_1.ExportResultCode.SUCCESS });
    }
    shutdown() {
      this._stopped = true;
      this.reset();
      return Promise.resolve();
    }
    getFinishedLogRecords() {
      return this._finishedLogRecords;
    }
    reset() {
      this._finishedLogRecords = [];
    }
  }
  exports.InMemoryLogRecordExporter = InMemoryLogRecordExporter;
});

// node_modules/@opentelemetry/sdk-logs/build/src/export/BatchLogRecordProcessorBase.js
var require_BatchLogRecordProcessorBase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchLogRecordProcessorBase = undefined;
  var core_1 = require_src3();
  var api_1 = require_src();
  var core_2 = require_src3();

  class BatchLogRecordProcessorBase {
    _exporter;
    _maxExportBatchSize;
    _maxQueueSize;
    _scheduledDelayMillis;
    _exportTimeoutMillis;
    _finishedLogRecords = [];
    _timer;
    _shutdownOnce;
    constructor(_exporter, config) {
      this._exporter = _exporter;
      this._maxExportBatchSize = config?.maxExportBatchSize ?? (0, core_1.getNumberFromEnv)("OTEL_BLRP_MAX_EXPORT_BATCH_SIZE") ?? 512;
      this._maxQueueSize = config?.maxQueueSize ?? (0, core_1.getNumberFromEnv)("OTEL_BLRP_MAX_QUEUE_SIZE") ?? 2048;
      this._scheduledDelayMillis = config?.scheduledDelayMillis ?? (0, core_1.getNumberFromEnv)("OTEL_BLRP_SCHEDULE_DELAY") ?? 5000;
      this._exportTimeoutMillis = config?.exportTimeoutMillis ?? (0, core_1.getNumberFromEnv)("OTEL_BLRP_EXPORT_TIMEOUT") ?? 30000;
      this._shutdownOnce = new core_2.BindOnceFuture(this._shutdown, this);
      if (this._maxExportBatchSize > this._maxQueueSize) {
        api_1.diag.warn("BatchLogRecordProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
        this._maxExportBatchSize = this._maxQueueSize;
      }
    }
    onEmit(logRecord) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      this._addToBuffer(logRecord);
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled) {
        return this._shutdownOnce.promise;
      }
      return this._flushAll();
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    async _shutdown() {
      this.onShutdown();
      await this._flushAll();
      await this._exporter.shutdown();
    }
    _addToBuffer(logRecord) {
      if (this._finishedLogRecords.length >= this._maxQueueSize) {
        return;
      }
      this._finishedLogRecords.push(logRecord);
      this._maybeStartTimer();
    }
    _flushAll() {
      return new Promise((resolve, reject) => {
        const promises = [];
        const batchCount = Math.ceil(this._finishedLogRecords.length / this._maxExportBatchSize);
        for (let i = 0;i < batchCount; i++) {
          promises.push(this._flushOneBatch());
        }
        Promise.all(promises).then(() => {
          resolve();
        }).catch(reject);
      });
    }
    _flushOneBatch() {
      this._clearTimer();
      if (this._finishedLogRecords.length === 0) {
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        (0, core_2.callWithTimeout)(this._export(this._finishedLogRecords.splice(0, this._maxExportBatchSize)), this._exportTimeoutMillis).then(() => resolve()).catch(reject);
      });
    }
    _maybeStartTimer() {
      if (this._timer !== undefined) {
        return;
      }
      this._timer = setTimeout(() => {
        this._flushOneBatch().then(() => {
          if (this._finishedLogRecords.length > 0) {
            this._clearTimer();
            this._maybeStartTimer();
          }
        }).catch((e) => {
          (0, core_2.globalErrorHandler)(e);
        });
      }, this._scheduledDelayMillis);
      (0, core_2.unrefTimer)(this._timer);
    }
    _clearTimer() {
      if (this._timer !== undefined) {
        clearTimeout(this._timer);
        this._timer = undefined;
      }
    }
    _export(logRecords) {
      const doExport = () => core_2.internal._export(this._exporter, logRecords).then((result) => {
        if (result.code !== core_2.ExportResultCode.SUCCESS) {
          (0, core_2.globalErrorHandler)(result.error ?? new Error(`BatchLogRecordProcessor: log record export failed (status ${result})`));
        }
      }).catch(core_2.globalErrorHandler);
      const pendingResources = logRecords.map((logRecord) => logRecord.resource).filter((resource) => resource.asyncAttributesPending);
      if (pendingResources.length === 0) {
        return doExport();
      } else {
        return Promise.all(pendingResources.map((resource) => resource.waitForAsyncAttributes?.())).then(doExport, core_2.globalErrorHandler);
      }
    }
  }
  exports.BatchLogRecordProcessorBase = BatchLogRecordProcessorBase;
});

// node_modules/@opentelemetry/sdk-logs/build/src/platform/node/export/BatchLogRecordProcessor.js
var require_BatchLogRecordProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchLogRecordProcessor = undefined;
  var BatchLogRecordProcessorBase_1 = require_BatchLogRecordProcessorBase();

  class BatchLogRecordProcessor extends BatchLogRecordProcessorBase_1.BatchLogRecordProcessorBase {
    onShutdown() {
    }
  }
  exports.BatchLogRecordProcessor = BatchLogRecordProcessor;
});

// node_modules/@opentelemetry/sdk-logs/build/src/platform/node/index.js
var require_node6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchLogRecordProcessor = undefined;
  var BatchLogRecordProcessor_1 = require_BatchLogRecordProcessor();
  Object.defineProperty(exports, "BatchLogRecordProcessor", { enumerable: true, get: function() {
    return BatchLogRecordProcessor_1.BatchLogRecordProcessor;
  } });
});

// node_modules/@opentelemetry/sdk-logs/build/src/platform/index.js
var require_platform6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchLogRecordProcessor = undefined;
  var node_1 = require_node6();
  Object.defineProperty(exports, "BatchLogRecordProcessor", { enumerable: true, get: function() {
    return node_1.BatchLogRecordProcessor;
  } });
});

// node_modules/@opentelemetry/sdk-logs/build/src/index.js
var require_src6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchLogRecordProcessor = exports.InMemoryLogRecordExporter = exports.SimpleLogRecordProcessor = exports.ConsoleLogRecordExporter = exports.NoopLogRecordProcessor = exports.LogRecord = exports.LoggerProvider = undefined;
  var LoggerProvider_1 = require_LoggerProvider();
  Object.defineProperty(exports, "LoggerProvider", { enumerable: true, get: function() {
    return LoggerProvider_1.LoggerProvider;
  } });
  var LogRecord_1 = require_LogRecord2();
  Object.defineProperty(exports, "LogRecord", { enumerable: true, get: function() {
    return LogRecord_1.LogRecord;
  } });
  var NoopLogRecordProcessor_1 = require_NoopLogRecordProcessor();
  Object.defineProperty(exports, "NoopLogRecordProcessor", { enumerable: true, get: function() {
    return NoopLogRecordProcessor_1.NoopLogRecordProcessor;
  } });
  var ConsoleLogRecordExporter_1 = require_ConsoleLogRecordExporter();
  Object.defineProperty(exports, "ConsoleLogRecordExporter", { enumerable: true, get: function() {
    return ConsoleLogRecordExporter_1.ConsoleLogRecordExporter;
  } });
  var SimpleLogRecordProcessor_1 = require_SimpleLogRecordProcessor();
  Object.defineProperty(exports, "SimpleLogRecordProcessor", { enumerable: true, get: function() {
    return SimpleLogRecordProcessor_1.SimpleLogRecordProcessor;
  } });
  var InMemoryLogRecordExporter_1 = require_InMemoryLogRecordExporter();
  Object.defineProperty(exports, "InMemoryLogRecordExporter", { enumerable: true, get: function() {
    return InMemoryLogRecordExporter_1.InMemoryLogRecordExporter;
  } });
  var platform_1 = require_platform6();
  Object.defineProperty(exports, "BatchLogRecordProcessor", { enumerable: true, get: function() {
    return platform_1.BatchLogRecordProcessor;
  } });
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js
var require_AggregationTemporality = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregationTemporality = undefined;
  var AggregationTemporality;
  (function(AggregationTemporality2) {
    AggregationTemporality2[AggregationTemporality2["DELTA"] = 0] = "DELTA";
    AggregationTemporality2[AggregationTemporality2["CUMULATIVE"] = 1] = "CUMULATIVE";
  })(AggregationTemporality = exports.AggregationTemporality || (exports.AggregationTemporality = {}));
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js
var require_MetricData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataPointType = exports.InstrumentType = undefined;
  var InstrumentType;
  (function(InstrumentType2) {
    InstrumentType2["COUNTER"] = "COUNTER";
    InstrumentType2["GAUGE"] = "GAUGE";
    InstrumentType2["HISTOGRAM"] = "HISTOGRAM";
    InstrumentType2["UP_DOWN_COUNTER"] = "UP_DOWN_COUNTER";
    InstrumentType2["OBSERVABLE_COUNTER"] = "OBSERVABLE_COUNTER";
    InstrumentType2["OBSERVABLE_GAUGE"] = "OBSERVABLE_GAUGE";
    InstrumentType2["OBSERVABLE_UP_DOWN_COUNTER"] = "OBSERVABLE_UP_DOWN_COUNTER";
  })(InstrumentType = exports.InstrumentType || (exports.InstrumentType = {}));
  var DataPointType;
  (function(DataPointType2) {
    DataPointType2[DataPointType2["HISTOGRAM"] = 0] = "HISTOGRAM";
    DataPointType2[DataPointType2["EXPONENTIAL_HISTOGRAM"] = 1] = "EXPONENTIAL_HISTOGRAM";
    DataPointType2[DataPointType2["GAUGE"] = 2] = "GAUGE";
    DataPointType2[DataPointType2["SUM"] = 3] = "SUM";
  })(DataPointType = exports.DataPointType || (exports.DataPointType = {}));
});

// node_modules/@opentelemetry/sdk-metrics/build/src/utils.js
var require_utils7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.equalsCaseInsensitive = exports.binarySearchUB = exports.setEquals = exports.FlatMap = exports.isPromiseAllSettledRejectionResult = exports.PromiseAllSettled = exports.callWithTimeout = exports.TimeoutError = exports.instrumentationScopeId = exports.hashAttributes = exports.isNotNullish = undefined;
  function isNotNullish(item) {
    return item !== undefined && item !== null;
  }
  exports.isNotNullish = isNotNullish;
  function hashAttributes(attributes) {
    let keys = Object.keys(attributes);
    if (keys.length === 0)
      return "";
    keys = keys.sort();
    return JSON.stringify(keys.map((key) => [key, attributes[key]]));
  }
  exports.hashAttributes = hashAttributes;
  function instrumentationScopeId(instrumentationScope) {
    return `${instrumentationScope.name}:${instrumentationScope.version ?? ""}:${instrumentationScope.schemaUrl ?? ""}`;
  }
  exports.instrumentationScopeId = instrumentationScopeId;

  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, TimeoutError.prototype);
    }
  }
  exports.TimeoutError = TimeoutError;
  function callWithTimeout(promise, timeout) {
    let timeoutHandle;
    const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
      timeoutHandle = setTimeout(function timeoutHandler() {
        reject(new TimeoutError("Operation timed out."));
      }, timeout);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    }, (reason) => {
      clearTimeout(timeoutHandle);
      throw reason;
    });
  }
  exports.callWithTimeout = callWithTimeout;
  async function PromiseAllSettled(promises) {
    return Promise.all(promises.map(async (p) => {
      try {
        const ret = await p;
        return {
          status: "fulfilled",
          value: ret
        };
      } catch (e) {
        return {
          status: "rejected",
          reason: e
        };
      }
    }));
  }
  exports.PromiseAllSettled = PromiseAllSettled;
  function isPromiseAllSettledRejectionResult(it) {
    return it.status === "rejected";
  }
  exports.isPromiseAllSettledRejectionResult = isPromiseAllSettledRejectionResult;
  function FlatMap(arr, fn) {
    const result = [];
    arr.forEach((it) => {
      result.push(...fn(it));
    });
    return result;
  }
  exports.FlatMap = FlatMap;
  function setEquals(lhs, rhs) {
    if (lhs.size !== rhs.size) {
      return false;
    }
    for (const item of lhs) {
      if (!rhs.has(item)) {
        return false;
      }
    }
    return true;
  }
  exports.setEquals = setEquals;
  function binarySearchUB(arr, value) {
    let lo = 0;
    let hi = arr.length - 1;
    let ret = arr.length;
    while (hi >= lo) {
      const mid = lo + Math.trunc((hi - lo) / 2);
      if (arr[mid] < value) {
        lo = mid + 1;
      } else {
        ret = mid;
        hi = mid - 1;
      }
    }
    return ret;
  }
  exports.binarySearchUB = binarySearchUB;
  function equalsCaseInsensitive(lhs, rhs) {
    return lhs.toLowerCase() === rhs.toLowerCase();
  }
  exports.equalsCaseInsensitive = equalsCaseInsensitive;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregatorKind = undefined;
  var AggregatorKind;
  (function(AggregatorKind2) {
    AggregatorKind2[AggregatorKind2["DROP"] = 0] = "DROP";
    AggregatorKind2[AggregatorKind2["SUM"] = 1] = "SUM";
    AggregatorKind2[AggregatorKind2["LAST_VALUE"] = 2] = "LAST_VALUE";
    AggregatorKind2[AggregatorKind2["HISTOGRAM"] = 3] = "HISTOGRAM";
    AggregatorKind2[AggregatorKind2["EXPONENTIAL_HISTOGRAM"] = 4] = "EXPONENTIAL_HISTOGRAM";
  })(AggregatorKind = exports.AggregatorKind || (exports.AggregatorKind = {}));
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js
var require_Drop = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropAggregator = undefined;
  var types_1 = require_types2();

  class DropAggregator {
    kind = types_1.AggregatorKind.DROP;
    createAccumulation() {
      return;
    }
    merge(_previous, _delta) {
      return;
    }
    diff(_previous, _current) {
      return;
    }
    toMetricData(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
      return;
    }
  }
  exports.DropAggregator = DropAggregator;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js
var require_Histogram = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HistogramAggregator = exports.HistogramAccumulation = undefined;
  var types_1 = require_types2();
  var MetricData_1 = require_MetricData();
  var utils_1 = require_utils7();
  function createNewEmptyCheckpoint(boundaries) {
    const counts = boundaries.map(() => 0);
    counts.push(0);
    return {
      buckets: {
        boundaries,
        counts
      },
      sum: 0,
      count: 0,
      hasMinMax: false,
      min: Infinity,
      max: -Infinity
    };
  }

  class HistogramAccumulation {
    startTime;
    _boundaries;
    _recordMinMax;
    _current;
    constructor(startTime, _boundaries, _recordMinMax = true, _current = createNewEmptyCheckpoint(_boundaries)) {
      this.startTime = startTime;
      this._boundaries = _boundaries;
      this._recordMinMax = _recordMinMax;
      this._current = _current;
    }
    record(value) {
      if (Number.isNaN(value)) {
        return;
      }
      this._current.count += 1;
      this._current.sum += value;
      if (this._recordMinMax) {
        this._current.min = Math.min(value, this._current.min);
        this._current.max = Math.max(value, this._current.max);
        this._current.hasMinMax = true;
      }
      const idx = (0, utils_1.binarySearchUB)(this._boundaries, value);
      this._current.buckets.counts[idx] += 1;
    }
    setStartTime(startTime) {
      this.startTime = startTime;
    }
    toPointValue() {
      return this._current;
    }
  }
  exports.HistogramAccumulation = HistogramAccumulation;

  class HistogramAggregator {
    _boundaries;
    _recordMinMax;
    kind = types_1.AggregatorKind.HISTOGRAM;
    constructor(_boundaries, _recordMinMax) {
      this._boundaries = _boundaries;
      this._recordMinMax = _recordMinMax;
    }
    createAccumulation(startTime) {
      return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
    }
    merge(previous, delta) {
      const previousValue = previous.toPointValue();
      const deltaValue = delta.toPointValue();
      const previousCounts = previousValue.buckets.counts;
      const deltaCounts = deltaValue.buckets.counts;
      const mergedCounts = new Array(previousCounts.length);
      for (let idx = 0;idx < previousCounts.length; idx++) {
        mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
      }
      let min = Infinity;
      let max = -Infinity;
      if (this._recordMinMax) {
        if (previousValue.hasMinMax && deltaValue.hasMinMax) {
          min = Math.min(previousValue.min, deltaValue.min);
          max = Math.max(previousValue.max, deltaValue.max);
        } else if (previousValue.hasMinMax) {
          min = previousValue.min;
          max = previousValue.max;
        } else if (deltaValue.hasMinMax) {
          min = deltaValue.min;
          max = deltaValue.max;
        }
      }
      return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
        buckets: {
          boundaries: previousValue.buckets.boundaries,
          counts: mergedCounts
        },
        count: previousValue.count + deltaValue.count,
        sum: previousValue.sum + deltaValue.sum,
        hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
        min,
        max
      });
    }
    diff(previous, current) {
      const previousValue = previous.toPointValue();
      const currentValue = current.toPointValue();
      const previousCounts = previousValue.buckets.counts;
      const currentCounts = currentValue.buckets.counts;
      const diffedCounts = new Array(previousCounts.length);
      for (let idx = 0;idx < previousCounts.length; idx++) {
        diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
      }
      return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
        buckets: {
          boundaries: previousValue.buckets.boundaries,
          counts: diffedCounts
        },
        count: currentValue.count - previousValue.count,
        sum: currentValue.sum - previousValue.sum,
        hasMinMax: false,
        min: Infinity,
        max: -Infinity
      });
    }
    toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
      return {
        descriptor,
        aggregationTemporality,
        dataPointType: MetricData_1.DataPointType.HISTOGRAM,
        dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
          const pointValue = accumulation.toPointValue();
          const allowsNegativeValues = descriptor.type === MetricData_1.InstrumentType.GAUGE || descriptor.type === MetricData_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === MetricData_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === MetricData_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
          return {
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: {
              min: pointValue.hasMinMax ? pointValue.min : undefined,
              max: pointValue.hasMinMax ? pointValue.max : undefined,
              sum: !allowsNegativeValues ? pointValue.sum : undefined,
              buckets: pointValue.buckets,
              count: pointValue.count
            }
          };
        })
      };
    }
  }
  exports.HistogramAggregator = HistogramAggregator;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js
var require_Buckets = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Buckets = undefined;

  class Buckets {
    backing;
    indexBase;
    indexStart;
    indexEnd;
    constructor(backing = new BucketsBacking, indexBase = 0, indexStart = 0, indexEnd = 0) {
      this.backing = backing;
      this.indexBase = indexBase;
      this.indexStart = indexStart;
      this.indexEnd = indexEnd;
    }
    get offset() {
      return this.indexStart;
    }
    get length() {
      if (this.backing.length === 0) {
        return 0;
      }
      if (this.indexEnd === this.indexStart && this.at(0) === 0) {
        return 0;
      }
      return this.indexEnd - this.indexStart + 1;
    }
    counts() {
      return Array.from({ length: this.length }, (_, i) => this.at(i));
    }
    at(position2) {
      const bias = this.indexBase - this.indexStart;
      if (position2 < bias) {
        position2 += this.backing.length;
      }
      position2 -= bias;
      return this.backing.countAt(position2);
    }
    incrementBucket(bucketIndex, increment) {
      this.backing.increment(bucketIndex, increment);
    }
    decrementBucket(bucketIndex, decrement) {
      this.backing.decrement(bucketIndex, decrement);
    }
    trim() {
      for (let i = 0;i < this.length; i++) {
        if (this.at(i) !== 0) {
          this.indexStart += i;
          break;
        } else if (i === this.length - 1) {
          this.indexStart = this.indexEnd = this.indexBase = 0;
          return;
        }
      }
      for (let i = this.length - 1;i >= 0; i--) {
        if (this.at(i) !== 0) {
          this.indexEnd -= this.length - i - 1;
          break;
        }
      }
      this._rotate();
    }
    downscale(by) {
      this._rotate();
      const size = 1 + this.indexEnd - this.indexStart;
      const each = 1 << by;
      let inpos = 0;
      let outpos = 0;
      for (let pos = this.indexStart;pos <= this.indexEnd; ) {
        let mod2 = pos % each;
        if (mod2 < 0) {
          mod2 += each;
        }
        for (let i = mod2;i < each && inpos < size; i++) {
          this._relocateBucket(outpos, inpos);
          inpos++;
          pos++;
        }
        outpos++;
      }
      this.indexStart >>= by;
      this.indexEnd >>= by;
      this.indexBase = this.indexStart;
    }
    clone() {
      return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
    }
    _rotate() {
      const bias = this.indexBase - this.indexStart;
      if (bias === 0) {
        return;
      } else if (bias > 0) {
        this.backing.reverse(0, this.backing.length);
        this.backing.reverse(0, bias);
        this.backing.reverse(bias, this.backing.length);
      } else {
        this.backing.reverse(0, this.backing.length);
        this.backing.reverse(0, this.backing.length + bias);
      }
      this.indexBase = this.indexStart;
    }
    _relocateBucket(dest, src) {
      if (dest === src) {
        return;
      }
      this.incrementBucket(dest, this.backing.emptyBucket(src));
    }
  }
  exports.Buckets = Buckets;

  class BucketsBacking {
    _counts;
    constructor(_counts = [0]) {
      this._counts = _counts;
    }
    get length() {
      return this._counts.length;
    }
    countAt(pos) {
      return this._counts[pos];
    }
    growTo(newSize, oldPositiveLimit, newPositiveLimit) {
      const tmp = new Array(newSize).fill(0);
      tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit));
      tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));
      this._counts = tmp;
    }
    reverse(from, limit) {
      const num = Math.floor((from + limit) / 2) - from;
      for (let i = 0;i < num; i++) {
        const tmp = this._counts[from + i];
        this._counts[from + i] = this._counts[limit - i - 1];
        this._counts[limit - i - 1] = tmp;
      }
    }
    emptyBucket(src) {
      const tmp = this._counts[src];
      this._counts[src] = 0;
      return tmp;
    }
    increment(bucketIndex, increment) {
      this._counts[bucketIndex] += increment;
    }
    decrement(bucketIndex, decrement) {
      if (this._counts[bucketIndex] >= decrement) {
        this._counts[bucketIndex] -= decrement;
      } else {
        this._counts[bucketIndex] = 0;
      }
    }
    clone() {
      return new BucketsBacking([...this._counts]);
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js
var require_ieee754 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSignificand = exports.getNormalBase2 = exports.MIN_VALUE = exports.MAX_NORMAL_EXPONENT = exports.MIN_NORMAL_EXPONENT = exports.SIGNIFICAND_WIDTH = undefined;
  exports.SIGNIFICAND_WIDTH = 52;
  var EXPONENT_MASK = 2146435072;
  var SIGNIFICAND_MASK = 1048575;
  var EXPONENT_BIAS = 1023;
  exports.MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
  exports.MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
  exports.MIN_VALUE = Math.pow(2, -1022);
  function getNormalBase2(value) {
    const dv = new DataView(new ArrayBuffer(8));
    dv.setFloat64(0, value);
    const hiBits = dv.getUint32(0);
    const expBits = (hiBits & EXPONENT_MASK) >> 20;
    return expBits - EXPONENT_BIAS;
  }
  exports.getNormalBase2 = getNormalBase2;
  function getSignificand(value) {
    const dv = new DataView(new ArrayBuffer(8));
    dv.setFloat64(0, value);
    const hiBits = dv.getUint32(0);
    const loBits = dv.getUint32(4);
    const significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);
    return significandHiBits + loBits;
  }
  exports.getSignificand = getSignificand;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nextGreaterSquare = exports.ldexp = undefined;
  function ldexp(frac, exp) {
    if (frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac)) {
      return frac;
    }
    return frac * Math.pow(2, exp);
  }
  exports.ldexp = ldexp;
  function nextGreaterSquare(v) {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
  }
  exports.nextGreaterSquare = nextGreaterSquare;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappingError = undefined;

  class MappingError extends Error {
  }
  exports.MappingError = MappingError;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js
var require_ExponentMapping = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExponentMapping = undefined;
  var ieee754 = require_ieee754();
  var util = require_util();
  var types_1 = require_types3();

  class ExponentMapping {
    _shift;
    constructor(scale) {
      this._shift = -scale;
    }
    mapToIndex(value) {
      if (value < ieee754.MIN_VALUE) {
        return this._minNormalLowerBoundaryIndex();
      }
      const exp = ieee754.getNormalBase2(value);
      const correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);
      return exp + correction >> this._shift;
    }
    lowerBoundary(index) {
      const minIndex = this._minNormalLowerBoundaryIndex();
      if (index < minIndex) {
        throw new types_1.MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);
      }
      const maxIndex = this._maxNormalLowerBoundaryIndex();
      if (index > maxIndex) {
        throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
      }
      return util.ldexp(1, index << this._shift);
    }
    get scale() {
      if (this._shift === 0) {
        return 0;
      }
      return -this._shift;
    }
    _minNormalLowerBoundaryIndex() {
      let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;
      if (this._shift < 2) {
        index--;
      }
      return index;
    }
    _maxNormalLowerBoundaryIndex() {
      return ieee754.MAX_NORMAL_EXPONENT >> this._shift;
    }
    _rightShift(value, shift) {
      return Math.floor(value * Math.pow(2, -shift));
    }
  }
  exports.ExponentMapping = ExponentMapping;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js
var require_LogarithmMapping = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogarithmMapping = undefined;
  var ieee754 = require_ieee754();
  var util = require_util();
  var types_1 = require_types3();

  class LogarithmMapping {
    _scale;
    _scaleFactor;
    _inverseFactor;
    constructor(scale) {
      this._scale = scale;
      this._scaleFactor = util.ldexp(Math.LOG2E, scale);
      this._inverseFactor = util.ldexp(Math.LN2, -scale);
    }
    mapToIndex(value) {
      if (value <= ieee754.MIN_VALUE) {
        return this._minNormalLowerBoundaryIndex() - 1;
      }
      if (ieee754.getSignificand(value) === 0) {
        const exp = ieee754.getNormalBase2(value);
        return (exp << this._scale) - 1;
      }
      const index = Math.floor(Math.log(value) * this._scaleFactor);
      const maxIndex = this._maxNormalLowerBoundaryIndex();
      if (index >= maxIndex) {
        return maxIndex;
      }
      return index;
    }
    lowerBoundary(index) {
      const maxIndex = this._maxNormalLowerBoundaryIndex();
      if (index >= maxIndex) {
        if (index === maxIndex) {
          return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
        }
        throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
      }
      const minIndex = this._minNormalLowerBoundaryIndex();
      if (index <= minIndex) {
        if (index === minIndex) {
          return ieee754.MIN_VALUE;
        } else if (index === minIndex - 1) {
          return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
        }
        throw new types_1.MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);
      }
      return Math.exp(index * this._inverseFactor);
    }
    get scale() {
      return this._scale;
    }
    _minNormalLowerBoundaryIndex() {
      return ieee754.MIN_NORMAL_EXPONENT << this._scale;
    }
    _maxNormalLowerBoundaryIndex() {
      return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
    }
  }
  exports.LogarithmMapping = LogarithmMapping;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js
var require_getMapping = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMapping = undefined;
  var ExponentMapping_1 = require_ExponentMapping();
  var LogarithmMapping_1 = require_LogarithmMapping();
  var types_1 = require_types3();
  var MIN_SCALE = -10;
  var MAX_SCALE = 20;
  var PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => {
    if (i > 10) {
      return new LogarithmMapping_1.LogarithmMapping(i - 10);
    }
    return new ExponentMapping_1.ExponentMapping(i - 10);
  });
  function getMapping(scale) {
    if (scale > MAX_SCALE || scale < MIN_SCALE) {
      throw new types_1.MappingError(`expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`);
    }
    return PREBUILT_MAPPINGS[scale + 10];
  }
  exports.getMapping = getMapping;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js
var require_ExponentialHistogram = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExponentialHistogramAggregator = exports.ExponentialHistogramAccumulation = undefined;
  var types_1 = require_types2();
  var MetricData_1 = require_MetricData();
  var api_1 = require_src();
  var Buckets_1 = require_Buckets();
  var getMapping_1 = require_getMapping();
  var util_1 = require_util();

  class HighLow {
    low;
    high;
    static combine(h1, h2) {
      return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
    }
    constructor(low, high) {
      this.low = low;
      this.high = high;
    }
  }
  var MAX_SCALE = 20;
  var DEFAULT_MAX_SIZE = 160;
  var MIN_MAX_SIZE = 2;

  class ExponentialHistogramAccumulation {
    startTime;
    _maxSize;
    _recordMinMax;
    _sum;
    _count;
    _zeroCount;
    _min;
    _max;
    _positive;
    _negative;
    _mapping;
    constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = true, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets_1.Buckets, _negative = new Buckets_1.Buckets, _mapping = (0, getMapping_1.getMapping)(MAX_SCALE)) {
      this.startTime = startTime;
      this._maxSize = _maxSize;
      this._recordMinMax = _recordMinMax;
      this._sum = _sum;
      this._count = _count;
      this._zeroCount = _zeroCount;
      this._min = _min;
      this._max = _max;
      this._positive = _positive;
      this._negative = _negative;
      this._mapping = _mapping;
      if (this._maxSize < MIN_MAX_SIZE) {
        api_1.diag.warn(`Exponential Histogram Max Size set to ${this._maxSize},                 changing to the minimum size of: ${MIN_MAX_SIZE}`);
        this._maxSize = MIN_MAX_SIZE;
      }
    }
    record(value) {
      this.updateByIncrement(value, 1);
    }
    setStartTime(startTime) {
      this.startTime = startTime;
    }
    toPointValue() {
      return {
        hasMinMax: this._recordMinMax,
        min: this.min,
        max: this.max,
        sum: this.sum,
        positive: {
          offset: this.positive.offset,
          bucketCounts: this.positive.counts()
        },
        negative: {
          offset: this.negative.offset,
          bucketCounts: this.negative.counts()
        },
        count: this.count,
        scale: this.scale,
        zeroCount: this.zeroCount
      };
    }
    get sum() {
      return this._sum;
    }
    get min() {
      return this._min;
    }
    get max() {
      return this._max;
    }
    get count() {
      return this._count;
    }
    get zeroCount() {
      return this._zeroCount;
    }
    get scale() {
      if (this._count === this._zeroCount) {
        return 0;
      }
      return this._mapping.scale;
    }
    get positive() {
      return this._positive;
    }
    get negative() {
      return this._negative;
    }
    updateByIncrement(value, increment) {
      if (Number.isNaN(value)) {
        return;
      }
      if (value > this._max) {
        this._max = value;
      }
      if (value < this._min) {
        this._min = value;
      }
      this._count += increment;
      if (value === 0) {
        this._zeroCount += increment;
        return;
      }
      this._sum += value * increment;
      if (value > 0) {
        this._updateBuckets(this._positive, value, increment);
      } else {
        this._updateBuckets(this._negative, -value, increment);
      }
    }
    merge(previous) {
      if (this._count === 0) {
        this._min = previous.min;
        this._max = previous.max;
      } else if (previous.count !== 0) {
        if (previous.min < this.min) {
          this._min = previous.min;
        }
        if (previous.max > this.max) {
          this._max = previous.max;
        }
      }
      this.startTime = previous.startTime;
      this._sum += previous.sum;
      this._count += previous.count;
      this._zeroCount += previous.zeroCount;
      const minScale = this._minScale(previous);
      this._downscale(this.scale - minScale);
      this._mergeBuckets(this.positive, previous, previous.positive, minScale);
      this._mergeBuckets(this.negative, previous, previous.negative, minScale);
    }
    diff(other) {
      this._min = Infinity;
      this._max = -Infinity;
      this._sum -= other.sum;
      this._count -= other.count;
      this._zeroCount -= other.zeroCount;
      const minScale = this._minScale(other);
      this._downscale(this.scale - minScale);
      this._diffBuckets(this.positive, other, other.positive, minScale);
      this._diffBuckets(this.negative, other, other.negative, minScale);
    }
    clone() {
      return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
    }
    _updateBuckets(buckets, value, increment) {
      let index = this._mapping.mapToIndex(value);
      let rescalingNeeded = false;
      let high = 0;
      let low = 0;
      if (buckets.length === 0) {
        buckets.indexStart = index;
        buckets.indexEnd = buckets.indexStart;
        buckets.indexBase = buckets.indexStart;
      } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {
        rescalingNeeded = true;
        low = index;
        high = buckets.indexEnd;
      } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {
        rescalingNeeded = true;
        low = buckets.indexStart;
        high = index;
      }
      if (rescalingNeeded) {
        const change = this._changeScale(high, low);
        this._downscale(change);
        index = this._mapping.mapToIndex(value);
      }
      this._incrementIndexBy(buckets, index, increment);
    }
    _incrementIndexBy(buckets, index, increment) {
      if (increment === 0) {
        return;
      }
      if (buckets.length === 0) {
        buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;
      }
      if (index < buckets.indexStart) {
        const span = buckets.indexEnd - index;
        if (span >= buckets.backing.length) {
          this._grow(buckets, span + 1);
        }
        buckets.indexStart = index;
      } else if (index > buckets.indexEnd) {
        const span = index - buckets.indexStart;
        if (span >= buckets.backing.length) {
          this._grow(buckets, span + 1);
        }
        buckets.indexEnd = index;
      }
      let bucketIndex = index - buckets.indexBase;
      if (bucketIndex < 0) {
        bucketIndex += buckets.backing.length;
      }
      buckets.incrementBucket(bucketIndex, increment);
    }
    _grow(buckets, needed) {
      const size = buckets.backing.length;
      const bias = buckets.indexBase - buckets.indexStart;
      const oldPositiveLimit = size - bias;
      let newSize = (0, util_1.nextGreaterSquare)(needed);
      if (newSize > this._maxSize) {
        newSize = this._maxSize;
      }
      const newPositiveLimit = newSize - bias;
      buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
    }
    _changeScale(high, low) {
      let change = 0;
      while (high - low >= this._maxSize) {
        high >>= 1;
        low >>= 1;
        change++;
      }
      return change;
    }
    _downscale(change) {
      if (change === 0) {
        return;
      }
      if (change < 0) {
        throw new Error(`impossible change of scale: ${this.scale}`);
      }
      const newScale = this._mapping.scale - change;
      this._positive.downscale(change);
      this._negative.downscale(change);
      this._mapping = (0, getMapping_1.getMapping)(newScale);
    }
    _minScale(other) {
      const minScale = Math.min(this.scale, other.scale);
      const highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));
      const highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
      return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
    }
    _highLowAtScale(buckets, currentScale, newScale) {
      if (buckets.length === 0) {
        return new HighLow(0, -1);
      }
      const shift = currentScale - newScale;
      return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);
    }
    _mergeBuckets(ours, other, theirs, scale) {
      const theirOffset = theirs.offset;
      const theirChange = other.scale - scale;
      for (let i = 0;i < theirs.length; i++) {
        this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));
      }
    }
    _diffBuckets(ours, other, theirs, scale) {
      const theirOffset = theirs.offset;
      const theirChange = other.scale - scale;
      for (let i = 0;i < theirs.length; i++) {
        const ourIndex = theirOffset + i >> theirChange;
        let bucketIndex = ourIndex - ours.indexBase;
        if (bucketIndex < 0) {
          bucketIndex += ours.backing.length;
        }
        ours.decrementBucket(bucketIndex, theirs.at(i));
      }
      ours.trim();
    }
  }
  exports.ExponentialHistogramAccumulation = ExponentialHistogramAccumulation;

  class ExponentialHistogramAggregator {
    _maxSize;
    _recordMinMax;
    kind = types_1.AggregatorKind.EXPONENTIAL_HISTOGRAM;
    constructor(_maxSize, _recordMinMax) {
      this._maxSize = _maxSize;
      this._recordMinMax = _recordMinMax;
    }
    createAccumulation(startTime) {
      return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
    }
    merge(previous, delta) {
      const result = delta.clone();
      result.merge(previous);
      return result;
    }
    diff(previous, current) {
      const result = current.clone();
      result.diff(previous);
      return result;
    }
    toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
      return {
        descriptor,
        aggregationTemporality,
        dataPointType: MetricData_1.DataPointType.EXPONENTIAL_HISTOGRAM,
        dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
          const pointValue = accumulation.toPointValue();
          const allowsNegativeValues = descriptor.type === MetricData_1.InstrumentType.GAUGE || descriptor.type === MetricData_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === MetricData_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === MetricData_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
          return {
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: {
              min: pointValue.hasMinMax ? pointValue.min : undefined,
              max: pointValue.hasMinMax ? pointValue.max : undefined,
              sum: !allowsNegativeValues ? pointValue.sum : undefined,
              positive: {
                offset: pointValue.positive.offset,
                bucketCounts: pointValue.positive.bucketCounts
              },
              negative: {
                offset: pointValue.negative.offset,
                bucketCounts: pointValue.negative.bucketCounts
              },
              count: pointValue.count,
              scale: pointValue.scale,
              zeroCount: pointValue.zeroCount
            }
          };
        })
      };
    }
  }
  exports.ExponentialHistogramAggregator = ExponentialHistogramAggregator;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js
var require_LastValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LastValueAggregator = exports.LastValueAccumulation = undefined;
  var types_1 = require_types2();
  var core_1 = require_src3();
  var MetricData_1 = require_MetricData();

  class LastValueAccumulation {
    startTime;
    _current;
    sampleTime;
    constructor(startTime, _current = 0, sampleTime = [0, 0]) {
      this.startTime = startTime;
      this._current = _current;
      this.sampleTime = sampleTime;
    }
    record(value) {
      this._current = value;
      this.sampleTime = (0, core_1.millisToHrTime)(Date.now());
    }
    setStartTime(startTime) {
      this.startTime = startTime;
    }
    toPointValue() {
      return this._current;
    }
  }
  exports.LastValueAccumulation = LastValueAccumulation;

  class LastValueAggregator {
    kind = types_1.AggregatorKind.LAST_VALUE;
    createAccumulation(startTime) {
      return new LastValueAccumulation(startTime);
    }
    merge(previous, delta) {
      const latestAccumulation = (0, core_1.hrTimeToMicroseconds)(delta.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? delta : previous;
      return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
    }
    diff(previous, current) {
      const latestAccumulation = (0, core_1.hrTimeToMicroseconds)(current.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? current : previous;
      return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
    }
    toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
      return {
        descriptor,
        aggregationTemporality,
        dataPointType: MetricData_1.DataPointType.GAUGE,
        dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
          return {
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          };
        })
      };
    }
  }
  exports.LastValueAggregator = LastValueAggregator;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js
var require_Sum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SumAggregator = exports.SumAccumulation = undefined;
  var types_1 = require_types2();
  var MetricData_1 = require_MetricData();

  class SumAccumulation {
    startTime;
    monotonic;
    _current;
    reset;
    constructor(startTime, monotonic, _current = 0, reset = false) {
      this.startTime = startTime;
      this.monotonic = monotonic;
      this._current = _current;
      this.reset = reset;
    }
    record(value) {
      if (this.monotonic && value < 0) {
        return;
      }
      this._current += value;
    }
    setStartTime(startTime) {
      this.startTime = startTime;
    }
    toPointValue() {
      return this._current;
    }
  }
  exports.SumAccumulation = SumAccumulation;

  class SumAggregator {
    monotonic;
    kind = types_1.AggregatorKind.SUM;
    constructor(monotonic) {
      this.monotonic = monotonic;
    }
    createAccumulation(startTime) {
      return new SumAccumulation(startTime, this.monotonic);
    }
    merge(previous, delta) {
      const prevPv = previous.toPointValue();
      const deltaPv = delta.toPointValue();
      if (delta.reset) {
        return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);
      }
      return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
    }
    diff(previous, current) {
      const prevPv = previous.toPointValue();
      const currPv = current.toPointValue();
      if (this.monotonic && prevPv > currPv) {
        return new SumAccumulation(current.startTime, this.monotonic, currPv, true);
      }
      return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
    }
    toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
      return {
        descriptor,
        aggregationTemporality,
        dataPointType: MetricData_1.DataPointType.SUM,
        dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
          return {
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          };
        }),
        isMonotonic: this.monotonic
      };
    }
  }
  exports.SumAggregator = SumAggregator;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js
var require_aggregator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SumAggregator = exports.SumAccumulation = exports.LastValueAggregator = exports.LastValueAccumulation = exports.ExponentialHistogramAggregator = exports.ExponentialHistogramAccumulation = exports.HistogramAggregator = exports.HistogramAccumulation = exports.DropAggregator = undefined;
  var Drop_1 = require_Drop();
  Object.defineProperty(exports, "DropAggregator", { enumerable: true, get: function() {
    return Drop_1.DropAggregator;
  } });
  var Histogram_1 = require_Histogram();
  Object.defineProperty(exports, "HistogramAccumulation", { enumerable: true, get: function() {
    return Histogram_1.HistogramAccumulation;
  } });
  Object.defineProperty(exports, "HistogramAggregator", { enumerable: true, get: function() {
    return Histogram_1.HistogramAggregator;
  } });
  var ExponentialHistogram_1 = require_ExponentialHistogram();
  Object.defineProperty(exports, "ExponentialHistogramAccumulation", { enumerable: true, get: function() {
    return ExponentialHistogram_1.ExponentialHistogramAccumulation;
  } });
  Object.defineProperty(exports, "ExponentialHistogramAggregator", { enumerable: true, get: function() {
    return ExponentialHistogram_1.ExponentialHistogramAggregator;
  } });
  var LastValue_1 = require_LastValue();
  Object.defineProperty(exports, "LastValueAccumulation", { enumerable: true, get: function() {
    return LastValue_1.LastValueAccumulation;
  } });
  Object.defineProperty(exports, "LastValueAggregator", { enumerable: true, get: function() {
    return LastValue_1.LastValueAggregator;
  } });
  var Sum_1 = require_Sum();
  Object.defineProperty(exports, "SumAccumulation", { enumerable: true, get: function() {
    return Sum_1.SumAccumulation;
  } });
  Object.defineProperty(exports, "SumAggregator", { enumerable: true, get: function() {
    return Sum_1.SumAggregator;
  } });
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js
var require_Aggregation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_AGGREGATION = exports.EXPONENTIAL_HISTOGRAM_AGGREGATION = exports.HISTOGRAM_AGGREGATION = exports.LAST_VALUE_AGGREGATION = exports.SUM_AGGREGATION = exports.DROP_AGGREGATION = exports.DefaultAggregation = exports.ExponentialHistogramAggregation = exports.ExplicitBucketHistogramAggregation = exports.HistogramAggregation = exports.LastValueAggregation = exports.SumAggregation = exports.DropAggregation = undefined;
  var api = require_src();
  var aggregator_1 = require_aggregator();
  var MetricData_1 = require_MetricData();

  class DropAggregation {
    static DEFAULT_INSTANCE = new aggregator_1.DropAggregator;
    createAggregator(_instrument) {
      return DropAggregation.DEFAULT_INSTANCE;
    }
  }
  exports.DropAggregation = DropAggregation;

  class SumAggregation {
    static MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(true);
    static NON_MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(false);
    createAggregator(instrument) {
      switch (instrument.type) {
        case MetricData_1.InstrumentType.COUNTER:
        case MetricData_1.InstrumentType.OBSERVABLE_COUNTER:
        case MetricData_1.InstrumentType.HISTOGRAM: {
          return SumAggregation.MONOTONIC_INSTANCE;
        }
        default: {
          return SumAggregation.NON_MONOTONIC_INSTANCE;
        }
      }
    }
  }
  exports.SumAggregation = SumAggregation;

  class LastValueAggregation {
    static DEFAULT_INSTANCE = new aggregator_1.LastValueAggregator;
    createAggregator(_instrument) {
      return LastValueAggregation.DEFAULT_INSTANCE;
    }
  }
  exports.LastValueAggregation = LastValueAggregation;

  class HistogramAggregation {
    static DEFAULT_INSTANCE = new aggregator_1.HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 1e4], true);
    createAggregator(_instrument) {
      return HistogramAggregation.DEFAULT_INSTANCE;
    }
  }
  exports.HistogramAggregation = HistogramAggregation;

  class ExplicitBucketHistogramAggregation {
    _recordMinMax;
    _boundaries;
    constructor(boundaries, _recordMinMax = true) {
      this._recordMinMax = _recordMinMax;
      if (boundaries == null) {
        throw new Error("ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array");
      }
      boundaries = boundaries.concat();
      boundaries = boundaries.sort((a, b) => a - b);
      const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);
      let infinityIndex = boundaries.indexOf(Infinity);
      if (infinityIndex === -1) {
        infinityIndex = undefined;
      }
      this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
    }
    createAggregator(_instrument) {
      return new aggregator_1.HistogramAggregator(this._boundaries, this._recordMinMax);
    }
  }
  exports.ExplicitBucketHistogramAggregation = ExplicitBucketHistogramAggregation;

  class ExponentialHistogramAggregation {
    _maxSize;
    _recordMinMax;
    constructor(_maxSize = 160, _recordMinMax = true) {
      this._maxSize = _maxSize;
      this._recordMinMax = _recordMinMax;
    }
    createAggregator(_instrument) {
      return new aggregator_1.ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);
    }
  }
  exports.ExponentialHistogramAggregation = ExponentialHistogramAggregation;

  class DefaultAggregation {
    _resolve(instrument) {
      switch (instrument.type) {
        case MetricData_1.InstrumentType.COUNTER:
        case MetricData_1.InstrumentType.UP_DOWN_COUNTER:
        case MetricData_1.InstrumentType.OBSERVABLE_COUNTER:
        case MetricData_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {
          return exports.SUM_AGGREGATION;
        }
        case MetricData_1.InstrumentType.GAUGE:
        case MetricData_1.InstrumentType.OBSERVABLE_GAUGE: {
          return exports.LAST_VALUE_AGGREGATION;
        }
        case MetricData_1.InstrumentType.HISTOGRAM: {
          if (instrument.advice.explicitBucketBoundaries) {
            return new ExplicitBucketHistogramAggregation(instrument.advice.explicitBucketBoundaries);
          }
          return exports.HISTOGRAM_AGGREGATION;
        }
      }
      api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);
      return exports.DROP_AGGREGATION;
    }
    createAggregator(instrument) {
      return this._resolve(instrument).createAggregator(instrument);
    }
  }
  exports.DefaultAggregation = DefaultAggregation;
  exports.DROP_AGGREGATION = new DropAggregation;
  exports.SUM_AGGREGATION = new SumAggregation;
  exports.LAST_VALUE_AGGREGATION = new LastValueAggregation;
  exports.HISTOGRAM_AGGREGATION = new HistogramAggregation;
  exports.EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation;
  exports.DEFAULT_AGGREGATION = new DefaultAggregation;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/AggregationOption.js
var require_AggregationOption = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toAggregation = exports.AggregationType = undefined;
  var Aggregation_1 = require_Aggregation();
  var AggregationType;
  (function(AggregationType2) {
    AggregationType2[AggregationType2["DEFAULT"] = 0] = "DEFAULT";
    AggregationType2[AggregationType2["DROP"] = 1] = "DROP";
    AggregationType2[AggregationType2["SUM"] = 2] = "SUM";
    AggregationType2[AggregationType2["LAST_VALUE"] = 3] = "LAST_VALUE";
    AggregationType2[AggregationType2["EXPLICIT_BUCKET_HISTOGRAM"] = 4] = "EXPLICIT_BUCKET_HISTOGRAM";
    AggregationType2[AggregationType2["EXPONENTIAL_HISTOGRAM"] = 5] = "EXPONENTIAL_HISTOGRAM";
  })(AggregationType = exports.AggregationType || (exports.AggregationType = {}));
  function toAggregation(option) {
    switch (option.type) {
      case AggregationType.DEFAULT:
        return Aggregation_1.DEFAULT_AGGREGATION;
      case AggregationType.DROP:
        return Aggregation_1.DROP_AGGREGATION;
      case AggregationType.SUM:
        return Aggregation_1.SUM_AGGREGATION;
      case AggregationType.LAST_VALUE:
        return Aggregation_1.LAST_VALUE_AGGREGATION;
      case AggregationType.EXPONENTIAL_HISTOGRAM: {
        const expOption = option;
        return new Aggregation_1.ExponentialHistogramAggregation(expOption.options?.maxSize, expOption.options?.recordMinMax);
      }
      case AggregationType.EXPLICIT_BUCKET_HISTOGRAM: {
        const expOption = option;
        if (expOption.options == null) {
          return Aggregation_1.HISTOGRAM_AGGREGATION;
        } else {
          return new Aggregation_1.ExplicitBucketHistogramAggregation(expOption.options?.boundaries, expOption.options?.recordMinMax);
        }
      }
      default:
        throw new Error("Unsupported Aggregation");
    }
  }
  exports.toAggregation = toAggregation;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js
var require_AggregationSelector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = exports.DEFAULT_AGGREGATION_SELECTOR = undefined;
  var AggregationTemporality_1 = require_AggregationTemporality();
  var AggregationOption_1 = require_AggregationOption();
  var DEFAULT_AGGREGATION_SELECTOR = (_instrumentType) => {
    return {
      type: AggregationOption_1.AggregationType.DEFAULT
    };
  };
  exports.DEFAULT_AGGREGATION_SELECTOR = DEFAULT_AGGREGATION_SELECTOR;
  var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = (_instrumentType) => AggregationTemporality_1.AggregationTemporality.CUMULATIVE;
  exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js
var require_MetricReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricReader = undefined;
  var api = require_src();
  var utils_1 = require_utils7();
  var AggregationSelector_1 = require_AggregationSelector();

  class MetricReader {
    _shutdown = false;
    _metricProducers;
    _sdkMetricProducer;
    _aggregationTemporalitySelector;
    _aggregationSelector;
    _cardinalitySelector;
    constructor(options) {
      this._aggregationSelector = options?.aggregationSelector ?? AggregationSelector_1.DEFAULT_AGGREGATION_SELECTOR;
      this._aggregationTemporalitySelector = options?.aggregationTemporalitySelector ?? AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
      this._metricProducers = options?.metricProducers ?? [];
      this._cardinalitySelector = options?.cardinalitySelector;
    }
    setMetricProducer(metricProducer) {
      if (this._sdkMetricProducer) {
        throw new Error("MetricReader can not be bound to a MeterProvider again.");
      }
      this._sdkMetricProducer = metricProducer;
      this.onInitialized();
    }
    selectAggregation(instrumentType) {
      return this._aggregationSelector(instrumentType);
    }
    selectAggregationTemporality(instrumentType) {
      return this._aggregationTemporalitySelector(instrumentType);
    }
    selectCardinalityLimit(instrumentType) {
      return this._cardinalitySelector ? this._cardinalitySelector(instrumentType) : 2000;
    }
    onInitialized() {
    }
    async collect(options) {
      if (this._sdkMetricProducer === undefined) {
        throw new Error("MetricReader is not bound to a MetricProducer");
      }
      if (this._shutdown) {
        throw new Error("MetricReader is shutdown");
      }
      const [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([
        this._sdkMetricProducer.collect({
          timeoutMillis: options?.timeoutMillis
        }),
        ...this._metricProducers.map((producer) => producer.collect({
          timeoutMillis: options?.timeoutMillis
        }))
      ]);
      const errors = sdkCollectionResults.errors.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.errors));
      const resource = sdkCollectionResults.resourceMetrics.resource;
      const scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.resourceMetrics.scopeMetrics));
      return {
        resourceMetrics: {
          resource,
          scopeMetrics
        },
        errors
      };
    }
    async shutdown(options) {
      if (this._shutdown) {
        api.diag.error("Cannot call shutdown twice.");
        return;
      }
      if (options?.timeoutMillis == null) {
        await this.onShutdown();
      } else {
        await (0, utils_1.callWithTimeout)(this.onShutdown(), options.timeoutMillis);
      }
      this._shutdown = true;
    }
    async forceFlush(options) {
      if (this._shutdown) {
        api.diag.warn("Cannot forceFlush on already shutdown MetricReader.");
        return;
      }
      if (options?.timeoutMillis == null) {
        await this.onForceFlush();
        return;
      }
      await (0, utils_1.callWithTimeout)(this.onForceFlush(), options.timeoutMillis);
    }
  }
  exports.MetricReader = MetricReader;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js
var require_PeriodicExportingMetricReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PeriodicExportingMetricReader = undefined;
  var api = require_src();
  var core_1 = require_src3();
  var MetricReader_1 = require_MetricReader();
  var utils_1 = require_utils7();

  class PeriodicExportingMetricReader extends MetricReader_1.MetricReader {
    _interval;
    _exporter;
    _exportInterval;
    _exportTimeout;
    constructor(options) {
      super({
        aggregationSelector: options.exporter.selectAggregation?.bind(options.exporter),
        aggregationTemporalitySelector: options.exporter.selectAggregationTemporality?.bind(options.exporter),
        metricProducers: options.metricProducers
      });
      if (options.exportIntervalMillis !== undefined && options.exportIntervalMillis <= 0) {
        throw Error("exportIntervalMillis must be greater than 0");
      }
      if (options.exportTimeoutMillis !== undefined && options.exportTimeoutMillis <= 0) {
        throw Error("exportTimeoutMillis must be greater than 0");
      }
      if (options.exportTimeoutMillis !== undefined && options.exportIntervalMillis !== undefined && options.exportIntervalMillis < options.exportTimeoutMillis) {
        throw Error("exportIntervalMillis must be greater than or equal to exportTimeoutMillis");
      }
      this._exportInterval = options.exportIntervalMillis ?? 60000;
      this._exportTimeout = options.exportTimeoutMillis ?? 30000;
      this._exporter = options.exporter;
    }
    async _runOnce() {
      try {
        await (0, utils_1.callWithTimeout)(this._doRun(), this._exportTimeout);
      } catch (err) {
        if (err instanceof utils_1.TimeoutError) {
          api.diag.error("Export took longer than %s milliseconds and timed out.", this._exportTimeout);
          return;
        }
        (0, core_1.globalErrorHandler)(err);
      }
    }
    async _doRun() {
      const { resourceMetrics, errors } = await this.collect({
        timeoutMillis: this._exportTimeout
      });
      if (errors.length > 0) {
        api.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors);
      }
      if (resourceMetrics.resource.asyncAttributesPending) {
        try {
          await resourceMetrics.resource.waitForAsyncAttributes?.();
        } catch (e) {
          api.diag.debug("Error while resolving async portion of resource: ", e);
          (0, core_1.globalErrorHandler)(e);
        }
      }
      if (resourceMetrics.scopeMetrics.length === 0) {
        return;
      }
      const result = await core_1.internal._export(this._exporter, resourceMetrics);
      if (result.code !== core_1.ExportResultCode.SUCCESS) {
        throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result.error})`);
      }
    }
    onInitialized() {
      this._interval = setInterval(() => {
        this._runOnce();
      }, this._exportInterval);
      (0, core_1.unrefTimer)(this._interval);
    }
    async onForceFlush() {
      await this._runOnce();
      await this._exporter.forceFlush();
    }
    async onShutdown() {
      if (this._interval) {
        clearInterval(this._interval);
      }
      await this.onForceFlush();
      await this._exporter.shutdown();
    }
  }
  exports.PeriodicExportingMetricReader = PeriodicExportingMetricReader;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js
var require_InMemoryMetricExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InMemoryMetricExporter = undefined;
  var core_1 = require_src3();

  class InMemoryMetricExporter {
    _shutdown = false;
    _aggregationTemporality;
    _metrics = [];
    constructor(aggregationTemporality) {
      this._aggregationTemporality = aggregationTemporality;
    }
    export(metrics, resultCallback) {
      if (this._shutdown) {
        setTimeout(() => resultCallback({ code: core_1.ExportResultCode.FAILED }), 0);
        return;
      }
      this._metrics.push(metrics);
      setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
    }
    getMetrics() {
      return this._metrics;
    }
    forceFlush() {
      return Promise.resolve();
    }
    reset() {
      this._metrics = [];
    }
    selectAggregationTemporality(_instrumentType) {
      return this._aggregationTemporality;
    }
    shutdown() {
      this._shutdown = true;
      return Promise.resolve();
    }
  }
  exports.InMemoryMetricExporter = InMemoryMetricExporter;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js
var require_ConsoleMetricExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConsoleMetricExporter = undefined;
  var core_1 = require_src3();
  var AggregationSelector_1 = require_AggregationSelector();

  class ConsoleMetricExporter {
    _shutdown = false;
    _temporalitySelector;
    constructor(options) {
      this._temporalitySelector = options?.temporalitySelector ?? AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
    }
    export(metrics, resultCallback) {
      if (this._shutdown) {
        setImmediate(resultCallback, { code: core_1.ExportResultCode.FAILED });
        return;
      }
      return ConsoleMetricExporter._sendMetrics(metrics, resultCallback);
    }
    forceFlush() {
      return Promise.resolve();
    }
    selectAggregationTemporality(_instrumentType) {
      return this._temporalitySelector(_instrumentType);
    }
    shutdown() {
      this._shutdown = true;
      return Promise.resolve();
    }
    static _sendMetrics(metrics, done) {
      for (const scopeMetrics of metrics.scopeMetrics) {
        for (const metric of scopeMetrics.metrics) {
          console.dir({
            descriptor: metric.descriptor,
            dataPointType: metric.dataPointType,
            dataPoints: metric.dataPoints
          }, { depth: null });
        }
      }
      done({ code: core_1.ExportResultCode.SUCCESS });
    }
  }
  exports.ConsoleMetricExporter = ConsoleMetricExporter;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js
var require_ViewRegistry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ViewRegistry = undefined;

  class ViewRegistry {
    _registeredViews = [];
    addView(view) {
      this._registeredViews.push(view);
    }
    findViews(instrument, meter) {
      const views = this._registeredViews.filter((registeredView) => {
        return this._matchInstrument(registeredView.instrumentSelector, instrument) && this._matchMeter(registeredView.meterSelector, meter);
      });
      return views;
    }
    _matchInstrument(selector, instrument) {
      return (selector.getType() === undefined || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
    }
    _matchMeter(selector, meter) {
      return selector.getNameFilter().match(meter.name) && (meter.version === undefined || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === undefined || selector.getSchemaUrlFilter().match(meter.schemaUrl));
    }
  }
  exports.ViewRegistry = ViewRegistry;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js
var require_InstrumentDescriptor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidName = exports.isDescriptorCompatibleWith = exports.createInstrumentDescriptorWithView = exports.createInstrumentDescriptor = undefined;
  var api_1 = require_src();
  var utils_1 = require_utils7();
  function createInstrumentDescriptor(name, type2, options) {
    if (!isValidName(name)) {
      api_1.diag.warn(`Invalid metric name: "${name}". The metric name should be a ASCII string with a length no greater than 255 characters.`);
    }
    return {
      name,
      type: type2,
      description: options?.description ?? "",
      unit: options?.unit ?? "",
      valueType: options?.valueType ?? api_1.ValueType.DOUBLE,
      advice: options?.advice ?? {}
    };
  }
  exports.createInstrumentDescriptor = createInstrumentDescriptor;
  function createInstrumentDescriptorWithView(view, instrument) {
    return {
      name: view.name ?? instrument.name,
      description: view.description ?? instrument.description,
      type: instrument.type,
      unit: instrument.unit,
      valueType: instrument.valueType,
      advice: instrument.advice
    };
  }
  exports.createInstrumentDescriptorWithView = createInstrumentDescriptorWithView;
  function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
    return (0, utils_1.equalsCaseInsensitive)(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;
  }
  exports.isDescriptorCompatibleWith = isDescriptorCompatibleWith;
  var NAME_REGEXP = /^[a-z][a-z0-9_.\-/]{0,254}$/i;
  function isValidName(name) {
    return name.match(NAME_REGEXP) != null;
  }
  exports.isValidName = isValidName;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js
var require_Instruments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObservableInstrument = exports.ObservableUpDownCounterInstrument = exports.ObservableGaugeInstrument = exports.ObservableCounterInstrument = exports.ObservableInstrument = exports.HistogramInstrument = exports.GaugeInstrument = exports.CounterInstrument = exports.UpDownCounterInstrument = exports.SyncInstrument = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();

  class SyncInstrument {
    _writableMetricStorage;
    _descriptor;
    constructor(_writableMetricStorage, _descriptor) {
      this._writableMetricStorage = _writableMetricStorage;
      this._descriptor = _descriptor;
    }
    _record(value, attributes = {}, context = api_1.context.active()) {
      if (typeof value !== "number") {
        api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
        return;
      }
      if (this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
        api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`);
        value = Math.trunc(value);
        if (!Number.isInteger(value)) {
          return;
        }
      }
      this._writableMetricStorage.record(value, attributes, context, (0, core_1.millisToHrTime)(Date.now()));
    }
  }
  exports.SyncInstrument = SyncInstrument;

  class UpDownCounterInstrument extends SyncInstrument {
    add(value, attributes, ctx) {
      this._record(value, attributes, ctx);
    }
  }
  exports.UpDownCounterInstrument = UpDownCounterInstrument;

  class CounterInstrument extends SyncInstrument {
    add(value, attributes, ctx) {
      if (value < 0) {
        api_1.diag.warn(`negative value provided to counter ${this._descriptor.name}: ${value}`);
        return;
      }
      this._record(value, attributes, ctx);
    }
  }
  exports.CounterInstrument = CounterInstrument;

  class GaugeInstrument extends SyncInstrument {
    record(value, attributes, ctx) {
      this._record(value, attributes, ctx);
    }
  }
  exports.GaugeInstrument = GaugeInstrument;

  class HistogramInstrument extends SyncInstrument {
    record(value, attributes, ctx) {
      if (value < 0) {
        api_1.diag.warn(`negative value provided to histogram ${this._descriptor.name}: ${value}`);
        return;
      }
      this._record(value, attributes, ctx);
    }
  }
  exports.HistogramInstrument = HistogramInstrument;

  class ObservableInstrument {
    _observableRegistry;
    _metricStorages;
    _descriptor;
    constructor(descriptor, metricStorages, _observableRegistry) {
      this._observableRegistry = _observableRegistry;
      this._descriptor = descriptor;
      this._metricStorages = metricStorages;
    }
    addCallback(callback) {
      this._observableRegistry.addCallback(callback, this);
    }
    removeCallback(callback) {
      this._observableRegistry.removeCallback(callback, this);
    }
  }
  exports.ObservableInstrument = ObservableInstrument;

  class ObservableCounterInstrument extends ObservableInstrument {
  }
  exports.ObservableCounterInstrument = ObservableCounterInstrument;

  class ObservableGaugeInstrument extends ObservableInstrument {
  }
  exports.ObservableGaugeInstrument = ObservableGaugeInstrument;

  class ObservableUpDownCounterInstrument extends ObservableInstrument {
  }
  exports.ObservableUpDownCounterInstrument = ObservableUpDownCounterInstrument;
  function isObservableInstrument(it) {
    return it instanceof ObservableInstrument;
  }
  exports.isObservableInstrument = isObservableInstrument;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js
var require_Meter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Meter = undefined;
  var InstrumentDescriptor_1 = require_InstrumentDescriptor();
  var Instruments_1 = require_Instruments();
  var MetricData_1 = require_MetricData();

  class Meter {
    _meterSharedState;
    constructor(_meterSharedState) {
      this._meterSharedState = _meterSharedState;
    }
    createGauge(name, options) {
      const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, MetricData_1.InstrumentType.GAUGE, options);
      const storage = this._meterSharedState.registerMetricStorage(descriptor);
      return new Instruments_1.GaugeInstrument(storage, descriptor);
    }
    createHistogram(name, options) {
      const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, MetricData_1.InstrumentType.HISTOGRAM, options);
      const storage = this._meterSharedState.registerMetricStorage(descriptor);
      return new Instruments_1.HistogramInstrument(storage, descriptor);
    }
    createCounter(name, options) {
      const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, MetricData_1.InstrumentType.COUNTER, options);
      const storage = this._meterSharedState.registerMetricStorage(descriptor);
      return new Instruments_1.CounterInstrument(storage, descriptor);
    }
    createUpDownCounter(name, options) {
      const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, MetricData_1.InstrumentType.UP_DOWN_COUNTER, options);
      const storage = this._meterSharedState.registerMetricStorage(descriptor);
      return new Instruments_1.UpDownCounterInstrument(storage, descriptor);
    }
    createObservableGauge(name, options) {
      const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, MetricData_1.InstrumentType.OBSERVABLE_GAUGE, options);
      const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
      return new Instruments_1.ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
    }
    createObservableCounter(name, options) {
      const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, MetricData_1.InstrumentType.OBSERVABLE_COUNTER, options);
      const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
      return new Instruments_1.ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
    }
    createObservableUpDownCounter(name, options) {
      const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, MetricData_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options);
      const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
      return new Instruments_1.ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
    }
    addBatchObservableCallback(callback, observables) {
      this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
    }
    removeBatchObservableCallback(callback, observables) {
      this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
    }
  }
  exports.Meter = Meter;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js
var require_MetricStorage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricStorage = undefined;
  var InstrumentDescriptor_1 = require_InstrumentDescriptor();

  class MetricStorage {
    _instrumentDescriptor;
    constructor(_instrumentDescriptor) {
      this._instrumentDescriptor = _instrumentDescriptor;
    }
    getInstrumentDescriptor() {
      return this._instrumentDescriptor;
    }
    updateDescription(description) {
      this._instrumentDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
        description,
        valueType: this._instrumentDescriptor.valueType,
        unit: this._instrumentDescriptor.unit,
        advice: this._instrumentDescriptor.advice
      });
    }
  }
  exports.MetricStorage = MetricStorage;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js
var require_HashMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeHashMap = exports.HashMap = undefined;
  var utils_1 = require_utils7();

  class HashMap {
    _hash;
    _valueMap = new Map;
    _keyMap = new Map;
    constructor(_hash) {
      this._hash = _hash;
    }
    get(key, hashCode) {
      hashCode ??= this._hash(key);
      return this._valueMap.get(hashCode);
    }
    getOrDefault(key, defaultFactory) {
      const hash = this._hash(key);
      if (this._valueMap.has(hash)) {
        return this._valueMap.get(hash);
      }
      const val = defaultFactory();
      if (!this._keyMap.has(hash)) {
        this._keyMap.set(hash, key);
      }
      this._valueMap.set(hash, val);
      return val;
    }
    set(key, value, hashCode) {
      hashCode ??= this._hash(key);
      if (!this._keyMap.has(hashCode)) {
        this._keyMap.set(hashCode, key);
      }
      this._valueMap.set(hashCode, value);
    }
    has(key, hashCode) {
      hashCode ??= this._hash(key);
      return this._valueMap.has(hashCode);
    }
    *keys() {
      const keyIterator = this._keyMap.entries();
      let next = keyIterator.next();
      while (next.done !== true) {
        yield [next.value[1], next.value[0]];
        next = keyIterator.next();
      }
    }
    *entries() {
      const valueIterator = this._valueMap.entries();
      let next = valueIterator.next();
      while (next.done !== true) {
        yield [this._keyMap.get(next.value[0]), next.value[1], next.value[0]];
        next = valueIterator.next();
      }
    }
    get size() {
      return this._valueMap.size;
    }
  }
  exports.HashMap = HashMap;

  class AttributeHashMap extends HashMap {
    constructor() {
      super(utils_1.hashAttributes);
    }
  }
  exports.AttributeHashMap = AttributeHashMap;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js
var require_DeltaMetricProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeltaMetricProcessor = undefined;
  var utils_1 = require_utils7();
  var HashMap_1 = require_HashMap();

  class DeltaMetricProcessor {
    _aggregator;
    _activeCollectionStorage = new HashMap_1.AttributeHashMap;
    _cumulativeMemoStorage = new HashMap_1.AttributeHashMap;
    _cardinalityLimit;
    _overflowAttributes = { "otel.metric.overflow": true };
    _overflowHashCode;
    constructor(_aggregator, aggregationCardinalityLimit) {
      this._aggregator = _aggregator;
      this._cardinalityLimit = (aggregationCardinalityLimit ?? 2000) - 1;
      this._overflowHashCode = (0, utils_1.hashAttributes)(this._overflowAttributes);
    }
    record(value, attributes, _context, collectionTime) {
      let accumulation = this._activeCollectionStorage.get(attributes);
      if (!accumulation) {
        if (this._activeCollectionStorage.size >= this._cardinalityLimit) {
          const overflowAccumulation = this._activeCollectionStorage.getOrDefault(this._overflowAttributes, () => this._aggregator.createAccumulation(collectionTime));
          overflowAccumulation?.record(value);
          return;
        }
        accumulation = this._aggregator.createAccumulation(collectionTime);
        this._activeCollectionStorage.set(attributes, accumulation);
      }
      accumulation?.record(value);
    }
    batchCumulate(measurements, collectionTime) {
      Array.from(measurements.entries()).forEach(([attributes, value, hashCode]) => {
        const accumulation = this._aggregator.createAccumulation(collectionTime);
        accumulation?.record(value);
        let delta = accumulation;
        if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
          const previous = this._cumulativeMemoStorage.get(attributes, hashCode);
          delta = this._aggregator.diff(previous, accumulation);
        } else {
          if (this._cumulativeMemoStorage.size >= this._cardinalityLimit) {
            attributes = this._overflowAttributes;
            hashCode = this._overflowHashCode;
            if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
              const previous = this._cumulativeMemoStorage.get(attributes, hashCode);
              delta = this._aggregator.diff(previous, accumulation);
            }
          }
        }
        if (this._activeCollectionStorage.has(attributes, hashCode)) {
          const active = this._activeCollectionStorage.get(attributes, hashCode);
          delta = this._aggregator.merge(active, delta);
        }
        this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);
        this._activeCollectionStorage.set(attributes, delta, hashCode);
      });
    }
    collect() {
      const unreportedDelta = this._activeCollectionStorage;
      this._activeCollectionStorage = new HashMap_1.AttributeHashMap;
      return unreportedDelta;
    }
  }
  exports.DeltaMetricProcessor = DeltaMetricProcessor;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js
var require_TemporalMetricProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemporalMetricProcessor = undefined;
  var AggregationTemporality_1 = require_AggregationTemporality();
  var HashMap_1 = require_HashMap();

  class TemporalMetricProcessor {
    _aggregator;
    _unreportedAccumulations = new Map;
    _reportHistory = new Map;
    constructor(_aggregator, collectorHandles) {
      this._aggregator = _aggregator;
      collectorHandles.forEach((handle) => {
        this._unreportedAccumulations.set(handle, []);
      });
    }
    buildMetrics(collector, instrumentDescriptor, currentAccumulations, collectionTime) {
      this._stashAccumulations(currentAccumulations);
      const unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);
      let result = unreportedAccumulations;
      let aggregationTemporality;
      if (this._reportHistory.has(collector)) {
        const last = this._reportHistory.get(collector);
        const lastCollectionTime = last.collectionTime;
        aggregationTemporality = last.aggregationTemporality;
        if (aggregationTemporality === AggregationTemporality_1.AggregationTemporality.CUMULATIVE) {
          result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);
        } else {
          result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
        }
      } else {
        aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
      }
      this._reportHistory.set(collector, {
        accumulations: result,
        collectionTime,
        aggregationTemporality
      });
      const accumulationRecords = AttributesMapToAccumulationRecords(result);
      if (accumulationRecords.length === 0) {
        return;
      }
      return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, collectionTime);
    }
    _stashAccumulations(currentAccumulation) {
      const registeredCollectors = this._unreportedAccumulations.keys();
      for (const collector of registeredCollectors) {
        let stash = this._unreportedAccumulations.get(collector);
        if (stash === undefined) {
          stash = [];
          this._unreportedAccumulations.set(collector, stash);
        }
        stash.push(currentAccumulation);
      }
    }
    _getMergedUnreportedAccumulations(collector) {
      let result = new HashMap_1.AttributeHashMap;
      const unreportedList = this._unreportedAccumulations.get(collector);
      this._unreportedAccumulations.set(collector, []);
      if (unreportedList === undefined) {
        return result;
      }
      for (const it of unreportedList) {
        result = TemporalMetricProcessor.merge(result, it, this._aggregator);
      }
      return result;
    }
    static merge(last, current, aggregator) {
      const result = last;
      const iterator = current.entries();
      let next = iterator.next();
      while (next.done !== true) {
        const [key, record, hash] = next.value;
        if (last.has(key, hash)) {
          const lastAccumulation = last.get(key, hash);
          const accumulation = aggregator.merge(lastAccumulation, record);
          result.set(key, accumulation, hash);
        } else {
          result.set(key, record, hash);
        }
        next = iterator.next();
      }
      return result;
    }
    static calibrateStartTime(last, current, lastCollectionTime) {
      for (const [key, hash] of last.keys()) {
        const currentAccumulation = current.get(key, hash);
        currentAccumulation?.setStartTime(lastCollectionTime);
      }
      return current;
    }
  }
  exports.TemporalMetricProcessor = TemporalMetricProcessor;
  function AttributesMapToAccumulationRecords(map) {
    return Array.from(map.entries());
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js
var require_AsyncMetricStorage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncMetricStorage = undefined;
  var MetricStorage_1 = require_MetricStorage();
  var DeltaMetricProcessor_1 = require_DeltaMetricProcessor();
  var TemporalMetricProcessor_1 = require_TemporalMetricProcessor();
  var HashMap_1 = require_HashMap();

  class AsyncMetricStorage extends MetricStorage_1.MetricStorage {
    _attributesProcessor;
    _aggregationCardinalityLimit;
    _deltaMetricStorage;
    _temporalMetricStorage;
    constructor(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
      super(_instrumentDescriptor);
      this._attributesProcessor = _attributesProcessor;
      this._aggregationCardinalityLimit = _aggregationCardinalityLimit;
      this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator, this._aggregationCardinalityLimit);
      this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
    }
    record(measurements, observationTime) {
      const processed = new HashMap_1.AttributeHashMap;
      Array.from(measurements.entries()).forEach(([attributes, value]) => {
        processed.set(this._attributesProcessor.process(attributes), value);
      });
      this._deltaMetricStorage.batchCumulate(processed, observationTime);
    }
    collect(collector, collectionTime) {
      const accumulations = this._deltaMetricStorage.collect();
      return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
    }
  }
  exports.AsyncMetricStorage = AsyncMetricStorage;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js
var require_RegistrationConflicts = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getConflictResolutionRecipe = exports.getDescriptionResolutionRecipe = exports.getTypeConflictResolutionRecipe = exports.getUnitConflictResolutionRecipe = exports.getValueTypeConflictResolutionRecipe = exports.getIncompatibilityDetails = undefined;
  function getIncompatibilityDetails(existing, otherDescriptor) {
    let incompatibility = "";
    if (existing.unit !== otherDescriptor.unit) {
      incompatibility += `\t- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'
`;
    }
    if (existing.type !== otherDescriptor.type) {
      incompatibility += `\t- Type '${existing.type}' does not match '${otherDescriptor.type}'
`;
    }
    if (existing.valueType !== otherDescriptor.valueType) {
      incompatibility += `\t- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'
`;
    }
    if (existing.description !== otherDescriptor.description) {
      incompatibility += `\t- Description '${existing.description}' does not match '${otherDescriptor.description}'
`;
    }
    return incompatibility;
  }
  exports.getIncompatibilityDetails = getIncompatibilityDetails;
  function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
    return `\t- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
  }
  exports.getValueTypeConflictResolutionRecipe = getValueTypeConflictResolutionRecipe;
  function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
    return `\t- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
  }
  exports.getUnitConflictResolutionRecipe = getUnitConflictResolutionRecipe;
  function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
    const selector = {
      name: otherDescriptor.name,
      type: otherDescriptor.type,
      unit: otherDescriptor.unit
    };
    const selectorString = JSON.stringify(selector);
    return `\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;
  }
  exports.getTypeConflictResolutionRecipe = getTypeConflictResolutionRecipe;
  function getDescriptionResolutionRecipe(existing, otherDescriptor) {
    const selector = {
      name: otherDescriptor.name,
      type: otherDescriptor.type,
      unit: otherDescriptor.unit
    };
    const selectorString = JSON.stringify(selector);
    return `\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'
    \t- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}
    \t- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;
  }
  exports.getDescriptionResolutionRecipe = getDescriptionResolutionRecipe;
  function getConflictResolutionRecipe(existing, otherDescriptor) {
    if (existing.valueType !== otherDescriptor.valueType) {
      return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);
    }
    if (existing.unit !== otherDescriptor.unit) {
      return getUnitConflictResolutionRecipe(existing, otherDescriptor);
    }
    if (existing.type !== otherDescriptor.type) {
      return getTypeConflictResolutionRecipe(existing, otherDescriptor);
    }
    if (existing.description !== otherDescriptor.description) {
      return getDescriptionResolutionRecipe(existing, otherDescriptor);
    }
    return "";
  }
  exports.getConflictResolutionRecipe = getConflictResolutionRecipe;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js
var require_MetricStorageRegistry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricStorageRegistry = undefined;
  var InstrumentDescriptor_1 = require_InstrumentDescriptor();
  var api = require_src();
  var RegistrationConflicts_1 = require_RegistrationConflicts();

  class MetricStorageRegistry {
    _sharedRegistry = new Map;
    _perCollectorRegistry = new Map;
    static create() {
      return new MetricStorageRegistry;
    }
    getStorages(collector) {
      let storages = [];
      for (const metricStorages of this._sharedRegistry.values()) {
        storages = storages.concat(metricStorages);
      }
      const perCollectorStorages = this._perCollectorRegistry.get(collector);
      if (perCollectorStorages != null) {
        for (const metricStorages of perCollectorStorages.values()) {
          storages = storages.concat(metricStorages);
        }
      }
      return storages;
    }
    register(storage) {
      this._registerStorage(storage, this._sharedRegistry);
    }
    registerForCollector(collector, storage) {
      let storageMap = this._perCollectorRegistry.get(collector);
      if (storageMap == null) {
        storageMap = new Map;
        this._perCollectorRegistry.set(collector, storageMap);
      }
      this._registerStorage(storage, storageMap);
    }
    findOrUpdateCompatibleStorage(expectedDescriptor) {
      const storages = this._sharedRegistry.get(expectedDescriptor.name);
      if (storages === undefined) {
        return null;
      }
      return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
    }
    findOrUpdateCompatibleCollectorStorage(collector, expectedDescriptor) {
      const storageMap = this._perCollectorRegistry.get(collector);
      if (storageMap === undefined) {
        return null;
      }
      const storages = storageMap.get(expectedDescriptor.name);
      if (storages === undefined) {
        return null;
      }
      return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
    }
    _registerStorage(storage, storageMap) {
      const descriptor = storage.getInstrumentDescriptor();
      const storages = storageMap.get(descriptor.name);
      if (storages === undefined) {
        storageMap.set(descriptor.name, [storage]);
        return;
      }
      storages.push(storage);
    }
    _findOrUpdateCompatibleStorage(expectedDescriptor, existingStorages) {
      let compatibleStorage = null;
      for (const existingStorage of existingStorages) {
        const existingDescriptor = existingStorage.getInstrumentDescriptor();
        if ((0, InstrumentDescriptor_1.isDescriptorCompatibleWith)(existingDescriptor, expectedDescriptor)) {
          if (existingDescriptor.description !== expectedDescriptor.description) {
            if (expectedDescriptor.description.length > existingDescriptor.description.length) {
              existingStorage.updateDescription(expectedDescriptor.description);
            }
            api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered, but has a different description and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `The longer description will be used.
To resolve the conflict:`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
          }
          compatibleStorage = existingStorage;
        } else {
          api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `To resolve the conflict:
`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
        }
      }
      return compatibleStorage;
    }
  }
  exports.MetricStorageRegistry = MetricStorageRegistry;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js
var require_MultiWritableMetricStorage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiMetricStorage = undefined;

  class MultiMetricStorage {
    _backingStorages;
    constructor(_backingStorages) {
      this._backingStorages = _backingStorages;
    }
    record(value, attributes, context, recordTime) {
      this._backingStorages.forEach((it) => {
        it.record(value, attributes, context, recordTime);
      });
    }
  }
  exports.MultiMetricStorage = MultiMetricStorage;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js
var require_ObservableResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchObservableResultImpl = exports.ObservableResultImpl = undefined;
  var api_1 = require_src();
  var HashMap_1 = require_HashMap();
  var Instruments_1 = require_Instruments();

  class ObservableResultImpl {
    _instrumentName;
    _valueType;
    _buffer = new HashMap_1.AttributeHashMap;
    constructor(_instrumentName, _valueType) {
      this._instrumentName = _instrumentName;
      this._valueType = _valueType;
    }
    observe(value, attributes = {}) {
      if (typeof value !== "number") {
        api_1.diag.warn(`non-number value provided to metric ${this._instrumentName}: ${value}`);
        return;
      }
      if (this._valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
        api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._instrumentName}, ignoring the fractional digits.`);
        value = Math.trunc(value);
        if (!Number.isInteger(value)) {
          return;
        }
      }
      this._buffer.set(attributes, value);
    }
  }
  exports.ObservableResultImpl = ObservableResultImpl;

  class BatchObservableResultImpl {
    _buffer = new Map;
    observe(metric, value, attributes = {}) {
      if (!(0, Instruments_1.isObservableInstrument)(metric)) {
        return;
      }
      let map = this._buffer.get(metric);
      if (map == null) {
        map = new HashMap_1.AttributeHashMap;
        this._buffer.set(metric, map);
      }
      if (typeof value !== "number") {
        api_1.diag.warn(`non-number value provided to metric ${metric._descriptor.name}: ${value}`);
        return;
      }
      if (metric._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
        api_1.diag.warn(`INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`);
        value = Math.trunc(value);
        if (!Number.isInteger(value)) {
          return;
        }
      }
      map.set(attributes, value);
    }
  }
  exports.BatchObservableResultImpl = BatchObservableResultImpl;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js
var require_ObservableRegistry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObservableRegistry = undefined;
  var api_1 = require_src();
  var Instruments_1 = require_Instruments();
  var ObservableResult_1 = require_ObservableResult();
  var utils_1 = require_utils7();

  class ObservableRegistry {
    _callbacks = [];
    _batchCallbacks = [];
    addCallback(callback, instrument) {
      const idx = this._findCallback(callback, instrument);
      if (idx >= 0) {
        return;
      }
      this._callbacks.push({ callback, instrument });
    }
    removeCallback(callback, instrument) {
      const idx = this._findCallback(callback, instrument);
      if (idx < 0) {
        return;
      }
      this._callbacks.splice(idx, 1);
    }
    addBatchCallback(callback, instruments) {
      const observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
      if (observableInstruments.size === 0) {
        api_1.diag.error("BatchObservableCallback is not associated with valid instruments", instruments);
        return;
      }
      const idx = this._findBatchCallback(callback, observableInstruments);
      if (idx >= 0) {
        return;
      }
      this._batchCallbacks.push({ callback, instruments: observableInstruments });
    }
    removeBatchCallback(callback, instruments) {
      const observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
      const idx = this._findBatchCallback(callback, observableInstruments);
      if (idx < 0) {
        return;
      }
      this._batchCallbacks.splice(idx, 1);
    }
    async observe(collectionTime, timeoutMillis) {
      const callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);
      const batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
      const results = await (0, utils_1.PromiseAllSettled)([
        ...callbackFutures,
        ...batchCallbackFutures
      ]);
      const rejections = results.filter(utils_1.isPromiseAllSettledRejectionResult).map((it) => it.reason);
      return rejections;
    }
    _observeCallbacks(observationTime, timeoutMillis) {
      return this._callbacks.map(async ({ callback, instrument }) => {
        const observableResult = new ObservableResult_1.ObservableResultImpl(instrument._descriptor.name, instrument._descriptor.valueType);
        let callPromise = Promise.resolve(callback(observableResult));
        if (timeoutMillis != null) {
          callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis);
        }
        await callPromise;
        instrument._metricStorages.forEach((metricStorage) => {
          metricStorage.record(observableResult._buffer, observationTime);
        });
      });
    }
    _observeBatchCallbacks(observationTime, timeoutMillis) {
      return this._batchCallbacks.map(async ({ callback, instruments }) => {
        const observableResult = new ObservableResult_1.BatchObservableResultImpl;
        let callPromise = Promise.resolve(callback(observableResult));
        if (timeoutMillis != null) {
          callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis);
        }
        await callPromise;
        instruments.forEach((instrument) => {
          const buffer = observableResult._buffer.get(instrument);
          if (buffer == null) {
            return;
          }
          instrument._metricStorages.forEach((metricStorage) => {
            metricStorage.record(buffer, observationTime);
          });
        });
      });
    }
    _findCallback(callback, instrument) {
      return this._callbacks.findIndex((record) => {
        return record.callback === callback && record.instrument === instrument;
      });
    }
    _findBatchCallback(callback, instruments) {
      return this._batchCallbacks.findIndex((record) => {
        return record.callback === callback && (0, utils_1.setEquals)(record.instruments, instruments);
      });
    }
  }
  exports.ObservableRegistry = ObservableRegistry;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js
var require_SyncMetricStorage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SyncMetricStorage = undefined;
  var MetricStorage_1 = require_MetricStorage();
  var DeltaMetricProcessor_1 = require_DeltaMetricProcessor();
  var TemporalMetricProcessor_1 = require_TemporalMetricProcessor();

  class SyncMetricStorage extends MetricStorage_1.MetricStorage {
    _attributesProcessor;
    _aggregationCardinalityLimit;
    _deltaMetricStorage;
    _temporalMetricStorage;
    constructor(instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
      super(instrumentDescriptor);
      this._attributesProcessor = _attributesProcessor;
      this._aggregationCardinalityLimit = _aggregationCardinalityLimit;
      this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator, this._aggregationCardinalityLimit);
      this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
    }
    record(value, attributes, context, recordTime) {
      attributes = this._attributesProcessor.process(attributes, context);
      this._deltaMetricStorage.record(value, attributes, context, recordTime);
    }
    collect(collector, collectionTime) {
      const accumulations = this._deltaMetricStorage.collect();
      return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
    }
  }
  exports.SyncMetricStorage = SyncMetricStorage;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js
var require_AttributesProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDenyListAttributesProcessor = exports.createAllowListAttributesProcessor = exports.createMultiAttributesProcessor = exports.createNoopAttributesProcessor = undefined;

  class NoopAttributesProcessor {
    process(incoming, _context) {
      return incoming;
    }
  }

  class MultiAttributesProcessor {
    _processors;
    constructor(_processors) {
      this._processors = _processors;
    }
    process(incoming, context) {
      let filteredAttributes = incoming;
      for (const processor of this._processors) {
        filteredAttributes = processor.process(filteredAttributes, context);
      }
      return filteredAttributes;
    }
  }

  class AllowListProcessor {
    _allowedAttributeNames;
    constructor(_allowedAttributeNames) {
      this._allowedAttributeNames = _allowedAttributeNames;
    }
    process(incoming, _context) {
      const filteredAttributes = {};
      Object.keys(incoming).filter((attributeName) => this._allowedAttributeNames.includes(attributeName)).forEach((attributeName) => filteredAttributes[attributeName] = incoming[attributeName]);
      return filteredAttributes;
    }
  }

  class DenyListProcessor {
    _deniedAttributeNames;
    constructor(_deniedAttributeNames) {
      this._deniedAttributeNames = _deniedAttributeNames;
    }
    process(incoming, _context) {
      const filteredAttributes = {};
      Object.keys(incoming).filter((attributeName) => !this._deniedAttributeNames.includes(attributeName)).forEach((attributeName) => filteredAttributes[attributeName] = incoming[attributeName]);
      return filteredAttributes;
    }
  }
  function createNoopAttributesProcessor() {
    return NOOP;
  }
  exports.createNoopAttributesProcessor = createNoopAttributesProcessor;
  function createMultiAttributesProcessor(processors) {
    return new MultiAttributesProcessor(processors);
  }
  exports.createMultiAttributesProcessor = createMultiAttributesProcessor;
  function createAllowListAttributesProcessor(attributeAllowList) {
    return new AllowListProcessor(attributeAllowList);
  }
  exports.createAllowListAttributesProcessor = createAllowListAttributesProcessor;
  function createDenyListAttributesProcessor(attributeDenyList) {
    return new DenyListProcessor(attributeDenyList);
  }
  exports.createDenyListAttributesProcessor = createDenyListAttributesProcessor;
  var NOOP = new NoopAttributesProcessor;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js
var require_MeterSharedState = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MeterSharedState = undefined;
  var InstrumentDescriptor_1 = require_InstrumentDescriptor();
  var Meter_1 = require_Meter();
  var utils_1 = require_utils7();
  var AsyncMetricStorage_1 = require_AsyncMetricStorage();
  var MetricStorageRegistry_1 = require_MetricStorageRegistry();
  var MultiWritableMetricStorage_1 = require_MultiWritableMetricStorage();
  var ObservableRegistry_1 = require_ObservableRegistry();
  var SyncMetricStorage_1 = require_SyncMetricStorage();
  var AttributesProcessor_1 = require_AttributesProcessor();

  class MeterSharedState {
    _meterProviderSharedState;
    _instrumentationScope;
    metricStorageRegistry = new MetricStorageRegistry_1.MetricStorageRegistry;
    observableRegistry = new ObservableRegistry_1.ObservableRegistry;
    meter;
    constructor(_meterProviderSharedState, _instrumentationScope) {
      this._meterProviderSharedState = _meterProviderSharedState;
      this._instrumentationScope = _instrumentationScope;
      this.meter = new Meter_1.Meter(this);
    }
    registerMetricStorage(descriptor) {
      const storages = this._registerMetricStorage(descriptor, SyncMetricStorage_1.SyncMetricStorage);
      if (storages.length === 1) {
        return storages[0];
      }
      return new MultiWritableMetricStorage_1.MultiMetricStorage(storages);
    }
    registerAsyncMetricStorage(descriptor) {
      const storages = this._registerMetricStorage(descriptor, AsyncMetricStorage_1.AsyncMetricStorage);
      return storages;
    }
    async collect(collector, collectionTime, options) {
      const errors = await this.observableRegistry.observe(collectionTime, options?.timeoutMillis);
      const storages = this.metricStorageRegistry.getStorages(collector);
      if (storages.length === 0) {
        return null;
      }
      const metricDataList = storages.map((metricStorage) => {
        return metricStorage.collect(collector, collectionTime);
      }).filter(utils_1.isNotNullish);
      if (metricDataList.length === 0) {
        return { errors };
      }
      return {
        scopeMetrics: {
          scope: this._instrumentationScope,
          metrics: metricDataList
        },
        errors
      };
    }
    _registerMetricStorage(descriptor, MetricStorageType) {
      const views = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope);
      let storages = views.map((view) => {
        const viewDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptorWithView)(view, descriptor);
        const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
        if (compatibleStorage != null) {
          return compatibleStorage;
        }
        const aggregator = view.aggregation.createAggregator(viewDescriptor);
        const viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, this._meterProviderSharedState.metricCollectors, view.aggregationCardinalityLimit);
        this.metricStorageRegistry.register(viewStorage);
        return viewStorage;
      });
      if (storages.length === 0) {
        const perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor.type);
        const collectorStorages = perCollectorAggregations.map(([collector, aggregation]) => {
          const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
          if (compatibleStorage != null) {
            return compatibleStorage;
          }
          const aggregator = aggregation.createAggregator(descriptor);
          const cardinalityLimit = collector.selectCardinalityLimit(descriptor.type);
          const storage = new MetricStorageType(descriptor, aggregator, (0, AttributesProcessor_1.createNoopAttributesProcessor)(), [collector], cardinalityLimit);
          this.metricStorageRegistry.registerForCollector(collector, storage);
          return storage;
        });
        storages = storages.concat(collectorStorages);
      }
      return storages;
    }
  }
  exports.MeterSharedState = MeterSharedState;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js
var require_MeterProviderSharedState = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MeterProviderSharedState = undefined;
  var utils_1 = require_utils7();
  var ViewRegistry_1 = require_ViewRegistry();
  var MeterSharedState_1 = require_MeterSharedState();
  var AggregationOption_1 = require_AggregationOption();

  class MeterProviderSharedState {
    resource;
    viewRegistry = new ViewRegistry_1.ViewRegistry;
    metricCollectors = [];
    meterSharedStates = new Map;
    constructor(resource) {
      this.resource = resource;
    }
    getMeterSharedState(instrumentationScope) {
      const id = (0, utils_1.instrumentationScopeId)(instrumentationScope);
      let meterSharedState = this.meterSharedStates.get(id);
      if (meterSharedState == null) {
        meterSharedState = new MeterSharedState_1.MeterSharedState(this, instrumentationScope);
        this.meterSharedStates.set(id, meterSharedState);
      }
      return meterSharedState;
    }
    selectAggregations(instrumentType) {
      const result = [];
      for (const collector of this.metricCollectors) {
        result.push([
          collector,
          (0, AggregationOption_1.toAggregation)(collector.selectAggregation(instrumentType))
        ]);
      }
      return result;
    }
  }
  exports.MeterProviderSharedState = MeterProviderSharedState;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js
var require_MetricCollector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricCollector = undefined;
  var core_1 = require_src3();

  class MetricCollector {
    _sharedState;
    _metricReader;
    constructor(_sharedState, _metricReader) {
      this._sharedState = _sharedState;
      this._metricReader = _metricReader;
    }
    async collect(options) {
      const collectionTime = (0, core_1.millisToHrTime)(Date.now());
      const scopeMetrics = [];
      const errors = [];
      const meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map(async (meterSharedState) => {
        const current = await meterSharedState.collect(this, collectionTime, options);
        if (current?.scopeMetrics != null) {
          scopeMetrics.push(current.scopeMetrics);
        }
        if (current?.errors != null) {
          errors.push(...current.errors);
        }
      });
      await Promise.all(meterCollectionPromises);
      return {
        resourceMetrics: {
          resource: this._sharedState.resource,
          scopeMetrics
        },
        errors
      };
    }
    async forceFlush(options) {
      await this._metricReader.forceFlush(options);
    }
    async shutdown(options) {
      await this._metricReader.shutdown(options);
    }
    selectAggregationTemporality(instrumentType) {
      return this._metricReader.selectAggregationTemporality(instrumentType);
    }
    selectAggregation(instrumentType) {
      return this._metricReader.selectAggregation(instrumentType);
    }
    selectCardinalityLimit(instrumentType) {
      return this._metricReader.selectCardinalityLimit?.(instrumentType) ?? 2000;
    }
  }
  exports.MetricCollector = MetricCollector;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js
var require_Predicate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExactPredicate = exports.PatternPredicate = undefined;
  var ESCAPE = /[\^$\\.+?()[\]{}|]/g;

  class PatternPredicate {
    _matchAll;
    _regexp;
    constructor(pattern) {
      if (pattern === "*") {
        this._matchAll = true;
        this._regexp = /.*/;
      } else {
        this._matchAll = false;
        this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));
      }
    }
    match(str) {
      if (this._matchAll) {
        return true;
      }
      return this._regexp.test(str);
    }
    static escapePattern(pattern) {
      return `^${pattern.replace(ESCAPE, "\\$&").replace("*", ".*")}$`;
    }
    static hasWildcard(pattern) {
      return pattern.includes("*");
    }
  }
  exports.PatternPredicate = PatternPredicate;

  class ExactPredicate {
    _matchAll;
    _pattern;
    constructor(pattern) {
      this._matchAll = pattern === undefined;
      this._pattern = pattern;
    }
    match(str) {
      if (this._matchAll) {
        return true;
      }
      if (str === this._pattern) {
        return true;
      }
      return false;
    }
  }
  exports.ExactPredicate = ExactPredicate;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js
var require_InstrumentSelector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentSelector = undefined;
  var Predicate_1 = require_Predicate();

  class InstrumentSelector {
    _nameFilter;
    _type;
    _unitFilter;
    constructor(criteria) {
      this._nameFilter = new Predicate_1.PatternPredicate(criteria?.name ?? "*");
      this._type = criteria?.type;
      this._unitFilter = new Predicate_1.ExactPredicate(criteria?.unit);
    }
    getType() {
      return this._type;
    }
    getNameFilter() {
      return this._nameFilter;
    }
    getUnitFilter() {
      return this._unitFilter;
    }
  }
  exports.InstrumentSelector = InstrumentSelector;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js
var require_MeterSelector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MeterSelector = undefined;
  var Predicate_1 = require_Predicate();

  class MeterSelector {
    _nameFilter;
    _versionFilter;
    _schemaUrlFilter;
    constructor(criteria) {
      this._nameFilter = new Predicate_1.ExactPredicate(criteria?.name);
      this._versionFilter = new Predicate_1.ExactPredicate(criteria?.version);
      this._schemaUrlFilter = new Predicate_1.ExactPredicate(criteria?.schemaUrl);
    }
    getNameFilter() {
      return this._nameFilter;
    }
    getVersionFilter() {
      return this._versionFilter;
    }
    getSchemaUrlFilter() {
      return this._schemaUrlFilter;
    }
  }
  exports.MeterSelector = MeterSelector;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js
var require_View = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.View = undefined;
  var Predicate_1 = require_Predicate();
  var AttributesProcessor_1 = require_AttributesProcessor();
  var InstrumentSelector_1 = require_InstrumentSelector();
  var MeterSelector_1 = require_MeterSelector();
  var AggregationOption_1 = require_AggregationOption();
  function isSelectorNotProvided(options) {
    return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;
  }
  function validateViewOptions(viewOptions) {
    if (isSelectorNotProvided(viewOptions)) {
      throw new Error("Cannot create view with no selector arguments supplied");
    }
    if (viewOptions.name != null && (viewOptions?.instrumentName == null || Predicate_1.PatternPredicate.hasWildcard(viewOptions.instrumentName))) {
      throw new Error("Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.");
    }
  }

  class View {
    name;
    description;
    aggregation;
    attributesProcessor;
    instrumentSelector;
    meterSelector;
    aggregationCardinalityLimit;
    constructor(viewOptions) {
      validateViewOptions(viewOptions);
      if (viewOptions.attributesProcessors != null) {
        this.attributesProcessor = (0, AttributesProcessor_1.createMultiAttributesProcessor)(viewOptions.attributesProcessors);
      } else {
        this.attributesProcessor = (0, AttributesProcessor_1.createNoopAttributesProcessor)();
      }
      this.name = viewOptions.name;
      this.description = viewOptions.description;
      this.aggregation = (0, AggregationOption_1.toAggregation)(viewOptions.aggregation ?? { type: AggregationOption_1.AggregationType.DEFAULT });
      this.instrumentSelector = new InstrumentSelector_1.InstrumentSelector({
        name: viewOptions.instrumentName,
        type: viewOptions.instrumentType,
        unit: viewOptions.instrumentUnit
      });
      this.meterSelector = new MeterSelector_1.MeterSelector({
        name: viewOptions.meterName,
        version: viewOptions.meterVersion,
        schemaUrl: viewOptions.meterSchemaUrl
      });
      this.aggregationCardinalityLimit = viewOptions.aggregationCardinalityLimit;
    }
  }
  exports.View = View;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js
var require_MeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MeterProvider = undefined;
  var api_1 = require_src();
  var resources_1 = require_src5();
  var MeterProviderSharedState_1 = require_MeterProviderSharedState();
  var MetricCollector_1 = require_MetricCollector();
  var View_1 = require_View();

  class MeterProvider {
    _sharedState;
    _shutdown = false;
    constructor(options) {
      this._sharedState = new MeterProviderSharedState_1.MeterProviderSharedState(options?.resource ?? (0, resources_1.defaultResource)());
      if (options?.views != null && options.views.length > 0) {
        for (const viewOption of options.views) {
          this._sharedState.viewRegistry.addView(new View_1.View(viewOption));
        }
      }
      if (options?.readers != null && options.readers.length > 0) {
        for (const metricReader of options.readers) {
          const collector = new MetricCollector_1.MetricCollector(this._sharedState, metricReader);
          metricReader.setMetricProducer(collector);
          this._sharedState.metricCollectors.push(collector);
        }
      }
    }
    getMeter(name, version = "", options = {}) {
      if (this._shutdown) {
        api_1.diag.warn("A shutdown MeterProvider cannot provide a Meter");
        return (0, api_1.createNoopMeter)();
      }
      return this._sharedState.getMeterSharedState({
        name,
        version,
        schemaUrl: options.schemaUrl
      }).meter;
    }
    async shutdown(options) {
      if (this._shutdown) {
        api_1.diag.warn("shutdown may only be called once per MeterProvider");
        return;
      }
      this._shutdown = true;
      await Promise.all(this._sharedState.metricCollectors.map((collector) => {
        return collector.shutdown(options);
      }));
    }
    async forceFlush(options) {
      if (this._shutdown) {
        api_1.diag.warn("invalid attempt to force flush after MeterProvider shutdown");
        return;
      }
      await Promise.all(this._sharedState.metricCollectors.map((collector) => {
        return collector.forceFlush(options);
      }));
    }
  }
  exports.MeterProvider = MeterProvider;
});

// node_modules/@opentelemetry/sdk-metrics/build/src/index.js
var require_src7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeoutError = exports.createDenyListAttributesProcessor = exports.createAllowListAttributesProcessor = exports.AggregationType = exports.MeterProvider = exports.ConsoleMetricExporter = exports.InMemoryMetricExporter = exports.PeriodicExportingMetricReader = exports.MetricReader = exports.InstrumentType = exports.DataPointType = exports.AggregationTemporality = undefined;
  var AggregationTemporality_1 = require_AggregationTemporality();
  Object.defineProperty(exports, "AggregationTemporality", { enumerable: true, get: function() {
    return AggregationTemporality_1.AggregationTemporality;
  } });
  var MetricData_1 = require_MetricData();
  Object.defineProperty(exports, "DataPointType", { enumerable: true, get: function() {
    return MetricData_1.DataPointType;
  } });
  Object.defineProperty(exports, "InstrumentType", { enumerable: true, get: function() {
    return MetricData_1.InstrumentType;
  } });
  var MetricReader_1 = require_MetricReader();
  Object.defineProperty(exports, "MetricReader", { enumerable: true, get: function() {
    return MetricReader_1.MetricReader;
  } });
  var PeriodicExportingMetricReader_1 = require_PeriodicExportingMetricReader();
  Object.defineProperty(exports, "PeriodicExportingMetricReader", { enumerable: true, get: function() {
    return PeriodicExportingMetricReader_1.PeriodicExportingMetricReader;
  } });
  var InMemoryMetricExporter_1 = require_InMemoryMetricExporter();
  Object.defineProperty(exports, "InMemoryMetricExporter", { enumerable: true, get: function() {
    return InMemoryMetricExporter_1.InMemoryMetricExporter;
  } });
  var ConsoleMetricExporter_1 = require_ConsoleMetricExporter();
  Object.defineProperty(exports, "ConsoleMetricExporter", { enumerable: true, get: function() {
    return ConsoleMetricExporter_1.ConsoleMetricExporter;
  } });
  var MeterProvider_1 = require_MeterProvider();
  Object.defineProperty(exports, "MeterProvider", { enumerable: true, get: function() {
    return MeterProvider_1.MeterProvider;
  } });
  var AggregationOption_1 = require_AggregationOption();
  Object.defineProperty(exports, "AggregationType", { enumerable: true, get: function() {
    return AggregationOption_1.AggregationType;
  } });
  var AttributesProcessor_1 = require_AttributesProcessor();
  Object.defineProperty(exports, "createAllowListAttributesProcessor", { enumerable: true, get: function() {
    return AttributesProcessor_1.createAllowListAttributesProcessor;
  } });
  Object.defineProperty(exports, "createDenyListAttributesProcessor", { enumerable: true, get: function() {
    return AttributesProcessor_1.createDenyListAttributesProcessor;
  } });
  var utils_1 = require_utils7();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return utils_1.TimeoutError;
  } });
});

// node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js
var require_AbstractAsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractAsyncHooksContextManager = undefined;
  var events_1 = __require("events");
  var ADD_LISTENER_METHODS = [
    "addListener",
    "on",
    "once",
    "prependListener",
    "prependOnceListener"
  ];

  class AbstractAsyncHooksContextManager {
    bind(context, target) {
      if (target instanceof events_1.EventEmitter) {
        return this._bindEventEmitter(context, target);
      }
      if (typeof target === "function") {
        return this._bindFunction(context, target);
      }
      return target;
    }
    _bindFunction(context, target) {
      const manager = this;
      const contextWrapper = function(...args) {
        return manager.with(context, () => target.apply(this, args));
      };
      Object.defineProperty(contextWrapper, "length", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    }
    _bindEventEmitter(context, ee) {
      const map = this._getPatchMap(ee);
      if (map !== undefined)
        return ee;
      this._createPatchMap(ee);
      ADD_LISTENER_METHODS.forEach((methodName) => {
        if (ee[methodName] === undefined)
          return;
        ee[methodName] = this._patchAddListener(ee, ee[methodName], context);
      });
      if (typeof ee.removeListener === "function") {
        ee.removeListener = this._patchRemoveListener(ee, ee.removeListener);
      }
      if (typeof ee.off === "function") {
        ee.off = this._patchRemoveListener(ee, ee.off);
      }
      if (typeof ee.removeAllListeners === "function") {
        ee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners);
      }
      return ee;
    }
    _patchRemoveListener(ee, original) {
      const contextManager = this;
      return function(event, listener) {
        const events = contextManager._getPatchMap(ee)?.[event];
        if (events === undefined) {
          return original.call(this, event, listener);
        }
        const patchedListener = events.get(listener);
        return original.call(this, event, patchedListener || listener);
      };
    }
    _patchRemoveAllListeners(ee, original) {
      const contextManager = this;
      return function(event) {
        const map = contextManager._getPatchMap(ee);
        if (map !== undefined) {
          if (arguments.length === 0) {
            contextManager._createPatchMap(ee);
          } else if (map[event] !== undefined) {
            delete map[event];
          }
        }
        return original.apply(this, arguments);
      };
    }
    _patchAddListener(ee, original, context) {
      const contextManager = this;
      return function(event, listener) {
        if (contextManager._wrapped) {
          return original.call(this, event, listener);
        }
        let map = contextManager._getPatchMap(ee);
        if (map === undefined) {
          map = contextManager._createPatchMap(ee);
        }
        let listeners = map[event];
        if (listeners === undefined) {
          listeners = new WeakMap;
          map[event] = listeners;
        }
        const patchedListener = contextManager.bind(context, listener);
        listeners.set(listener, patchedListener);
        contextManager._wrapped = true;
        try {
          return original.call(this, event, patchedListener);
        } finally {
          contextManager._wrapped = false;
        }
      };
    }
    _createPatchMap(ee) {
      const map = Object.create(null);
      ee[this._kOtListeners] = map;
      return map;
    }
    _getPatchMap(ee) {
      return ee[this._kOtListeners];
    }
    _kOtListeners = Symbol("OtListeners");
    _wrapped = false;
  }
  exports.AbstractAsyncHooksContextManager = AbstractAsyncHooksContextManager;
});

// node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js
var require_AsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncHooksContextManager = undefined;
  var api_1 = require_src();
  var asyncHooks = __require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncHooksContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    _asyncHook;
    _contexts = new Map;
    _stack = [];
    constructor() {
      super();
      this._asyncHook = asyncHooks.createHook({
        init: this._init.bind(this),
        before: this._before.bind(this),
        after: this._after.bind(this),
        destroy: this._destroy.bind(this),
        promiseResolve: this._destroy.bind(this)
      });
    }
    active() {
      return this._stack[this._stack.length - 1] ?? api_1.ROOT_CONTEXT;
    }
    with(context, fn, thisArg, ...args) {
      this._enterContext(context);
      try {
        return fn.call(thisArg, ...args);
      } finally {
        this._exitContext();
      }
    }
    enable() {
      this._asyncHook.enable();
      return this;
    }
    disable() {
      this._asyncHook.disable();
      this._contexts.clear();
      this._stack = [];
      return this;
    }
    _init(uid, type2) {
      if (type2 === "TIMERWRAP")
        return;
      const context = this._stack[this._stack.length - 1];
      if (context !== undefined) {
        this._contexts.set(uid, context);
      }
    }
    _destroy(uid) {
      this._contexts.delete(uid);
    }
    _before(uid) {
      const context = this._contexts.get(uid);
      if (context !== undefined) {
        this._enterContext(context);
      }
    }
    _after() {
      this._exitContext();
    }
    _enterContext(context) {
      this._stack.push(context);
    }
    _exitContext() {
      this._stack.pop();
    }
  }
  exports.AsyncHooksContextManager = AsyncHooksContextManager;
});

// node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js
var require_AsyncLocalStorageContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = undefined;
  var api_1 = require_src();
  var async_hooks_1 = __require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    _asyncLocalStorage;
    constructor() {
      super();
      this._asyncLocalStorage = new async_hooks_1.AsyncLocalStorage;
    }
    active() {
      return this._asyncLocalStorage.getStore() ?? api_1.ROOT_CONTEXT;
    }
    with(context, fn, thisArg, ...args) {
      const cb = thisArg == null ? fn : fn.bind(thisArg);
      return this._asyncLocalStorage.run(context, cb, ...args);
    }
    enable() {
      return this;
    }
    disable() {
      this._asyncLocalStorage.disable();
      return this;
    }
  }
  exports.AsyncLocalStorageContextManager = AsyncLocalStorageContextManager;
});

// node_modules/@opentelemetry/context-async-hooks/build/src/index.js
var require_src8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = exports.AsyncHooksContextManager = undefined;
  var AsyncHooksContextManager_1 = require_AsyncHooksContextManager();
  Object.defineProperty(exports, "AsyncHooksContextManager", { enumerable: true, get: function() {
    return AsyncHooksContextManager_1.AsyncHooksContextManager;
  } });
  var AsyncLocalStorageContextManager_1 = require_AsyncLocalStorageContextManager();
  Object.defineProperty(exports, "AsyncLocalStorageContextManager", { enumerable: true, get: function() {
    return AsyncLocalStorageContextManager_1.AsyncLocalStorageContextManager;
  } });
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js
var require_enums = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExceptionEventName = undefined;
  exports.ExceptionEventName = "exception";
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js
var require_Span = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanImpl = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var semantic_conventions_1 = require_src2();
  var enums_1 = require_enums();

  class SpanImpl {
    _spanContext;
    kind;
    parentSpanContext;
    attributes = {};
    links = [];
    events = [];
    startTime;
    resource;
    instrumentationScope;
    _droppedAttributesCount = 0;
    _droppedEventsCount = 0;
    _droppedLinksCount = 0;
    name;
    status = {
      code: api_1.SpanStatusCode.UNSET
    };
    endTime = [0, 0];
    _ended = false;
    _duration = [-1, -1];
    _spanProcessor;
    _spanLimits;
    _attributeValueLengthLimit;
    _performanceStartTime;
    _performanceOffset;
    _startTimeProvided;
    constructor(opts) {
      const now = Date.now();
      this._spanContext = opts.spanContext;
      this._performanceStartTime = core_1.otperformance.now();
      this._performanceOffset = now - (this._performanceStartTime + (0, core_1.getTimeOrigin)());
      this._startTimeProvided = opts.startTime != null;
      this._spanLimits = opts.spanLimits;
      this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      this._spanProcessor = opts.spanProcessor;
      this.name = opts.name;
      this.parentSpanContext = opts.parentSpanContext;
      this.kind = opts.kind;
      this.links = opts.links || [];
      this.startTime = this._getTime(opts.startTime ?? now);
      this.resource = opts.resource;
      this.instrumentationScope = opts.scope;
      if (opts.attributes != null) {
        this.setAttributes(opts.attributes);
      }
      this._spanProcessor.onStart(this, opts.context);
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(key, value) {
      if (value == null || this._isSpanEnded())
        return this;
      if (key.length === 0) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        return this;
      }
      if (!(0, core_1.isAttributeValue)(value)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        return this;
      }
      const { attributeCountLimit } = this._spanLimits;
      if (attributeCountLimit !== undefined && Object.keys(this.attributes).length >= attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
        this._droppedAttributesCount++;
        return this;
      }
      this.attributes[key] = this._truncateToSize(value);
      return this;
    }
    setAttributes(attributes) {
      for (const [k, v] of Object.entries(attributes)) {
        this.setAttribute(k, v);
      }
      return this;
    }
    addEvent(name, attributesOrStartTime, timeStamp) {
      if (this._isSpanEnded())
        return this;
      const { eventCountLimit } = this._spanLimits;
      if (eventCountLimit === 0) {
        api_1.diag.warn("No events allowed.");
        this._droppedEventsCount++;
        return this;
      }
      if (eventCountLimit !== undefined && this.events.length >= eventCountLimit) {
        if (this._droppedEventsCount === 0) {
          api_1.diag.debug("Dropping extra events.");
        }
        this.events.shift();
        this._droppedEventsCount++;
      }
      if ((0, core_1.isTimeInput)(attributesOrStartTime)) {
        if (!(0, core_1.isTimeInput)(timeStamp)) {
          timeStamp = attributesOrStartTime;
        }
        attributesOrStartTime = undefined;
      }
      const attributes = (0, core_1.sanitizeAttributes)(attributesOrStartTime);
      this.events.push({
        name,
        attributes,
        time: this._getTime(timeStamp),
        droppedAttributesCount: 0
      });
      return this;
    }
    addLink(link) {
      this.links.push(link);
      return this;
    }
    addLinks(links) {
      this.links.push(...links);
      return this;
    }
    setStatus(status) {
      if (this._isSpanEnded())
        return this;
      this.status = { ...status };
      if (this.status.message != null && typeof status.message !== "string") {
        api_1.diag.warn(`Dropping invalid status.message of type '${typeof status.message}', expected 'string'`);
        delete this.status.message;
      }
      return this;
    }
    updateName(name) {
      if (this._isSpanEnded())
        return this;
      this.name = name;
      return this;
    }
    end(endTime) {
      if (this._isSpanEnded()) {
        api_1.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
        return;
      }
      this._ended = true;
      this.endTime = this._getTime(endTime);
      this._duration = (0, core_1.hrTimeDuration)(this.startTime, this.endTime);
      if (this._duration[0] < 0) {
        api_1.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
        this.endTime = this.startTime.slice();
        this._duration = [0, 0];
      }
      if (this._droppedEventsCount > 0) {
        api_1.diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);
      }
      this._spanProcessor.onEnd(this);
    }
    _getTime(inp) {
      if (typeof inp === "number" && inp <= core_1.otperformance.now()) {
        return (0, core_1.hrTime)(inp + this._performanceOffset);
      }
      if (typeof inp === "number") {
        return (0, core_1.millisToHrTime)(inp);
      }
      if (inp instanceof Date) {
        return (0, core_1.millisToHrTime)(inp.getTime());
      }
      if ((0, core_1.isTimeInputHrTime)(inp)) {
        return inp;
      }
      if (this._startTimeProvided) {
        return (0, core_1.millisToHrTime)(Date.now());
      }
      const msDuration = core_1.otperformance.now() - this._performanceStartTime;
      return (0, core_1.addHrTimes)(this.startTime, (0, core_1.millisToHrTime)(msDuration));
    }
    isRecording() {
      return this._ended === false;
    }
    recordException(exception, time) {
      const attributes = {};
      if (typeof exception === "string") {
        attributes[semantic_conventions_1.ATTR_EXCEPTION_MESSAGE] = exception;
      } else if (exception) {
        if (exception.code) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_TYPE] = exception.code.toString();
        } else if (exception.name) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_TYPE] = exception.name;
        }
        if (exception.message) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_MESSAGE] = exception.message;
        }
        if (exception.stack) {
          attributes[semantic_conventions_1.ATTR_EXCEPTION_STACKTRACE] = exception.stack;
        }
      }
      if (attributes[semantic_conventions_1.ATTR_EXCEPTION_TYPE] || attributes[semantic_conventions_1.ATTR_EXCEPTION_MESSAGE]) {
        this.addEvent(enums_1.ExceptionEventName, attributes, time);
      } else {
        api_1.diag.warn(`Failed to record an exception ${exception}`);
      }
    }
    get duration() {
      return this._duration;
    }
    get ended() {
      return this._ended;
    }
    get droppedAttributesCount() {
      return this._droppedAttributesCount;
    }
    get droppedEventsCount() {
      return this._droppedEventsCount;
    }
    get droppedLinksCount() {
      return this._droppedLinksCount;
    }
    _isSpanEnded() {
      if (this._ended) {
        const error = new Error(`Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);
        api_1.diag.warn(`Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`, error);
      }
      return this._ended;
    }
    _truncateToLimitUtil(value, limit) {
      if (value.length <= limit) {
        return value;
      }
      return value.substring(0, limit);
    }
    _truncateToSize(value) {
      const limit = this._attributeValueLengthLimit;
      if (limit <= 0) {
        api_1.diag.warn(`Attribute value limit must be positive, got ${limit}`);
        return value;
      }
      if (typeof value === "string") {
        return this._truncateToLimitUtil(value, limit);
      }
      if (Array.isArray(value)) {
        return value.map((val) => typeof val === "string" ? this._truncateToLimitUtil(val, limit) : val);
      }
      return value;
    }
  }
  exports.SpanImpl = SpanImpl;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js
var require_Sampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOffSampler = undefined;
  var Sampler_1 = require_Sampler();

  class AlwaysOffSampler {
    shouldSample() {
      return {
        decision: Sampler_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return "AlwaysOffSampler";
    }
  }
  exports.AlwaysOffSampler = AlwaysOffSampler;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOnSampler = undefined;
  var Sampler_1 = require_Sampler();

  class AlwaysOnSampler {
    shouldSample() {
      return {
        decision: Sampler_1.SamplingDecision.RECORD_AND_SAMPLED
      };
    }
    toString() {
      return "AlwaysOnSampler";
    }
  }
  exports.AlwaysOnSampler = AlwaysOnSampler;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentBasedSampler = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();

  class ParentBasedSampler {
    _root;
    _remoteParentSampled;
    _remoteParentNotSampled;
    _localParentSampled;
    _localParentNotSampled;
    constructor(config) {
      this._root = config.root;
      if (!this._root) {
        (0, core_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
        this._root = new AlwaysOnSampler_1.AlwaysOnSampler;
      }
      this._remoteParentSampled = config.remoteParentSampled ?? new AlwaysOnSampler_1.AlwaysOnSampler;
      this._remoteParentNotSampled = config.remoteParentNotSampled ?? new AlwaysOffSampler_1.AlwaysOffSampler;
      this._localParentSampled = config.localParentSampled ?? new AlwaysOnSampler_1.AlwaysOnSampler;
      this._localParentNotSampled = config.localParentNotSampled ?? new AlwaysOffSampler_1.AlwaysOffSampler;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
      const parentContext = api_1.trace.getSpanContext(context);
      if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
        return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.isRemote) {
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
        return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    toString() {
      return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
    }
  }
  exports.ParentBasedSampler = ParentBasedSampler;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceIdRatioBasedSampler = undefined;
  var api_1 = require_src();
  var Sampler_1 = require_Sampler();

  class TraceIdRatioBasedSampler {
    _ratio;
    _upperBound;
    constructor(_ratio = 0) {
      this._ratio = _ratio;
      this._ratio = this._normalize(_ratio);
      this._upperBound = Math.floor(this._ratio * 4294967295);
    }
    shouldSample(context, traceId) {
      return {
        decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? Sampler_1.SamplingDecision.RECORD_AND_SAMPLED : Sampler_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return `TraceIdRatioBased{${this._ratio}}`;
    }
    _normalize(ratio) {
      if (typeof ratio !== "number" || isNaN(ratio))
        return 0;
      return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }
    _accumulate(traceId) {
      let accumulation = 0;
      for (let i = 0;i < traceId.length / 8; i++) {
        const pos = i * 8;
        const part = parseInt(traceId.slice(pos, pos + 8), 16);
        accumulation = (accumulation ^ part) >>> 0;
      }
      return accumulation;
    }
  }
  exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/config.js
var require_config2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildSamplerFromEnv = exports.loadDefaultConfig = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();
  var ParentBasedSampler_1 = require_ParentBasedSampler();
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
  var DEFAULT_RATIO = 1;
  function loadDefaultConfig() {
    return {
      sampler: buildSamplerFromEnv(),
      forceFlushTimeoutMillis: 30000,
      generalLimits: {
        attributeValueLengthLimit: (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity,
        attributeCountLimit: (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? 128
      },
      spanLimits: {
        attributeValueLengthLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity,
        attributeCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ?? 128,
        linkCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_LINK_COUNT_LIMIT") ?? 128,
        eventCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_EVENT_COUNT_LIMIT") ?? 128,
        attributePerEventCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT") ?? 128,
        attributePerLinkCountLimit: (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT") ?? 128
      }
    };
  }
  exports.loadDefaultConfig = loadDefaultConfig;
  function buildSamplerFromEnv() {
    const sampler = (0, core_1.getStringFromEnv)("OTEL_TRACES_SAMPLER") ?? "parentbased_always_on";
    switch (sampler) {
      case "always_on":
        return new AlwaysOnSampler_1.AlwaysOnSampler;
      case "always_off":
        return new AlwaysOffSampler_1.AlwaysOffSampler;
      case "parentbased_always_on":
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOnSampler_1.AlwaysOnSampler
        });
      case "parentbased_always_off":
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOffSampler_1.AlwaysOffSampler
        });
      case "traceidratio":
        return new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv());
      case "parentbased_traceidratio":
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv())
        });
      default:
        api_1.diag.error(`OTEL_TRACES_SAMPLER value "${sampler}" invalid, defaulting to "${"parentbased_always_on"}".`);
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOnSampler_1.AlwaysOnSampler
        });
    }
  }
  exports.buildSamplerFromEnv = buildSamplerFromEnv;
  function getSamplerProbabilityFromEnv() {
    const probability = (0, core_1.getNumberFromEnv)("OTEL_TRACES_SAMPLER_ARG");
    if (probability == null) {
      api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`);
      return DEFAULT_RATIO;
    }
    if (probability < 0 || probability > 1) {
      api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${probability} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`);
      return DEFAULT_RATIO;
    }
    return probability;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js
var require_utility = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconfigureLimits = exports.mergeConfig = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = undefined;
  var config_1 = require_config2();
  var core_1 = require_src3();
  exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
  exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
  function mergeConfig(userConfig) {
    const perInstanceDefaults = {
      sampler: (0, config_1.buildSamplerFromEnv)()
    };
    const DEFAULT_CONFIG = (0, config_1.loadDefaultConfig)();
    const target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
    target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
    return target;
  }
  exports.mergeConfig = mergeConfig;
  function reconfigureLimits(userConfig) {
    const spanLimits = Object.assign({}, userConfig.spanLimits);
    spanLimits.attributeCountLimit = userConfig.spanLimits?.attributeCountLimit ?? userConfig.generalLimits?.attributeCountLimit ?? (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT") ?? (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    spanLimits.attributeValueLengthLimit = userConfig.spanLimits?.attributeValueLengthLimit ?? userConfig.generalLimits?.attributeValueLengthLimit ?? (0, core_1.getNumberFromEnv)("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? (0, core_1.getNumberFromEnv)("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    return Object.assign({}, userConfig, { spanLimits });
  }
  exports.reconfigureLimits = reconfigureLimits;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js
var require_BatchSpanProcessorBase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchSpanProcessorBase = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();

  class BatchSpanProcessorBase {
    _exporter;
    _maxExportBatchSize;
    _maxQueueSize;
    _scheduledDelayMillis;
    _exportTimeoutMillis;
    _isExporting = false;
    _finishedSpans = [];
    _timer;
    _shutdownOnce;
    _droppedSpansCount = 0;
    constructor(_exporter, config) {
      this._exporter = _exporter;
      this._maxExportBatchSize = typeof config?.maxExportBatchSize === "number" ? config.maxExportBatchSize : (0, core_1.getNumberFromEnv)("OTEL_BSP_MAX_EXPORT_BATCH_SIZE") ?? 512;
      this._maxQueueSize = typeof config?.maxQueueSize === "number" ? config.maxQueueSize : (0, core_1.getNumberFromEnv)("OTEL_BSP_MAX_QUEUE_SIZE") ?? 2048;
      this._scheduledDelayMillis = typeof config?.scheduledDelayMillis === "number" ? config.scheduledDelayMillis : (0, core_1.getNumberFromEnv)("OTEL_BSP_SCHEDULE_DELAY") ?? 5000;
      this._exportTimeoutMillis = typeof config?.exportTimeoutMillis === "number" ? config.exportTimeoutMillis : (0, core_1.getNumberFromEnv)("OTEL_BSP_EXPORT_TIMEOUT") ?? 30000;
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
      if (this._maxExportBatchSize > this._maxQueueSize) {
        api_1.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
        this._maxExportBatchSize = this._maxQueueSize;
      }
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled) {
        return this._shutdownOnce.promise;
      }
      return this._flushAll();
    }
    onStart(_span, _parentContext) {
    }
    onEnd(span) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
        return;
      }
      this._addToBuffer(span);
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return Promise.resolve().then(() => {
        return this.onShutdown();
      }).then(() => {
        return this._flushAll();
      }).then(() => {
        return this._exporter.shutdown();
      });
    }
    _addToBuffer(span) {
      if (this._finishedSpans.length >= this._maxQueueSize) {
        if (this._droppedSpansCount === 0) {
          api_1.diag.debug("maxQueueSize reached, dropping spans");
        }
        this._droppedSpansCount++;
        return;
      }
      if (this._droppedSpansCount > 0) {
        api_1.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);
        this._droppedSpansCount = 0;
      }
      this._finishedSpans.push(span);
      this._maybeStartTimer();
    }
    _flushAll() {
      return new Promise((resolve, reject) => {
        const promises = [];
        const count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
        for (let i = 0, j = count;i < j; i++) {
          promises.push(this._flushOneBatch());
        }
        Promise.all(promises).then(() => {
          resolve();
        }).catch(reject);
      });
    }
    _flushOneBatch() {
      this._clearTimer();
      if (this._finishedSpans.length === 0) {
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          reject(new Error("Timeout"));
        }, this._exportTimeoutMillis);
        api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
          let spans;
          if (this._finishedSpans.length <= this._maxExportBatchSize) {
            spans = this._finishedSpans;
            this._finishedSpans = [];
          } else {
            spans = this._finishedSpans.splice(0, this._maxExportBatchSize);
          }
          const doExport = () => this._exporter.export(spans, (result) => {
            clearTimeout(timer);
            if (result.code === core_1.ExportResultCode.SUCCESS) {
              resolve();
            } else {
              reject(result.error ?? new Error("BatchSpanProcessor: span export failed"));
            }
          });
          let pendingResources = null;
          for (let i = 0, len = spans.length;i < len; i++) {
            const span = spans[i];
            if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
              pendingResources ??= [];
              pendingResources.push(span.resource.waitForAsyncAttributes());
            }
          }
          if (pendingResources === null) {
            doExport();
          } else {
            Promise.all(pendingResources).then(doExport, (err) => {
              (0, core_1.globalErrorHandler)(err);
              reject(err);
            });
          }
        });
      });
    }
    _maybeStartTimer() {
      if (this._isExporting)
        return;
      const flush = () => {
        this._isExporting = true;
        this._flushOneBatch().finally(() => {
          this._isExporting = false;
          if (this._finishedSpans.length > 0) {
            this._clearTimer();
            this._maybeStartTimer();
          }
        }).catch((e) => {
          this._isExporting = false;
          (0, core_1.globalErrorHandler)(e);
        });
      };
      if (this._finishedSpans.length >= this._maxExportBatchSize) {
        return flush();
      }
      if (this._timer !== undefined)
        return;
      this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);
      (0, core_1.unrefTimer)(this._timer);
    }
    _clearTimer() {
      if (this._timer !== undefined) {
        clearTimeout(this._timer);
        this._timer = undefined;
      }
    }
  }
  exports.BatchSpanProcessorBase = BatchSpanProcessorBase;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js
var require_BatchSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchSpanProcessor = undefined;
  var BatchSpanProcessorBase_1 = require_BatchSpanProcessorBase();

  class BatchSpanProcessor extends BatchSpanProcessorBase_1.BatchSpanProcessorBase {
    onShutdown() {
    }
  }
  exports.BatchSpanProcessor = BatchSpanProcessor;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = undefined;
  var SPAN_ID_BYTES = 8;
  var TRACE_ID_BYTES = 16;

  class RandomIdGenerator {
    generateTraceId = getIdGenerator(TRACE_ID_BYTES);
    generateSpanId = getIdGenerator(SPAN_ID_BYTES);
  }
  exports.RandomIdGenerator = RandomIdGenerator;
  var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  function getIdGenerator(bytes) {
    return function generateId() {
      for (let i = 0;i < bytes / 4; i++) {
        SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
      }
      for (let i = 0;i < bytes; i++) {
        if (SHARED_BUFFER[i] > 0) {
          break;
        } else if (i === bytes - 1) {
          SHARED_BUFFER[bytes - 1] = 1;
        }
      }
      return SHARED_BUFFER.toString("hex", 0, bytes);
    };
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js
var require_node7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = exports.BatchSpanProcessor = undefined;
  var BatchSpanProcessor_1 = require_BatchSpanProcessor();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return BatchSpanProcessor_1.BatchSpanProcessor;
  } });
  var RandomIdGenerator_1 = require_RandomIdGenerator();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return RandomIdGenerator_1.RandomIdGenerator;
  } });
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js
var require_platform7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = exports.BatchSpanProcessor = undefined;
  var node_1 = require_node7();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return node_1.BatchSpanProcessor;
  } });
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return node_1.RandomIdGenerator;
  } });
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js
var require_Tracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tracer = undefined;
  var api = require_src();
  var core_1 = require_src3();
  var Span_1 = require_Span();
  var utility_1 = require_utility();
  var platform_1 = require_platform7();

  class Tracer {
    _sampler;
    _generalLimits;
    _spanLimits;
    _idGenerator;
    instrumentationScope;
    _resource;
    _spanProcessor;
    constructor(instrumentationScope, config, resource, spanProcessor) {
      const localConfig = (0, utility_1.mergeConfig)(config);
      this._sampler = localConfig.sampler;
      this._generalLimits = localConfig.generalLimits;
      this._spanLimits = localConfig.spanLimits;
      this._idGenerator = config.idGenerator || new platform_1.RandomIdGenerator;
      this._resource = resource;
      this._spanProcessor = spanProcessor;
      this.instrumentationScope = instrumentationScope;
    }
    startSpan(name, options = {}, context = api.context.active()) {
      if (options.root) {
        context = api.trace.deleteSpan(context);
      }
      const parentSpan = api.trace.getSpan(context);
      if ((0, core_1.isTracingSuppressed)(context)) {
        api.diag.debug("Instrumentation suppressed, returning Noop Span");
        const nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
        return nonRecordingSpan;
      }
      const parentSpanContext = parentSpan?.spanContext();
      const spanId = this._idGenerator.generateSpanId();
      let validParentSpanContext;
      let traceId;
      let traceState;
      if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {
        traceId = this._idGenerator.generateTraceId();
      } else {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        validParentSpanContext = parentSpanContext;
      }
      const spanKind = options.kind ?? api.SpanKind.INTERNAL;
      const links = (options.links ?? []).map((link) => {
        return {
          context: link.context,
          attributes: (0, core_1.sanitizeAttributes)(link.attributes)
        };
      });
      const attributes = (0, core_1.sanitizeAttributes)(options.attributes);
      const samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);
      traceState = samplingResult.traceState ?? traceState;
      const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;
      const spanContext = { traceId, spanId, traceFlags, traceState };
      if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
        api.diag.debug("Recording is off, propagating context in a non-recording span");
        const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);
        return nonRecordingSpan;
      }
      const initAttributes = (0, core_1.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
      const span = new Span_1.SpanImpl({
        resource: this._resource,
        scope: this.instrumentationScope,
        context,
        spanContext,
        name,
        kind: spanKind,
        links,
        parentSpanContext: validParentSpanContext,
        attributes: initAttributes,
        startTime: options.startTime,
        spanProcessor: this._spanProcessor,
        spanLimits: this._spanLimits
      });
      return span;
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx ?? api.context.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = api.trace.setSpan(parentContext, span);
      return api.context.with(contextWithSpanSet, fn, undefined, span);
    }
    getGeneralLimits() {
      return this._generalLimits;
    }
    getSpanLimits() {
      return this._spanLimits;
    }
  }
  exports.Tracer = Tracer;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js
var require_MultiSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiSpanProcessor = undefined;
  var core_1 = require_src3();

  class MultiSpanProcessor {
    _spanProcessors;
    constructor(_spanProcessors) {
      this._spanProcessors = _spanProcessors;
    }
    forceFlush() {
      const promises = [];
      for (const spanProcessor of this._spanProcessors) {
        promises.push(spanProcessor.forceFlush());
      }
      return new Promise((resolve) => {
        Promise.all(promises).then(() => {
          resolve();
        }).catch((error) => {
          (0, core_1.globalErrorHandler)(error || new Error("MultiSpanProcessor: forceFlush failed"));
          resolve();
        });
      });
    }
    onStart(span, context) {
      for (const spanProcessor of this._spanProcessors) {
        spanProcessor.onStart(span, context);
      }
    }
    onEnd(span) {
      for (const spanProcessor of this._spanProcessors) {
        spanProcessor.onEnd(span);
      }
    }
    shutdown() {
      const promises = [];
      for (const spanProcessor of this._spanProcessors) {
        promises.push(spanProcessor.shutdown());
      }
      return new Promise((resolve, reject) => {
        Promise.all(promises).then(() => {
          resolve();
        }, reject);
      });
    }
  }
  exports.MultiSpanProcessor = MultiSpanProcessor;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js
var require_BasicTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicTracerProvider = exports.ForceFlushState = undefined;
  var core_1 = require_src3();
  var resources_1 = require_src5();
  var Tracer_1 = require_Tracer();
  var config_1 = require_config2();
  var MultiSpanProcessor_1 = require_MultiSpanProcessor();
  var utility_1 = require_utility();
  var ForceFlushState;
  (function(ForceFlushState2) {
    ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
    ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
    ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
    ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
  })(ForceFlushState = exports.ForceFlushState || (exports.ForceFlushState = {}));

  class BasicTracerProvider {
    _config;
    _tracers = new Map;
    _resource;
    _activeSpanProcessor;
    constructor(config = {}) {
      const mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), (0, utility_1.reconfigureLimits)(config));
      this._resource = mergedConfig.resource ?? (0, resources_1.defaultResource)();
      this._config = Object.assign({}, mergedConfig, {
        resource: this._resource
      });
      const spanProcessors = [];
      if (config.spanProcessors?.length) {
        spanProcessors.push(...config.spanProcessors);
      }
      this._activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(spanProcessors);
    }
    getTracer(name, version, options) {
      const key = `${name}@${version || ""}:${options?.schemaUrl || ""}`;
      if (!this._tracers.has(key)) {
        this._tracers.set(key, new Tracer_1.Tracer({ name, version, schemaUrl: options?.schemaUrl }, this._config, this._resource, this._activeSpanProcessor));
      }
      return this._tracers.get(key);
    }
    forceFlush() {
      const timeout = this._config.forceFlushTimeoutMillis;
      const promises = this._activeSpanProcessor["_spanProcessors"].map((spanProcessor) => {
        return new Promise((resolve) => {
          let state;
          const timeoutInterval = setTimeout(() => {
            resolve(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));
            state = ForceFlushState.timeout;
          }, timeout);
          spanProcessor.forceFlush().then(() => {
            clearTimeout(timeoutInterval);
            if (state !== ForceFlushState.timeout) {
              state = ForceFlushState.resolved;
              resolve(state);
            }
          }).catch((error) => {
            clearTimeout(timeoutInterval);
            state = ForceFlushState.error;
            resolve(error);
          });
        });
      });
      return new Promise((resolve, reject) => {
        Promise.all(promises).then((results) => {
          const errors = results.filter((result) => result !== ForceFlushState.resolved);
          if (errors.length > 0) {
            reject(errors);
          } else {
            resolve();
          }
        }).catch((error) => reject([error]));
      });
    }
    shutdown() {
      return this._activeSpanProcessor.shutdown();
    }
  }
  exports.BasicTracerProvider = BasicTracerProvider;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js
var require_ConsoleSpanExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConsoleSpanExporter = undefined;
  var core_1 = require_src3();

  class ConsoleSpanExporter {
    export(spans, resultCallback) {
      return this._sendSpans(spans, resultCallback);
    }
    shutdown() {
      this._sendSpans([]);
      return this.forceFlush();
    }
    forceFlush() {
      return Promise.resolve();
    }
    _exportInfo(span) {
      return {
        resource: {
          attributes: span.resource.attributes
        },
        instrumentationScope: span.instrumentationScope,
        traceId: span.spanContext().traceId,
        parentSpanContext: span.parentSpanContext,
        traceState: span.spanContext().traceState?.serialize(),
        name: span.name,
        id: span.spanContext().spanId,
        kind: span.kind,
        timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
        duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
        attributes: span.attributes,
        status: span.status,
        events: span.events,
        links: span.links
      };
    }
    _sendSpans(spans, done) {
      for (const span of spans) {
        console.dir(this._exportInfo(span), { depth: 3 });
      }
      if (done) {
        return done({ code: core_1.ExportResultCode.SUCCESS });
      }
    }
  }
  exports.ConsoleSpanExporter = ConsoleSpanExporter;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js
var require_InMemorySpanExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InMemorySpanExporter = undefined;
  var core_1 = require_src3();

  class InMemorySpanExporter {
    _finishedSpans = [];
    _stopped = false;
    export(spans, resultCallback) {
      if (this._stopped)
        return resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Exporter has been stopped")
        });
      this._finishedSpans.push(...spans);
      setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
    }
    shutdown() {
      this._stopped = true;
      this._finishedSpans = [];
      return this.forceFlush();
    }
    forceFlush() {
      return Promise.resolve();
    }
    reset() {
      this._finishedSpans = [];
    }
    getFinishedSpans() {
      return this._finishedSpans;
    }
  }
  exports.InMemorySpanExporter = InMemorySpanExporter;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js
var require_SimpleSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SimpleSpanProcessor = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();

  class SimpleSpanProcessor {
    _exporter;
    _shutdownOnce;
    _pendingExports;
    constructor(_exporter) {
      this._exporter = _exporter;
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
      this._pendingExports = new Set;
    }
    async forceFlush() {
      await Promise.all(Array.from(this._pendingExports));
      if (this._exporter.forceFlush) {
        await this._exporter.forceFlush();
      }
    }
    onStart(_span, _parentContext) {
    }
    onEnd(span) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
        return;
      }
      const pendingExport = this._doExport(span).catch((err) => (0, core_1.globalErrorHandler)(err));
      this._pendingExports.add(pendingExport);
      pendingExport.finally(() => this._pendingExports.delete(pendingExport));
    }
    async _doExport(span) {
      if (span.resource.asyncAttributesPending) {
        await span.resource.waitForAsyncAttributes?.();
      }
      const result = await core_1.internal._export(this._exporter, [span]);
      if (result.code !== core_1.ExportResultCode.SUCCESS) {
        throw result.error ?? new Error(`SimpleSpanProcessor: span export failed (status ${result})`);
      }
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._exporter.shutdown();
    }
  }
  exports.SimpleSpanProcessor = SimpleSpanProcessor;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js
var require_NoopSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopSpanProcessor = undefined;

  class NoopSpanProcessor {
    onStart(_span, _context) {
    }
    onEnd(_span) {
    }
    shutdown() {
      return Promise.resolve();
    }
    forceFlush() {
      return Promise.resolve();
    }
  }
  exports.NoopSpanProcessor = NoopSpanProcessor;
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/index.js
var require_src9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = exports.TraceIdRatioBasedSampler = exports.ParentBasedSampler = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.NoopSpanProcessor = exports.SimpleSpanProcessor = exports.InMemorySpanExporter = exports.ConsoleSpanExporter = exports.RandomIdGenerator = exports.BatchSpanProcessor = exports.BasicTracerProvider = undefined;
  var BasicTracerProvider_1 = require_BasicTracerProvider();
  Object.defineProperty(exports, "BasicTracerProvider", { enumerable: true, get: function() {
    return BasicTracerProvider_1.BasicTracerProvider;
  } });
  var platform_1 = require_platform7();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return platform_1.BatchSpanProcessor;
  } });
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return platform_1.RandomIdGenerator;
  } });
  var ConsoleSpanExporter_1 = require_ConsoleSpanExporter();
  Object.defineProperty(exports, "ConsoleSpanExporter", { enumerable: true, get: function() {
    return ConsoleSpanExporter_1.ConsoleSpanExporter;
  } });
  var InMemorySpanExporter_1 = require_InMemorySpanExporter();
  Object.defineProperty(exports, "InMemorySpanExporter", { enumerable: true, get: function() {
    return InMemorySpanExporter_1.InMemorySpanExporter;
  } });
  var SimpleSpanProcessor_1 = require_SimpleSpanProcessor();
  Object.defineProperty(exports, "SimpleSpanProcessor", { enumerable: true, get: function() {
    return SimpleSpanProcessor_1.SimpleSpanProcessor;
  } });
  var NoopSpanProcessor_1 = require_NoopSpanProcessor();
  Object.defineProperty(exports, "NoopSpanProcessor", { enumerable: true, get: function() {
    return NoopSpanProcessor_1.NoopSpanProcessor;
  } });
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
    return AlwaysOffSampler_1.AlwaysOffSampler;
  } });
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();
  Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
    return AlwaysOnSampler_1.AlwaysOnSampler;
  } });
  var ParentBasedSampler_1 = require_ParentBasedSampler();
  Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
    return ParentBasedSampler_1.ParentBasedSampler;
  } });
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
  Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
    return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
  } });
  var Sampler_1 = require_Sampler();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return Sampler_1.SamplingDecision;
  } });
});

// node_modules/@opentelemetry/sdk-trace-node/build/src/NodeTracerProvider.js
var require_NodeTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeTracerProvider = undefined;
  var context_async_hooks_1 = require_src8();
  var sdk_trace_base_1 = require_src9();
  var api_1 = require_src();
  var core_1 = require_src3();
  function setupContextManager(contextManager) {
    if (contextManager === null) {
      return;
    }
    if (contextManager === undefined) {
      const defaultContextManager = new context_async_hooks_1.AsyncLocalStorageContextManager;
      defaultContextManager.enable();
      api_1.context.setGlobalContextManager(defaultContextManager);
      return;
    }
    contextManager.enable();
    api_1.context.setGlobalContextManager(contextManager);
  }
  function setupPropagator(propagator) {
    if (propagator === null) {
      return;
    }
    if (propagator === undefined) {
      api_1.propagation.setGlobalPropagator(new core_1.CompositePropagator({
        propagators: [
          new core_1.W3CTraceContextPropagator,
          new core_1.W3CBaggagePropagator
        ]
      }));
      return;
    }
    api_1.propagation.setGlobalPropagator(propagator);
  }

  class NodeTracerProvider extends sdk_trace_base_1.BasicTracerProvider {
    constructor(config = {}) {
      super(config);
    }
    register(config = {}) {
      api_1.trace.setGlobalTracerProvider(this);
      setupContextManager(config.contextManager);
      setupPropagator(config.propagator);
    }
  }
  exports.NodeTracerProvider = NodeTracerProvider;
});

// node_modules/@opentelemetry/sdk-trace-node/build/src/index.js
var require_src10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceIdRatioBasedSampler = exports.SimpleSpanProcessor = exports.SamplingDecision = exports.RandomIdGenerator = exports.ParentBasedSampler = exports.NoopSpanProcessor = exports.InMemorySpanExporter = exports.ConsoleSpanExporter = exports.BatchSpanProcessor = exports.BasicTracerProvider = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.NodeTracerProvider = undefined;
  var NodeTracerProvider_1 = require_NodeTracerProvider();
  Object.defineProperty(exports, "NodeTracerProvider", { enumerable: true, get: function() {
    return NodeTracerProvider_1.NodeTracerProvider;
  } });
  var sdk_trace_base_1 = require_src9();
  Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
    return sdk_trace_base_1.AlwaysOffSampler;
  } });
  Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
    return sdk_trace_base_1.AlwaysOnSampler;
  } });
  Object.defineProperty(exports, "BasicTracerProvider", { enumerable: true, get: function() {
    return sdk_trace_base_1.BasicTracerProvider;
  } });
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return sdk_trace_base_1.BatchSpanProcessor;
  } });
  Object.defineProperty(exports, "ConsoleSpanExporter", { enumerable: true, get: function() {
    return sdk_trace_base_1.ConsoleSpanExporter;
  } });
  Object.defineProperty(exports, "InMemorySpanExporter", { enumerable: true, get: function() {
    return sdk_trace_base_1.InMemorySpanExporter;
  } });
  Object.defineProperty(exports, "NoopSpanProcessor", { enumerable: true, get: function() {
    return sdk_trace_base_1.NoopSpanProcessor;
  } });
  Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
    return sdk_trace_base_1.ParentBasedSampler;
  } });
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return sdk_trace_base_1.RandomIdGenerator;
  } });
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return sdk_trace_base_1.SamplingDecision;
  } });
  Object.defineProperty(exports, "SimpleSpanProcessor", { enumerable: true, get: function() {
    return sdk_trace_base_1.SimpleSpanProcessor;
  } });
  Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
    return sdk_trace_base_1.TraceIdRatioBasedSampler;
  } });
});

// node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js
var require_autoLoaderUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableInstrumentations = exports.enableInstrumentations = undefined;
  function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for (let i = 0, j = instrumentations.length;i < j; i++) {
      const instrumentation = instrumentations[i];
      if (tracerProvider) {
        instrumentation.setTracerProvider(tracerProvider);
      }
      if (meterProvider) {
        instrumentation.setMeterProvider(meterProvider);
      }
      if (loggerProvider && instrumentation.setLoggerProvider) {
        instrumentation.setLoggerProvider(loggerProvider);
      }
      if (!instrumentation.getConfig().enabled) {
        instrumentation.enable();
      }
    }
  }
  exports.enableInstrumentations = enableInstrumentations;
  function disableInstrumentations(instrumentations) {
    instrumentations.forEach((instrumentation) => instrumentation.disable());
  }
  exports.disableInstrumentations = disableInstrumentations;
});

// node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js
var require_autoLoader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerInstrumentations = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var autoLoaderUtils_1 = require_autoLoaderUtils();
  function registerInstrumentations(options) {
    const tracerProvider = options.tracerProvider || api_1.trace.getTracerProvider();
    const meterProvider = options.meterProvider || api_1.metrics.getMeterProvider();
    const loggerProvider = options.loggerProvider || api_logs_1.logs.getLoggerProvider();
    const instrumentations = options.instrumentations?.flat() ?? [];
    (0, autoLoaderUtils_1.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return () => {
      (0, autoLoaderUtils_1.disableInstrumentations)(instrumentations);
    };
  }
  exports.registerInstrumentations = registerInstrumentations;
});

// node_modules/@opentelemetry/instrumentation/build/src/semver.js
var require_semver2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.satisfies = undefined;
  var api_1 = require_src();
  var VERSION_REGEXP = /^(?:v)?(?<version>(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*))(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  var RANGE_REGEXP = /^(?<op><|>|=|==|<=|>=|~|\^|~>)?\s*(?:v)?(?<version>(?<major>x|X|\*|0|[1-9]\d*)(?:\.(?<minor>x|X|\*|0|[1-9]\d*))?(?:\.(?<patch>x|X|\*|0|[1-9]\d*))?)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  var operatorResMap = {
    ">": [1],
    ">=": [0, 1],
    "=": [0],
    "<=": [-1, 0],
    "<": [-1],
    "!=": [-1, 1]
  };
  function satisfies(version, range, options) {
    if (!_validateVersion(version)) {
      api_1.diag.error(`Invalid version: ${version}`);
      return false;
    }
    if (!range) {
      return true;
    }
    range = range.replace(/([<>=~^]+)\s+/g, "$1");
    const parsedVersion = _parseVersion(version);
    if (!parsedVersion) {
      return false;
    }
    const allParsedRanges = [];
    const checkResult = _doSatisfies(parsedVersion, range, allParsedRanges, options);
    if (checkResult && !options?.includePrerelease) {
      return _doPreleaseCheck(parsedVersion, allParsedRanges);
    }
    return checkResult;
  }
  exports.satisfies = satisfies;
  function _validateVersion(version) {
    return typeof version === "string" && VERSION_REGEXP.test(version);
  }
  function _doSatisfies(parsedVersion, range, allParsedRanges, options) {
    if (range.includes("||")) {
      const ranges = range.trim().split("||");
      for (const r of ranges) {
        if (_checkRange(parsedVersion, r, allParsedRanges, options)) {
          return true;
        }
      }
      return false;
    } else if (range.includes(" - ")) {
      range = replaceHyphen(range, options);
    } else if (range.includes(" ")) {
      const ranges = range.trim().replace(/\s{2,}/g, " ").split(" ");
      for (const r of ranges) {
        if (!_checkRange(parsedVersion, r, allParsedRanges, options)) {
          return false;
        }
      }
      return true;
    }
    return _checkRange(parsedVersion, range, allParsedRanges, options);
  }
  function _checkRange(parsedVersion, range, allParsedRanges, options) {
    range = _normalizeRange(range, options);
    if (range.includes(" ")) {
      return _doSatisfies(parsedVersion, range, allParsedRanges, options);
    } else {
      const parsedRange = _parseRange(range);
      allParsedRanges.push(parsedRange);
      return _satisfies(parsedVersion, parsedRange);
    }
  }
  function _satisfies(parsedVersion, parsedRange) {
    if (parsedRange.invalid) {
      return false;
    }
    if (!parsedRange.version || _isWildcard(parsedRange.version)) {
      return true;
    }
    let comparisonResult = _compareVersionSegments(parsedVersion.versionSegments || [], parsedRange.versionSegments || []);
    if (comparisonResult === 0) {
      const versionPrereleaseSegments = parsedVersion.prereleaseSegments || [];
      const rangePrereleaseSegments = parsedRange.prereleaseSegments || [];
      if (!versionPrereleaseSegments.length && !rangePrereleaseSegments.length) {
        comparisonResult = 0;
      } else if (!versionPrereleaseSegments.length && rangePrereleaseSegments.length) {
        comparisonResult = 1;
      } else if (versionPrereleaseSegments.length && !rangePrereleaseSegments.length) {
        comparisonResult = -1;
      } else {
        comparisonResult = _compareVersionSegments(versionPrereleaseSegments, rangePrereleaseSegments);
      }
    }
    return operatorResMap[parsedRange.op]?.includes(comparisonResult);
  }
  function _doPreleaseCheck(parsedVersion, allParsedRanges) {
    if (parsedVersion.prerelease) {
      return allParsedRanges.some((r) => r.prerelease && r.version === parsedVersion.version);
    }
    return true;
  }
  function _normalizeRange(range, options) {
    range = range.trim();
    range = replaceCaret(range, options);
    range = replaceTilde(range);
    range = replaceXRange(range, options);
    range = range.trim();
    return range;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function _parseVersion(versionString) {
    const match = versionString.match(VERSION_REGEXP);
    if (!match) {
      api_1.diag.error(`Invalid version: ${versionString}`);
      return;
    }
    const version = match.groups.version;
    const prerelease = match.groups.prerelease;
    const build = match.groups.build;
    const versionSegments = version.split(".");
    const prereleaseSegments = prerelease?.split(".");
    return {
      op: undefined,
      version,
      versionSegments,
      versionSegmentCount: versionSegments.length,
      prerelease,
      prereleaseSegments,
      prereleaseSegmentCount: prereleaseSegments ? prereleaseSegments.length : 0,
      build
    };
  }
  function _parseRange(rangeString) {
    if (!rangeString) {
      return {};
    }
    const match = rangeString.match(RANGE_REGEXP);
    if (!match) {
      api_1.diag.error(`Invalid range: ${rangeString}`);
      return {
        invalid: true
      };
    }
    let op = match.groups.op;
    const version = match.groups.version;
    const prerelease = match.groups.prerelease;
    const build = match.groups.build;
    const versionSegments = version.split(".");
    const prereleaseSegments = prerelease?.split(".");
    if (op === "==") {
      op = "=";
    }
    return {
      op: op || "=",
      version,
      versionSegments,
      versionSegmentCount: versionSegments.length,
      prerelease,
      prereleaseSegments,
      prereleaseSegmentCount: prereleaseSegments ? prereleaseSegments.length : 0,
      build
    };
  }
  function _isWildcard(s) {
    return s === "*" || s === "x" || s === "X";
  }
  function _parseVersionString(v) {
    const n = parseInt(v, 10);
    return isNaN(n) ? v : n;
  }
  function _normalizeVersionType(a, b) {
    if (typeof a === typeof b) {
      if (typeof a === "number") {
        return [a, b];
      } else if (typeof a === "string") {
        return [a, b];
      } else {
        throw new Error("Version segments can only be strings or numbers");
      }
    } else {
      return [String(a), String(b)];
    }
  }
  function _compareVersionStrings(v1, v2) {
    if (_isWildcard(v1) || _isWildcard(v2)) {
      return 0;
    }
    const [parsedV1, parsedV2] = _normalizeVersionType(_parseVersionString(v1), _parseVersionString(v2));
    if (parsedV1 > parsedV2) {
      return 1;
    } else if (parsedV1 < parsedV2) {
      return -1;
    }
    return 0;
  }
  function _compareVersionSegments(v1, v2) {
    for (let i = 0;i < Math.max(v1.length, v2.length); i++) {
      const res = _compareVersionStrings(v1[i] || "0", v2[i] || "0");
      if (res !== 0) {
        return res;
      }
    }
    return 0;
  }
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var NUMERICIDENTIFIER = "0|[1-9]\\d*";
  var NONNUMERICIDENTIFIER = `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`;
  var GTLT = "((?:<|>)?=?)";
  var PRERELEASEIDENTIFIER = `(?:${NUMERICIDENTIFIER}|${NONNUMERICIDENTIFIER})`;
  var PRERELEASE = `(?:-(${PRERELEASEIDENTIFIER}(?:\\.${PRERELEASEIDENTIFIER})*))`;
  var BUILDIDENTIFIER = `${LETTERDASHNUMBER}+`;
  var BUILD = `(?:\\+(${BUILDIDENTIFIER}(?:\\.${BUILDIDENTIFIER})*))`;
  var XRANGEIDENTIFIER = `${NUMERICIDENTIFIER}|x|X|\\*`;
  var XRANGEPLAIN = `[v=\\s]*(${XRANGEIDENTIFIER})` + `(?:\\.(${XRANGEIDENTIFIER})` + `(?:\\.(${XRANGEIDENTIFIER})` + `(?:${PRERELEASE})?${BUILD}?` + `)?)?`;
  var XRANGE = `^${GTLT}\\s*${XRANGEPLAIN}$`;
  var XRANGE_REGEXP = new RegExp(XRANGE);
  var HYPHENRANGE = `^\\s*(${XRANGEPLAIN})` + `\\s+-\\s+` + `(${XRANGEPLAIN})` + `\\s*$`;
  var HYPHENRANGE_REGEXP = new RegExp(HYPHENRANGE);
  var LONETILDE = "(?:~>?)";
  var TILDE = `^${LONETILDE}${XRANGEPLAIN}$`;
  var TILDE_REGEXP = new RegExp(TILDE);
  var LONECARET = "(?:\\^)";
  var CARET = `^${LONECARET}${XRANGEPLAIN}$`;
  var CARET_REGEXP = new RegExp(CARET);
  function replaceTilde(comp) {
    const r = TILDE_REGEXP;
    return comp.replace(r, (_, M, m, p, pr) => {
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      return ret;
    });
  }
  function replaceCaret(comp, options) {
    const r = CARET_REGEXP;
    const z = options?.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      return ret;
    });
  }
  function replaceXRange(comp, options) {
    const r = XRANGE_REGEXP;
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options?.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      return ret;
    });
  }
  function replaceHyphen(comp, options) {
    const r = HYPHENRANGE_REGEXP;
    return comp.replace(r, (_, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${options?.includePrerelease ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${options?.includePrerelease ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${options?.includePrerelease ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (options?.includePrerelease) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    });
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/shimmer.js
var require_shimmer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.massUnwrap = exports.unwrap = exports.massWrap = exports.wrap = undefined;
  var logger = console.error.bind(console);
  function defineProperty(obj, name, value) {
    const enumerable = !!obj[name] && Object.prototype.propertyIsEnumerable.call(obj, name);
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable,
      writable: true,
      value
    });
  }
  var wrap = (nodule, name, wrapper) => {
    if (!nodule || !nodule[name]) {
      logger("no original function " + String(name) + " to wrap");
      return;
    }
    if (!wrapper) {
      logger("no wrapper function");
      logger(new Error().stack);
      return;
    }
    const original = nodule[name];
    if (typeof original !== "function" || typeof wrapper !== "function") {
      logger("original object and wrapper must be functions");
      return;
    }
    const wrapped = wrapper(original, name);
    defineProperty(wrapped, "__original", original);
    defineProperty(wrapped, "__unwrap", () => {
      if (nodule[name] === wrapped) {
        defineProperty(nodule, name, original);
      }
    });
    defineProperty(wrapped, "__wrapped", true);
    defineProperty(nodule, name, wrapped);
    return wrapped;
  };
  exports.wrap = wrap;
  var massWrap = (nodules, names, wrapper) => {
    if (!nodules) {
      logger("must provide one or more modules to patch");
      logger(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger("must provide one or more functions to wrap on modules");
      return;
    }
    nodules.forEach((nodule) => {
      names.forEach((name) => {
        (0, exports.wrap)(nodule, name, wrapper);
      });
    });
  };
  exports.massWrap = massWrap;
  var unwrap = (nodule, name) => {
    if (!nodule || !nodule[name]) {
      logger("no function to unwrap.");
      logger(new Error().stack);
      return;
    }
    const wrapped = nodule[name];
    if (!wrapped.__unwrap) {
      logger("no original to unwrap to -- has " + String(name) + " already been unwrapped?");
    } else {
      wrapped.__unwrap();
      return;
    }
  };
  exports.unwrap = unwrap;
  var massUnwrap = (nodules, names) => {
    if (!nodules) {
      logger("must provide one or more modules to patch");
      logger(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger("must provide one or more functions to unwrap on modules");
      return;
    }
    nodules.forEach((nodule) => {
      names.forEach((name) => {
        (0, exports.unwrap)(nodule, name);
      });
    });
  };
  exports.massUnwrap = massUnwrap;
  function shimmer(options) {
    if (options && options.logger) {
      if (typeof options.logger !== "function") {
        logger("new logger isn't a function, not replacing");
      } else {
        logger = options.logger;
      }
    }
  }
  exports.default = shimmer;
  shimmer.wrap = exports.wrap;
  shimmer.massWrap = exports.massWrap;
  shimmer.unwrap = exports.unwrap;
  shimmer.massUnwrap = exports.massUnwrap;
});

// node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js
var require_instrumentation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationAbstract = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var shimmer = require_shimmer();

  class InstrumentationAbstract {
    instrumentationName;
    instrumentationVersion;
    _config = {};
    _tracer;
    _meter;
    _logger;
    _diag;
    constructor(instrumentationName, instrumentationVersion, config) {
      this.instrumentationName = instrumentationName;
      this.instrumentationVersion = instrumentationVersion;
      this.setConfig(config);
      this._diag = api_1.diag.createComponentLogger({
        namespace: instrumentationName
      });
      this._tracer = api_1.trace.getTracer(instrumentationName, instrumentationVersion);
      this._meter = api_1.metrics.getMeter(instrumentationName, instrumentationVersion);
      this._logger = api_logs_1.logs.getLogger(instrumentationName, instrumentationVersion);
      this._updateMetricInstruments();
    }
    _wrap = shimmer.wrap;
    _unwrap = shimmer.unwrap;
    _massWrap = shimmer.massWrap;
    _massUnwrap = shimmer.massUnwrap;
    get meter() {
      return this._meter;
    }
    setMeterProvider(meterProvider) {
      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      this._updateMetricInstruments();
    }
    get logger() {
      return this._logger;
    }
    setLoggerProvider(loggerProvider) {
      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    }
    getModuleDefinitions() {
      const initResult = this.init() ?? [];
      if (!Array.isArray(initResult)) {
        return [initResult];
      }
      return initResult;
    }
    _updateMetricInstruments() {
      return;
    }
    getConfig() {
      return this._config;
    }
    setConfig(config) {
      this._config = {
        enabled: true,
        ...config
      };
    }
    setTracerProvider(tracerProvider) {
      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    }
    get tracer() {
      return this._tracer;
    }
    _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
      if (!hookHandler) {
        return;
      }
      try {
        hookHandler(span, info);
      } catch (e) {
        this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e);
      }
    }
  }
  exports.InstrumentationAbstract = InstrumentationAbstract;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position2 = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position2 !== -1 && (terminatorPosition === -1 || position2 < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
});

// node_modules/debug/src/node.js
var require_node8 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src11 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node8();
  }
});

// node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS((exports, module) => {
  var sep = __require("path").sep;
  module.exports = function(file) {
    var segments = file.split(sep);
    var index = segments.lastIndexOf("node_modules");
    if (index === -1)
      return;
    if (!segments[index + 1])
      return;
    var scoped = segments[index + 1][0] === "@";
    var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
    var offset = scoped ? 3 : 2;
    var basedir = "";
    var lastBaseDirSegmentIndex = index + offset - 1;
    for (var i = 0;i <= lastBaseDirSegmentIndex; i++) {
      if (i === lastBaseDirSegmentIndex) {
        basedir += segments[i];
      } else {
        basedir += segments[i] + sep;
      }
    }
    var path = "";
    var lastSegmentIndex = segments.length - 1;
    for (var i2 = index + offset;i2 <= lastSegmentIndex; i2++) {
      if (i2 === lastSegmentIndex) {
        path += segments[i2];
      } else {
        path += segments[i2] + sep;
      }
    }
    return {
      name,
      basedir,
      path
    };
  };
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS((exports, module) => {
  var os = __require("os");
  module.exports = os.homedir || function homedir() {
    var home = process.env.HOME;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    if (process.platform === "win32") {
      return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }
    if (process.platform === "darwin") {
      return home || (user ? "/Users/" + user : null);
    }
    if (process.platform === "linux") {
      return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
    }
    return home || null;
  };
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  module.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows)
    module.exports = win32.parse;
  else
    module.exports = posix.parse;
  module.exports.posix = posix.parse;
  module.exports.win32 = win32.parse;
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports, module) => {
  var path = __require("path");
  var parse2 = path.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse2(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse2(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module.exports = function nodeModulesPaths(start, opts, request2) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request2, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports, module) => {
  module.exports = function(x, opts) {
    return opts || {};
  };
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// node_modules/is-core-module/core.json
var require_core = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    "node:sea": [">= 20.12 && < 21", ">= 21.7"],
    smalloc: ">= 0.11.5 && < 3",
    "node:sqlite": [">= 22.13 && < 23", ">= 23.4"],
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "test/mock_loader": ">= 22.3 && < 22.7",
    "node:test/mock_loader": ">= 22.3 && < 22.7",
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports, module) => {
  var hasOwn = require_hasown();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0;i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0;i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0;i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core();
  module.exports = function isCore(x, nodeVersion) {
    return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS((exports, module) => {
  var fs = __require("fs");
  var getHomedir = require_homedir();
  var path = __require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir, ".node_modules"),
      path.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg = JSON.parse(body);
          cb(null, pkg);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = path.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = undefined;
      }
      var exts = [""].concat(extensions);
      load(exts, x2, loadAsFilePackage);
      function load(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, undefined, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load([""].concat(extensions.slice()), path.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path.dirname(dir), cb2);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path.dirname(dir), cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb2(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path.join(x2, "index"), fpkg, cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package " + pkg.name + " `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                if (err4)
                  return cb2(err4);
                if (m)
                  return cb2(null, m, pkg2);
                if (!pkg2)
                  return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                var dir = path.resolve(x2, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg3);
                  loadAsFile(path.join(x2, "index"), pkg3, cb2);
                });
              });
              return;
            }
            loadAsFile(path.join(x2, "/index"), pkg, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, undefined);
      var dir = dirs[0];
      isDirectory(path.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    "node:sea": [">= 20.12 && < 21", ">= 21.7"],
    smalloc: ">= 0.11.5 && < 3",
    "node:sqlite": ">= 23.4",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "test/mock_loader": ">= 22.3 && < 22.7",
    "node:test/mock_loader": ">= 22.3 && < 22.7",
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  var data = require_core2();
  var core = {};
  for (mod2 in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod2)) {
      core[mod2] = isCoreModule(mod2);
    }
  }
  var mod2;
  module.exports = core;
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  module.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports, module) => {
  var isCore = require_is_core_module();
  var fs = __require("fs");
  var path = __require("path");
  var getHomedir = require_homedir();
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir, ".node_modules"),
      path.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs.statSync(file, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs.statSync(dir, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
      var pkg = JSON.parse(body);
      return pkg;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0;i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path.dirname(dir));
      }
      var pkg = readPackageSync(readFileSync, pkgfile);
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return { pkg, dir };
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x2);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package " + pkg.name + " `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0;i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path.dirname(dir))) {
          var m2 = loadAsFileSync(dir);
          if (m2)
            return m2;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// node_modules/resolve/index.js
var require_resolve = __commonJS((exports, module) => {
  var async = require_async();
  async.core = require_core3();
  async.isCore = require_is_core();
  async.sync = require_sync();
  module.exports = async;
});

// node_modules/require-in-the-middle/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "require-in-the-middle",
    version: "7.5.2",
    description: "Module to hook into the Node.js require function",
    main: "index.js",
    types: "types/index.d.ts",
    dependencies: {
      debug: "^4.3.5",
      "module-details-from-path": "^1.0.3",
      resolve: "^1.22.8"
    },
    devDependencies: {
      "@babel/core": "^7.9.0",
      "@babel/preset-env": "^7.9.5",
      "@babel/preset-typescript": "^7.9.0",
      "@babel/register": "^7.9.0",
      "ipp-printer": "^1.0.0",
      patterns: "^1.0.3",
      roundround: "^0.2.0",
      semver: "^6.3.0",
      standard: "^14.3.1",
      tape: "^4.11.0"
    },
    scripts: {
      test: "npm run test:lint && npm run test:tape && npm run test:babel",
      "test:lint": "standard",
      "test:tape": "tape test/*.js",
      "test:babel": "node test/babel/babel-register.js"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/nodejs/require-in-the-middle.git"
    },
    keywords: [
      "require",
      "hook",
      "shim",
      "shimmer",
      "shimming",
      "patch",
      "monkey",
      "monkeypatch",
      "module",
      "load"
    ],
    files: [
      "types"
    ],
    author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
    license: "MIT",
    bugs: {
      url: "https://github.com/nodejs/require-in-the-middle/issues"
    },
    homepage: "https://github.com/nodejs/require-in-the-middle#readme",
    engines: {
      node: ">=8.6.0"
    }
  };
});

// node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS((exports, module) => {
  var path = __require("path");
  var Module = __require("module");
  var debug = require_src11()("require-in-the-middle");
  var moduleDetailsFromPath = require_module_details_from_path();
  module.exports = Hook;
  module.exports.Hook = Hook;
  var builtinModules;
  var isCore;
  if (Module.isBuiltin) {
    isCore = Module.isBuiltin;
  } else if (Module.builtinModules) {
    isCore = (moduleName2) => {
      if (moduleName2.startsWith("node:")) {
        return true;
      }
      if (builtinModules === undefined) {
        builtinModules = new Set(Module.builtinModules);
      }
      return builtinModules.has(moduleName2);
    };
  } else {
    const _resolve2 = require_resolve();
    const [major, minor] = process.versions.node.split(".").map(Number);
    if (major === 8 && minor < 8) {
      isCore = (moduleName2) => {
        if (moduleName2 === "http2") {
          return true;
        }
        return !!_resolve2.core[moduleName2];
      };
    } else {
      isCore = (moduleName2) => {
        return !!_resolve2.core[moduleName2];
      };
    }
  }
  var _resolve;
  function resolve(moduleName2, basedir) {
    if (!_resolve) {
      if (__require.resolve && __require.resolve.paths) {
        _resolve = function(moduleName3, basedir2) {
          return __require.resolve(moduleName3, { paths: [basedir2] });
        };
      } else {
        const resolve2 = require_resolve();
        _resolve = function(moduleName3, basedir2) {
          return resolve2.sync(moduleName3, { basedir: basedir2 });
        };
      }
    }
    return _resolve(moduleName2, basedir);
  }
  var normalize = /([/\\]index)?(\.js)?$/;

  class ExportsCache {
    constructor() {
      this._localCache = new Map;
      this._kRitmExports = Symbol("RitmExports");
    }
    has(filename, isBuiltin) {
      if (this._localCache.has(filename)) {
        return true;
      } else if (!isBuiltin) {
        const mod2 = __require.cache[filename];
        return !!(mod2 && (this._kRitmExports in mod2));
      } else {
        return false;
      }
    }
    get(filename, isBuiltin) {
      const cachedExports = this._localCache.get(filename);
      if (cachedExports !== undefined) {
        return cachedExports;
      } else if (!isBuiltin) {
        const mod2 = __require.cache[filename];
        return mod2 && mod2[this._kRitmExports];
      }
    }
    set(filename, exports2, isBuiltin) {
      if (isBuiltin) {
        this._localCache.set(filename, exports2);
      } else if (filename in __require.cache) {
        __require.cache[filename][this._kRitmExports] = exports2;
      } else {
        debug('non-core module is unexpectedly not in require.cache: "%s"', filename);
        this._localCache.set(filename, exports2);
      }
    }
  }
  function Hook(modules, options, onrequire) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, onrequire);
    if (typeof modules === "function") {
      onrequire = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      onrequire = options;
      options = null;
    }
    if (typeof Module._resolveFilename !== "function") {
      console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
      console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package().bugs.url);
      return;
    }
    this._cache = new ExportsCache;
    this._unhooked = false;
    this._origRequire = Module.prototype.require;
    const self2 = this;
    const patching = new Set;
    const internals = options ? options.internals === true : false;
    const hasWhitelist = Array.isArray(modules);
    debug("registering require hook");
    this._require = Module.prototype.require = function(id) {
      if (self2._unhooked === true) {
        debug("ignoring require call - module is soft-unhooked");
        return self2._origRequire.apply(this, arguments);
      }
      return patchedRequire.call(this, arguments, false);
    };
    if (typeof process.getBuiltinModule === "function") {
      this._origGetBuiltinModule = process.getBuiltinModule;
      this._getBuiltinModule = process.getBuiltinModule = function(id) {
        if (self2._unhooked === true) {
          debug("ignoring process.getBuiltinModule call - module is soft-unhooked");
          return self2._origGetBuiltinModule.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, true);
      };
    }
    function patchedRequire(args, coreOnly) {
      const id = args[0];
      const core = isCore(id);
      let filename;
      if (core) {
        filename = id;
        if (id.startsWith("node:")) {
          const idWithoutPrefix = id.slice(5);
          if (isCore(idWithoutPrefix)) {
            filename = idWithoutPrefix;
          }
        }
      } else if (coreOnly) {
        debug("call to process.getBuiltinModule with unknown built-in id");
        return self2._origGetBuiltinModule.apply(this, args);
      } else {
        try {
          filename = Module._resolveFilename(id, this);
        } catch (resolveErr) {
          debug('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
          return self2._origRequire.apply(this, args);
        }
      }
      let moduleName2, basedir;
      debug("processing %s module require('%s'): %s", core === true ? "core" : "non-core", id, filename);
      if (self2._cache.has(filename, core) === true) {
        debug("returning already patched cached module: %s", filename);
        return self2._cache.get(filename, core);
      }
      const isPatching = patching.has(filename);
      if (isPatching === false) {
        patching.add(filename);
      }
      const exports2 = coreOnly ? self2._origGetBuiltinModule.apply(this, args) : self2._origRequire.apply(this, args);
      if (isPatching === true) {
        debug("module is in the process of being patched already - ignoring: %s", filename);
        return exports2;
      }
      patching.delete(filename);
      if (core === true) {
        if (hasWhitelist === true && modules.includes(filename) === false) {
          debug("ignoring core module not on whitelist: %s", filename);
          return exports2;
        }
        moduleName2 = filename;
      } else if (hasWhitelist === true && modules.includes(filename)) {
        const parsedPath = path.parse(filename);
        moduleName2 = parsedPath.name;
        basedir = parsedPath.dir;
      } else {
        const stat = moduleDetailsFromPath(filename);
        if (stat === undefined) {
          debug("could not parse filename: %s", filename);
          return exports2;
        }
        moduleName2 = stat.name;
        basedir = stat.basedir;
        const fullModuleName = resolveModuleName(stat);
        debug("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName2, id, fullModuleName, basedir);
        let matchFound = false;
        if (hasWhitelist) {
          if (!id.startsWith(".") && modules.includes(id)) {
            moduleName2 = id;
            matchFound = true;
          }
          if (!modules.includes(moduleName2) && !modules.includes(fullModuleName)) {
            return exports2;
          }
          if (modules.includes(fullModuleName) && fullModuleName !== moduleName2) {
            moduleName2 = fullModuleName;
            matchFound = true;
          }
        }
        if (!matchFound) {
          let res;
          try {
            res = resolve(moduleName2, basedir);
          } catch (e) {
            debug("could not resolve module: %s", moduleName2);
            self2._cache.set(filename, exports2, core);
            return exports2;
          }
          if (res !== filename) {
            if (internals === true) {
              moduleName2 = moduleName2 + path.sep + path.relative(basedir, filename);
              debug("preparing to process require of internal file: %s", moduleName2);
            } else {
              debug("ignoring require of non-main module file: %s", res);
              self2._cache.set(filename, exports2, core);
              return exports2;
            }
          }
        }
      }
      self2._cache.set(filename, exports2, core);
      debug("calling require hook: %s", moduleName2);
      const patchedExports = onrequire(exports2, moduleName2, basedir);
      self2._cache.set(filename, patchedExports, core);
      debug("returning module: %s", moduleName2);
      return patchedExports;
    }
  }
  Hook.prototype.unhook = function() {
    this._unhooked = true;
    if (this._require === Module.prototype.require) {
      Module.prototype.require = this._origRequire;
      debug("require unhook successful");
    } else {
      debug("require unhook unsuccessful");
    }
    if (process.getBuiltinModule !== undefined) {
      if (this._getBuiltinModule === process.getBuiltinModule) {
        process.getBuiltinModule = this._origGetBuiltinModule;
        debug("process.getBuiltinModule unhook successful");
      } else {
        debug("process.getBuiltinModule unhook unsuccessful");
      }
    }
  };
  function resolveModuleName(stat) {
    const normalizedPath = path.sep !== "/" ? stat.path.split(path.sep).join("/") : stat.path;
    return path.posix.join(stat.name, normalizedPath).replace(normalize, "");
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js
var require_ModuleNameTrie = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ModuleNameTrie = exports.ModuleNameSeparator = undefined;
  exports.ModuleNameSeparator = "/";

  class ModuleNameTrieNode {
    hooks = [];
    children = new Map;
  }

  class ModuleNameTrie {
    _trie = new ModuleNameTrieNode;
    _counter = 0;
    insert(hook) {
      let trieNode = this._trie;
      for (const moduleNamePart of hook.moduleName.split(exports.ModuleNameSeparator)) {
        let nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          nextNode = new ModuleNameTrieNode;
          trieNode.children.set(moduleNamePart, nextNode);
        }
        trieNode = nextNode;
      }
      trieNode.hooks.push({ hook, insertedId: this._counter++ });
    }
    search(moduleName2, { maintainInsertionOrder, fullOnly } = {}) {
      let trieNode = this._trie;
      const results = [];
      let foundFull = true;
      for (const moduleNamePart of moduleName2.split(exports.ModuleNameSeparator)) {
        const nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          foundFull = false;
          break;
        }
        if (!fullOnly) {
          results.push(...nextNode.hooks);
        }
        trieNode = nextNode;
      }
      if (fullOnly && foundFull) {
        results.push(...trieNode.hooks);
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return [results[0].hook];
      }
      if (maintainInsertionOrder) {
        results.sort((a, b) => a.insertedId - b.insertedId);
      }
      return results.map(({ hook }) => hook);
    }
  }
  exports.ModuleNameTrie = ModuleNameTrie;
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js
var require_RequireInTheMiddleSingleton = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequireInTheMiddleSingleton = undefined;
  var require_in_the_middle_1 = require_require_in_the_middle();
  var path = __require("path");
  var ModuleNameTrie_1 = require_ModuleNameTrie();
  var isMocha = [
    "afterEach",
    "after",
    "beforeEach",
    "before",
    "describe",
    "it"
  ].every((fn) => {
    return typeof global[fn] === "function";
  });

  class RequireInTheMiddleSingleton {
    _moduleNameTrie = new ModuleNameTrie_1.ModuleNameTrie;
    static _instance;
    constructor() {
      this._initialize();
    }
    _initialize() {
      new require_in_the_middle_1.Hook(null, { internals: true }, (exports2, name, basedir) => {
        const normalizedModuleName = normalizePathSeparators(name);
        const matches = this._moduleNameTrie.search(normalizedModuleName, {
          maintainInsertionOrder: true,
          fullOnly: basedir === undefined
        });
        for (const { onRequire } of matches) {
          exports2 = onRequire(exports2, name, basedir);
        }
        return exports2;
      });
    }
    register(moduleName2, onRequire) {
      const hooked = { moduleName: moduleName2, onRequire };
      this._moduleNameTrie.insert(hooked);
      return hooked;
    }
    static getInstance() {
      if (isMocha)
        return new RequireInTheMiddleSingleton;
      return this._instance = this._instance ?? new RequireInTheMiddleSingleton;
    }
  }
  exports.RequireInTheMiddleSingleton = RequireInTheMiddleSingleton;
  function normalizePathSeparators(moduleNameOrPath) {
    return path.sep !== ModuleNameTrie_1.ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameTrie_1.ModuleNameSeparator) : moduleNameOrPath;
  }
});

// node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS((exports) => {
  var importHooks = [];
  var setters = new WeakMap;
  var getters = new WeakMap;
  var specifiers = new Map;
  var toHook = [];
  var proxyHandler = {
    set(target, name, value) {
      return setters.get(target)[name](value);
    },
    get(target, name) {
      if (name === Symbol.toStringTag) {
        return "Module";
      }
      const getter = getters.get(target)[name];
      if (typeof getter === "function") {
        return getter();
      }
    },
    defineProperty(target, property, descriptor) {
      if (!("value" in descriptor)) {
        throw new Error("Getters/setters are not supported for exports property descriptors.");
      }
      return setters.get(target)[property](descriptor.value);
    }
  };
  function register(name, namespace, set, get, specifier) {
    specifiers.set(name, specifier);
    setters.set(namespace, set);
    getters.set(namespace, get);
    const proxy = new Proxy(namespace, proxyHandler);
    importHooks.forEach((hook) => hook(name, proxy));
    toHook.push([name, proxy]);
  }
  var experimentalPatchInternals = false;
  function getExperimentalPatchInternals() {
    return experimentalPatchInternals;
  }
  function setExperimentalPatchInternals(value) {
    experimentalPatchInternals = value;
  }
  exports.register = register;
  exports.importHooks = importHooks;
  exports.specifiers = specifiers;
  exports.toHook = toHook;
  exports.getExperimentalPatchInternals = getExperimentalPatchInternals;
  exports.setExperimentalPatchInternals = setExperimentalPatchInternals;
});

// node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS((exports, module) => {
  var path = __require("path");
  var parse2 = require_module_details_from_path();
  var { fileURLToPath } = __require("url");
  var { MessageChannel } = __require("worker_threads");
  var {
    importHooks,
    specifiers,
    toHook,
    getExperimentalPatchInternals
  } = require_register();
  function addHook(hook) {
    importHooks.push(hook);
    toHook.forEach(([name, namespace]) => hook(name, namespace));
  }
  function removeHook(hook) {
    const index = importHooks.indexOf(hook);
    if (index > -1) {
      importHooks.splice(index, 1);
    }
  }
  function callHookFn(hookFn, namespace, name, baseDir) {
    const newDefault = hookFn(namespace, name, baseDir);
    if (newDefault && newDefault !== namespace) {
      namespace.default = newDefault;
    }
  }
  var sendModulesToLoader;
  function createAddHookMessageChannel() {
    const { port1, port2 } = new MessageChannel;
    let pendingAckCount = 0;
    let resolveFn;
    sendModulesToLoader = (modules) => {
      pendingAckCount++;
      port1.postMessage(modules);
    };
    port1.on("message", () => {
      pendingAckCount--;
      if (resolveFn && pendingAckCount <= 0) {
        resolveFn();
      }
    }).unref();
    function waitForAllMessagesAcknowledged() {
      const timer = setInterval(() => {
      }, 1000);
      const promise = new Promise((resolve) => {
        resolveFn = resolve;
      }).then(() => {
        clearInterval(timer);
      });
      if (pendingAckCount === 0) {
        resolveFn();
      }
      return promise;
    }
    const addHookMessagePort = port2;
    const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
    return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
  }
  function Hook(modules, options, hookFn) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, hookFn);
    if (typeof modules === "function") {
      hookFn = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      hookFn = options;
      options = null;
    }
    const internals = options ? options.internals === true : false;
    if (sendModulesToLoader && Array.isArray(modules)) {
      sendModulesToLoader(modules);
    }
    this._iitmHook = (name, namespace) => {
      const filename = name;
      const isBuiltin = name.startsWith("node:");
      let baseDir;
      if (isBuiltin) {
        name = name.replace(/^node:/, "");
      } else {
        if (name.startsWith("file://")) {
          try {
            name = fileURLToPath(name);
          } catch (e) {
          }
        }
        const details = parse2(name);
        if (details) {
          name = details.name;
          baseDir = details.basedir;
        }
      }
      if (modules) {
        for (const moduleName2 of modules) {
          if (moduleName2 === name) {
            if (baseDir) {
              if (internals) {
                name = name + path.sep + path.relative(baseDir, fileURLToPath(filename));
              } else {
                if (!getExperimentalPatchInternals() && !baseDir.endsWith(specifiers.get(filename)))
                  continue;
              }
            }
            callHookFn(hookFn, namespace, name, baseDir);
          }
        }
      } else {
        callHookFn(hookFn, namespace, name, baseDir);
      }
    };
    addHook(this._iitmHook);
  }
  Hook.prototype.unhook = function() {
    removeHook(this._iitmHook);
  };
  module.exports = Hook;
  module.exports.Hook = Hook;
  module.exports.addHook = addHook;
  module.exports.removeHook = removeHook;
  module.exports.createAddHookMessageChannel = createAddHookMessageChannel;
});

// node_modules/@opentelemetry/instrumentation/build/src/utils.js
var require_utils8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = undefined;
  function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = execute();
    } catch (e) {
      error = e;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddle = safeExecuteInTheMiddle;
  async function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = await execute();
    } catch (e) {
      error = e;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddleAsync = safeExecuteInTheMiddleAsync;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js
var require_instrumentation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationBase = undefined;
  var path = __require("path");
  var util_1 = __require("util");
  var semver_1 = require_semver2();
  var shimmer_1 = require_shimmer();
  var instrumentation_1 = require_instrumentation();
  var RequireInTheMiddleSingleton_1 = require_RequireInTheMiddleSingleton();
  var import_in_the_middle_1 = require_import_in_the_middle();
  var api_1 = require_src();
  var require_in_the_middle_1 = require_require_in_the_middle();
  var fs_1 = __require("fs");
  var utils_1 = require_utils8();

  class InstrumentationBase extends instrumentation_1.InstrumentationAbstract {
    _modules;
    _hooks = [];
    _requireInTheMiddleSingleton = RequireInTheMiddleSingleton_1.RequireInTheMiddleSingleton.getInstance();
    _enabled = false;
    constructor(instrumentationName, instrumentationVersion, config) {
      super(instrumentationName, instrumentationVersion, config);
      let modules = this.init();
      if (modules && !Array.isArray(modules)) {
        modules = [modules];
      }
      this._modules = modules || [];
      if (this._config.enabled) {
        this.enable();
      }
    }
    _wrap = (moduleExports, name, wrapper) => {
      if ((0, utils_1.isWrapped)(moduleExports[name])) {
        this._unwrap(moduleExports, name);
      }
      if (!util_1.types.isProxy(moduleExports)) {
        return (0, shimmer_1.wrap)(moduleExports, name, wrapper);
      } else {
        const wrapped = (0, shimmer_1.wrap)(Object.assign({}, moduleExports), name, wrapper);
        Object.defineProperty(moduleExports, name, {
          value: wrapped
        });
        return wrapped;
      }
    };
    _unwrap = (moduleExports, name) => {
      if (!util_1.types.isProxy(moduleExports)) {
        return (0, shimmer_1.unwrap)(moduleExports, name);
      } else {
        return Object.defineProperty(moduleExports, name, {
          value: moduleExports[name]
        });
      }
    };
    _massWrap = (moduleExportsArray, names, wrapper) => {
      if (!moduleExportsArray) {
        api_1.diag.error("must provide one or more modules to patch");
        return;
      } else if (!Array.isArray(moduleExportsArray)) {
        moduleExportsArray = [moduleExportsArray];
      }
      if (!(names && Array.isArray(names))) {
        api_1.diag.error("must provide one or more functions to wrap on modules");
        return;
      }
      moduleExportsArray.forEach((moduleExports) => {
        names.forEach((name) => {
          this._wrap(moduleExports, name, wrapper);
        });
      });
    };
    _massUnwrap = (moduleExportsArray, names) => {
      if (!moduleExportsArray) {
        api_1.diag.error("must provide one or more modules to patch");
        return;
      } else if (!Array.isArray(moduleExportsArray)) {
        moduleExportsArray = [moduleExportsArray];
      }
      if (!(names && Array.isArray(names))) {
        api_1.diag.error("must provide one or more functions to wrap on modules");
        return;
      }
      moduleExportsArray.forEach((moduleExports) => {
        names.forEach((name) => {
          this._unwrap(moduleExports, name);
        });
      });
    };
    _warnOnPreloadedModules() {
      this._modules.forEach((module2) => {
        const { name } = module2;
        try {
          const resolvedModule = __require.resolve(name);
          if (__require.cache[resolvedModule]) {
            this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
          }
        } catch {
        }
      });
    }
    _extractPackageVersion(baseDir) {
      try {
        const json = (0, fs_1.readFileSync)(path.join(baseDir, "package.json"), {
          encoding: "utf8"
        });
        const version = JSON.parse(json).version;
        return typeof version === "string" ? version : undefined;
      } catch (error) {
        api_1.diag.warn("Failed extracting version", baseDir);
      }
      return;
    }
    _onRequire(module2, exports2, name, baseDir) {
      if (!baseDir) {
        if (typeof module2.patch === "function") {
          module2.moduleExports = exports2;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
              module: module2.name
            });
            return module2.patch(exports2);
          }
        }
        return exports2;
      }
      const version = this._extractPackageVersion(baseDir);
      module2.moduleVersion = version;
      if (module2.name === name) {
        if (isSupported(module2.supportedVersions, version, module2.includePrerelease)) {
          if (typeof module2.patch === "function") {
            module2.moduleExports = exports2;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for module on require hook", {
                module: module2.name,
                version: module2.moduleVersion,
                baseDir
              });
              return module2.patch(exports2, module2.moduleVersion);
            }
          }
        }
        return exports2;
      }
      const files2 = module2.files ?? [];
      const normalizedName = path.normalize(name);
      const supportedFileInstrumentations = files2.filter((f) => f.name === normalizedName).filter((f) => isSupported(f.supportedVersions, version, module2.includePrerelease));
      return supportedFileInstrumentations.reduce((patchedExports, file) => {
        file.moduleExports = patchedExports;
        if (this._enabled) {
          this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
            module: module2.name,
            version: module2.moduleVersion,
            fileName: file.name,
            baseDir
          });
          return file.patch(patchedExports, module2.moduleVersion);
        }
        return patchedExports;
      }, exports2);
    }
    enable() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._hooks.length > 0) {
        for (const module2 of this._modules) {
          if (typeof module2.patch === "function" && module2.moduleExports) {
            this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
              module: module2.name,
              version: module2.moduleVersion
            });
            module2.patch(module2.moduleExports, module2.moduleVersion);
          }
          for (const file of module2.files) {
            if (file.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                module: module2.name,
                version: module2.moduleVersion,
                fileName: file.name
              });
              file.patch(file.moduleExports, module2.moduleVersion);
            }
          }
        }
        return;
      }
      this._warnOnPreloadedModules();
      for (const module2 of this._modules) {
        const hookFn = (exports2, name, baseDir) => {
          if (!baseDir && path.isAbsolute(name)) {
            const parsedPath = path.parse(name);
            name = parsedPath.name;
            baseDir = parsedPath.dir;
          }
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const onRequire = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const hook = path.isAbsolute(module2.name) ? new require_in_the_middle_1.Hook([module2.name], { internals: true }, onRequire) : this._requireInTheMiddleSingleton.register(module2.name, onRequire);
        this._hooks.push(hook);
        const esmHook = new import_in_the_middle_1.Hook([module2.name], { internals: false }, hookFn);
        this._hooks.push(esmHook);
      }
    }
    disable() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      for (const module2 of this._modules) {
        if (typeof module2.unpatch === "function" && module2.moduleExports) {
          this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
            module: module2.name,
            version: module2.moduleVersion
          });
          module2.unpatch(module2.moduleExports, module2.moduleVersion);
        }
        for (const file of module2.files) {
          if (file.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
              module: module2.name,
              version: module2.moduleVersion,
              fileName: file.name
            });
            file.unpatch(file.moduleExports, module2.moduleVersion);
          }
        }
      }
    }
    isEnabled() {
      return this._enabled;
    }
  }
  exports.InstrumentationBase = InstrumentationBase;
  function isSupported(supportedVersions, version, includePrerelease) {
    if (typeof version === "undefined") {
      return supportedVersions.includes("*");
    }
    return supportedVersions.some((supportedVersion) => {
      return (0, semver_1.satisfies)(version, supportedVersion, { includePrerelease });
    });
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js
var require_normalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = undefined;
  var path_1 = __require("path");
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return path_1.normalize;
  } });
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js
var require_node9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var instrumentation_1 = require_instrumentation2();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return instrumentation_1.InstrumentationBase;
  } });
  var normalize_1 = require_normalize();
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return normalize_1.normalize;
  } });
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/index.js
var require_platform8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var node_1 = require_node9();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return node_1.InstrumentationBase;
  } });
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return node_1.normalize;
  } });
});

// node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js
var require_instrumentationNodeModuleDefinition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleDefinition = undefined;

  class InstrumentationNodeModuleDefinition {
    name;
    supportedVersions;
    patch;
    unpatch;
    files;
    constructor(name, supportedVersions, patch, unpatch, files2) {
      this.name = name;
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.files = files2 || [];
    }
  }
  exports.InstrumentationNodeModuleDefinition = InstrumentationNodeModuleDefinition;
});

// node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js
var require_instrumentationNodeModuleFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleFile = undefined;
  var index_1 = require_platform8();

  class InstrumentationNodeModuleFile {
    supportedVersions;
    patch;
    unpatch;
    name;
    constructor(name, supportedVersions, patch, unpatch) {
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.name = (0, index_1.normalize)(name);
    }
  }
  exports.InstrumentationNodeModuleFile = InstrumentationNodeModuleFile;
});

// node_modules/@opentelemetry/instrumentation/build/src/semconvStability.js
var require_semconvStability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.semconvStabilityFromStr = exports.SemconvStability = undefined;
  var SemconvStability;
  (function(SemconvStability2) {
    SemconvStability2[SemconvStability2["STABLE"] = 1] = "STABLE";
    SemconvStability2[SemconvStability2["OLD"] = 2] = "OLD";
    SemconvStability2[SemconvStability2["DUPLICATE"] = 3] = "DUPLICATE";
  })(SemconvStability = exports.SemconvStability || (exports.SemconvStability = {}));
  function semconvStabilityFromStr(namespace, str) {
    let semconvStability = SemconvStability.OLD;
    const entries = str?.split(",").map((v) => v.trim()).filter((s) => s !== "");
    for (const entry of entries ?? []) {
      if (entry.toLowerCase() === namespace + "/dup") {
        semconvStability = SemconvStability.DUPLICATE;
        break;
      } else if (entry.toLowerCase() === namespace) {
        semconvStability = SemconvStability.STABLE;
      }
    }
    return semconvStability;
  }
  exports.semconvStabilityFromStr = semconvStabilityFromStr;
});

// node_modules/@opentelemetry/instrumentation/build/src/index.js
var require_src12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.semconvStabilityFromStr = exports.SemconvStability = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = exports.isWrapped = exports.InstrumentationNodeModuleFile = exports.InstrumentationNodeModuleDefinition = exports.InstrumentationBase = exports.registerInstrumentations = undefined;
  var autoLoader_1 = require_autoLoader();
  Object.defineProperty(exports, "registerInstrumentations", { enumerable: true, get: function() {
    return autoLoader_1.registerInstrumentations;
  } });
  var index_1 = require_platform8();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return index_1.InstrumentationBase;
  } });
  var instrumentationNodeModuleDefinition_1 = require_instrumentationNodeModuleDefinition();
  Object.defineProperty(exports, "InstrumentationNodeModuleDefinition", { enumerable: true, get: function() {
    return instrumentationNodeModuleDefinition_1.InstrumentationNodeModuleDefinition;
  } });
  var instrumentationNodeModuleFile_1 = require_instrumentationNodeModuleFile();
  Object.defineProperty(exports, "InstrumentationNodeModuleFile", { enumerable: true, get: function() {
    return instrumentationNodeModuleFile_1.InstrumentationNodeModuleFile;
  } });
  var utils_1 = require_utils8();
  Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
    return utils_1.isWrapped;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddle", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddle;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddleAsync", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddleAsync;
  } });
  var semconvStability_1 = require_semconvStability();
  Object.defineProperty(exports, "SemconvStability", { enumerable: true, get: function() {
    return semconvStability_1.SemconvStability;
  } });
  Object.defineProperty(exports, "semconvStabilityFromStr", { enumerable: true, get: function() {
    return semconvStability_1.semconvStabilityFromStr;
  } });
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/OTLPExporterBase.js
var require_OTLPExporterBase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPExporterBase = undefined;

  class OTLPExporterBase {
    _delegate;
    constructor(_delegate) {
      this._delegate = _delegate;
    }
    export(items, resultCallback) {
      this._delegate.export(items, resultCallback);
    }
    forceFlush() {
      return this._delegate.forceFlush();
    }
    shutdown() {
      return this._delegate.shutdown();
    }
  }
  exports.OTLPExporterBase = OTLPExporterBase;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/types.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPExporterError = undefined;

  class OTLPExporterError extends Error {
    code;
    name = "OTLPExporterError";
    data;
    constructor(message, code, data) {
      super(message);
      this.data = data;
      this.code = code;
    }
  }
  exports.OTLPExporterError = OTLPExporterError;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/configuration/shared-configuration.js
var require_shared_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSharedConfigurationDefaults = exports.mergeOtlpSharedConfigurationWithDefaults = exports.wrapStaticHeadersInFunction = exports.validateTimeoutMillis = undefined;
  function validateTimeoutMillis(timeoutMillis) {
    if (Number.isFinite(timeoutMillis) && timeoutMillis > 0) {
      return timeoutMillis;
    }
    throw new Error(`Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '${timeoutMillis}')`);
  }
  exports.validateTimeoutMillis = validateTimeoutMillis;
  function wrapStaticHeadersInFunction(headers) {
    if (headers == null) {
      return;
    }
    return () => headers;
  }
  exports.wrapStaticHeadersInFunction = wrapStaticHeadersInFunction;
  function mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
    return {
      timeoutMillis: validateTimeoutMillis(userProvidedConfiguration.timeoutMillis ?? fallbackConfiguration.timeoutMillis ?? defaultConfiguration.timeoutMillis),
      concurrencyLimit: userProvidedConfiguration.concurrencyLimit ?? fallbackConfiguration.concurrencyLimit ?? defaultConfiguration.concurrencyLimit,
      compression: userProvidedConfiguration.compression ?? fallbackConfiguration.compression ?? defaultConfiguration.compression
    };
  }
  exports.mergeOtlpSharedConfigurationWithDefaults = mergeOtlpSharedConfigurationWithDefaults;
  function getSharedConfigurationDefaults() {
    return {
      timeoutMillis: 1e4,
      concurrencyLimit: 30,
      compression: "none"
    };
  }
  exports.getSharedConfigurationDefaults = getSharedConfigurationDefaults;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/configuration/legacy-node-configuration.js
var require_legacy_node_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompressionAlgorithm = undefined;
  var CompressionAlgorithm;
  (function(CompressionAlgorithm2) {
    CompressionAlgorithm2["NONE"] = "none";
    CompressionAlgorithm2["GZIP"] = "gzip";
  })(CompressionAlgorithm = exports.CompressionAlgorithm || (exports.CompressionAlgorithm = {}));
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/bounded-queue-export-promise-handler.js
var require_bounded_queue_export_promise_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createBoundedQueueExportPromiseHandler = undefined;

  class BoundedQueueExportPromiseHandler {
    _concurrencyLimit;
    _sendingPromises = [];
    constructor(concurrencyLimit) {
      this._concurrencyLimit = concurrencyLimit;
    }
    pushPromise(promise) {
      if (this.hasReachedLimit()) {
        throw new Error("Concurrency Limit reached");
      }
      this._sendingPromises.push(promise);
      const popPromise = () => {
        const index = this._sendingPromises.indexOf(promise);
        this._sendingPromises.splice(index, 1);
      };
      promise.then(popPromise, popPromise);
    }
    hasReachedLimit() {
      return this._sendingPromises.length >= this._concurrencyLimit;
    }
    async awaitAll() {
      await Promise.all(this._sendingPromises);
    }
  }
  function createBoundedQueueExportPromiseHandler(options) {
    return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);
  }
  exports.createBoundedQueueExportPromiseHandler = createBoundedQueueExportPromiseHandler;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/logging-response-handler.js
var require_logging_response_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLoggingPartialSuccessResponseHandler = undefined;
  var api_1 = require_src();
  function isPartialSuccessResponse(response) {
    return Object.prototype.hasOwnProperty.call(response, "partialSuccess");
  }
  function createLoggingPartialSuccessResponseHandler() {
    return {
      handleResponse(response) {
        if (response == null || !isPartialSuccessResponse(response) || response.partialSuccess == null || Object.keys(response.partialSuccess).length === 0) {
          return;
        }
        api_1.diag.warn("Received Partial Success response:", JSON.stringify(response.partialSuccess));
      }
    };
  }
  exports.createLoggingPartialSuccessResponseHandler = createLoggingPartialSuccessResponseHandler;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/otlp-export-delegate.js
var require_otlp_export_delegate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createOtlpExportDelegate = undefined;
  var core_1 = require_src3();
  var types_1 = require_types4();
  var logging_response_handler_1 = require_logging_response_handler();
  var api_1 = require_src();

  class OTLPExportDelegate {
    _transport;
    _serializer;
    _responseHandler;
    _promiseQueue;
    _timeout;
    _diagLogger;
    constructor(_transport, _serializer, _responseHandler, _promiseQueue, _timeout) {
      this._transport = _transport;
      this._serializer = _serializer;
      this._responseHandler = _responseHandler;
      this._promiseQueue = _promiseQueue;
      this._timeout = _timeout;
      this._diagLogger = api_1.diag.createComponentLogger({
        namespace: "OTLPExportDelegate"
      });
    }
    export(internalRepresentation, resultCallback) {
      this._diagLogger.debug("items to be sent", internalRepresentation);
      if (this._promiseQueue.hasReachedLimit()) {
        resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Concurrent export limit reached")
        });
        return;
      }
      const serializedRequest = this._serializer.serializeRequest(internalRepresentation);
      if (serializedRequest == null) {
        resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Nothing to send")
        });
        return;
      }
      this._promiseQueue.pushPromise(this._transport.send(serializedRequest, this._timeout).then((response) => {
        if (response.status === "success") {
          if (response.data != null) {
            try {
              this._responseHandler.handleResponse(this._serializer.deserializeResponse(response.data));
            } catch (e) {
              this._diagLogger.warn("Export succeeded but could not deserialize response - is the response specification compliant?", e, response.data);
            }
          }
          resultCallback({
            code: core_1.ExportResultCode.SUCCESS
          });
          return;
        } else if (response.status === "failure" && response.error) {
          resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: response.error
          });
          return;
        } else if (response.status === "retryable") {
          resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new types_1.OTLPExporterError("Export failed with retryable status")
          });
        } else {
          resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new types_1.OTLPExporterError("Export failed with unknown error")
          });
        }
      }, (reason) => resultCallback({
        code: core_1.ExportResultCode.FAILED,
        error: reason
      })));
    }
    forceFlush() {
      return this._promiseQueue.awaitAll();
    }
    async shutdown() {
      this._diagLogger.debug("shutdown started");
      await this.forceFlush();
      this._transport.shutdown();
    }
  }
  function createOtlpExportDelegate(components, settings) {
    return new OTLPExportDelegate(components.transport, components.serializer, (0, logging_response_handler_1.createLoggingPartialSuccessResponseHandler)(), components.promiseHandler, settings.timeout);
  }
  exports.createOtlpExportDelegate = createOtlpExportDelegate;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/otlp-network-export-delegate.js
var require_otlp_network_export_delegate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createOtlpNetworkExportDelegate = undefined;
  var bounded_queue_export_promise_handler_1 = require_bounded_queue_export_promise_handler();
  var otlp_export_delegate_1 = require_otlp_export_delegate();
  function createOtlpNetworkExportDelegate(options, serializer, transport) {
    return (0, otlp_export_delegate_1.createOtlpExportDelegate)({
      transport,
      serializer,
      promiseHandler: (0, bounded_queue_export_promise_handler_1.createBoundedQueueExportPromiseHandler)(options)
    }, { timeout: options.timeoutMillis });
  }
  exports.createOtlpNetworkExportDelegate = createOtlpNetworkExportDelegate;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/index.js
var require_src13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createOtlpNetworkExportDelegate = exports.CompressionAlgorithm = exports.getSharedConfigurationDefaults = exports.mergeOtlpSharedConfigurationWithDefaults = exports.OTLPExporterError = exports.OTLPExporterBase = undefined;
  var OTLPExporterBase_1 = require_OTLPExporterBase();
  Object.defineProperty(exports, "OTLPExporterBase", { enumerable: true, get: function() {
    return OTLPExporterBase_1.OTLPExporterBase;
  } });
  var types_1 = require_types4();
  Object.defineProperty(exports, "OTLPExporterError", { enumerable: true, get: function() {
    return types_1.OTLPExporterError;
  } });
  var shared_configuration_1 = require_shared_configuration();
  Object.defineProperty(exports, "mergeOtlpSharedConfigurationWithDefaults", { enumerable: true, get: function() {
    return shared_configuration_1.mergeOtlpSharedConfigurationWithDefaults;
  } });
  Object.defineProperty(exports, "getSharedConfigurationDefaults", { enumerable: true, get: function() {
    return shared_configuration_1.getSharedConfigurationDefaults;
  } });
  var legacy_node_configuration_1 = require_legacy_node_configuration();
  Object.defineProperty(exports, "CompressionAlgorithm", { enumerable: true, get: function() {
    return legacy_node_configuration_1.CompressionAlgorithm;
  } });
  var otlp_network_export_delegate_1 = require_otlp_network_export_delegate();
  Object.defineProperty(exports, "createOtlpNetworkExportDelegate", { enumerable: true, get: function() {
    return otlp_network_export_delegate_1.createOtlpNetworkExportDelegate;
  } });
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS((exports, module) => {
  module.exports = asPromise;
  function asPromise(fn, ctx) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while (index < arguments.length)
      params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
      params[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params2 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params2.length)
              params2[offset2++] = arguments[offset2];
            resolve.apply(null, params2);
          }
        }
      };
      try {
        fn.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS((exports) => {
  var base64 = exports;
  base64.length = function length(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n;
    return Math.ceil(string.length * 3) / 4 - n;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (i = 0;i < 64; )
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
  var i;
  base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i2 = 0, j = 0, t;
    while (start < end) {
      var b = buffer[start++];
      switch (j) {
        case 0:
          chunk[i2++] = b64[b >> 2];
          t = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i2++] = b64[t | b >> 4];
          t = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i2++] = b64[t | b >> 6];
          chunk[i2++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (j) {
      chunk[i2++] = b64[t];
      chunk[i2++] = 61;
      if (j === 1)
        chunk[i2++] = 61;
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  var invalidEncoding = "invalid encoding";
  base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t;
    for (var i2 = 0;i2 < string.length; ) {
      var c = string.charCodeAt(i2++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS((exports, module) => {
  module.exports = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
      this._listeners = {};
    else {
      if (fn === undefined)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i = 0;i < listeners.length; )
          if (listeners[i].fn === fn)
            listeners.splice(i, 1);
          else
            ++i;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i = 1;
      for (;i < arguments.length; )
        args.push(arguments[i++]);
      for (i = 0;i < listeners.length; )
        listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
  };
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS((exports, module) => {
  module.exports = factory(factory);
  function factory(exports2) {
    if (typeof Float32Array !== "undefined")
      (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports2.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports2.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports2.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports2.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
    else
      (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 340282346638528860000000000000000000000)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 0.000000000000000000000000000000000000011754943508222875)
            writeUint((sign << 31 | Math.round(val / 0.000000000000000000000000000000000000000000001401298464324817)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 0.000000000000000000000000000000000000000000001401298464324817 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
    if (typeof Float64Array !== "undefined")
      (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports2.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports2.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports2.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports2.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
    else
      (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014) {
              mantissa = val / 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
    return exports2;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS((exports, module) => {
  module.exports = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {
    }
    return null;
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS((exports) => {
  var utf8 = exports;
  utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for (var i = 0;i < string.length; ++i) {
      c = string.charCodeAt(i);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i = 0, t;
    while (start < end) {
      t = buffer[start++];
      if (t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else
        chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
      if (i > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i = 0;
      }
    }
    if (parts) {
      if (i)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
  };
  utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2;
    for (var i = 0;i < string.length; ++i) {
      c1 = string.charCodeAt(i);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS((exports, module) => {
  module.exports = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS((exports, module) => {
  module.exports = LongBits;
  var util = require_minimal();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\x00\x00\x00\x00\x00\x00\x00\x00";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util.isString(value)) {
      if (util.Long)
        value = util.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
      return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS((exports) => {
  var util = exports;
  util.asPromise = require_aspromise();
  util.base64 = require_base64();
  util.EventEmitter = require_eventemitter();
  util.float = require_float();
  util.inquire = require_inquire();
  util.utf8 = require_utf8();
  util.pool = require_pool();
  util.LongBits = require_longbits();
  util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
  util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports;
  util.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };
  util.isObject = function isObject(value) {
    return value && typeof value === "object";
  };
  util.isset = util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util.Buffer = function() {
    try {
      var Buffer2 = util.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e) {
      return null;
    }
  }();
  util._Buffer_from = null;
  util._Buffer_allocUnsafe = null;
  util.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
  util.key2Re = /^true|false|0|1$/;
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
  };
  util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
      return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0;i < keys.length; ++i)
      if (dst[keys[i]] === undefined || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  util.merge = merge;
  util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name) {
    function CustomError(message, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message, properties);
      Object.defineProperty(this, "message", { get: function() {
        return message;
      } });
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", { value: new Error().stack || "" });
      if (properties)
        merge(this, properties);
    }
    CustomError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: CustomError,
        writable: true,
        enumerable: false,
        configurable: true
      },
      name: {
        get: function get() {
          return name;
        },
        set: undefined,
        enumerable: false,
        configurable: true
      },
      toString: {
        value: function value() {
          return this.name + ": " + this.message;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    return CustomError;
  }
  util.newError = newError;
  util.ProtocolError = newError("ProtocolError");
  util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0;i < fieldNames.length; ++i)
      fieldMap[fieldNames[i]] = 1;
    return function() {
      for (var keys = Object.keys(this), i2 = keys.length - 1;i2 > -1; --i2)
        if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== undefined && this[keys[i2]] !== null)
          return keys[i2];
    };
  };
  util.oneOfSetter = function setOneOf(fieldNames) {
    return function(name) {
      for (var i = 0;i < fieldNames.length; ++i)
        if (fieldNames[i] !== name)
          delete this[fieldNames[i]];
    };
  };
  util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util._configure = function() {
    var Buffer2 = util.Buffer;
    if (!Buffer2) {
      util._Buffer_from = util._Buffer_allocUnsafe = null;
      return;
    }
    util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS((exports, module) => {
  module.exports = Writer;
  var util = require_minimal();
  var BufferWriter;
  var LongBits = util.LongBits;
  var base64 = util.base64;
  var utf8 = util.utf8;
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  function noop() {
  }
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create = function create() {
    return util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter;
      })();
    } : function create_array() {
      return new Writer;
    };
  };
  Writer.create = create();
  Writer.alloc = function alloc(size) {
    return new util.Array(size);
  };
  if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0;i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
  };
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS((exports, module) => {
  module.exports = BufferWriter;
  var Writer = require_writer();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util = require_minimal();
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0;i < val.length; )
          buf[pos++] = val[i++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
      value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
  BufferWriter._configure();
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS((exports, module) => {
  module.exports = Reader;
  var util = require_minimal();
  var BufferReader;
  var LongBits = util.LongBits;
  var utf8 = util.utf8;
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  } : function create_array(buffer) {
    if (Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  };
  var create = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
  };
  Reader.create = create();
  Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
  Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (;i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (;i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (;i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (;i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    if (start === end) {
      var nativeBuffer = util.Buffer;
      return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : "toNumber";
    util.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS((exports, module) => {
  module.exports = BufferReader;
  var Reader = require_reader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util = require_minimal();
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }
  BufferReader._configure = function() {
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS((exports, module) => {
  module.exports = Service;
  var util = require_minimal();
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
    if (!request2)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return;
    }
    try {
      return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(), function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      });
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS((exports) => {
  var rpc = exports;
  rpc.Service = require_service();
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS((exports, module) => {
  module.exports = {};
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS((exports) => {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = require_writer();
  protobuf.BufferWriter = require_writer_buffer();
  protobuf.Reader = require_reader();
  protobuf.BufferReader = require_reader_buffer();
  protobuf.util = require_minimal();
  protobuf.rpc = require_rpc();
  protobuf.roots = require_roots();
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
});

// node_modules/@opentelemetry/otlp-transformer/build/src/generated/root.js
var require_root = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var $protobuf = require_index_minimal();
  var $Reader = $protobuf.Reader;
  var $Writer = $protobuf.Writer;
  var $util = $protobuf.util;
  var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
  $root.opentelemetry = function() {
    var opentelemetry = {};
    opentelemetry.proto = function() {
      var proto = {};
      proto.common = function() {
        var common = {};
        common.v1 = function() {
          var v1 = {};
          v1.AnyValue = function() {
            function AnyValue(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            AnyValue.prototype.stringValue = null;
            AnyValue.prototype.boolValue = null;
            AnyValue.prototype.intValue = null;
            AnyValue.prototype.doubleValue = null;
            AnyValue.prototype.arrayValue = null;
            AnyValue.prototype.kvlistValue = null;
            AnyValue.prototype.bytesValue = null;
            var $oneOfFields;
            Object.defineProperty(AnyValue.prototype, "value", {
              get: $util.oneOfGetter($oneOfFields = ["stringValue", "boolValue", "intValue", "doubleValue", "arrayValue", "kvlistValue", "bytesValue"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            AnyValue.create = function create(properties) {
              return new AnyValue(properties);
            };
            AnyValue.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                writer.uint32(10).string(message.stringValue);
              if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                writer.uint32(16).bool(message.boolValue);
              if (message.intValue != null && Object.hasOwnProperty.call(message, "intValue"))
                writer.uint32(24).int64(message.intValue);
              if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                writer.uint32(33).double(message.doubleValue);
              if (message.arrayValue != null && Object.hasOwnProperty.call(message, "arrayValue"))
                $root.opentelemetry.proto.common.v1.ArrayValue.encode(message.arrayValue, writer.uint32(42).fork()).ldelim();
              if (message.kvlistValue != null && Object.hasOwnProperty.call(message, "kvlistValue"))
                $root.opentelemetry.proto.common.v1.KeyValueList.encode(message.kvlistValue, writer.uint32(50).fork()).ldelim();
              if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
                writer.uint32(58).bytes(message.bytesValue);
              return writer;
            };
            AnyValue.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            AnyValue.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.AnyValue;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.stringValue = reader.string();
                    break;
                  }
                  case 2: {
                    message.boolValue = reader.bool();
                    break;
                  }
                  case 3: {
                    message.intValue = reader.int64();
                    break;
                  }
                  case 4: {
                    message.doubleValue = reader.double();
                    break;
                  }
                  case 5: {
                    message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.decode(reader, reader.uint32());
                    break;
                  }
                  case 6: {
                    message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.decode(reader, reader.uint32());
                    break;
                  }
                  case 7: {
                    message.bytesValue = reader.bytes();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            AnyValue.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            AnyValue.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                properties.value = 1;
                if (!$util.isString(message.stringValue))
                  return "stringValue: string expected";
              }
              if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (typeof message.boolValue !== "boolean")
                  return "boolValue: boolean expected";
              }
              if (message.intValue != null && message.hasOwnProperty("intValue")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))
                  return "intValue: integer|Long expected";
              }
              if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (typeof message.doubleValue !== "number")
                  return "doubleValue: number expected";
              }
              if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                {
                  var error = $root.opentelemetry.proto.common.v1.ArrayValue.verify(message.arrayValue);
                  if (error)
                    return "arrayValue." + error;
                }
              }
              if (message.kvlistValue != null && message.hasOwnProperty("kvlistValue")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                {
                  var error = $root.opentelemetry.proto.common.v1.KeyValueList.verify(message.kvlistValue);
                  if (error)
                    return "kvlistValue." + error;
                }
              }
              if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                  return "bytesValue: buffer expected";
              }
              return null;
            };
            AnyValue.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.common.v1.AnyValue)
                return object;
              var message = new $root.opentelemetry.proto.common.v1.AnyValue;
              if (object.stringValue != null)
                message.stringValue = String(object.stringValue);
              if (object.boolValue != null)
                message.boolValue = Boolean(object.boolValue);
              if (object.intValue != null) {
                if ($util.Long)
                  (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;
                else if (typeof object.intValue === "string")
                  message.intValue = parseInt(object.intValue, 10);
                else if (typeof object.intValue === "number")
                  message.intValue = object.intValue;
                else if (typeof object.intValue === "object")
                  message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();
              }
              if (object.doubleValue != null)
                message.doubleValue = Number(object.doubleValue);
              if (object.arrayValue != null) {
                if (typeof object.arrayValue !== "object")
                  throw TypeError(".opentelemetry.proto.common.v1.AnyValue.arrayValue: object expected");
                message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.fromObject(object.arrayValue);
              }
              if (object.kvlistValue != null) {
                if (typeof object.kvlistValue !== "object")
                  throw TypeError(".opentelemetry.proto.common.v1.AnyValue.kvlistValue: object expected");
                message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.fromObject(object.kvlistValue);
              }
              if (object.bytesValue != null) {
                if (typeof object.bytesValue === "string")
                  $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                else if (object.bytesValue.length >= 0)
                  message.bytesValue = object.bytesValue;
              }
              return message;
            };
            AnyValue.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                object.stringValue = message.stringValue;
                if (options.oneofs)
                  object.value = "stringValue";
              }
              if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                object.boolValue = message.boolValue;
                if (options.oneofs)
                  object.value = "boolValue";
              }
              if (message.intValue != null && message.hasOwnProperty("intValue")) {
                if (typeof message.intValue === "number")
                  object.intValue = options.longs === String ? String(message.intValue) : message.intValue;
                else
                  object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;
                if (options.oneofs)
                  object.value = "intValue";
              }
              if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (options.oneofs)
                  object.value = "doubleValue";
              }
              if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                object.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.toObject(message.arrayValue, options);
                if (options.oneofs)
                  object.value = "arrayValue";
              }
              if (message.kvlistValue != null && message.hasOwnProperty("kvlistValue")) {
                object.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.toObject(message.kvlistValue, options);
                if (options.oneofs)
                  object.value = "kvlistValue";
              }
              if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                if (options.oneofs)
                  object.value = "bytesValue";
              }
              return object;
            };
            AnyValue.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            AnyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.common.v1.AnyValue";
            };
            return AnyValue;
          }();
          v1.ArrayValue = function() {
            function ArrayValue(properties) {
              this.values = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ArrayValue.prototype.values = $util.emptyArray;
            ArrayValue.create = function create(properties) {
              return new ArrayValue(properties);
            };
            ArrayValue.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.values != null && message.values.length)
                for (var i = 0;i < message.values.length; ++i)
                  $root.opentelemetry.proto.common.v1.AnyValue.encode(message.values[i], writer.uint32(10).fork()).ldelim();
              return writer;
            };
            ArrayValue.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ArrayValue.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.ArrayValue;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.values && message.values.length))
                      message.values = [];
                    message.values.push($root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ArrayValue.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ArrayValue.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.values != null && message.hasOwnProperty("values")) {
                if (!Array.isArray(message.values))
                  return "values: array expected";
                for (var i = 0;i < message.values.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.values[i]);
                  if (error)
                    return "values." + error;
                }
              }
              return null;
            };
            ArrayValue.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.common.v1.ArrayValue)
                return object;
              var message = new $root.opentelemetry.proto.common.v1.ArrayValue;
              if (object.values) {
                if (!Array.isArray(object.values))
                  throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: array expected");
                message.values = [];
                for (var i = 0;i < object.values.length; ++i) {
                  if (typeof object.values[i] !== "object")
                    throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: object expected");
                  message.values[i] = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.values[i]);
                }
              }
              return message;
            };
            ArrayValue.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.values = [];
              if (message.values && message.values.length) {
                object.values = [];
                for (var j = 0;j < message.values.length; ++j)
                  object.values[j] = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.values[j], options);
              }
              return object;
            };
            ArrayValue.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ArrayValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.common.v1.ArrayValue";
            };
            return ArrayValue;
          }();
          v1.KeyValueList = function() {
            function KeyValueList(properties) {
              this.values = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            KeyValueList.prototype.values = $util.emptyArray;
            KeyValueList.create = function create(properties) {
              return new KeyValueList(properties);
            };
            KeyValueList.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.values != null && message.values.length)
                for (var i = 0;i < message.values.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.values[i], writer.uint32(10).fork()).ldelim();
              return writer;
            };
            KeyValueList.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            KeyValueList.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValueList;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.values && message.values.length))
                      message.values = [];
                    message.values.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            KeyValueList.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            KeyValueList.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.values != null && message.hasOwnProperty("values")) {
                if (!Array.isArray(message.values))
                  return "values: array expected";
                for (var i = 0;i < message.values.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.values[i]);
                  if (error)
                    return "values." + error;
                }
              }
              return null;
            };
            KeyValueList.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.common.v1.KeyValueList)
                return object;
              var message = new $root.opentelemetry.proto.common.v1.KeyValueList;
              if (object.values) {
                if (!Array.isArray(object.values))
                  throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: array expected");
                message.values = [];
                for (var i = 0;i < object.values.length; ++i) {
                  if (typeof object.values[i] !== "object")
                    throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: object expected");
                  message.values[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.values[i]);
                }
              }
              return message;
            };
            KeyValueList.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.values = [];
              if (message.values && message.values.length) {
                object.values = [];
                for (var j = 0;j < message.values.length; ++j)
                  object.values[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.values[j], options);
              }
              return object;
            };
            KeyValueList.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            KeyValueList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValueList";
            };
            return KeyValueList;
          }();
          v1.KeyValue = function() {
            function KeyValue(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            KeyValue.prototype.key = null;
            KeyValue.prototype.value = null;
            KeyValue.create = function create(properties) {
              return new KeyValue(properties);
            };
            KeyValue.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(10).string(message.key);
              if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                $root.opentelemetry.proto.common.v1.AnyValue.encode(message.value, writer.uint32(18).fork()).ldelim();
              return writer;
            };
            KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            KeyValue.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValue;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.key = reader.string();
                    break;
                  }
                  case 2: {
                    message.value = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            KeyValue.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            KeyValue.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.key != null && message.hasOwnProperty("key")) {
                if (!$util.isString(message.key))
                  return "key: string expected";
              }
              if (message.value != null && message.hasOwnProperty("value")) {
                var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.value);
                if (error)
                  return "value." + error;
              }
              return null;
            };
            KeyValue.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.common.v1.KeyValue)
                return object;
              var message = new $root.opentelemetry.proto.common.v1.KeyValue;
              if (object.key != null)
                message.key = String(object.key);
              if (object.value != null) {
                if (typeof object.value !== "object")
                  throw TypeError(".opentelemetry.proto.common.v1.KeyValue.value: object expected");
                message.value = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.value);
              }
              return message;
            };
            KeyValue.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.key = "";
                object.value = null;
              }
              if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
              if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.value, options);
              return object;
            };
            KeyValue.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            KeyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValue";
            };
            return KeyValue;
          }();
          v1.InstrumentationScope = function() {
            function InstrumentationScope(properties) {
              this.attributes = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            InstrumentationScope.prototype.name = null;
            InstrumentationScope.prototype.version = null;
            InstrumentationScope.prototype.attributes = $util.emptyArray;
            InstrumentationScope.prototype.droppedAttributesCount = null;
            InstrumentationScope.create = function create(properties) {
              return new InstrumentationScope(properties);
            };
            InstrumentationScope.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(10).string(message.name);
              if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(18).string(message.version);
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(26).fork()).ldelim();
              if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                writer.uint32(32).uint32(message.droppedAttributesCount);
              return writer;
            };
            InstrumentationScope.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            InstrumentationScope.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.InstrumentationScope;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.name = reader.string();
                    break;
                  }
                  case 2: {
                    message.version = reader.string();
                    break;
                  }
                  case 3: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 4: {
                    message.droppedAttributesCount = reader.uint32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            InstrumentationScope.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            InstrumentationScope.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.name != null && message.hasOwnProperty("name")) {
                if (!$util.isString(message.name))
                  return "name: string expected";
              }
              if (message.version != null && message.hasOwnProperty("version")) {
                if (!$util.isString(message.version))
                  return "version: string expected";
              }
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                if (!$util.isInteger(message.droppedAttributesCount))
                  return "droppedAttributesCount: integer expected";
              }
              return null;
            };
            InstrumentationScope.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.common.v1.InstrumentationScope)
                return object;
              var message = new $root.opentelemetry.proto.common.v1.InstrumentationScope;
              if (object.name != null)
                message.name = String(object.name);
              if (object.version != null)
                message.version = String(object.version);
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.droppedAttributesCount != null)
                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
              return message;
            };
            InstrumentationScope.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.attributes = [];
              if (options.defaults) {
                object.name = "";
                object.version = "";
                object.droppedAttributesCount = 0;
              }
              if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
              if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                object.droppedAttributesCount = message.droppedAttributesCount;
              return object;
            };
            InstrumentationScope.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            InstrumentationScope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.common.v1.InstrumentationScope";
            };
            return InstrumentationScope;
          }();
          v1.EntityRef = function() {
            function EntityRef(properties) {
              this.idKeys = [];
              this.descriptionKeys = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            EntityRef.prototype.schemaUrl = null;
            EntityRef.prototype.type = null;
            EntityRef.prototype.idKeys = $util.emptyArray;
            EntityRef.prototype.descriptionKeys = $util.emptyArray;
            EntityRef.create = function create(properties) {
              return new EntityRef(properties);
            };
            EntityRef.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                writer.uint32(10).string(message.schemaUrl);
              if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(18).string(message.type);
              if (message.idKeys != null && message.idKeys.length)
                for (var i = 0;i < message.idKeys.length; ++i)
                  writer.uint32(26).string(message.idKeys[i]);
              if (message.descriptionKeys != null && message.descriptionKeys.length)
                for (var i = 0;i < message.descriptionKeys.length; ++i)
                  writer.uint32(34).string(message.descriptionKeys[i]);
              return writer;
            };
            EntityRef.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            EntityRef.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.EntityRef;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.schemaUrl = reader.string();
                    break;
                  }
                  case 2: {
                    message.type = reader.string();
                    break;
                  }
                  case 3: {
                    if (!(message.idKeys && message.idKeys.length))
                      message.idKeys = [];
                    message.idKeys.push(reader.string());
                    break;
                  }
                  case 4: {
                    if (!(message.descriptionKeys && message.descriptionKeys.length))
                      message.descriptionKeys = [];
                    message.descriptionKeys.push(reader.string());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            EntityRef.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            EntityRef.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                if (!$util.isString(message.schemaUrl))
                  return "schemaUrl: string expected";
              }
              if (message.type != null && message.hasOwnProperty("type")) {
                if (!$util.isString(message.type))
                  return "type: string expected";
              }
              if (message.idKeys != null && message.hasOwnProperty("idKeys")) {
                if (!Array.isArray(message.idKeys))
                  return "idKeys: array expected";
                for (var i = 0;i < message.idKeys.length; ++i)
                  if (!$util.isString(message.idKeys[i]))
                    return "idKeys: string[] expected";
              }
              if (message.descriptionKeys != null && message.hasOwnProperty("descriptionKeys")) {
                if (!Array.isArray(message.descriptionKeys))
                  return "descriptionKeys: array expected";
                for (var i = 0;i < message.descriptionKeys.length; ++i)
                  if (!$util.isString(message.descriptionKeys[i]))
                    return "descriptionKeys: string[] expected";
              }
              return null;
            };
            EntityRef.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.common.v1.EntityRef)
                return object;
              var message = new $root.opentelemetry.proto.common.v1.EntityRef;
              if (object.schemaUrl != null)
                message.schemaUrl = String(object.schemaUrl);
              if (object.type != null)
                message.type = String(object.type);
              if (object.idKeys) {
                if (!Array.isArray(object.idKeys))
                  throw TypeError(".opentelemetry.proto.common.v1.EntityRef.idKeys: array expected");
                message.idKeys = [];
                for (var i = 0;i < object.idKeys.length; ++i)
                  message.idKeys[i] = String(object.idKeys[i]);
              }
              if (object.descriptionKeys) {
                if (!Array.isArray(object.descriptionKeys))
                  throw TypeError(".opentelemetry.proto.common.v1.EntityRef.descriptionKeys: array expected");
                message.descriptionKeys = [];
                for (var i = 0;i < object.descriptionKeys.length; ++i)
                  message.descriptionKeys[i] = String(object.descriptionKeys[i]);
              }
              return message;
            };
            EntityRef.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                object.idKeys = [];
                object.descriptionKeys = [];
              }
              if (options.defaults) {
                object.schemaUrl = "";
                object.type = "";
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                object.schemaUrl = message.schemaUrl;
              if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
              if (message.idKeys && message.idKeys.length) {
                object.idKeys = [];
                for (var j = 0;j < message.idKeys.length; ++j)
                  object.idKeys[j] = message.idKeys[j];
              }
              if (message.descriptionKeys && message.descriptionKeys.length) {
                object.descriptionKeys = [];
                for (var j = 0;j < message.descriptionKeys.length; ++j)
                  object.descriptionKeys[j] = message.descriptionKeys[j];
              }
              return object;
            };
            EntityRef.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            EntityRef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.common.v1.EntityRef";
            };
            return EntityRef;
          }();
          return v1;
        }();
        return common;
      }();
      proto.resource = function() {
        var resource = {};
        resource.v1 = function() {
          var v1 = {};
          v1.Resource = function() {
            function Resource(properties) {
              this.attributes = [];
              this.entityRefs = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Resource.prototype.attributes = $util.emptyArray;
            Resource.prototype.droppedAttributesCount = null;
            Resource.prototype.entityRefs = $util.emptyArray;
            Resource.create = function create(properties) {
              return new Resource(properties);
            };
            Resource.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(10).fork()).ldelim();
              if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                writer.uint32(16).uint32(message.droppedAttributesCount);
              if (message.entityRefs != null && message.entityRefs.length)
                for (var i = 0;i < message.entityRefs.length; ++i)
                  $root.opentelemetry.proto.common.v1.EntityRef.encode(message.entityRefs[i], writer.uint32(26).fork()).ldelim();
              return writer;
            };
            Resource.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Resource.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.resource.v1.Resource;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.droppedAttributesCount = reader.uint32();
                    break;
                  }
                  case 3: {
                    if (!(message.entityRefs && message.entityRefs.length))
                      message.entityRefs = [];
                    message.entityRefs.push($root.opentelemetry.proto.common.v1.EntityRef.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Resource.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Resource.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                if (!$util.isInteger(message.droppedAttributesCount))
                  return "droppedAttributesCount: integer expected";
              }
              if (message.entityRefs != null && message.hasOwnProperty("entityRefs")) {
                if (!Array.isArray(message.entityRefs))
                  return "entityRefs: array expected";
                for (var i = 0;i < message.entityRefs.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.EntityRef.verify(message.entityRefs[i]);
                  if (error)
                    return "entityRefs." + error;
                }
              }
              return null;
            };
            Resource.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.resource.v1.Resource)
                return object;
              var message = new $root.opentelemetry.proto.resource.v1.Resource;
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.droppedAttributesCount != null)
                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
              if (object.entityRefs) {
                if (!Array.isArray(object.entityRefs))
                  throw TypeError(".opentelemetry.proto.resource.v1.Resource.entityRefs: array expected");
                message.entityRefs = [];
                for (var i = 0;i < object.entityRefs.length; ++i) {
                  if (typeof object.entityRefs[i] !== "object")
                    throw TypeError(".opentelemetry.proto.resource.v1.Resource.entityRefs: object expected");
                  message.entityRefs[i] = $root.opentelemetry.proto.common.v1.EntityRef.fromObject(object.entityRefs[i]);
                }
              }
              return message;
            };
            Resource.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                object.attributes = [];
                object.entityRefs = [];
              }
              if (options.defaults)
                object.droppedAttributesCount = 0;
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                object.droppedAttributesCount = message.droppedAttributesCount;
              if (message.entityRefs && message.entityRefs.length) {
                object.entityRefs = [];
                for (var j = 0;j < message.entityRefs.length; ++j)
                  object.entityRefs[j] = $root.opentelemetry.proto.common.v1.EntityRef.toObject(message.entityRefs[j], options);
              }
              return object;
            };
            Resource.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Resource.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.resource.v1.Resource";
            };
            return Resource;
          }();
          return v1;
        }();
        return resource;
      }();
      proto.trace = function() {
        var trace = {};
        trace.v1 = function() {
          var v1 = {};
          v1.TracesData = function() {
            function TracesData(properties) {
              this.resourceSpans = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            TracesData.prototype.resourceSpans = $util.emptyArray;
            TracesData.create = function create(properties) {
              return new TracesData(properties);
            };
            TracesData.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.resourceSpans != null && message.resourceSpans.length)
                for (var i = 0;i < message.resourceSpans.length; ++i)
                  $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(10).fork()).ldelim();
              return writer;
            };
            TracesData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            TracesData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.TracesData;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.resourceSpans && message.resourceSpans.length))
                      message.resourceSpans = [];
                    message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            TracesData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            TracesData.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
                if (!Array.isArray(message.resourceSpans))
                  return "resourceSpans: array expected";
                for (var i = 0;i < message.resourceSpans.length; ++i) {
                  var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);
                  if (error)
                    return "resourceSpans." + error;
                }
              }
              return null;
            };
            TracesData.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.trace.v1.TracesData)
                return object;
              var message = new $root.opentelemetry.proto.trace.v1.TracesData;
              if (object.resourceSpans) {
                if (!Array.isArray(object.resourceSpans))
                  throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: array expected");
                message.resourceSpans = [];
                for (var i = 0;i < object.resourceSpans.length; ++i) {
                  if (typeof object.resourceSpans[i] !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: object expected");
                  message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);
                }
              }
              return message;
            };
            TracesData.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.resourceSpans = [];
              if (message.resourceSpans && message.resourceSpans.length) {
                object.resourceSpans = [];
                for (var j = 0;j < message.resourceSpans.length; ++j)
                  object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);
              }
              return object;
            };
            TracesData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            TracesData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.trace.v1.TracesData";
            };
            return TracesData;
          }();
          v1.ResourceSpans = function() {
            function ResourceSpans(properties) {
              this.scopeSpans = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ResourceSpans.prototype.resource = null;
            ResourceSpans.prototype.scopeSpans = $util.emptyArray;
            ResourceSpans.prototype.schemaUrl = null;
            ResourceSpans.create = function create(properties) {
              return new ResourceSpans(properties);
            };
            ResourceSpans.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
              if (message.scopeSpans != null && message.scopeSpans.length)
                for (var i = 0;i < message.scopeSpans.length; ++i)
                  $root.opentelemetry.proto.trace.v1.ScopeSpans.encode(message.scopeSpans[i], writer.uint32(18).fork()).ldelim();
              if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                writer.uint32(26).string(message.schemaUrl);
              return writer;
            };
            ResourceSpans.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ResourceSpans.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ResourceSpans;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                    break;
                  }
                  case 2: {
                    if (!(message.scopeSpans && message.scopeSpans.length))
                      message.scopeSpans = [];
                    message.scopeSpans.push($root.opentelemetry.proto.trace.v1.ScopeSpans.decode(reader, reader.uint32()));
                    break;
                  }
                  case 3: {
                    message.schemaUrl = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ResourceSpans.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ResourceSpans.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                if (error)
                  return "resource." + error;
              }
              if (message.scopeSpans != null && message.hasOwnProperty("scopeSpans")) {
                if (!Array.isArray(message.scopeSpans))
                  return "scopeSpans: array expected";
                for (var i = 0;i < message.scopeSpans.length; ++i) {
                  var error = $root.opentelemetry.proto.trace.v1.ScopeSpans.verify(message.scopeSpans[i]);
                  if (error)
                    return "scopeSpans." + error;
                }
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                if (!$util.isString(message.schemaUrl))
                  return "schemaUrl: string expected";
              }
              return null;
            };
            ResourceSpans.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.trace.v1.ResourceSpans)
                return object;
              var message = new $root.opentelemetry.proto.trace.v1.ResourceSpans;
              if (object.resource != null) {
                if (typeof object.resource !== "object")
                  throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.resource: object expected");
                message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
              }
              if (object.scopeSpans) {
                if (!Array.isArray(object.scopeSpans))
                  throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: array expected");
                message.scopeSpans = [];
                for (var i = 0;i < object.scopeSpans.length; ++i) {
                  if (typeof object.scopeSpans[i] !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: object expected");
                  message.scopeSpans[i] = $root.opentelemetry.proto.trace.v1.ScopeSpans.fromObject(object.scopeSpans[i]);
                }
              }
              if (object.schemaUrl != null)
                message.schemaUrl = String(object.schemaUrl);
              return message;
            };
            ResourceSpans.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.scopeSpans = [];
              if (options.defaults) {
                object.resource = null;
                object.schemaUrl = "";
              }
              if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
              if (message.scopeSpans && message.scopeSpans.length) {
                object.scopeSpans = [];
                for (var j = 0;j < message.scopeSpans.length; ++j)
                  object.scopeSpans[j] = $root.opentelemetry.proto.trace.v1.ScopeSpans.toObject(message.scopeSpans[j], options);
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                object.schemaUrl = message.schemaUrl;
              return object;
            };
            ResourceSpans.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ResourceSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.trace.v1.ResourceSpans";
            };
            return ResourceSpans;
          }();
          v1.ScopeSpans = function() {
            function ScopeSpans(properties) {
              this.spans = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ScopeSpans.prototype.scope = null;
            ScopeSpans.prototype.spans = $util.emptyArray;
            ScopeSpans.prototype.schemaUrl = null;
            ScopeSpans.create = function create(properties) {
              return new ScopeSpans(properties);
            };
            ScopeSpans.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
                $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(10).fork()).ldelim();
              if (message.spans != null && message.spans.length)
                for (var i = 0;i < message.spans.length; ++i)
                  $root.opentelemetry.proto.trace.v1.Span.encode(message.spans[i], writer.uint32(18).fork()).ldelim();
              if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                writer.uint32(26).string(message.schemaUrl);
              return writer;
            };
            ScopeSpans.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ScopeSpans.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ScopeSpans;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                    break;
                  }
                  case 2: {
                    if (!(message.spans && message.spans.length))
                      message.spans = [];
                    message.spans.push($root.opentelemetry.proto.trace.v1.Span.decode(reader, reader.uint32()));
                    break;
                  }
                  case 3: {
                    message.schemaUrl = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ScopeSpans.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ScopeSpans.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.scope != null && message.hasOwnProperty("scope")) {
                var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                if (error)
                  return "scope." + error;
              }
              if (message.spans != null && message.hasOwnProperty("spans")) {
                if (!Array.isArray(message.spans))
                  return "spans: array expected";
                for (var i = 0;i < message.spans.length; ++i) {
                  var error = $root.opentelemetry.proto.trace.v1.Span.verify(message.spans[i]);
                  if (error)
                    return "spans." + error;
                }
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                if (!$util.isString(message.schemaUrl))
                  return "schemaUrl: string expected";
              }
              return null;
            };
            ScopeSpans.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.trace.v1.ScopeSpans)
                return object;
              var message = new $root.opentelemetry.proto.trace.v1.ScopeSpans;
              if (object.scope != null) {
                if (typeof object.scope !== "object")
                  throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.scope: object expected");
                message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
              }
              if (object.spans) {
                if (!Array.isArray(object.spans))
                  throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: array expected");
                message.spans = [];
                for (var i = 0;i < object.spans.length; ++i) {
                  if (typeof object.spans[i] !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: object expected");
                  message.spans[i] = $root.opentelemetry.proto.trace.v1.Span.fromObject(object.spans[i]);
                }
              }
              if (object.schemaUrl != null)
                message.schemaUrl = String(object.schemaUrl);
              return message;
            };
            ScopeSpans.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.spans = [];
              if (options.defaults) {
                object.scope = null;
                object.schemaUrl = "";
              }
              if (message.scope != null && message.hasOwnProperty("scope"))
                object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
              if (message.spans && message.spans.length) {
                object.spans = [];
                for (var j = 0;j < message.spans.length; ++j)
                  object.spans[j] = $root.opentelemetry.proto.trace.v1.Span.toObject(message.spans[j], options);
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                object.schemaUrl = message.schemaUrl;
              return object;
            };
            ScopeSpans.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ScopeSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.trace.v1.ScopeSpans";
            };
            return ScopeSpans;
          }();
          v1.Span = function() {
            function Span(properties) {
              this.attributes = [];
              this.events = [];
              this.links = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Span.prototype.traceId = null;
            Span.prototype.spanId = null;
            Span.prototype.traceState = null;
            Span.prototype.parentSpanId = null;
            Span.prototype.flags = null;
            Span.prototype.name = null;
            Span.prototype.kind = null;
            Span.prototype.startTimeUnixNano = null;
            Span.prototype.endTimeUnixNano = null;
            Span.prototype.attributes = $util.emptyArray;
            Span.prototype.droppedAttributesCount = null;
            Span.prototype.events = $util.emptyArray;
            Span.prototype.droppedEventsCount = null;
            Span.prototype.links = $util.emptyArray;
            Span.prototype.droppedLinksCount = null;
            Span.prototype.status = null;
            Span.create = function create(properties) {
              return new Span(properties);
            };
            Span.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                writer.uint32(10).bytes(message.traceId);
              if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                writer.uint32(18).bytes(message.spanId);
              if (message.traceState != null && Object.hasOwnProperty.call(message, "traceState"))
                writer.uint32(26).string(message.traceState);
              if (message.parentSpanId != null && Object.hasOwnProperty.call(message, "parentSpanId"))
                writer.uint32(34).bytes(message.parentSpanId);
              if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(42).string(message.name);
              if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                writer.uint32(48).int32(message.kind);
              if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                writer.uint32(57).fixed64(message.startTimeUnixNano);
              if (message.endTimeUnixNano != null && Object.hasOwnProperty.call(message, "endTimeUnixNano"))
                writer.uint32(65).fixed64(message.endTimeUnixNano);
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(74).fork()).ldelim();
              if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                writer.uint32(80).uint32(message.droppedAttributesCount);
              if (message.events != null && message.events.length)
                for (var i = 0;i < message.events.length; ++i)
                  $root.opentelemetry.proto.trace.v1.Span.Event.encode(message.events[i], writer.uint32(90).fork()).ldelim();
              if (message.droppedEventsCount != null && Object.hasOwnProperty.call(message, "droppedEventsCount"))
                writer.uint32(96).uint32(message.droppedEventsCount);
              if (message.links != null && message.links.length)
                for (var i = 0;i < message.links.length; ++i)
                  $root.opentelemetry.proto.trace.v1.Span.Link.encode(message.links[i], writer.uint32(106).fork()).ldelim();
              if (message.droppedLinksCount != null && Object.hasOwnProperty.call(message, "droppedLinksCount"))
                writer.uint32(112).uint32(message.droppedLinksCount);
              if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.opentelemetry.proto.trace.v1.Status.encode(message.status, writer.uint32(122).fork()).ldelim();
              if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(133).fixed32(message.flags);
              return writer;
            };
            Span.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Span.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.traceId = reader.bytes();
                    break;
                  }
                  case 2: {
                    message.spanId = reader.bytes();
                    break;
                  }
                  case 3: {
                    message.traceState = reader.string();
                    break;
                  }
                  case 4: {
                    message.parentSpanId = reader.bytes();
                    break;
                  }
                  case 16: {
                    message.flags = reader.fixed32();
                    break;
                  }
                  case 5: {
                    message.name = reader.string();
                    break;
                  }
                  case 6: {
                    message.kind = reader.int32();
                    break;
                  }
                  case 7: {
                    message.startTimeUnixNano = reader.fixed64();
                    break;
                  }
                  case 8: {
                    message.endTimeUnixNano = reader.fixed64();
                    break;
                  }
                  case 9: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 10: {
                    message.droppedAttributesCount = reader.uint32();
                    break;
                  }
                  case 11: {
                    if (!(message.events && message.events.length))
                      message.events = [];
                    message.events.push($root.opentelemetry.proto.trace.v1.Span.Event.decode(reader, reader.uint32()));
                    break;
                  }
                  case 12: {
                    message.droppedEventsCount = reader.uint32();
                    break;
                  }
                  case 13: {
                    if (!(message.links && message.links.length))
                      message.links = [];
                    message.links.push($root.opentelemetry.proto.trace.v1.Span.Link.decode(reader, reader.uint32()));
                    break;
                  }
                  case 14: {
                    message.droppedLinksCount = reader.uint32();
                    break;
                  }
                  case 15: {
                    message.status = $root.opentelemetry.proto.trace.v1.Status.decode(reader, reader.uint32());
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Span.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Span.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.traceId != null && message.hasOwnProperty("traceId")) {
                if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                  return "traceId: buffer expected";
              }
              if (message.spanId != null && message.hasOwnProperty("spanId")) {
                if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                  return "spanId: buffer expected";
              }
              if (message.traceState != null && message.hasOwnProperty("traceState")) {
                if (!$util.isString(message.traceState))
                  return "traceState: string expected";
              }
              if (message.parentSpanId != null && message.hasOwnProperty("parentSpanId")) {
                if (!(message.parentSpanId && typeof message.parentSpanId.length === "number" || $util.isString(message.parentSpanId)))
                  return "parentSpanId: buffer expected";
              }
              if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!$util.isInteger(message.flags))
                  return "flags: integer expected";
              }
              if (message.name != null && message.hasOwnProperty("name")) {
                if (!$util.isString(message.name))
                  return "name: string expected";
              }
              if (message.kind != null && message.hasOwnProperty("kind"))
                switch (message.kind) {
                  default:
                    return "kind: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                    break;
                }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
              }
              if (message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano")) {
                if (!$util.isInteger(message.endTimeUnixNano) && !(message.endTimeUnixNano && $util.isInteger(message.endTimeUnixNano.low) && $util.isInteger(message.endTimeUnixNano.high)))
                  return "endTimeUnixNano: integer|Long expected";
              }
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                if (!$util.isInteger(message.droppedAttributesCount))
                  return "droppedAttributesCount: integer expected";
              }
              if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                  return "events: array expected";
                for (var i = 0;i < message.events.length; ++i) {
                  var error = $root.opentelemetry.proto.trace.v1.Span.Event.verify(message.events[i]);
                  if (error)
                    return "events." + error;
                }
              }
              if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount")) {
                if (!$util.isInteger(message.droppedEventsCount))
                  return "droppedEventsCount: integer expected";
              }
              if (message.links != null && message.hasOwnProperty("links")) {
                if (!Array.isArray(message.links))
                  return "links: array expected";
                for (var i = 0;i < message.links.length; ++i) {
                  var error = $root.opentelemetry.proto.trace.v1.Span.Link.verify(message.links[i]);
                  if (error)
                    return "links." + error;
                }
              }
              if (message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount")) {
                if (!$util.isInteger(message.droppedLinksCount))
                  return "droppedLinksCount: integer expected";
              }
              if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.opentelemetry.proto.trace.v1.Status.verify(message.status);
                if (error)
                  return "status." + error;
              }
              return null;
            };
            Span.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.trace.v1.Span)
                return object;
              var message = new $root.opentelemetry.proto.trace.v1.Span;
              if (object.traceId != null) {
                if (typeof object.traceId === "string")
                  $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
                else if (object.traceId.length >= 0)
                  message.traceId = object.traceId;
              }
              if (object.spanId != null) {
                if (typeof object.spanId === "string")
                  $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
                else if (object.spanId.length >= 0)
                  message.spanId = object.spanId;
              }
              if (object.traceState != null)
                message.traceState = String(object.traceState);
              if (object.parentSpanId != null) {
                if (typeof object.parentSpanId === "string")
                  $util.base64.decode(object.parentSpanId, message.parentSpanId = $util.newBuffer($util.base64.length(object.parentSpanId)), 0);
                else if (object.parentSpanId.length >= 0)
                  message.parentSpanId = object.parentSpanId;
              }
              if (object.flags != null)
                message.flags = object.flags >>> 0;
              if (object.name != null)
                message.name = String(object.name);
              switch (object.kind) {
                default:
                  if (typeof object.kind === "number") {
                    message.kind = object.kind;
                    break;
                  }
                  break;
                case "SPAN_KIND_UNSPECIFIED":
                case 0:
                  message.kind = 0;
                  break;
                case "SPAN_KIND_INTERNAL":
                case 1:
                  message.kind = 1;
                  break;
                case "SPAN_KIND_SERVER":
                case 2:
                  message.kind = 2;
                  break;
                case "SPAN_KIND_CLIENT":
                case 3:
                  message.kind = 3;
                  break;
                case "SPAN_KIND_PRODUCER":
                case 4:
                  message.kind = 4;
                  break;
                case "SPAN_KIND_CONSUMER":
                case 5:
                  message.kind = 5;
                  break;
              }
              if (object.startTimeUnixNano != null) {
                if ($util.Long)
                  (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
                else if (typeof object.startTimeUnixNano === "string")
                  message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
                else if (typeof object.startTimeUnixNano === "number")
                  message.startTimeUnixNano = object.startTimeUnixNano;
                else if (typeof object.startTimeUnixNano === "object")
                  message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
              }
              if (object.endTimeUnixNano != null) {
                if ($util.Long)
                  (message.endTimeUnixNano = $util.Long.fromValue(object.endTimeUnixNano)).unsigned = false;
                else if (typeof object.endTimeUnixNano === "string")
                  message.endTimeUnixNano = parseInt(object.endTimeUnixNano, 10);
                else if (typeof object.endTimeUnixNano === "number")
                  message.endTimeUnixNano = object.endTimeUnixNano;
                else if (typeof object.endTimeUnixNano === "object")
                  message.endTimeUnixNano = new $util.LongBits(object.endTimeUnixNano.low >>> 0, object.endTimeUnixNano.high >>> 0).toNumber();
              }
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.droppedAttributesCount != null)
                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
              if (object.events) {
                if (!Array.isArray(object.events))
                  throw TypeError(".opentelemetry.proto.trace.v1.Span.events: array expected");
                message.events = [];
                for (var i = 0;i < object.events.length; ++i) {
                  if (typeof object.events[i] !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.events: object expected");
                  message.events[i] = $root.opentelemetry.proto.trace.v1.Span.Event.fromObject(object.events[i]);
                }
              }
              if (object.droppedEventsCount != null)
                message.droppedEventsCount = object.droppedEventsCount >>> 0;
              if (object.links) {
                if (!Array.isArray(object.links))
                  throw TypeError(".opentelemetry.proto.trace.v1.Span.links: array expected");
                message.links = [];
                for (var i = 0;i < object.links.length; ++i) {
                  if (typeof object.links[i] !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.links: object expected");
                  message.links[i] = $root.opentelemetry.proto.trace.v1.Span.Link.fromObject(object.links[i]);
                }
              }
              if (object.droppedLinksCount != null)
                message.droppedLinksCount = object.droppedLinksCount >>> 0;
              if (object.status != null) {
                if (typeof object.status !== "object")
                  throw TypeError(".opentelemetry.proto.trace.v1.Span.status: object expected");
                message.status = $root.opentelemetry.proto.trace.v1.Status.fromObject(object.status);
              }
              return message;
            };
            Span.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                object.attributes = [];
                object.events = [];
                object.links = [];
              }
              if (options.defaults) {
                if (options.bytes === String)
                  object.traceId = "";
                else {
                  object.traceId = [];
                  if (options.bytes !== Array)
                    object.traceId = $util.newBuffer(object.traceId);
                }
                if (options.bytes === String)
                  object.spanId = "";
                else {
                  object.spanId = [];
                  if (options.bytes !== Array)
                    object.spanId = $util.newBuffer(object.spanId);
                }
                object.traceState = "";
                if (options.bytes === String)
                  object.parentSpanId = "";
                else {
                  object.parentSpanId = [];
                  if (options.bytes !== Array)
                    object.parentSpanId = $util.newBuffer(object.parentSpanId);
                }
                object.name = "";
                object.kind = options.enums === String ? "SPAN_KIND_UNSPECIFIED" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.startTimeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.endTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.endTimeUnixNano = options.longs === String ? "0" : 0;
                object.droppedAttributesCount = 0;
                object.droppedEventsCount = 0;
                object.droppedLinksCount = 0;
                object.status = null;
                object.flags = 0;
              }
              if (message.traceId != null && message.hasOwnProperty("traceId"))
                object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
              if (message.spanId != null && message.hasOwnProperty("spanId"))
                object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
              if (message.traceState != null && message.hasOwnProperty("traceState"))
                object.traceState = message.traceState;
              if (message.parentSpanId != null && message.hasOwnProperty("parentSpanId"))
                object.parentSpanId = options.bytes === String ? $util.base64.encode(message.parentSpanId, 0, message.parentSpanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentSpanId) : message.parentSpanId;
              if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
              if (message.kind != null && message.hasOwnProperty("kind"))
                object.kind = options.enums === String ? $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] === undefined ? message.kind : $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] : message.kind;
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                if (typeof message.startTimeUnixNano === "number")
                  object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                else
                  object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
              if (message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano"))
                if (typeof message.endTimeUnixNano === "number")
                  object.endTimeUnixNano = options.longs === String ? String(message.endTimeUnixNano) : message.endTimeUnixNano;
                else
                  object.endTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.endTimeUnixNano.low >>> 0, message.endTimeUnixNano.high >>> 0).toNumber() : message.endTimeUnixNano;
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                object.droppedAttributesCount = message.droppedAttributesCount;
              if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0;j < message.events.length; ++j)
                  object.events[j] = $root.opentelemetry.proto.trace.v1.Span.Event.toObject(message.events[j], options);
              }
              if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount"))
                object.droppedEventsCount = message.droppedEventsCount;
              if (message.links && message.links.length) {
                object.links = [];
                for (var j = 0;j < message.links.length; ++j)
                  object.links[j] = $root.opentelemetry.proto.trace.v1.Span.Link.toObject(message.links[j], options);
              }
              if (message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount"))
                object.droppedLinksCount = message.droppedLinksCount;
              if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.opentelemetry.proto.trace.v1.Status.toObject(message.status, options);
              if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
              return object;
            };
            Span.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Span.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span";
            };
            Span.SpanKind = function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "SPAN_KIND_UNSPECIFIED"] = 0;
              values[valuesById[1] = "SPAN_KIND_INTERNAL"] = 1;
              values[valuesById[2] = "SPAN_KIND_SERVER"] = 2;
              values[valuesById[3] = "SPAN_KIND_CLIENT"] = 3;
              values[valuesById[4] = "SPAN_KIND_PRODUCER"] = 4;
              values[valuesById[5] = "SPAN_KIND_CONSUMER"] = 5;
              return values;
            }();
            Span.Event = function() {
              function Event(properties) {
                this.attributes = [];
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              Event.prototype.timeUnixNano = null;
              Event.prototype.name = null;
              Event.prototype.attributes = $util.emptyArray;
              Event.prototype.droppedAttributesCount = null;
              Event.create = function create(properties) {
                return new Event(properties);
              };
              Event.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                  writer.uint32(9).fixed64(message.timeUnixNano);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                  writer.uint32(18).string(message.name);
                if (message.attributes != null && message.attributes.length)
                  for (var i = 0;i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(26).fork()).ldelim();
                if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                  writer.uint32(32).uint32(message.droppedAttributesCount);
                return writer;
              };
              Event.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Event.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Event;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 2: {
                      message.name = reader.string();
                      break;
                    }
                    case 3: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 4: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              Event.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Event.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                  if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                }
                if (message.name != null && message.hasOwnProperty("name")) {
                  if (!$util.isString(message.name))
                    return "name: string expected";
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0;i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                  if (!$util.isInteger(message.droppedAttributesCount))
                    return "droppedAttributesCount: integer expected";
                }
                return null;
              };
              Event.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Event)
                  return object;
                var message = new $root.opentelemetry.proto.trace.v1.Span.Event;
                if (object.timeUnixNano != null) {
                  if ($util.Long)
                    (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                  else if (typeof object.timeUnixNano === "string")
                    message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                  else if (typeof object.timeUnixNano === "number")
                    message.timeUnixNano = object.timeUnixNano;
                  else if (typeof object.timeUnixNano === "object")
                    message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
                }
                if (object.name != null)
                  message.name = String(object.name);
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0;i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                if (object.droppedAttributesCount != null)
                  message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
                return message;
              };
              Event.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.arrays || options.defaults)
                  object.attributes = [];
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.timeUnixNano = options.longs === String ? "0" : 0;
                  object.name = "";
                  object.droppedAttributesCount = 0;
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                  if (typeof message.timeUnixNano === "number")
                    object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                  else
                    object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                if (message.name != null && message.hasOwnProperty("name"))
                  object.name = message.name;
                if (message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0;j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                  object.droppedAttributesCount = message.droppedAttributesCount;
                return object;
              };
              Event.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Event.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Event";
              };
              return Event;
            }();
            Span.Link = function() {
              function Link(properties) {
                this.attributes = [];
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              Link.prototype.traceId = null;
              Link.prototype.spanId = null;
              Link.prototype.traceState = null;
              Link.prototype.attributes = $util.emptyArray;
              Link.prototype.droppedAttributesCount = null;
              Link.prototype.flags = null;
              Link.create = function create(properties) {
                return new Link(properties);
              };
              Link.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                  writer.uint32(10).bytes(message.traceId);
                if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                  writer.uint32(18).bytes(message.spanId);
                if (message.traceState != null && Object.hasOwnProperty.call(message, "traceState"))
                  writer.uint32(26).string(message.traceState);
                if (message.attributes != null && message.attributes.length)
                  for (var i = 0;i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(34).fork()).ldelim();
                if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                  writer.uint32(40).uint32(message.droppedAttributesCount);
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                  writer.uint32(53).fixed32(message.flags);
                return writer;
              };
              Link.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Link.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Link;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.traceId = reader.bytes();
                      break;
                    }
                    case 2: {
                      message.spanId = reader.bytes();
                      break;
                    }
                    case 3: {
                      message.traceState = reader.string();
                      break;
                    }
                    case 4: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 5: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    case 6: {
                      message.flags = reader.fixed32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              Link.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Link.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.traceId != null && message.hasOwnProperty("traceId")) {
                  if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                    return "traceId: buffer expected";
                }
                if (message.spanId != null && message.hasOwnProperty("spanId")) {
                  if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                    return "spanId: buffer expected";
                }
                if (message.traceState != null && message.hasOwnProperty("traceState")) {
                  if (!$util.isString(message.traceState))
                    return "traceState: string expected";
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0;i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                  if (!$util.isInteger(message.droppedAttributesCount))
                    return "droppedAttributesCount: integer expected";
                }
                if (message.flags != null && message.hasOwnProperty("flags")) {
                  if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
                }
                return null;
              };
              Link.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Link)
                  return object;
                var message = new $root.opentelemetry.proto.trace.v1.Span.Link;
                if (object.traceId != null) {
                  if (typeof object.traceId === "string")
                    $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
                  else if (object.traceId.length >= 0)
                    message.traceId = object.traceId;
                }
                if (object.spanId != null) {
                  if (typeof object.spanId === "string")
                    $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
                  else if (object.spanId.length >= 0)
                    message.spanId = object.spanId;
                }
                if (object.traceState != null)
                  message.traceState = String(object.traceState);
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0;i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                if (object.droppedAttributesCount != null)
                  message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
                if (object.flags != null)
                  message.flags = object.flags >>> 0;
                return message;
              };
              Link.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.arrays || options.defaults)
                  object.attributes = [];
                if (options.defaults) {
                  if (options.bytes === String)
                    object.traceId = "";
                  else {
                    object.traceId = [];
                    if (options.bytes !== Array)
                      object.traceId = $util.newBuffer(object.traceId);
                  }
                  if (options.bytes === String)
                    object.spanId = "";
                  else {
                    object.spanId = [];
                    if (options.bytes !== Array)
                      object.spanId = $util.newBuffer(object.spanId);
                  }
                  object.traceState = "";
                  object.droppedAttributesCount = 0;
                  object.flags = 0;
                }
                if (message.traceId != null && message.hasOwnProperty("traceId"))
                  object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
                if (message.spanId != null && message.hasOwnProperty("spanId"))
                  object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
                if (message.traceState != null && message.hasOwnProperty("traceState"))
                  object.traceState = message.traceState;
                if (message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0;j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                  object.droppedAttributesCount = message.droppedAttributesCount;
                if (message.flags != null && message.hasOwnProperty("flags"))
                  object.flags = message.flags;
                return object;
              };
              Link.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Link.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Link";
              };
              return Link;
            }();
            return Span;
          }();
          v1.Status = function() {
            function Status(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Status.prototype.message = null;
            Status.prototype.code = null;
            Status.create = function create(properties) {
              return new Status(properties);
            };
            Status.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
              if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(24).int32(message.code);
              return writer;
            };
            Status.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Status.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Status;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 2: {
                    message.message = reader.string();
                    break;
                  }
                  case 3: {
                    message.code = reader.int32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Status.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Status.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.message != null && message.hasOwnProperty("message")) {
                if (!$util.isString(message.message))
                  return "message: string expected";
              }
              if (message.code != null && message.hasOwnProperty("code"))
                switch (message.code) {
                  default:
                    return "code: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              return null;
            };
            Status.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.trace.v1.Status)
                return object;
              var message = new $root.opentelemetry.proto.trace.v1.Status;
              if (object.message != null)
                message.message = String(object.message);
              switch (object.code) {
                default:
                  if (typeof object.code === "number") {
                    message.code = object.code;
                    break;
                  }
                  break;
                case "STATUS_CODE_UNSET":
                case 0:
                  message.code = 0;
                  break;
                case "STATUS_CODE_OK":
                case 1:
                  message.code = 1;
                  break;
                case "STATUS_CODE_ERROR":
                case 2:
                  message.code = 2;
                  break;
              }
              return message;
            };
            Status.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.message = "";
                object.code = options.enums === String ? "STATUS_CODE_UNSET" : 0;
              }
              if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
              if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.enums === String ? $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] === undefined ? message.code : $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] : message.code;
              return object;
            };
            Status.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Status.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Status";
            };
            Status.StatusCode = function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "STATUS_CODE_UNSET"] = 0;
              values[valuesById[1] = "STATUS_CODE_OK"] = 1;
              values[valuesById[2] = "STATUS_CODE_ERROR"] = 2;
              return values;
            }();
            return Status;
          }();
          v1.SpanFlags = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SPAN_FLAGS_DO_NOT_USE"] = 0;
            values[valuesById[255] = "SPAN_FLAGS_TRACE_FLAGS_MASK"] = 255;
            values[valuesById[256] = "SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK"] = 256;
            values[valuesById[512] = "SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK"] = 512;
            return values;
          }();
          return v1;
        }();
        return trace;
      }();
      proto.collector = function() {
        var collector = {};
        collector.trace = function() {
          var trace = {};
          trace.v1 = function() {
            var v1 = {};
            v1.TraceService = function() {
              function TraceService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
              }
              (TraceService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TraceService;
              TraceService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
              };
              Object.defineProperty(TraceService.prototype["export"] = function export_(request2, callback) {
                return this.rpcCall(export_, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse, request2, callback);
              }, "name", { value: "Export" });
              return TraceService;
            }();
            v1.ExportTraceServiceRequest = function() {
              function ExportTraceServiceRequest(properties) {
                this.resourceSpans = [];
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportTraceServiceRequest.prototype.resourceSpans = $util.emptyArray;
              ExportTraceServiceRequest.create = function create(properties) {
                return new ExportTraceServiceRequest(properties);
              };
              ExportTraceServiceRequest.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resourceSpans != null && message.resourceSpans.length)
                  for (var i = 0;i < message.resourceSpans.length; ++i)
                    $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(10).fork()).ldelim();
                return writer;
              };
              ExportTraceServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportTraceServiceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      if (!(message.resourceSpans && message.resourceSpans.length))
                        message.resourceSpans = [];
                      message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportTraceServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportTraceServiceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
                  if (!Array.isArray(message.resourceSpans))
                    return "resourceSpans: array expected";
                  for (var i = 0;i < message.resourceSpans.length; ++i) {
                    var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);
                    if (error)
                      return "resourceSpans." + error;
                  }
                }
                return null;
              };
              ExportTraceServiceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest)
                  return object;
                var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;
                if (object.resourceSpans) {
                  if (!Array.isArray(object.resourceSpans))
                    throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: array expected");
                  message.resourceSpans = [];
                  for (var i = 0;i < object.resourceSpans.length; ++i) {
                    if (typeof object.resourceSpans[i] !== "object")
                      throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: object expected");
                    message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);
                  }
                }
                return message;
              };
              ExportTraceServiceRequest.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.arrays || options.defaults)
                  object.resourceSpans = [];
                if (message.resourceSpans && message.resourceSpans.length) {
                  object.resourceSpans = [];
                  for (var j = 0;j < message.resourceSpans.length; ++j)
                    object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);
                }
                return object;
              };
              ExportTraceServiceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportTraceServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest";
              };
              return ExportTraceServiceRequest;
            }();
            v1.ExportTraceServiceResponse = function() {
              function ExportTraceServiceResponse(properties) {
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportTraceServiceResponse.prototype.partialSuccess = null;
              ExportTraceServiceResponse.create = function create(properties) {
                return new ExportTraceServiceResponse(properties);
              };
              ExportTraceServiceResponse.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
                  $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.encode(message.partialSuccess, writer.uint32(10).fork()).ldelim();
                return writer;
              };
              ExportTraceServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportTraceServiceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportTraceServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportTraceServiceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                  var error = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify(message.partialSuccess);
                  if (error)
                    return "partialSuccess." + error;
                }
                return null;
              };
              ExportTraceServiceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse)
                  return object;
                var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse;
                if (object.partialSuccess != null) {
                  if (typeof object.partialSuccess !== "object")
                    throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.partialSuccess: object expected");
                  message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.fromObject(object.partialSuccess);
                }
                return message;
              };
              ExportTraceServiceResponse.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.defaults)
                  object.partialSuccess = null;
                if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
                  object.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.toObject(message.partialSuccess, options);
                return object;
              };
              ExportTraceServiceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportTraceServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse";
              };
              return ExportTraceServiceResponse;
            }();
            v1.ExportTracePartialSuccess = function() {
              function ExportTracePartialSuccess(properties) {
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportTracePartialSuccess.prototype.rejectedSpans = null;
              ExportTracePartialSuccess.prototype.errorMessage = null;
              ExportTracePartialSuccess.create = function create(properties) {
                return new ExportTracePartialSuccess(properties);
              };
              ExportTracePartialSuccess.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.rejectedSpans != null && Object.hasOwnProperty.call(message, "rejectedSpans"))
                  writer.uint32(8).int64(message.rejectedSpans);
                if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                  writer.uint32(18).string(message.errorMessage);
                return writer;
              };
              ExportTracePartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportTracePartialSuccess.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.rejectedSpans = reader.int64();
                      break;
                    }
                    case 2: {
                      message.errorMessage = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportTracePartialSuccess.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportTracePartialSuccess.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans")) {
                  if (!$util.isInteger(message.rejectedSpans) && !(message.rejectedSpans && $util.isInteger(message.rejectedSpans.low) && $util.isInteger(message.rejectedSpans.high)))
                    return "rejectedSpans: integer|Long expected";
                }
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage")) {
                  if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
                }
                return null;
              };
              ExportTracePartialSuccess.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess)
                  return object;
                var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess;
                if (object.rejectedSpans != null) {
                  if ($util.Long)
                    (message.rejectedSpans = $util.Long.fromValue(object.rejectedSpans)).unsigned = false;
                  else if (typeof object.rejectedSpans === "string")
                    message.rejectedSpans = parseInt(object.rejectedSpans, 10);
                  else if (typeof object.rejectedSpans === "number")
                    message.rejectedSpans = object.rejectedSpans;
                  else if (typeof object.rejectedSpans === "object")
                    message.rejectedSpans = new $util.LongBits(object.rejectedSpans.low >>> 0, object.rejectedSpans.high >>> 0).toNumber();
                }
                if (object.errorMessage != null)
                  message.errorMessage = String(object.errorMessage);
                return message;
              };
              ExportTracePartialSuccess.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rejectedSpans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.rejectedSpans = options.longs === String ? "0" : 0;
                  object.errorMessage = "";
                }
                if (message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans"))
                  if (typeof message.rejectedSpans === "number")
                    object.rejectedSpans = options.longs === String ? String(message.rejectedSpans) : message.rejectedSpans;
                  else
                    object.rejectedSpans = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedSpans) : options.longs === Number ? new $util.LongBits(message.rejectedSpans.low >>> 0, message.rejectedSpans.high >>> 0).toNumber() : message.rejectedSpans;
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                  object.errorMessage = message.errorMessage;
                return object;
              };
              ExportTracePartialSuccess.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportTracePartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess";
              };
              return ExportTracePartialSuccess;
            }();
            return v1;
          }();
          return trace;
        }();
        collector.metrics = function() {
          var metrics = {};
          metrics.v1 = function() {
            var v1 = {};
            v1.MetricsService = function() {
              function MetricsService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
              }
              (MetricsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetricsService;
              MetricsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
              };
              Object.defineProperty(MetricsService.prototype["export"] = function export_(request2, callback) {
                return this.rpcCall(export_, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse, request2, callback);
              }, "name", { value: "Export" });
              return MetricsService;
            }();
            v1.ExportMetricsServiceRequest = function() {
              function ExportMetricsServiceRequest(properties) {
                this.resourceMetrics = [];
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportMetricsServiceRequest.prototype.resourceMetrics = $util.emptyArray;
              ExportMetricsServiceRequest.create = function create(properties) {
                return new ExportMetricsServiceRequest(properties);
              };
              ExportMetricsServiceRequest.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resourceMetrics != null && message.resourceMetrics.length)
                  for (var i = 0;i < message.resourceMetrics.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(10).fork()).ldelim();
                return writer;
              };
              ExportMetricsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportMetricsServiceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      if (!(message.resourceMetrics && message.resourceMetrics.length))
                        message.resourceMetrics = [];
                      message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportMetricsServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportMetricsServiceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
                  if (!Array.isArray(message.resourceMetrics))
                    return "resourceMetrics: array expected";
                  for (var i = 0;i < message.resourceMetrics.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);
                    if (error)
                      return "resourceMetrics." + error;
                  }
                }
                return null;
              };
              ExportMetricsServiceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest)
                  return object;
                var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest;
                if (object.resourceMetrics) {
                  if (!Array.isArray(object.resourceMetrics))
                    throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: array expected");
                  message.resourceMetrics = [];
                  for (var i = 0;i < object.resourceMetrics.length; ++i) {
                    if (typeof object.resourceMetrics[i] !== "object")
                      throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: object expected");
                    message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);
                  }
                }
                return message;
              };
              ExportMetricsServiceRequest.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.arrays || options.defaults)
                  object.resourceMetrics = [];
                if (message.resourceMetrics && message.resourceMetrics.length) {
                  object.resourceMetrics = [];
                  for (var j = 0;j < message.resourceMetrics.length; ++j)
                    object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);
                }
                return object;
              };
              ExportMetricsServiceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportMetricsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest";
              };
              return ExportMetricsServiceRequest;
            }();
            v1.ExportMetricsServiceResponse = function() {
              function ExportMetricsServiceResponse(properties) {
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportMetricsServiceResponse.prototype.partialSuccess = null;
              ExportMetricsServiceResponse.create = function create(properties) {
                return new ExportMetricsServiceResponse(properties);
              };
              ExportMetricsServiceResponse.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
                  $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.encode(message.partialSuccess, writer.uint32(10).fork()).ldelim();
                return writer;
              };
              ExportMetricsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportMetricsServiceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportMetricsServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportMetricsServiceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                  var error = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify(message.partialSuccess);
                  if (error)
                    return "partialSuccess." + error;
                }
                return null;
              };
              ExportMetricsServiceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse)
                  return object;
                var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse;
                if (object.partialSuccess != null) {
                  if (typeof object.partialSuccess !== "object")
                    throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.partialSuccess: object expected");
                  message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.fromObject(object.partialSuccess);
                }
                return message;
              };
              ExportMetricsServiceResponse.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.defaults)
                  object.partialSuccess = null;
                if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
                  object.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.toObject(message.partialSuccess, options);
                return object;
              };
              ExportMetricsServiceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportMetricsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse";
              };
              return ExportMetricsServiceResponse;
            }();
            v1.ExportMetricsPartialSuccess = function() {
              function ExportMetricsPartialSuccess(properties) {
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportMetricsPartialSuccess.prototype.rejectedDataPoints = null;
              ExportMetricsPartialSuccess.prototype.errorMessage = null;
              ExportMetricsPartialSuccess.create = function create(properties) {
                return new ExportMetricsPartialSuccess(properties);
              };
              ExportMetricsPartialSuccess.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.rejectedDataPoints != null && Object.hasOwnProperty.call(message, "rejectedDataPoints"))
                  writer.uint32(8).int64(message.rejectedDataPoints);
                if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                  writer.uint32(18).string(message.errorMessage);
                return writer;
              };
              ExportMetricsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportMetricsPartialSuccess.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.rejectedDataPoints = reader.int64();
                      break;
                    }
                    case 2: {
                      message.errorMessage = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportMetricsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportMetricsPartialSuccess.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints")) {
                  if (!$util.isInteger(message.rejectedDataPoints) && !(message.rejectedDataPoints && $util.isInteger(message.rejectedDataPoints.low) && $util.isInteger(message.rejectedDataPoints.high)))
                    return "rejectedDataPoints: integer|Long expected";
                }
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage")) {
                  if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
                }
                return null;
              };
              ExportMetricsPartialSuccess.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess)
                  return object;
                var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess;
                if (object.rejectedDataPoints != null) {
                  if ($util.Long)
                    (message.rejectedDataPoints = $util.Long.fromValue(object.rejectedDataPoints)).unsigned = false;
                  else if (typeof object.rejectedDataPoints === "string")
                    message.rejectedDataPoints = parseInt(object.rejectedDataPoints, 10);
                  else if (typeof object.rejectedDataPoints === "number")
                    message.rejectedDataPoints = object.rejectedDataPoints;
                  else if (typeof object.rejectedDataPoints === "object")
                    message.rejectedDataPoints = new $util.LongBits(object.rejectedDataPoints.low >>> 0, object.rejectedDataPoints.high >>> 0).toNumber();
                }
                if (object.errorMessage != null)
                  message.errorMessage = String(object.errorMessage);
                return message;
              };
              ExportMetricsPartialSuccess.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rejectedDataPoints = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.rejectedDataPoints = options.longs === String ? "0" : 0;
                  object.errorMessage = "";
                }
                if (message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints"))
                  if (typeof message.rejectedDataPoints === "number")
                    object.rejectedDataPoints = options.longs === String ? String(message.rejectedDataPoints) : message.rejectedDataPoints;
                  else
                    object.rejectedDataPoints = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedDataPoints) : options.longs === Number ? new $util.LongBits(message.rejectedDataPoints.low >>> 0, message.rejectedDataPoints.high >>> 0).toNumber() : message.rejectedDataPoints;
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                  object.errorMessage = message.errorMessage;
                return object;
              };
              ExportMetricsPartialSuccess.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportMetricsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess";
              };
              return ExportMetricsPartialSuccess;
            }();
            return v1;
          }();
          return metrics;
        }();
        collector.logs = function() {
          var logs = {};
          logs.v1 = function() {
            var v1 = {};
            v1.LogsService = function() {
              function LogsService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
              }
              (LogsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LogsService;
              LogsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
              };
              Object.defineProperty(LogsService.prototype["export"] = function export_(request2, callback) {
                return this.rpcCall(export_, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse, request2, callback);
              }, "name", { value: "Export" });
              return LogsService;
            }();
            v1.ExportLogsServiceRequest = function() {
              function ExportLogsServiceRequest(properties) {
                this.resourceLogs = [];
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportLogsServiceRequest.prototype.resourceLogs = $util.emptyArray;
              ExportLogsServiceRequest.create = function create(properties) {
                return new ExportLogsServiceRequest(properties);
              };
              ExportLogsServiceRequest.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resourceLogs != null && message.resourceLogs.length)
                  for (var i = 0;i < message.resourceLogs.length; ++i)
                    $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(10).fork()).ldelim();
                return writer;
              };
              ExportLogsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportLogsServiceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      if (!(message.resourceLogs && message.resourceLogs.length))
                        message.resourceLogs = [];
                      message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportLogsServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportLogsServiceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
                  if (!Array.isArray(message.resourceLogs))
                    return "resourceLogs: array expected";
                  for (var i = 0;i < message.resourceLogs.length; ++i) {
                    var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);
                    if (error)
                      return "resourceLogs." + error;
                  }
                }
                return null;
              };
              ExportLogsServiceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest)
                  return object;
                var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest;
                if (object.resourceLogs) {
                  if (!Array.isArray(object.resourceLogs))
                    throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: array expected");
                  message.resourceLogs = [];
                  for (var i = 0;i < object.resourceLogs.length; ++i) {
                    if (typeof object.resourceLogs[i] !== "object")
                      throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: object expected");
                    message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);
                  }
                }
                return message;
              };
              ExportLogsServiceRequest.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.arrays || options.defaults)
                  object.resourceLogs = [];
                if (message.resourceLogs && message.resourceLogs.length) {
                  object.resourceLogs = [];
                  for (var j = 0;j < message.resourceLogs.length; ++j)
                    object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);
                }
                return object;
              };
              ExportLogsServiceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportLogsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest";
              };
              return ExportLogsServiceRequest;
            }();
            v1.ExportLogsServiceResponse = function() {
              function ExportLogsServiceResponse(properties) {
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportLogsServiceResponse.prototype.partialSuccess = null;
              ExportLogsServiceResponse.create = function create(properties) {
                return new ExportLogsServiceResponse(properties);
              };
              ExportLogsServiceResponse.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
                  $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.encode(message.partialSuccess, writer.uint32(10).fork()).ldelim();
                return writer;
              };
              ExportLogsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportLogsServiceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportLogsServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportLogsServiceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                  var error = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify(message.partialSuccess);
                  if (error)
                    return "partialSuccess." + error;
                }
                return null;
              };
              ExportLogsServiceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse)
                  return object;
                var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse;
                if (object.partialSuccess != null) {
                  if (typeof object.partialSuccess !== "object")
                    throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.partialSuccess: object expected");
                  message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.fromObject(object.partialSuccess);
                }
                return message;
              };
              ExportLogsServiceResponse.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.defaults)
                  object.partialSuccess = null;
                if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
                  object.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.toObject(message.partialSuccess, options);
                return object;
              };
              ExportLogsServiceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportLogsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse";
              };
              return ExportLogsServiceResponse;
            }();
            v1.ExportLogsPartialSuccess = function() {
              function ExportLogsPartialSuccess(properties) {
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ExportLogsPartialSuccess.prototype.rejectedLogRecords = null;
              ExportLogsPartialSuccess.prototype.errorMessage = null;
              ExportLogsPartialSuccess.create = function create(properties) {
                return new ExportLogsPartialSuccess(properties);
              };
              ExportLogsPartialSuccess.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.rejectedLogRecords != null && Object.hasOwnProperty.call(message, "rejectedLogRecords"))
                  writer.uint32(8).int64(message.rejectedLogRecords);
                if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                  writer.uint32(18).string(message.errorMessage);
                return writer;
              };
              ExportLogsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExportLogsPartialSuccess.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.rejectedLogRecords = reader.int64();
                      break;
                    }
                    case 2: {
                      message.errorMessage = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ExportLogsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExportLogsPartialSuccess.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords")) {
                  if (!$util.isInteger(message.rejectedLogRecords) && !(message.rejectedLogRecords && $util.isInteger(message.rejectedLogRecords.low) && $util.isInteger(message.rejectedLogRecords.high)))
                    return "rejectedLogRecords: integer|Long expected";
                }
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage")) {
                  if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
                }
                return null;
              };
              ExportLogsPartialSuccess.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess)
                  return object;
                var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess;
                if (object.rejectedLogRecords != null) {
                  if ($util.Long)
                    (message.rejectedLogRecords = $util.Long.fromValue(object.rejectedLogRecords)).unsigned = false;
                  else if (typeof object.rejectedLogRecords === "string")
                    message.rejectedLogRecords = parseInt(object.rejectedLogRecords, 10);
                  else if (typeof object.rejectedLogRecords === "number")
                    message.rejectedLogRecords = object.rejectedLogRecords;
                  else if (typeof object.rejectedLogRecords === "object")
                    message.rejectedLogRecords = new $util.LongBits(object.rejectedLogRecords.low >>> 0, object.rejectedLogRecords.high >>> 0).toNumber();
                }
                if (object.errorMessage != null)
                  message.errorMessage = String(object.errorMessage);
                return message;
              };
              ExportLogsPartialSuccess.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rejectedLogRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.rejectedLogRecords = options.longs === String ? "0" : 0;
                  object.errorMessage = "";
                }
                if (message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords"))
                  if (typeof message.rejectedLogRecords === "number")
                    object.rejectedLogRecords = options.longs === String ? String(message.rejectedLogRecords) : message.rejectedLogRecords;
                  else
                    object.rejectedLogRecords = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedLogRecords) : options.longs === Number ? new $util.LongBits(message.rejectedLogRecords.low >>> 0, message.rejectedLogRecords.high >>> 0).toNumber() : message.rejectedLogRecords;
                if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                  object.errorMessage = message.errorMessage;
                return object;
              };
              ExportLogsPartialSuccess.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExportLogsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess";
              };
              return ExportLogsPartialSuccess;
            }();
            return v1;
          }();
          return logs;
        }();
        return collector;
      }();
      proto.metrics = function() {
        var metrics = {};
        metrics.v1 = function() {
          var v1 = {};
          v1.MetricsData = function() {
            function MetricsData(properties) {
              this.resourceMetrics = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            MetricsData.prototype.resourceMetrics = $util.emptyArray;
            MetricsData.create = function create(properties) {
              return new MetricsData(properties);
            };
            MetricsData.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.resourceMetrics != null && message.resourceMetrics.length)
                for (var i = 0;i < message.resourceMetrics.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(10).fork()).ldelim();
              return writer;
            };
            MetricsData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            MetricsData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.MetricsData;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.resourceMetrics && message.resourceMetrics.length))
                      message.resourceMetrics = [];
                    message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            MetricsData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            MetricsData.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
                if (!Array.isArray(message.resourceMetrics))
                  return "resourceMetrics: array expected";
                for (var i = 0;i < message.resourceMetrics.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);
                  if (error)
                    return "resourceMetrics." + error;
                }
              }
              return null;
            };
            MetricsData.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.MetricsData)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.MetricsData;
              if (object.resourceMetrics) {
                if (!Array.isArray(object.resourceMetrics))
                  throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: array expected");
                message.resourceMetrics = [];
                for (var i = 0;i < object.resourceMetrics.length; ++i) {
                  if (typeof object.resourceMetrics[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: object expected");
                  message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);
                }
              }
              return message;
            };
            MetricsData.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.resourceMetrics = [];
              if (message.resourceMetrics && message.resourceMetrics.length) {
                object.resourceMetrics = [];
                for (var j = 0;j < message.resourceMetrics.length; ++j)
                  object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);
              }
              return object;
            };
            MetricsData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            MetricsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.MetricsData";
            };
            return MetricsData;
          }();
          v1.ResourceMetrics = function() {
            function ResourceMetrics(properties) {
              this.scopeMetrics = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ResourceMetrics.prototype.resource = null;
            ResourceMetrics.prototype.scopeMetrics = $util.emptyArray;
            ResourceMetrics.prototype.schemaUrl = null;
            ResourceMetrics.create = function create(properties) {
              return new ResourceMetrics(properties);
            };
            ResourceMetrics.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
              if (message.scopeMetrics != null && message.scopeMetrics.length)
                for (var i = 0;i < message.scopeMetrics.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.ScopeMetrics.encode(message.scopeMetrics[i], writer.uint32(18).fork()).ldelim();
              if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                writer.uint32(26).string(message.schemaUrl);
              return writer;
            };
            ResourceMetrics.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ResourceMetrics.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                    break;
                  }
                  case 2: {
                    if (!(message.scopeMetrics && message.scopeMetrics.length))
                      message.scopeMetrics = [];
                    message.scopeMetrics.push($root.opentelemetry.proto.metrics.v1.ScopeMetrics.decode(reader, reader.uint32()));
                    break;
                  }
                  case 3: {
                    message.schemaUrl = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ResourceMetrics.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ResourceMetrics.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                if (error)
                  return "resource." + error;
              }
              if (message.scopeMetrics != null && message.hasOwnProperty("scopeMetrics")) {
                if (!Array.isArray(message.scopeMetrics))
                  return "scopeMetrics: array expected";
                for (var i = 0;i < message.scopeMetrics.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.verify(message.scopeMetrics[i]);
                  if (error)
                    return "scopeMetrics." + error;
                }
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                if (!$util.isString(message.schemaUrl))
                  return "schemaUrl: string expected";
              }
              return null;
            };
            ResourceMetrics.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.ResourceMetrics)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics;
              if (object.resource != null) {
                if (typeof object.resource !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.resource: object expected");
                message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
              }
              if (object.scopeMetrics) {
                if (!Array.isArray(object.scopeMetrics))
                  throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: array expected");
                message.scopeMetrics = [];
                for (var i = 0;i < object.scopeMetrics.length; ++i) {
                  if (typeof object.scopeMetrics[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: object expected");
                  message.scopeMetrics[i] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.fromObject(object.scopeMetrics[i]);
                }
              }
              if (object.schemaUrl != null)
                message.schemaUrl = String(object.schemaUrl);
              return message;
            };
            ResourceMetrics.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.scopeMetrics = [];
              if (options.defaults) {
                object.resource = null;
                object.schemaUrl = "";
              }
              if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
              if (message.scopeMetrics && message.scopeMetrics.length) {
                object.scopeMetrics = [];
                for (var j = 0;j < message.scopeMetrics.length; ++j)
                  object.scopeMetrics[j] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.toObject(message.scopeMetrics[j], options);
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                object.schemaUrl = message.schemaUrl;
              return object;
            };
            ResourceMetrics.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ResourceMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ResourceMetrics";
            };
            return ResourceMetrics;
          }();
          v1.ScopeMetrics = function() {
            function ScopeMetrics(properties) {
              this.metrics = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ScopeMetrics.prototype.scope = null;
            ScopeMetrics.prototype.metrics = $util.emptyArray;
            ScopeMetrics.prototype.schemaUrl = null;
            ScopeMetrics.create = function create(properties) {
              return new ScopeMetrics(properties);
            };
            ScopeMetrics.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
                $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(10).fork()).ldelim();
              if (message.metrics != null && message.metrics.length)
                for (var i = 0;i < message.metrics.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.Metric.encode(message.metrics[i], writer.uint32(18).fork()).ldelim();
              if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                writer.uint32(26).string(message.schemaUrl);
              return writer;
            };
            ScopeMetrics.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ScopeMetrics.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                    break;
                  }
                  case 2: {
                    if (!(message.metrics && message.metrics.length))
                      message.metrics = [];
                    message.metrics.push($root.opentelemetry.proto.metrics.v1.Metric.decode(reader, reader.uint32()));
                    break;
                  }
                  case 3: {
                    message.schemaUrl = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ScopeMetrics.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ScopeMetrics.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.scope != null && message.hasOwnProperty("scope")) {
                var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                if (error)
                  return "scope." + error;
              }
              if (message.metrics != null && message.hasOwnProperty("metrics")) {
                if (!Array.isArray(message.metrics))
                  return "metrics: array expected";
                for (var i = 0;i < message.metrics.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.Metric.verify(message.metrics[i]);
                  if (error)
                    return "metrics." + error;
                }
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                if (!$util.isString(message.schemaUrl))
                  return "schemaUrl: string expected";
              }
              return null;
            };
            ScopeMetrics.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.ScopeMetrics)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics;
              if (object.scope != null) {
                if (typeof object.scope !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.scope: object expected");
                message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
              }
              if (object.metrics) {
                if (!Array.isArray(object.metrics))
                  throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: array expected");
                message.metrics = [];
                for (var i = 0;i < object.metrics.length; ++i) {
                  if (typeof object.metrics[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: object expected");
                  message.metrics[i] = $root.opentelemetry.proto.metrics.v1.Metric.fromObject(object.metrics[i]);
                }
              }
              if (object.schemaUrl != null)
                message.schemaUrl = String(object.schemaUrl);
              return message;
            };
            ScopeMetrics.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.metrics = [];
              if (options.defaults) {
                object.scope = null;
                object.schemaUrl = "";
              }
              if (message.scope != null && message.hasOwnProperty("scope"))
                object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
              if (message.metrics && message.metrics.length) {
                object.metrics = [];
                for (var j = 0;j < message.metrics.length; ++j)
                  object.metrics[j] = $root.opentelemetry.proto.metrics.v1.Metric.toObject(message.metrics[j], options);
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                object.schemaUrl = message.schemaUrl;
              return object;
            };
            ScopeMetrics.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ScopeMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ScopeMetrics";
            };
            return ScopeMetrics;
          }();
          v1.Metric = function() {
            function Metric(properties) {
              this.metadata = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Metric.prototype.name = null;
            Metric.prototype.description = null;
            Metric.prototype.unit = null;
            Metric.prototype.gauge = null;
            Metric.prototype.sum = null;
            Metric.prototype.histogram = null;
            Metric.prototype.exponentialHistogram = null;
            Metric.prototype.summary = null;
            Metric.prototype.metadata = $util.emptyArray;
            var $oneOfFields;
            Object.defineProperty(Metric.prototype, "data", {
              get: $util.oneOfGetter($oneOfFields = ["gauge", "sum", "histogram", "exponentialHistogram", "summary"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Metric.create = function create(properties) {
              return new Metric(properties);
            };
            Metric.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(10).string(message.name);
              if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(18).string(message.description);
              if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
                writer.uint32(26).string(message.unit);
              if (message.gauge != null && Object.hasOwnProperty.call(message, "gauge"))
                $root.opentelemetry.proto.metrics.v1.Gauge.encode(message.gauge, writer.uint32(42).fork()).ldelim();
              if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                $root.opentelemetry.proto.metrics.v1.Sum.encode(message.sum, writer.uint32(58).fork()).ldelim();
              if (message.histogram != null && Object.hasOwnProperty.call(message, "histogram"))
                $root.opentelemetry.proto.metrics.v1.Histogram.encode(message.histogram, writer.uint32(74).fork()).ldelim();
              if (message.exponentialHistogram != null && Object.hasOwnProperty.call(message, "exponentialHistogram"))
                $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.encode(message.exponentialHistogram, writer.uint32(82).fork()).ldelim();
              if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                $root.opentelemetry.proto.metrics.v1.Summary.encode(message.summary, writer.uint32(90).fork()).ldelim();
              if (message.metadata != null && message.metadata.length)
                for (var i = 0;i < message.metadata.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.metadata[i], writer.uint32(98).fork()).ldelim();
              return writer;
            };
            Metric.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Metric.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Metric;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.name = reader.string();
                    break;
                  }
                  case 2: {
                    message.description = reader.string();
                    break;
                  }
                  case 3: {
                    message.unit = reader.string();
                    break;
                  }
                  case 5: {
                    message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.decode(reader, reader.uint32());
                    break;
                  }
                  case 7: {
                    message.sum = $root.opentelemetry.proto.metrics.v1.Sum.decode(reader, reader.uint32());
                    break;
                  }
                  case 9: {
                    message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.decode(reader, reader.uint32());
                    break;
                  }
                  case 10: {
                    message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.decode(reader, reader.uint32());
                    break;
                  }
                  case 11: {
                    message.summary = $root.opentelemetry.proto.metrics.v1.Summary.decode(reader, reader.uint32());
                    break;
                  }
                  case 12: {
                    if (!(message.metadata && message.metadata.length))
                      message.metadata = [];
                    message.metadata.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Metric.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Metric.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.name != null && message.hasOwnProperty("name")) {
                if (!$util.isString(message.name))
                  return "name: string expected";
              }
              if (message.description != null && message.hasOwnProperty("description")) {
                if (!$util.isString(message.description))
                  return "description: string expected";
              }
              if (message.unit != null && message.hasOwnProperty("unit")) {
                if (!$util.isString(message.unit))
                  return "unit: string expected";
              }
              if (message.gauge != null && message.hasOwnProperty("gauge")) {
                properties.data = 1;
                {
                  var error = $root.opentelemetry.proto.metrics.v1.Gauge.verify(message.gauge);
                  if (error)
                    return "gauge." + error;
                }
              }
              if (message.sum != null && message.hasOwnProperty("sum")) {
                if (properties.data === 1)
                  return "data: multiple values";
                properties.data = 1;
                {
                  var error = $root.opentelemetry.proto.metrics.v1.Sum.verify(message.sum);
                  if (error)
                    return "sum." + error;
                }
              }
              if (message.histogram != null && message.hasOwnProperty("histogram")) {
                if (properties.data === 1)
                  return "data: multiple values";
                properties.data = 1;
                {
                  var error = $root.opentelemetry.proto.metrics.v1.Histogram.verify(message.histogram);
                  if (error)
                    return "histogram." + error;
                }
              }
              if (message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram")) {
                if (properties.data === 1)
                  return "data: multiple values";
                properties.data = 1;
                {
                  var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.verify(message.exponentialHistogram);
                  if (error)
                    return "exponentialHistogram." + error;
                }
              }
              if (message.summary != null && message.hasOwnProperty("summary")) {
                if (properties.data === 1)
                  return "data: multiple values";
                properties.data = 1;
                {
                  var error = $root.opentelemetry.proto.metrics.v1.Summary.verify(message.summary);
                  if (error)
                    return "summary." + error;
                }
              }
              if (message.metadata != null && message.hasOwnProperty("metadata")) {
                if (!Array.isArray(message.metadata))
                  return "metadata: array expected";
                for (var i = 0;i < message.metadata.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.metadata[i]);
                  if (error)
                    return "metadata." + error;
                }
              }
              return null;
            };
            Metric.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.Metric)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.Metric;
              if (object.name != null)
                message.name = String(object.name);
              if (object.description != null)
                message.description = String(object.description);
              if (object.unit != null)
                message.unit = String(object.unit);
              if (object.gauge != null) {
                if (typeof object.gauge !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.Metric.gauge: object expected");
                message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.fromObject(object.gauge);
              }
              if (object.sum != null) {
                if (typeof object.sum !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.Metric.sum: object expected");
                message.sum = $root.opentelemetry.proto.metrics.v1.Sum.fromObject(object.sum);
              }
              if (object.histogram != null) {
                if (typeof object.histogram !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.Metric.histogram: object expected");
                message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.fromObject(object.histogram);
              }
              if (object.exponentialHistogram != null) {
                if (typeof object.exponentialHistogram !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.Metric.exponentialHistogram: object expected");
                message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.fromObject(object.exponentialHistogram);
              }
              if (object.summary != null) {
                if (typeof object.summary !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.Metric.summary: object expected");
                message.summary = $root.opentelemetry.proto.metrics.v1.Summary.fromObject(object.summary);
              }
              if (object.metadata) {
                if (!Array.isArray(object.metadata))
                  throw TypeError(".opentelemetry.proto.metrics.v1.Metric.metadata: array expected");
                message.metadata = [];
                for (var i = 0;i < object.metadata.length; ++i) {
                  if (typeof object.metadata[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.metadata: object expected");
                  message.metadata[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.metadata[i]);
                }
              }
              return message;
            };
            Metric.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.metadata = [];
              if (options.defaults) {
                object.name = "";
                object.description = "";
                object.unit = "";
              }
              if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
              if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
              if (message.unit != null && message.hasOwnProperty("unit"))
                object.unit = message.unit;
              if (message.gauge != null && message.hasOwnProperty("gauge")) {
                object.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.toObject(message.gauge, options);
                if (options.oneofs)
                  object.data = "gauge";
              }
              if (message.sum != null && message.hasOwnProperty("sum")) {
                object.sum = $root.opentelemetry.proto.metrics.v1.Sum.toObject(message.sum, options);
                if (options.oneofs)
                  object.data = "sum";
              }
              if (message.histogram != null && message.hasOwnProperty("histogram")) {
                object.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.toObject(message.histogram, options);
                if (options.oneofs)
                  object.data = "histogram";
              }
              if (message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram")) {
                object.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.toObject(message.exponentialHistogram, options);
                if (options.oneofs)
                  object.data = "exponentialHistogram";
              }
              if (message.summary != null && message.hasOwnProperty("summary")) {
                object.summary = $root.opentelemetry.proto.metrics.v1.Summary.toObject(message.summary, options);
                if (options.oneofs)
                  object.data = "summary";
              }
              if (message.metadata && message.metadata.length) {
                object.metadata = [];
                for (var j = 0;j < message.metadata.length; ++j)
                  object.metadata[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.metadata[j], options);
              }
              return object;
            };
            Metric.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Metric.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Metric";
            };
            return Metric;
          }();
          v1.Gauge = function() {
            function Gauge(properties) {
              this.dataPoints = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Gauge.prototype.dataPoints = $util.emptyArray;
            Gauge.create = function create(properties) {
              return new Gauge(properties);
            };
            Gauge.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.dataPoints != null && message.dataPoints.length)
                for (var i = 0;i < message.dataPoints.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(10).fork()).ldelim();
              return writer;
            };
            Gauge.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Gauge.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Gauge;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.dataPoints && message.dataPoints.length))
                      message.dataPoints = [];
                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Gauge.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Gauge.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                if (!Array.isArray(message.dataPoints))
                  return "dataPoints: array expected";
                for (var i = 0;i < message.dataPoints.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);
                  if (error)
                    return "dataPoints." + error;
                }
              }
              return null;
            };
            Gauge.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.Gauge)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.Gauge;
              if (object.dataPoints) {
                if (!Array.isArray(object.dataPoints))
                  throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: array expected");
                message.dataPoints = [];
                for (var i = 0;i < object.dataPoints.length; ++i) {
                  if (typeof object.dataPoints[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: object expected");
                  message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);
                }
              }
              return message;
            };
            Gauge.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.dataPoints = [];
              if (message.dataPoints && message.dataPoints.length) {
                object.dataPoints = [];
                for (var j = 0;j < message.dataPoints.length; ++j)
                  object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);
              }
              return object;
            };
            Gauge.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Gauge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Gauge";
            };
            return Gauge;
          }();
          v1.Sum = function() {
            function Sum(properties) {
              this.dataPoints = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Sum.prototype.dataPoints = $util.emptyArray;
            Sum.prototype.aggregationTemporality = null;
            Sum.prototype.isMonotonic = null;
            Sum.create = function create(properties) {
              return new Sum(properties);
            };
            Sum.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.dataPoints != null && message.dataPoints.length)
                for (var i = 0;i < message.dataPoints.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(10).fork()).ldelim();
              if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
                writer.uint32(16).int32(message.aggregationTemporality);
              if (message.isMonotonic != null && Object.hasOwnProperty.call(message, "isMonotonic"))
                writer.uint32(24).bool(message.isMonotonic);
              return writer;
            };
            Sum.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Sum.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Sum;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.dataPoints && message.dataPoints.length))
                      message.dataPoints = [];
                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.aggregationTemporality = reader.int32();
                    break;
                  }
                  case 3: {
                    message.isMonotonic = reader.bool();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Sum.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Sum.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                if (!Array.isArray(message.dataPoints))
                  return "dataPoints: array expected";
                for (var i = 0;i < message.dataPoints.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);
                  if (error)
                    return "dataPoints." + error;
                }
              }
              if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                switch (message.aggregationTemporality) {
                  default:
                    return "aggregationTemporality: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              if (message.isMonotonic != null && message.hasOwnProperty("isMonotonic")) {
                if (typeof message.isMonotonic !== "boolean")
                  return "isMonotonic: boolean expected";
              }
              return null;
            };
            Sum.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.Sum)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.Sum;
              if (object.dataPoints) {
                if (!Array.isArray(object.dataPoints))
                  throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: array expected");
                message.dataPoints = [];
                for (var i = 0;i < object.dataPoints.length; ++i) {
                  if (typeof object.dataPoints[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: object expected");
                  message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);
                }
              }
              switch (object.aggregationTemporality) {
                default:
                  if (typeof object.aggregationTemporality === "number") {
                    message.aggregationTemporality = object.aggregationTemporality;
                    break;
                  }
                  break;
                case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                case 0:
                  message.aggregationTemporality = 0;
                  break;
                case "AGGREGATION_TEMPORALITY_DELTA":
                case 1:
                  message.aggregationTemporality = 1;
                  break;
                case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                case 2:
                  message.aggregationTemporality = 2;
                  break;
              }
              if (object.isMonotonic != null)
                message.isMonotonic = Boolean(object.isMonotonic);
              return message;
            };
            Sum.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.dataPoints = [];
              if (options.defaults) {
                object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
                object.isMonotonic = false;
              }
              if (message.dataPoints && message.dataPoints.length) {
                object.dataPoints = [];
                for (var j = 0;j < message.dataPoints.length; ++j)
                  object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);
              }
              if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
              if (message.isMonotonic != null && message.hasOwnProperty("isMonotonic"))
                object.isMonotonic = message.isMonotonic;
              return object;
            };
            Sum.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Sum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Sum";
            };
            return Sum;
          }();
          v1.Histogram = function() {
            function Histogram(properties) {
              this.dataPoints = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Histogram.prototype.dataPoints = $util.emptyArray;
            Histogram.prototype.aggregationTemporality = null;
            Histogram.create = function create(properties) {
              return new Histogram(properties);
            };
            Histogram.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.dataPoints != null && message.dataPoints.length)
                for (var i = 0;i < message.dataPoints.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.encode(message.dataPoints[i], writer.uint32(10).fork()).ldelim();
              if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
                writer.uint32(16).int32(message.aggregationTemporality);
              return writer;
            };
            Histogram.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Histogram.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Histogram;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.dataPoints && message.dataPoints.length))
                      message.dataPoints = [];
                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.HistogramDataPoint.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.aggregationTemporality = reader.int32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Histogram.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Histogram.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                if (!Array.isArray(message.dataPoints))
                  return "dataPoints: array expected";
                for (var i = 0;i < message.dataPoints.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.verify(message.dataPoints[i]);
                  if (error)
                    return "dataPoints." + error;
                }
              }
              if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                switch (message.aggregationTemporality) {
                  default:
                    return "aggregationTemporality: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              return null;
            };
            Histogram.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.Histogram)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.Histogram;
              if (object.dataPoints) {
                if (!Array.isArray(object.dataPoints))
                  throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: array expected");
                message.dataPoints = [];
                for (var i = 0;i < object.dataPoints.length; ++i) {
                  if (typeof object.dataPoints[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: object expected");
                  message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.fromObject(object.dataPoints[i]);
                }
              }
              switch (object.aggregationTemporality) {
                default:
                  if (typeof object.aggregationTemporality === "number") {
                    message.aggregationTemporality = object.aggregationTemporality;
                    break;
                  }
                  break;
                case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                case 0:
                  message.aggregationTemporality = 0;
                  break;
                case "AGGREGATION_TEMPORALITY_DELTA":
                case 1:
                  message.aggregationTemporality = 1;
                  break;
                case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                case 2:
                  message.aggregationTemporality = 2;
                  break;
              }
              return message;
            };
            Histogram.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.dataPoints = [];
              if (options.defaults)
                object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
              if (message.dataPoints && message.dataPoints.length) {
                object.dataPoints = [];
                for (var j = 0;j < message.dataPoints.length; ++j)
                  object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.toObject(message.dataPoints[j], options);
              }
              if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
              return object;
            };
            Histogram.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Histogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Histogram";
            };
            return Histogram;
          }();
          v1.ExponentialHistogram = function() {
            function ExponentialHistogram(properties) {
              this.dataPoints = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ExponentialHistogram.prototype.dataPoints = $util.emptyArray;
            ExponentialHistogram.prototype.aggregationTemporality = null;
            ExponentialHistogram.create = function create(properties) {
              return new ExponentialHistogram(properties);
            };
            ExponentialHistogram.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.dataPoints != null && message.dataPoints.length)
                for (var i = 0;i < message.dataPoints.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.encode(message.dataPoints[i], writer.uint32(10).fork()).ldelim();
              if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
                writer.uint32(16).int32(message.aggregationTemporality);
              return writer;
            };
            ExponentialHistogram.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ExponentialHistogram.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.dataPoints && message.dataPoints.length))
                      message.dataPoints = [];
                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.aggregationTemporality = reader.int32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ExponentialHistogram.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ExponentialHistogram.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                if (!Array.isArray(message.dataPoints))
                  return "dataPoints: array expected";
                for (var i = 0;i < message.dataPoints.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify(message.dataPoints[i]);
                  if (error)
                    return "dataPoints." + error;
                }
              }
              if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                switch (message.aggregationTemporality) {
                  default:
                    return "aggregationTemporality: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              return null;
            };
            ExponentialHistogram.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogram)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram;
              if (object.dataPoints) {
                if (!Array.isArray(object.dataPoints))
                  throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: array expected");
                message.dataPoints = [];
                for (var i = 0;i < object.dataPoints.length; ++i) {
                  if (typeof object.dataPoints[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: object expected");
                  message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.fromObject(object.dataPoints[i]);
                }
              }
              switch (object.aggregationTemporality) {
                default:
                  if (typeof object.aggregationTemporality === "number") {
                    message.aggregationTemporality = object.aggregationTemporality;
                    break;
                  }
                  break;
                case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                case 0:
                  message.aggregationTemporality = 0;
                  break;
                case "AGGREGATION_TEMPORALITY_DELTA":
                case 1:
                  message.aggregationTemporality = 1;
                  break;
                case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                case 2:
                  message.aggregationTemporality = 2;
                  break;
              }
              return message;
            };
            ExponentialHistogram.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.dataPoints = [];
              if (options.defaults)
                object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
              if (message.dataPoints && message.dataPoints.length) {
                object.dataPoints = [];
                for (var j = 0;j < message.dataPoints.length; ++j)
                  object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.toObject(message.dataPoints[j], options);
              }
              if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
              return object;
            };
            ExponentialHistogram.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ExponentialHistogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogram";
            };
            return ExponentialHistogram;
          }();
          v1.Summary = function() {
            function Summary(properties) {
              this.dataPoints = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Summary.prototype.dataPoints = $util.emptyArray;
            Summary.create = function create(properties) {
              return new Summary(properties);
            };
            Summary.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.dataPoints != null && message.dataPoints.length)
                for (var i = 0;i < message.dataPoints.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.encode(message.dataPoints[i], writer.uint32(10).fork()).ldelim();
              return writer;
            };
            Summary.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Summary.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Summary;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.dataPoints && message.dataPoints.length))
                      message.dataPoints = [];
                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Summary.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Summary.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                if (!Array.isArray(message.dataPoints))
                  return "dataPoints: array expected";
                for (var i = 0;i < message.dataPoints.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.verify(message.dataPoints[i]);
                  if (error)
                    return "dataPoints." + error;
                }
              }
              return null;
            };
            Summary.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.Summary)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.Summary;
              if (object.dataPoints) {
                if (!Array.isArray(object.dataPoints))
                  throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: array expected");
                message.dataPoints = [];
                for (var i = 0;i < object.dataPoints.length; ++i) {
                  if (typeof object.dataPoints[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: object expected");
                  message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.fromObject(object.dataPoints[i]);
                }
              }
              return message;
            };
            Summary.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.dataPoints = [];
              if (message.dataPoints && message.dataPoints.length) {
                object.dataPoints = [];
                for (var j = 0;j < message.dataPoints.length; ++j)
                  object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.toObject(message.dataPoints[j], options);
              }
              return object;
            };
            Summary.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Summary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Summary";
            };
            return Summary;
          }();
          v1.AggregationTemporality = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AGGREGATION_TEMPORALITY_UNSPECIFIED"] = 0;
            values[valuesById[1] = "AGGREGATION_TEMPORALITY_DELTA"] = 1;
            values[valuesById[2] = "AGGREGATION_TEMPORALITY_CUMULATIVE"] = 2;
            return values;
          }();
          v1.DataPointFlags = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DATA_POINT_FLAGS_DO_NOT_USE"] = 0;
            values[valuesById[1] = "DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK"] = 1;
            return values;
          }();
          v1.NumberDataPoint = function() {
            function NumberDataPoint(properties) {
              this.attributes = [];
              this.exemplars = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            NumberDataPoint.prototype.attributes = $util.emptyArray;
            NumberDataPoint.prototype.startTimeUnixNano = null;
            NumberDataPoint.prototype.timeUnixNano = null;
            NumberDataPoint.prototype.asDouble = null;
            NumberDataPoint.prototype.asInt = null;
            NumberDataPoint.prototype.exemplars = $util.emptyArray;
            NumberDataPoint.prototype.flags = null;
            var $oneOfFields;
            Object.defineProperty(NumberDataPoint.prototype, "value", {
              get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            NumberDataPoint.create = function create(properties) {
              return new NumberDataPoint(properties);
            };
            NumberDataPoint.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                writer.uint32(17).fixed64(message.startTimeUnixNano);
              if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                writer.uint32(25).fixed64(message.timeUnixNano);
              if (message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble"))
                writer.uint32(33).double(message.asDouble);
              if (message.exemplars != null && message.exemplars.length)
                for (var i = 0;i < message.exemplars.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(42).fork()).ldelim();
              if (message.asInt != null && Object.hasOwnProperty.call(message, "asInt"))
                writer.uint32(49).sfixed64(message.asInt);
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(58).fork()).ldelim();
              if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(64).uint32(message.flags);
              return writer;
            };
            NumberDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            NumberDataPoint.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 7: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.startTimeUnixNano = reader.fixed64();
                    break;
                  }
                  case 3: {
                    message.timeUnixNano = reader.fixed64();
                    break;
                  }
                  case 4: {
                    message.asDouble = reader.double();
                    break;
                  }
                  case 6: {
                    message.asInt = reader.sfixed64();
                    break;
                  }
                  case 5: {
                    if (!(message.exemplars && message.exemplars.length))
                      message.exemplars = [];
                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                    break;
                  }
                  case 8: {
                    message.flags = reader.uint32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            NumberDataPoint.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            NumberDataPoint.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
              }
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
              }
              if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                properties.value = 1;
                if (typeof message.asDouble !== "number")
                  return "asDouble: number expected";
              }
              if (message.asInt != null && message.hasOwnProperty("asInt")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
                  return "asInt: integer|Long expected";
              }
              if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                if (!Array.isArray(message.exemplars))
                  return "exemplars: array expected";
                for (var i = 0;i < message.exemplars.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
                  if (error)
                    return "exemplars." + error;
                }
              }
              if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!$util.isInteger(message.flags))
                  return "flags: integer expected";
              }
              return null;
            };
            NumberDataPoint.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.NumberDataPoint)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint;
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.startTimeUnixNano != null) {
                if ($util.Long)
                  (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
                else if (typeof object.startTimeUnixNano === "string")
                  message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
                else if (typeof object.startTimeUnixNano === "number")
                  message.startTimeUnixNano = object.startTimeUnixNano;
                else if (typeof object.startTimeUnixNano === "object")
                  message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
              }
              if (object.timeUnixNano != null) {
                if ($util.Long)
                  (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                else if (typeof object.timeUnixNano === "string")
                  message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                else if (typeof object.timeUnixNano === "number")
                  message.timeUnixNano = object.timeUnixNano;
                else if (typeof object.timeUnixNano === "object")
                  message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
              }
              if (object.asDouble != null)
                message.asDouble = Number(object.asDouble);
              if (object.asInt != null) {
                if ($util.Long)
                  (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;
                else if (typeof object.asInt === "string")
                  message.asInt = parseInt(object.asInt, 10);
                else if (typeof object.asInt === "number")
                  message.asInt = object.asInt;
                else if (typeof object.asInt === "object")
                  message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();
              }
              if (object.exemplars) {
                if (!Array.isArray(object.exemplars))
                  throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: array expected");
                message.exemplars = [];
                for (var i = 0;i < object.exemplars.length; ++i) {
                  if (typeof object.exemplars[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: object expected");
                  message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
                }
              }
              if (object.flags != null)
                message.flags = object.flags >>> 0;
              return message;
            };
            NumberDataPoint.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                object.exemplars = [];
                object.attributes = [];
              }
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.startTimeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.timeUnixNano = options.longs === String ? "0" : 0;
                object.flags = 0;
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                if (typeof message.startTimeUnixNano === "number")
                  object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                else
                  object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                if (typeof message.timeUnixNano === "number")
                  object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                else
                  object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
              if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;
                if (options.oneofs)
                  object.value = "asDouble";
              }
              if (message.exemplars && message.exemplars.length) {
                object.exemplars = [];
                for (var j = 0;j < message.exemplars.length; ++j)
                  object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
              }
              if (message.asInt != null && message.hasOwnProperty("asInt")) {
                if (typeof message.asInt === "number")
                  object.asInt = options.longs === String ? String(message.asInt) : message.asInt;
                else
                  object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;
                if (options.oneofs)
                  object.value = "asInt";
              }
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
              return object;
            };
            NumberDataPoint.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            NumberDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.NumberDataPoint";
            };
            return NumberDataPoint;
          }();
          v1.HistogramDataPoint = function() {
            function HistogramDataPoint(properties) {
              this.attributes = [];
              this.bucketCounts = [];
              this.explicitBounds = [];
              this.exemplars = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            HistogramDataPoint.prototype.attributes = $util.emptyArray;
            HistogramDataPoint.prototype.startTimeUnixNano = null;
            HistogramDataPoint.prototype.timeUnixNano = null;
            HistogramDataPoint.prototype.count = null;
            HistogramDataPoint.prototype.sum = null;
            HistogramDataPoint.prototype.bucketCounts = $util.emptyArray;
            HistogramDataPoint.prototype.explicitBounds = $util.emptyArray;
            HistogramDataPoint.prototype.exemplars = $util.emptyArray;
            HistogramDataPoint.prototype.flags = null;
            HistogramDataPoint.prototype.min = null;
            HistogramDataPoint.prototype.max = null;
            var $oneOfFields;
            Object.defineProperty(HistogramDataPoint.prototype, "_sum", {
              get: $util.oneOfGetter($oneOfFields = ["sum"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Object.defineProperty(HistogramDataPoint.prototype, "_min", {
              get: $util.oneOfGetter($oneOfFields = ["min"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Object.defineProperty(HistogramDataPoint.prototype, "_max", {
              get: $util.oneOfGetter($oneOfFields = ["max"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            HistogramDataPoint.create = function create(properties) {
              return new HistogramDataPoint(properties);
            };
            HistogramDataPoint.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                writer.uint32(17).fixed64(message.startTimeUnixNano);
              if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                writer.uint32(25).fixed64(message.timeUnixNano);
              if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(33).fixed64(message.count);
              if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                writer.uint32(41).double(message.sum);
              if (message.bucketCounts != null && message.bucketCounts.length) {
                writer.uint32(50).fork();
                for (var i = 0;i < message.bucketCounts.length; ++i)
                  writer.fixed64(message.bucketCounts[i]);
                writer.ldelim();
              }
              if (message.explicitBounds != null && message.explicitBounds.length) {
                writer.uint32(58).fork();
                for (var i = 0;i < message.explicitBounds.length; ++i)
                  writer.double(message.explicitBounds[i]);
                writer.ldelim();
              }
              if (message.exemplars != null && message.exemplars.length)
                for (var i = 0;i < message.exemplars.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(66).fork()).ldelim();
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(74).fork()).ldelim();
              if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(80).uint32(message.flags);
              if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                writer.uint32(89).double(message.min);
              if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                writer.uint32(97).double(message.max);
              return writer;
            };
            HistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            HistogramDataPoint.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 9: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.startTimeUnixNano = reader.fixed64();
                    break;
                  }
                  case 3: {
                    message.timeUnixNano = reader.fixed64();
                    break;
                  }
                  case 4: {
                    message.count = reader.fixed64();
                    break;
                  }
                  case 5: {
                    message.sum = reader.double();
                    break;
                  }
                  case 6: {
                    if (!(message.bucketCounts && message.bucketCounts.length))
                      message.bucketCounts = [];
                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;
                      while (reader.pos < end2)
                        message.bucketCounts.push(reader.fixed64());
                    } else
                      message.bucketCounts.push(reader.fixed64());
                    break;
                  }
                  case 7: {
                    if (!(message.explicitBounds && message.explicitBounds.length))
                      message.explicitBounds = [];
                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;
                      while (reader.pos < end2)
                        message.explicitBounds.push(reader.double());
                    } else
                      message.explicitBounds.push(reader.double());
                    break;
                  }
                  case 8: {
                    if (!(message.exemplars && message.exemplars.length))
                      message.exemplars = [];
                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                    break;
                  }
                  case 10: {
                    message.flags = reader.uint32();
                    break;
                  }
                  case 11: {
                    message.min = reader.double();
                    break;
                  }
                  case 12: {
                    message.max = reader.double();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            HistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            HistogramDataPoint.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
              }
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
              }
              if (message.count != null && message.hasOwnProperty("count")) {
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                  return "count: integer|Long expected";
              }
              if (message.sum != null && message.hasOwnProperty("sum")) {
                properties._sum = 1;
                if (typeof message.sum !== "number")
                  return "sum: number expected";
              }
              if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
                if (!Array.isArray(message.bucketCounts))
                  return "bucketCounts: array expected";
                for (var i = 0;i < message.bucketCounts.length; ++i)
                  if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))
                    return "bucketCounts: integer|Long[] expected";
              }
              if (message.explicitBounds != null && message.hasOwnProperty("explicitBounds")) {
                if (!Array.isArray(message.explicitBounds))
                  return "explicitBounds: array expected";
                for (var i = 0;i < message.explicitBounds.length; ++i)
                  if (typeof message.explicitBounds[i] !== "number")
                    return "explicitBounds: number[] expected";
              }
              if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                if (!Array.isArray(message.exemplars))
                  return "exemplars: array expected";
                for (var i = 0;i < message.exemplars.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
                  if (error)
                    return "exemplars." + error;
                }
              }
              if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!$util.isInteger(message.flags))
                  return "flags: integer expected";
              }
              if (message.min != null && message.hasOwnProperty("min")) {
                properties._min = 1;
                if (typeof message.min !== "number")
                  return "min: number expected";
              }
              if (message.max != null && message.hasOwnProperty("max")) {
                properties._max = 1;
                if (typeof message.max !== "number")
                  return "max: number expected";
              }
              return null;
            };
            HistogramDataPoint.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.HistogramDataPoint)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint;
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.startTimeUnixNano != null) {
                if ($util.Long)
                  (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
                else if (typeof object.startTimeUnixNano === "string")
                  message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
                else if (typeof object.startTimeUnixNano === "number")
                  message.startTimeUnixNano = object.startTimeUnixNano;
                else if (typeof object.startTimeUnixNano === "object")
                  message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
              }
              if (object.timeUnixNano != null) {
                if ($util.Long)
                  (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                else if (typeof object.timeUnixNano === "string")
                  message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                else if (typeof object.timeUnixNano === "number")
                  message.timeUnixNano = object.timeUnixNano;
                else if (typeof object.timeUnixNano === "object")
                  message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
              }
              if (object.count != null) {
                if ($util.Long)
                  (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                  message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                  message.count = object.count;
                else if (typeof object.count === "object")
                  message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
              }
              if (object.sum != null)
                message.sum = Number(object.sum);
              if (object.bucketCounts) {
                if (!Array.isArray(object.bucketCounts))
                  throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.bucketCounts: array expected");
                message.bucketCounts = [];
                for (var i = 0;i < object.bucketCounts.length; ++i)
                  if ($util.Long)
                    (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = false;
                  else if (typeof object.bucketCounts[i] === "string")
                    message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);
                  else if (typeof object.bucketCounts[i] === "number")
                    message.bucketCounts[i] = object.bucketCounts[i];
                  else if (typeof object.bucketCounts[i] === "object")
                    message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber();
              }
              if (object.explicitBounds) {
                if (!Array.isArray(object.explicitBounds))
                  throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.explicitBounds: array expected");
                message.explicitBounds = [];
                for (var i = 0;i < object.explicitBounds.length; ++i)
                  message.explicitBounds[i] = Number(object.explicitBounds[i]);
              }
              if (object.exemplars) {
                if (!Array.isArray(object.exemplars))
                  throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: array expected");
                message.exemplars = [];
                for (var i = 0;i < object.exemplars.length; ++i) {
                  if (typeof object.exemplars[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: object expected");
                  message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
                }
              }
              if (object.flags != null)
                message.flags = object.flags >>> 0;
              if (object.min != null)
                message.min = Number(object.min);
              if (object.max != null)
                message.max = Number(object.max);
              return message;
            };
            HistogramDataPoint.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                object.bucketCounts = [];
                object.explicitBounds = [];
                object.exemplars = [];
                object.attributes = [];
              }
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.startTimeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.timeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.count = options.longs === String ? "0" : 0;
                object.flags = 0;
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                if (typeof message.startTimeUnixNano === "number")
                  object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                else
                  object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                if (typeof message.timeUnixNano === "number")
                  object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                else
                  object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
              if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                  object.count = options.longs === String ? String(message.count) : message.count;
                else
                  object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
              if (message.sum != null && message.hasOwnProperty("sum")) {
                object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
                if (options.oneofs)
                  object._sum = "sum";
              }
              if (message.bucketCounts && message.bucketCounts.length) {
                object.bucketCounts = [];
                for (var j = 0;j < message.bucketCounts.length; ++j)
                  if (typeof message.bucketCounts[j] === "number")
                    object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];
                  else
                    object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber() : message.bucketCounts[j];
              }
              if (message.explicitBounds && message.explicitBounds.length) {
                object.explicitBounds = [];
                for (var j = 0;j < message.explicitBounds.length; ++j)
                  object.explicitBounds[j] = options.json && !isFinite(message.explicitBounds[j]) ? String(message.explicitBounds[j]) : message.explicitBounds[j];
              }
              if (message.exemplars && message.exemplars.length) {
                object.exemplars = [];
                for (var j = 0;j < message.exemplars.length; ++j)
                  object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
              }
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
              if (message.min != null && message.hasOwnProperty("min")) {
                object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                if (options.oneofs)
                  object._min = "min";
              }
              if (message.max != null && message.hasOwnProperty("max")) {
                object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                if (options.oneofs)
                  object._max = "max";
              }
              return object;
            };
            HistogramDataPoint.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            HistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.HistogramDataPoint";
            };
            return HistogramDataPoint;
          }();
          v1.ExponentialHistogramDataPoint = function() {
            function ExponentialHistogramDataPoint(properties) {
              this.attributes = [];
              this.exemplars = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ExponentialHistogramDataPoint.prototype.attributes = $util.emptyArray;
            ExponentialHistogramDataPoint.prototype.startTimeUnixNano = null;
            ExponentialHistogramDataPoint.prototype.timeUnixNano = null;
            ExponentialHistogramDataPoint.prototype.count = null;
            ExponentialHistogramDataPoint.prototype.sum = null;
            ExponentialHistogramDataPoint.prototype.scale = null;
            ExponentialHistogramDataPoint.prototype.zeroCount = null;
            ExponentialHistogramDataPoint.prototype.positive = null;
            ExponentialHistogramDataPoint.prototype.negative = null;
            ExponentialHistogramDataPoint.prototype.flags = null;
            ExponentialHistogramDataPoint.prototype.exemplars = $util.emptyArray;
            ExponentialHistogramDataPoint.prototype.min = null;
            ExponentialHistogramDataPoint.prototype.max = null;
            ExponentialHistogramDataPoint.prototype.zeroThreshold = null;
            var $oneOfFields;
            Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_sum", {
              get: $util.oneOfGetter($oneOfFields = ["sum"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_min", {
              get: $util.oneOfGetter($oneOfFields = ["min"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_max", {
              get: $util.oneOfGetter($oneOfFields = ["max"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            ExponentialHistogramDataPoint.create = function create(properties) {
              return new ExponentialHistogramDataPoint(properties);
            };
            ExponentialHistogramDataPoint.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(10).fork()).ldelim();
              if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                writer.uint32(17).fixed64(message.startTimeUnixNano);
              if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                writer.uint32(25).fixed64(message.timeUnixNano);
              if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(33).fixed64(message.count);
              if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                writer.uint32(41).double(message.sum);
              if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(48).sint32(message.scale);
              if (message.zeroCount != null && Object.hasOwnProperty.call(message, "zeroCount"))
                writer.uint32(57).fixed64(message.zeroCount);
              if (message.positive != null && Object.hasOwnProperty.call(message, "positive"))
                $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.positive, writer.uint32(66).fork()).ldelim();
              if (message.negative != null && Object.hasOwnProperty.call(message, "negative"))
                $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.negative, writer.uint32(74).fork()).ldelim();
              if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(80).uint32(message.flags);
              if (message.exemplars != null && message.exemplars.length)
                for (var i = 0;i < message.exemplars.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(90).fork()).ldelim();
              if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                writer.uint32(97).double(message.min);
              if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                writer.uint32(105).double(message.max);
              if (message.zeroThreshold != null && Object.hasOwnProperty.call(message, "zeroThreshold"))
                writer.uint32(113).double(message.zeroThreshold);
              return writer;
            };
            ExponentialHistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ExponentialHistogramDataPoint.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.startTimeUnixNano = reader.fixed64();
                    break;
                  }
                  case 3: {
                    message.timeUnixNano = reader.fixed64();
                    break;
                  }
                  case 4: {
                    message.count = reader.fixed64();
                    break;
                  }
                  case 5: {
                    message.sum = reader.double();
                    break;
                  }
                  case 6: {
                    message.scale = reader.sint32();
                    break;
                  }
                  case 7: {
                    message.zeroCount = reader.fixed64();
                    break;
                  }
                  case 8: {
                    message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
                    break;
                  }
                  case 9: {
                    message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
                    break;
                  }
                  case 10: {
                    message.flags = reader.uint32();
                    break;
                  }
                  case 11: {
                    if (!(message.exemplars && message.exemplars.length))
                      message.exemplars = [];
                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                    break;
                  }
                  case 12: {
                    message.min = reader.double();
                    break;
                  }
                  case 13: {
                    message.max = reader.double();
                    break;
                  }
                  case 14: {
                    message.zeroThreshold = reader.double();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ExponentialHistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ExponentialHistogramDataPoint.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
              }
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
              }
              if (message.count != null && message.hasOwnProperty("count")) {
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                  return "count: integer|Long expected";
              }
              if (message.sum != null && message.hasOwnProperty("sum")) {
                properties._sum = 1;
                if (typeof message.sum !== "number")
                  return "sum: number expected";
              }
              if (message.scale != null && message.hasOwnProperty("scale")) {
                if (!$util.isInteger(message.scale))
                  return "scale: integer expected";
              }
              if (message.zeroCount != null && message.hasOwnProperty("zeroCount")) {
                if (!$util.isInteger(message.zeroCount) && !(message.zeroCount && $util.isInteger(message.zeroCount.low) && $util.isInteger(message.zeroCount.high)))
                  return "zeroCount: integer|Long expected";
              }
              if (message.positive != null && message.hasOwnProperty("positive")) {
                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.positive);
                if (error)
                  return "positive." + error;
              }
              if (message.negative != null && message.hasOwnProperty("negative")) {
                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.negative);
                if (error)
                  return "negative." + error;
              }
              if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!$util.isInteger(message.flags))
                  return "flags: integer expected";
              }
              if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                if (!Array.isArray(message.exemplars))
                  return "exemplars: array expected";
                for (var i = 0;i < message.exemplars.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
                  if (error)
                    return "exemplars." + error;
                }
              }
              if (message.min != null && message.hasOwnProperty("min")) {
                properties._min = 1;
                if (typeof message.min !== "number")
                  return "min: number expected";
              }
              if (message.max != null && message.hasOwnProperty("max")) {
                properties._max = 1;
                if (typeof message.max !== "number")
                  return "max: number expected";
              }
              if (message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold")) {
                if (typeof message.zeroThreshold !== "number")
                  return "zeroThreshold: number expected";
              }
              return null;
            };
            ExponentialHistogramDataPoint.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint;
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.startTimeUnixNano != null) {
                if ($util.Long)
                  (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
                else if (typeof object.startTimeUnixNano === "string")
                  message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
                else if (typeof object.startTimeUnixNano === "number")
                  message.startTimeUnixNano = object.startTimeUnixNano;
                else if (typeof object.startTimeUnixNano === "object")
                  message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
              }
              if (object.timeUnixNano != null) {
                if ($util.Long)
                  (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                else if (typeof object.timeUnixNano === "string")
                  message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                else if (typeof object.timeUnixNano === "number")
                  message.timeUnixNano = object.timeUnixNano;
                else if (typeof object.timeUnixNano === "object")
                  message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
              }
              if (object.count != null) {
                if ($util.Long)
                  (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                  message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                  message.count = object.count;
                else if (typeof object.count === "object")
                  message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
              }
              if (object.sum != null)
                message.sum = Number(object.sum);
              if (object.scale != null)
                message.scale = object.scale | 0;
              if (object.zeroCount != null) {
                if ($util.Long)
                  (message.zeroCount = $util.Long.fromValue(object.zeroCount)).unsigned = false;
                else if (typeof object.zeroCount === "string")
                  message.zeroCount = parseInt(object.zeroCount, 10);
                else if (typeof object.zeroCount === "number")
                  message.zeroCount = object.zeroCount;
                else if (typeof object.zeroCount === "object")
                  message.zeroCount = new $util.LongBits(object.zeroCount.low >>> 0, object.zeroCount.high >>> 0).toNumber();
              }
              if (object.positive != null) {
                if (typeof object.positive !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.positive: object expected");
                message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.positive);
              }
              if (object.negative != null) {
                if (typeof object.negative !== "object")
                  throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.negative: object expected");
                message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.negative);
              }
              if (object.flags != null)
                message.flags = object.flags >>> 0;
              if (object.exemplars) {
                if (!Array.isArray(object.exemplars))
                  throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: array expected");
                message.exemplars = [];
                for (var i = 0;i < object.exemplars.length; ++i) {
                  if (typeof object.exemplars[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: object expected");
                  message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
                }
              }
              if (object.min != null)
                message.min = Number(object.min);
              if (object.max != null)
                message.max = Number(object.max);
              if (object.zeroThreshold != null)
                message.zeroThreshold = Number(object.zeroThreshold);
              return message;
            };
            ExponentialHistogramDataPoint.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                object.attributes = [];
                object.exemplars = [];
              }
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.startTimeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.timeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.count = options.longs === String ? "0" : 0;
                object.scale = 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.zeroCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.zeroCount = options.longs === String ? "0" : 0;
                object.positive = null;
                object.negative = null;
                object.flags = 0;
                object.zeroThreshold = 0;
              }
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                if (typeof message.startTimeUnixNano === "number")
                  object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                else
                  object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                if (typeof message.timeUnixNano === "number")
                  object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                else
                  object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
              if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                  object.count = options.longs === String ? String(message.count) : message.count;
                else
                  object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
              if (message.sum != null && message.hasOwnProperty("sum")) {
                object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
                if (options.oneofs)
                  object._sum = "sum";
              }
              if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = message.scale;
              if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
                if (typeof message.zeroCount === "number")
                  object.zeroCount = options.longs === String ? String(message.zeroCount) : message.zeroCount;
                else
                  object.zeroCount = options.longs === String ? $util.Long.prototype.toString.call(message.zeroCount) : options.longs === Number ? new $util.LongBits(message.zeroCount.low >>> 0, message.zeroCount.high >>> 0).toNumber() : message.zeroCount;
              if (message.positive != null && message.hasOwnProperty("positive"))
                object.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.positive, options);
              if (message.negative != null && message.hasOwnProperty("negative"))
                object.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.negative, options);
              if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
              if (message.exemplars && message.exemplars.length) {
                object.exemplars = [];
                for (var j = 0;j < message.exemplars.length; ++j)
                  object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
              }
              if (message.min != null && message.hasOwnProperty("min")) {
                object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                if (options.oneofs)
                  object._min = "min";
              }
              if (message.max != null && message.hasOwnProperty("max")) {
                object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                if (options.oneofs)
                  object._max = "max";
              }
              if (message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold"))
                object.zeroThreshold = options.json && !isFinite(message.zeroThreshold) ? String(message.zeroThreshold) : message.zeroThreshold;
              return object;
            };
            ExponentialHistogramDataPoint.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ExponentialHistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint";
            };
            ExponentialHistogramDataPoint.Buckets = function() {
              function Buckets(properties) {
                this.bucketCounts = [];
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              Buckets.prototype.offset = null;
              Buckets.prototype.bucketCounts = $util.emptyArray;
              Buckets.create = function create(properties) {
                return new Buckets(properties);
              };
              Buckets.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                  writer.uint32(8).sint32(message.offset);
                if (message.bucketCounts != null && message.bucketCounts.length) {
                  writer.uint32(18).fork();
                  for (var i = 0;i < message.bucketCounts.length; ++i)
                    writer.uint64(message.bucketCounts[i]);
                  writer.ldelim();
                }
                return writer;
              };
              Buckets.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Buckets.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.offset = reader.sint32();
                      break;
                    }
                    case 2: {
                      if (!(message.bucketCounts && message.bucketCounts.length))
                        message.bucketCounts = [];
                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                          message.bucketCounts.push(reader.uint64());
                      } else
                        message.bucketCounts.push(reader.uint64());
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              Buckets.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Buckets.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.offset != null && message.hasOwnProperty("offset")) {
                  if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
                }
                if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
                  if (!Array.isArray(message.bucketCounts))
                    return "bucketCounts: array expected";
                  for (var i = 0;i < message.bucketCounts.length; ++i)
                    if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))
                      return "bucketCounts: integer|Long[] expected";
                }
                return null;
              };
              Buckets.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets;
                if (object.offset != null)
                  message.offset = object.offset | 0;
                if (object.bucketCounts) {
                  if (!Array.isArray(object.bucketCounts))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.bucketCounts: array expected");
                  message.bucketCounts = [];
                  for (var i = 0;i < object.bucketCounts.length; ++i)
                    if ($util.Long)
                      (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = true;
                    else if (typeof object.bucketCounts[i] === "string")
                      message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);
                    else if (typeof object.bucketCounts[i] === "number")
                      message.bucketCounts[i] = object.bucketCounts[i];
                    else if (typeof object.bucketCounts[i] === "object")
                      message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber(true);
                }
                return message;
              };
              Buckets.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.arrays || options.defaults)
                  object.bucketCounts = [];
                if (options.defaults)
                  object.offset = 0;
                if (message.offset != null && message.hasOwnProperty("offset"))
                  object.offset = message.offset;
                if (message.bucketCounts && message.bucketCounts.length) {
                  object.bucketCounts = [];
                  for (var j = 0;j < message.bucketCounts.length; ++j)
                    if (typeof message.bucketCounts[j] === "number")
                      object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];
                    else
                      object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber(true) : message.bucketCounts[j];
                }
                return object;
              };
              Buckets.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Buckets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets";
              };
              return Buckets;
            }();
            return ExponentialHistogramDataPoint;
          }();
          v1.SummaryDataPoint = function() {
            function SummaryDataPoint(properties) {
              this.attributes = [];
              this.quantileValues = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            SummaryDataPoint.prototype.attributes = $util.emptyArray;
            SummaryDataPoint.prototype.startTimeUnixNano = null;
            SummaryDataPoint.prototype.timeUnixNano = null;
            SummaryDataPoint.prototype.count = null;
            SummaryDataPoint.prototype.sum = null;
            SummaryDataPoint.prototype.quantileValues = $util.emptyArray;
            SummaryDataPoint.prototype.flags = null;
            SummaryDataPoint.create = function create(properties) {
              return new SummaryDataPoint(properties);
            };
            SummaryDataPoint.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                writer.uint32(17).fixed64(message.startTimeUnixNano);
              if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                writer.uint32(25).fixed64(message.timeUnixNano);
              if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(33).fixed64(message.count);
              if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                writer.uint32(41).double(message.sum);
              if (message.quantileValues != null && message.quantileValues.length)
                for (var i = 0;i < message.quantileValues.length; ++i)
                  $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.encode(message.quantileValues[i], writer.uint32(50).fork()).ldelim();
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(58).fork()).ldelim();
              if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(64).uint32(message.flags);
              return writer;
            };
            SummaryDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            SummaryDataPoint.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 7: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.startTimeUnixNano = reader.fixed64();
                    break;
                  }
                  case 3: {
                    message.timeUnixNano = reader.fixed64();
                    break;
                  }
                  case 4: {
                    message.count = reader.fixed64();
                    break;
                  }
                  case 5: {
                    message.sum = reader.double();
                    break;
                  }
                  case 6: {
                    if (!(message.quantileValues && message.quantileValues.length))
                      message.quantileValues = [];
                    message.quantileValues.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.decode(reader, reader.uint32()));
                    break;
                  }
                  case 8: {
                    message.flags = reader.uint32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            SummaryDataPoint.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            SummaryDataPoint.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
              }
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
              }
              if (message.count != null && message.hasOwnProperty("count")) {
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                  return "count: integer|Long expected";
              }
              if (message.sum != null && message.hasOwnProperty("sum")) {
                if (typeof message.sum !== "number")
                  return "sum: number expected";
              }
              if (message.quantileValues != null && message.hasOwnProperty("quantileValues")) {
                if (!Array.isArray(message.quantileValues))
                  return "quantileValues: array expected";
                for (var i = 0;i < message.quantileValues.length; ++i) {
                  var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify(message.quantileValues[i]);
                  if (error)
                    return "quantileValues." + error;
                }
              }
              if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!$util.isInteger(message.flags))
                  return "flags: integer expected";
              }
              return null;
            };
            SummaryDataPoint.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint;
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.startTimeUnixNano != null) {
                if ($util.Long)
                  (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
                else if (typeof object.startTimeUnixNano === "string")
                  message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
                else if (typeof object.startTimeUnixNano === "number")
                  message.startTimeUnixNano = object.startTimeUnixNano;
                else if (typeof object.startTimeUnixNano === "object")
                  message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
              }
              if (object.timeUnixNano != null) {
                if ($util.Long)
                  (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                else if (typeof object.timeUnixNano === "string")
                  message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                else if (typeof object.timeUnixNano === "number")
                  message.timeUnixNano = object.timeUnixNano;
                else if (typeof object.timeUnixNano === "object")
                  message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
              }
              if (object.count != null) {
                if ($util.Long)
                  (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                  message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                  message.count = object.count;
                else if (typeof object.count === "object")
                  message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
              }
              if (object.sum != null)
                message.sum = Number(object.sum);
              if (object.quantileValues) {
                if (!Array.isArray(object.quantileValues))
                  throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: array expected");
                message.quantileValues = [];
                for (var i = 0;i < object.quantileValues.length; ++i) {
                  if (typeof object.quantileValues[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: object expected");
                  message.quantileValues[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.fromObject(object.quantileValues[i]);
                }
              }
              if (object.flags != null)
                message.flags = object.flags >>> 0;
              return message;
            };
            SummaryDataPoint.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                object.quantileValues = [];
                object.attributes = [];
              }
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.startTimeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.timeUnixNano = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.count = options.longs === String ? "0" : 0;
                object.sum = 0;
                object.flags = 0;
              }
              if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                if (typeof message.startTimeUnixNano === "number")
                  object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                else
                  object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                if (typeof message.timeUnixNano === "number")
                  object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                else
                  object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
              if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                  object.count = options.longs === String ? String(message.count) : message.count;
                else
                  object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
              if (message.sum != null && message.hasOwnProperty("sum"))
                object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
              if (message.quantileValues && message.quantileValues.length) {
                object.quantileValues = [];
                for (var j = 0;j < message.quantileValues.length; ++j)
                  object.quantileValues[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.toObject(message.quantileValues[j], options);
              }
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
              return object;
            };
            SummaryDataPoint.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            SummaryDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint";
            };
            SummaryDataPoint.ValueAtQuantile = function() {
              function ValueAtQuantile(properties) {
                if (properties) {
                  for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
                }
              }
              ValueAtQuantile.prototype.quantile = null;
              ValueAtQuantile.prototype.value = null;
              ValueAtQuantile.create = function create(properties) {
                return new ValueAtQuantile(properties);
              };
              ValueAtQuantile.encode = function encode(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.quantile != null && Object.hasOwnProperty.call(message, "quantile"))
                  writer.uint32(9).double(message.quantile);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                  writer.uint32(17).double(message.value);
                return writer;
              };
              ValueAtQuantile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ValueAtQuantile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile;
                while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.quantile = reader.double();
                      break;
                    }
                    case 2: {
                      message.value = reader.double();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };
              ValueAtQuantile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ValueAtQuantile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.quantile != null && message.hasOwnProperty("quantile")) {
                  if (typeof message.quantile !== "number")
                    return "quantile: number expected";
                }
                if (message.value != null && message.hasOwnProperty("value")) {
                  if (typeof message.value !== "number")
                    return "value: number expected";
                }
                return null;
              };
              ValueAtQuantile.fromObject = function fromObject(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile;
                if (object.quantile != null)
                  message.quantile = Number(object.quantile);
                if (object.value != null)
                  message.value = Number(object.value);
                return message;
              };
              ValueAtQuantile.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object = {};
                if (options.defaults) {
                  object.quantile = 0;
                  object.value = 0;
                }
                if (message.quantile != null && message.hasOwnProperty("quantile"))
                  object.quantile = options.json && !isFinite(message.quantile) ? String(message.quantile) : message.quantile;
                if (message.value != null && message.hasOwnProperty("value"))
                  object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
              };
              ValueAtQuantile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ValueAtQuantile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile";
              };
              return ValueAtQuantile;
            }();
            return SummaryDataPoint;
          }();
          v1.Exemplar = function() {
            function Exemplar(properties) {
              this.filteredAttributes = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Exemplar.prototype.filteredAttributes = $util.emptyArray;
            Exemplar.prototype.timeUnixNano = null;
            Exemplar.prototype.asDouble = null;
            Exemplar.prototype.asInt = null;
            Exemplar.prototype.spanId = null;
            Exemplar.prototype.traceId = null;
            var $oneOfFields;
            Object.defineProperty(Exemplar.prototype, "value", {
              get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Exemplar.create = function create(properties) {
              return new Exemplar(properties);
            };
            Exemplar.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                writer.uint32(17).fixed64(message.timeUnixNano);
              if (message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble"))
                writer.uint32(25).double(message.asDouble);
              if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                writer.uint32(34).bytes(message.spanId);
              if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                writer.uint32(42).bytes(message.traceId);
              if (message.asInt != null && Object.hasOwnProperty.call(message, "asInt"))
                writer.uint32(49).sfixed64(message.asInt);
              if (message.filteredAttributes != null && message.filteredAttributes.length)
                for (var i = 0;i < message.filteredAttributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.filteredAttributes[i], writer.uint32(58).fork()).ldelim();
              return writer;
            };
            Exemplar.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Exemplar.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Exemplar;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 7: {
                    if (!(message.filteredAttributes && message.filteredAttributes.length))
                      message.filteredAttributes = [];
                    message.filteredAttributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 2: {
                    message.timeUnixNano = reader.fixed64();
                    break;
                  }
                  case 3: {
                    message.asDouble = reader.double();
                    break;
                  }
                  case 6: {
                    message.asInt = reader.sfixed64();
                    break;
                  }
                  case 4: {
                    message.spanId = reader.bytes();
                    break;
                  }
                  case 5: {
                    message.traceId = reader.bytes();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Exemplar.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Exemplar.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.filteredAttributes != null && message.hasOwnProperty("filteredAttributes")) {
                if (!Array.isArray(message.filteredAttributes))
                  return "filteredAttributes: array expected";
                for (var i = 0;i < message.filteredAttributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.filteredAttributes[i]);
                  if (error)
                    return "filteredAttributes." + error;
                }
              }
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
              }
              if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                properties.value = 1;
                if (typeof message.asDouble !== "number")
                  return "asDouble: number expected";
              }
              if (message.asInt != null && message.hasOwnProperty("asInt")) {
                if (properties.value === 1)
                  return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
                  return "asInt: integer|Long expected";
              }
              if (message.spanId != null && message.hasOwnProperty("spanId")) {
                if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                  return "spanId: buffer expected";
              }
              if (message.traceId != null && message.hasOwnProperty("traceId")) {
                if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                  return "traceId: buffer expected";
              }
              return null;
            };
            Exemplar.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.metrics.v1.Exemplar)
                return object;
              var message = new $root.opentelemetry.proto.metrics.v1.Exemplar;
              if (object.filteredAttributes) {
                if (!Array.isArray(object.filteredAttributes))
                  throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: array expected");
                message.filteredAttributes = [];
                for (var i = 0;i < object.filteredAttributes.length; ++i) {
                  if (typeof object.filteredAttributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: object expected");
                  message.filteredAttributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.filteredAttributes[i]);
                }
              }
              if (object.timeUnixNano != null) {
                if ($util.Long)
                  (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                else if (typeof object.timeUnixNano === "string")
                  message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                else if (typeof object.timeUnixNano === "number")
                  message.timeUnixNano = object.timeUnixNano;
                else if (typeof object.timeUnixNano === "object")
                  message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
              }
              if (object.asDouble != null)
                message.asDouble = Number(object.asDouble);
              if (object.asInt != null) {
                if ($util.Long)
                  (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;
                else if (typeof object.asInt === "string")
                  message.asInt = parseInt(object.asInt, 10);
                else if (typeof object.asInt === "number")
                  message.asInt = object.asInt;
                else if (typeof object.asInt === "object")
                  message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();
              }
              if (object.spanId != null) {
                if (typeof object.spanId === "string")
                  $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
                else if (object.spanId.length >= 0)
                  message.spanId = object.spanId;
              }
              if (object.traceId != null) {
                if (typeof object.traceId === "string")
                  $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
                else if (object.traceId.length >= 0)
                  message.traceId = object.traceId;
              }
              return message;
            };
            Exemplar.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.filteredAttributes = [];
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.timeUnixNano = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                  object.spanId = "";
                else {
                  object.spanId = [];
                  if (options.bytes !== Array)
                    object.spanId = $util.newBuffer(object.spanId);
                }
                if (options.bytes === String)
                  object.traceId = "";
                else {
                  object.traceId = [];
                  if (options.bytes !== Array)
                    object.traceId = $util.newBuffer(object.traceId);
                }
              }
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                if (typeof message.timeUnixNano === "number")
                  object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                else
                  object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
              if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;
                if (options.oneofs)
                  object.value = "asDouble";
              }
              if (message.spanId != null && message.hasOwnProperty("spanId"))
                object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
              if (message.traceId != null && message.hasOwnProperty("traceId"))
                object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
              if (message.asInt != null && message.hasOwnProperty("asInt")) {
                if (typeof message.asInt === "number")
                  object.asInt = options.longs === String ? String(message.asInt) : message.asInt;
                else
                  object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;
                if (options.oneofs)
                  object.value = "asInt";
              }
              if (message.filteredAttributes && message.filteredAttributes.length) {
                object.filteredAttributes = [];
                for (var j = 0;j < message.filteredAttributes.length; ++j)
                  object.filteredAttributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.filteredAttributes[j], options);
              }
              return object;
            };
            Exemplar.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Exemplar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Exemplar";
            };
            return Exemplar;
          }();
          return v1;
        }();
        return metrics;
      }();
      proto.logs = function() {
        var logs = {};
        logs.v1 = function() {
          var v1 = {};
          v1.LogsData = function() {
            function LogsData(properties) {
              this.resourceLogs = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            LogsData.prototype.resourceLogs = $util.emptyArray;
            LogsData.create = function create(properties) {
              return new LogsData(properties);
            };
            LogsData.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.resourceLogs != null && message.resourceLogs.length)
                for (var i = 0;i < message.resourceLogs.length; ++i)
                  $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(10).fork()).ldelim();
              return writer;
            };
            LogsData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            LogsData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogsData;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.resourceLogs && message.resourceLogs.length))
                      message.resourceLogs = [];
                    message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            LogsData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            LogsData.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
                if (!Array.isArray(message.resourceLogs))
                  return "resourceLogs: array expected";
                for (var i = 0;i < message.resourceLogs.length; ++i) {
                  var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);
                  if (error)
                    return "resourceLogs." + error;
                }
              }
              return null;
            };
            LogsData.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.logs.v1.LogsData)
                return object;
              var message = new $root.opentelemetry.proto.logs.v1.LogsData;
              if (object.resourceLogs) {
                if (!Array.isArray(object.resourceLogs))
                  throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: array expected");
                message.resourceLogs = [];
                for (var i = 0;i < object.resourceLogs.length; ++i) {
                  if (typeof object.resourceLogs[i] !== "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: object expected");
                  message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);
                }
              }
              return message;
            };
            LogsData.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.resourceLogs = [];
              if (message.resourceLogs && message.resourceLogs.length) {
                object.resourceLogs = [];
                for (var j = 0;j < message.resourceLogs.length; ++j)
                  object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);
              }
              return object;
            };
            LogsData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            LogsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogsData";
            };
            return LogsData;
          }();
          v1.ResourceLogs = function() {
            function ResourceLogs(properties) {
              this.scopeLogs = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ResourceLogs.prototype.resource = null;
            ResourceLogs.prototype.scopeLogs = $util.emptyArray;
            ResourceLogs.prototype.schemaUrl = null;
            ResourceLogs.create = function create(properties) {
              return new ResourceLogs(properties);
            };
            ResourceLogs.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
              if (message.scopeLogs != null && message.scopeLogs.length)
                for (var i = 0;i < message.scopeLogs.length; ++i)
                  $root.opentelemetry.proto.logs.v1.ScopeLogs.encode(message.scopeLogs[i], writer.uint32(18).fork()).ldelim();
              if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                writer.uint32(26).string(message.schemaUrl);
              return writer;
            };
            ResourceLogs.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ResourceLogs.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ResourceLogs;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                    break;
                  }
                  case 2: {
                    if (!(message.scopeLogs && message.scopeLogs.length))
                      message.scopeLogs = [];
                    message.scopeLogs.push($root.opentelemetry.proto.logs.v1.ScopeLogs.decode(reader, reader.uint32()));
                    break;
                  }
                  case 3: {
                    message.schemaUrl = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ResourceLogs.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ResourceLogs.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.resource != null && message.hasOwnProperty("resource")) {
                var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                if (error)
                  return "resource." + error;
              }
              if (message.scopeLogs != null && message.hasOwnProperty("scopeLogs")) {
                if (!Array.isArray(message.scopeLogs))
                  return "scopeLogs: array expected";
                for (var i = 0;i < message.scopeLogs.length; ++i) {
                  var error = $root.opentelemetry.proto.logs.v1.ScopeLogs.verify(message.scopeLogs[i]);
                  if (error)
                    return "scopeLogs." + error;
                }
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                if (!$util.isString(message.schemaUrl))
                  return "schemaUrl: string expected";
              }
              return null;
            };
            ResourceLogs.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.logs.v1.ResourceLogs)
                return object;
              var message = new $root.opentelemetry.proto.logs.v1.ResourceLogs;
              if (object.resource != null) {
                if (typeof object.resource !== "object")
                  throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.resource: object expected");
                message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
              }
              if (object.scopeLogs) {
                if (!Array.isArray(object.scopeLogs))
                  throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: array expected");
                message.scopeLogs = [];
                for (var i = 0;i < object.scopeLogs.length; ++i) {
                  if (typeof object.scopeLogs[i] !== "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: object expected");
                  message.scopeLogs[i] = $root.opentelemetry.proto.logs.v1.ScopeLogs.fromObject(object.scopeLogs[i]);
                }
              }
              if (object.schemaUrl != null)
                message.schemaUrl = String(object.schemaUrl);
              return message;
            };
            ResourceLogs.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.scopeLogs = [];
              if (options.defaults) {
                object.resource = null;
                object.schemaUrl = "";
              }
              if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
              if (message.scopeLogs && message.scopeLogs.length) {
                object.scopeLogs = [];
                for (var j = 0;j < message.scopeLogs.length; ++j)
                  object.scopeLogs[j] = $root.opentelemetry.proto.logs.v1.ScopeLogs.toObject(message.scopeLogs[j], options);
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                object.schemaUrl = message.schemaUrl;
              return object;
            };
            ResourceLogs.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ResourceLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.logs.v1.ResourceLogs";
            };
            return ResourceLogs;
          }();
          v1.ScopeLogs = function() {
            function ScopeLogs(properties) {
              this.logRecords = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ScopeLogs.prototype.scope = null;
            ScopeLogs.prototype.logRecords = $util.emptyArray;
            ScopeLogs.prototype.schemaUrl = null;
            ScopeLogs.create = function create(properties) {
              return new ScopeLogs(properties);
            };
            ScopeLogs.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
                $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(10).fork()).ldelim();
              if (message.logRecords != null && message.logRecords.length)
                for (var i = 0;i < message.logRecords.length; ++i)
                  $root.opentelemetry.proto.logs.v1.LogRecord.encode(message.logRecords[i], writer.uint32(18).fork()).ldelim();
              if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                writer.uint32(26).string(message.schemaUrl);
              return writer;
            };
            ScopeLogs.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ScopeLogs.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ScopeLogs;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                    break;
                  }
                  case 2: {
                    if (!(message.logRecords && message.logRecords.length))
                      message.logRecords = [];
                    message.logRecords.push($root.opentelemetry.proto.logs.v1.LogRecord.decode(reader, reader.uint32()));
                    break;
                  }
                  case 3: {
                    message.schemaUrl = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ScopeLogs.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ScopeLogs.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.scope != null && message.hasOwnProperty("scope")) {
                var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                if (error)
                  return "scope." + error;
              }
              if (message.logRecords != null && message.hasOwnProperty("logRecords")) {
                if (!Array.isArray(message.logRecords))
                  return "logRecords: array expected";
                for (var i = 0;i < message.logRecords.length; ++i) {
                  var error = $root.opentelemetry.proto.logs.v1.LogRecord.verify(message.logRecords[i]);
                  if (error)
                    return "logRecords." + error;
                }
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                if (!$util.isString(message.schemaUrl))
                  return "schemaUrl: string expected";
              }
              return null;
            };
            ScopeLogs.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.logs.v1.ScopeLogs)
                return object;
              var message = new $root.opentelemetry.proto.logs.v1.ScopeLogs;
              if (object.scope != null) {
                if (typeof object.scope !== "object")
                  throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.scope: object expected");
                message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
              }
              if (object.logRecords) {
                if (!Array.isArray(object.logRecords))
                  throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: array expected");
                message.logRecords = [];
                for (var i = 0;i < object.logRecords.length; ++i) {
                  if (typeof object.logRecords[i] !== "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: object expected");
                  message.logRecords[i] = $root.opentelemetry.proto.logs.v1.LogRecord.fromObject(object.logRecords[i]);
                }
              }
              if (object.schemaUrl != null)
                message.schemaUrl = String(object.schemaUrl);
              return message;
            };
            ScopeLogs.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.logRecords = [];
              if (options.defaults) {
                object.scope = null;
                object.schemaUrl = "";
              }
              if (message.scope != null && message.hasOwnProperty("scope"))
                object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
              if (message.logRecords && message.logRecords.length) {
                object.logRecords = [];
                for (var j = 0;j < message.logRecords.length; ++j)
                  object.logRecords[j] = $root.opentelemetry.proto.logs.v1.LogRecord.toObject(message.logRecords[j], options);
              }
              if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                object.schemaUrl = message.schemaUrl;
              return object;
            };
            ScopeLogs.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ScopeLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.logs.v1.ScopeLogs";
            };
            return ScopeLogs;
          }();
          v1.SeverityNumber = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SEVERITY_NUMBER_UNSPECIFIED"] = 0;
            values[valuesById[1] = "SEVERITY_NUMBER_TRACE"] = 1;
            values[valuesById[2] = "SEVERITY_NUMBER_TRACE2"] = 2;
            values[valuesById[3] = "SEVERITY_NUMBER_TRACE3"] = 3;
            values[valuesById[4] = "SEVERITY_NUMBER_TRACE4"] = 4;
            values[valuesById[5] = "SEVERITY_NUMBER_DEBUG"] = 5;
            values[valuesById[6] = "SEVERITY_NUMBER_DEBUG2"] = 6;
            values[valuesById[7] = "SEVERITY_NUMBER_DEBUG3"] = 7;
            values[valuesById[8] = "SEVERITY_NUMBER_DEBUG4"] = 8;
            values[valuesById[9] = "SEVERITY_NUMBER_INFO"] = 9;
            values[valuesById[10] = "SEVERITY_NUMBER_INFO2"] = 10;
            values[valuesById[11] = "SEVERITY_NUMBER_INFO3"] = 11;
            values[valuesById[12] = "SEVERITY_NUMBER_INFO4"] = 12;
            values[valuesById[13] = "SEVERITY_NUMBER_WARN"] = 13;
            values[valuesById[14] = "SEVERITY_NUMBER_WARN2"] = 14;
            values[valuesById[15] = "SEVERITY_NUMBER_WARN3"] = 15;
            values[valuesById[16] = "SEVERITY_NUMBER_WARN4"] = 16;
            values[valuesById[17] = "SEVERITY_NUMBER_ERROR"] = 17;
            values[valuesById[18] = "SEVERITY_NUMBER_ERROR2"] = 18;
            values[valuesById[19] = "SEVERITY_NUMBER_ERROR3"] = 19;
            values[valuesById[20] = "SEVERITY_NUMBER_ERROR4"] = 20;
            values[valuesById[21] = "SEVERITY_NUMBER_FATAL"] = 21;
            values[valuesById[22] = "SEVERITY_NUMBER_FATAL2"] = 22;
            values[valuesById[23] = "SEVERITY_NUMBER_FATAL3"] = 23;
            values[valuesById[24] = "SEVERITY_NUMBER_FATAL4"] = 24;
            return values;
          }();
          v1.LogRecordFlags = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LOG_RECORD_FLAGS_DO_NOT_USE"] = 0;
            values[valuesById[255] = "LOG_RECORD_FLAGS_TRACE_FLAGS_MASK"] = 255;
            return values;
          }();
          v1.LogRecord = function() {
            function LogRecord(properties) {
              this.attributes = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            LogRecord.prototype.timeUnixNano = null;
            LogRecord.prototype.observedTimeUnixNano = null;
            LogRecord.prototype.severityNumber = null;
            LogRecord.prototype.severityText = null;
            LogRecord.prototype.body = null;
            LogRecord.prototype.attributes = $util.emptyArray;
            LogRecord.prototype.droppedAttributesCount = null;
            LogRecord.prototype.flags = null;
            LogRecord.prototype.traceId = null;
            LogRecord.prototype.spanId = null;
            LogRecord.prototype.eventName = null;
            LogRecord.create = function create(properties) {
              return new LogRecord(properties);
            };
            LogRecord.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                writer.uint32(9).fixed64(message.timeUnixNano);
              if (message.severityNumber != null && Object.hasOwnProperty.call(message, "severityNumber"))
                writer.uint32(16).int32(message.severityNumber);
              if (message.severityText != null && Object.hasOwnProperty.call(message, "severityText"))
                writer.uint32(26).string(message.severityText);
              if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                $root.opentelemetry.proto.common.v1.AnyValue.encode(message.body, writer.uint32(42).fork()).ldelim();
              if (message.attributes != null && message.attributes.length)
                for (var i = 0;i < message.attributes.length; ++i)
                  $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(50).fork()).ldelim();
              if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                writer.uint32(56).uint32(message.droppedAttributesCount);
              if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(69).fixed32(message.flags);
              if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                writer.uint32(74).bytes(message.traceId);
              if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                writer.uint32(82).bytes(message.spanId);
              if (message.observedTimeUnixNano != null && Object.hasOwnProperty.call(message, "observedTimeUnixNano"))
                writer.uint32(89).fixed64(message.observedTimeUnixNano);
              if (message.eventName != null && Object.hasOwnProperty.call(message, "eventName"))
                writer.uint32(98).string(message.eventName);
              return writer;
            };
            LogRecord.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            LogRecord.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogRecord;
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.timeUnixNano = reader.fixed64();
                    break;
                  }
                  case 11: {
                    message.observedTimeUnixNano = reader.fixed64();
                    break;
                  }
                  case 2: {
                    message.severityNumber = reader.int32();
                    break;
                  }
                  case 3: {
                    message.severityText = reader.string();
                    break;
                  }
                  case 5: {
                    message.body = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
                    break;
                  }
                  case 6: {
                    if (!(message.attributes && message.attributes.length))
                      message.attributes = [];
                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                    break;
                  }
                  case 7: {
                    message.droppedAttributesCount = reader.uint32();
                    break;
                  }
                  case 8: {
                    message.flags = reader.fixed32();
                    break;
                  }
                  case 9: {
                    message.traceId = reader.bytes();
                    break;
                  }
                  case 10: {
                    message.spanId = reader.bytes();
                    break;
                  }
                  case 12: {
                    message.eventName = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            LogRecord.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            LogRecord.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
              }
              if (message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano")) {
                if (!$util.isInteger(message.observedTimeUnixNano) && !(message.observedTimeUnixNano && $util.isInteger(message.observedTimeUnixNano.low) && $util.isInteger(message.observedTimeUnixNano.high)))
                  return "observedTimeUnixNano: integer|Long expected";
              }
              if (message.severityNumber != null && message.hasOwnProperty("severityNumber"))
                switch (message.severityNumber) {
                  default:
                    return "severityNumber: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                  case 11:
                  case 12:
                  case 13:
                  case 14:
                  case 15:
                  case 16:
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                    break;
                }
              if (message.severityText != null && message.hasOwnProperty("severityText")) {
                if (!$util.isString(message.severityText))
                  return "severityText: string expected";
              }
              if (message.body != null && message.hasOwnProperty("body")) {
                var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.body);
                if (error)
                  return "body." + error;
              }
              if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                  return "attributes: array expected";
                for (var i = 0;i < message.attributes.length; ++i) {
                  var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                  if (error)
                    return "attributes." + error;
                }
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                if (!$util.isInteger(message.droppedAttributesCount))
                  return "droppedAttributesCount: integer expected";
              }
              if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!$util.isInteger(message.flags))
                  return "flags: integer expected";
              }
              if (message.traceId != null && message.hasOwnProperty("traceId")) {
                if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                  return "traceId: buffer expected";
              }
              if (message.spanId != null && message.hasOwnProperty("spanId")) {
                if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                  return "spanId: buffer expected";
              }
              if (message.eventName != null && message.hasOwnProperty("eventName")) {
                if (!$util.isString(message.eventName))
                  return "eventName: string expected";
              }
              return null;
            };
            LogRecord.fromObject = function fromObject(object) {
              if (object instanceof $root.opentelemetry.proto.logs.v1.LogRecord)
                return object;
              var message = new $root.opentelemetry.proto.logs.v1.LogRecord;
              if (object.timeUnixNano != null) {
                if ($util.Long)
                  (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                else if (typeof object.timeUnixNano === "string")
                  message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                else if (typeof object.timeUnixNano === "number")
                  message.timeUnixNano = object.timeUnixNano;
                else if (typeof object.timeUnixNano === "object")
                  message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
              }
              if (object.observedTimeUnixNano != null) {
                if ($util.Long)
                  (message.observedTimeUnixNano = $util.Long.fromValue(object.observedTimeUnixNano)).unsigned = false;
                else if (typeof object.observedTimeUnixNano === "string")
                  message.observedTimeUnixNano = parseInt(object.observedTimeUnixNano, 10);
                else if (typeof object.observedTimeUnixNano === "number")
                  message.observedTimeUnixNano = object.observedTimeUnixNano;
                else if (typeof object.observedTimeUnixNano === "object")
                  message.observedTimeUnixNano = new $util.LongBits(object.observedTimeUnixNano.low >>> 0, object.observedTimeUnixNano.high >>> 0).toNumber();
              }
              switch (object.severityNumber) {
                default:
                  if (typeof object.severityNumber === "number") {
                    message.severityNumber = object.severityNumber;
                    break;
                  }
                  break;
                case "SEVERITY_NUMBER_UNSPECIFIED":
                case 0:
                  message.severityNumber = 0;
                  break;
                case "SEVERITY_NUMBER_TRACE":
                case 1:
                  message.severityNumber = 1;
                  break;
                case "SEVERITY_NUMBER_TRACE2":
                case 2:
                  message.severityNumber = 2;
                  break;
                case "SEVERITY_NUMBER_TRACE3":
                case 3:
                  message.severityNumber = 3;
                  break;
                case "SEVERITY_NUMBER_TRACE4":
                case 4:
                  message.severityNumber = 4;
                  break;
                case "SEVERITY_NUMBER_DEBUG":
                case 5:
                  message.severityNumber = 5;
                  break;
                case "SEVERITY_NUMBER_DEBUG2":
                case 6:
                  message.severityNumber = 6;
                  break;
                case "SEVERITY_NUMBER_DEBUG3":
                case 7:
                  message.severityNumber = 7;
                  break;
                case "SEVERITY_NUMBER_DEBUG4":
                case 8:
                  message.severityNumber = 8;
                  break;
                case "SEVERITY_NUMBER_INFO":
                case 9:
                  message.severityNumber = 9;
                  break;
                case "SEVERITY_NUMBER_INFO2":
                case 10:
                  message.severityNumber = 10;
                  break;
                case "SEVERITY_NUMBER_INFO3":
                case 11:
                  message.severityNumber = 11;
                  break;
                case "SEVERITY_NUMBER_INFO4":
                case 12:
                  message.severityNumber = 12;
                  break;
                case "SEVERITY_NUMBER_WARN":
                case 13:
                  message.severityNumber = 13;
                  break;
                case "SEVERITY_NUMBER_WARN2":
                case 14:
                  message.severityNumber = 14;
                  break;
                case "SEVERITY_NUMBER_WARN3":
                case 15:
                  message.severityNumber = 15;
                  break;
                case "SEVERITY_NUMBER_WARN4":
                case 16:
                  message.severityNumber = 16;
                  break;
                case "SEVERITY_NUMBER_ERROR":
                case 17:
                  message.severityNumber = 17;
                  break;
                case "SEVERITY_NUMBER_ERROR2":
                case 18:
                  message.severityNumber = 18;
                  break;
                case "SEVERITY_NUMBER_ERROR3":
                case 19:
                  message.severityNumber = 19;
                  break;
                case "SEVERITY_NUMBER_ERROR4":
                case 20:
                  message.severityNumber = 20;
                  break;
                case "SEVERITY_NUMBER_FATAL":
                case 21:
                  message.severityNumber = 21;
                  break;
                case "SEVERITY_NUMBER_FATAL2":
                case 22:
                  message.severityNumber = 22;
                  break;
                case "SEVERITY_NUMBER_FATAL3":
                case 23:
                  message.severityNumber = 23;
                  break;
                case "SEVERITY_NUMBER_FATAL4":
                case 24:
                  message.severityNumber = 24;
                  break;
              }
              if (object.severityText != null)
                message.severityText = String(object.severityText);
              if (object.body != null) {
                if (typeof object.body !== "object")
                  throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.body: object expected");
                message.body = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.body);
              }
              if (object.attributes) {
                if (!Array.isArray(object.attributes))
                  throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: array expected");
                message.attributes = [];
                for (var i = 0;i < object.attributes.length; ++i) {
                  if (typeof object.attributes[i] !== "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: object expected");
                  message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                }
              }
              if (object.droppedAttributesCount != null)
                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
              if (object.flags != null)
                message.flags = object.flags >>> 0;
              if (object.traceId != null) {
                if (typeof object.traceId === "string")
                  $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
                else if (object.traceId.length >= 0)
                  message.traceId = object.traceId;
              }
              if (object.spanId != null) {
                if (typeof object.spanId === "string")
                  $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
                else if (object.spanId.length >= 0)
                  message.spanId = object.spanId;
              }
              if (object.eventName != null)
                message.eventName = String(object.eventName);
              return message;
            };
            LogRecord.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.attributes = [];
              if (options.defaults) {
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.timeUnixNano = options.longs === String ? "0" : 0;
                object.severityNumber = options.enums === String ? "SEVERITY_NUMBER_UNSPECIFIED" : 0;
                object.severityText = "";
                object.body = null;
                object.droppedAttributesCount = 0;
                object.flags = 0;
                if (options.bytes === String)
                  object.traceId = "";
                else {
                  object.traceId = [];
                  if (options.bytes !== Array)
                    object.traceId = $util.newBuffer(object.traceId);
                }
                if (options.bytes === String)
                  object.spanId = "";
                else {
                  object.spanId = [];
                  if (options.bytes !== Array)
                    object.spanId = $util.newBuffer(object.spanId);
                }
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.observedTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.observedTimeUnixNano = options.longs === String ? "0" : 0;
                object.eventName = "";
              }
              if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                if (typeof message.timeUnixNano === "number")
                  object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                else
                  object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
              if (message.severityNumber != null && message.hasOwnProperty("severityNumber"))
                object.severityNumber = options.enums === String ? $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] === undefined ? message.severityNumber : $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] : message.severityNumber;
              if (message.severityText != null && message.hasOwnProperty("severityText"))
                object.severityText = message.severityText;
              if (message.body != null && message.hasOwnProperty("body"))
                object.body = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.body, options);
              if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0;j < message.attributes.length; ++j)
                  object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
              }
              if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                object.droppedAttributesCount = message.droppedAttributesCount;
              if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
              if (message.traceId != null && message.hasOwnProperty("traceId"))
                object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
              if (message.spanId != null && message.hasOwnProperty("spanId"))
                object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
              if (message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano"))
                if (typeof message.observedTimeUnixNano === "number")
                  object.observedTimeUnixNano = options.longs === String ? String(message.observedTimeUnixNano) : message.observedTimeUnixNano;
                else
                  object.observedTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.observedTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.observedTimeUnixNano.low >>> 0, message.observedTimeUnixNano.high >>> 0).toNumber() : message.observedTimeUnixNano;
              if (message.eventName != null && message.hasOwnProperty("eventName"))
                object.eventName = message.eventName;
              return object;
            };
            LogRecord.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            LogRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogRecord";
            };
            return LogRecord;
          }();
          return v1;
        }();
        return logs;
      }();
      return proto;
    }();
    return opentelemetry;
  }();
  module.exports = $root;
});

// node_modules/@opentelemetry/otlp-transformer/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToBinary = undefined;
  function intValue(charCode) {
    if (charCode >= 48 && charCode <= 57) {
      return charCode - 48;
    }
    if (charCode >= 97 && charCode <= 102) {
      return charCode - 87;
    }
    return charCode - 55;
  }
  function hexToBinary(hexStr) {
    const buf = new Uint8Array(hexStr.length / 2);
    let offset = 0;
    for (let i = 0;i < hexStr.length; i += 2) {
      const hi = intValue(hexStr.charCodeAt(i));
      const lo = intValue(hexStr.charCodeAt(i + 1));
      buf[offset++] = hi << 4 | lo;
    }
    return buf;
  }
  exports.hexToBinary = hexToBinary;
});

// node_modules/@opentelemetry/otlp-transformer/build/src/common/utils.js
var require_utils9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOtlpEncoder = exports.encodeAsString = exports.encodeAsLongBits = exports.toLongBits = exports.hrTimeToNanos = undefined;
  var core_1 = require_src3();
  var hex_to_binary_1 = require_hex_to_binary();
  function hrTimeToNanos(hrTime) {
    const NANOSECONDS = BigInt(1e9);
    return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);
  }
  exports.hrTimeToNanos = hrTimeToNanos;
  function toLongBits(value) {
    const low = Number(BigInt.asUintN(32, value));
    const high = Number(BigInt.asUintN(32, value >> BigInt(32)));
    return { low, high };
  }
  exports.toLongBits = toLongBits;
  function encodeAsLongBits(hrTime) {
    const nanos = hrTimeToNanos(hrTime);
    return toLongBits(nanos);
  }
  exports.encodeAsLongBits = encodeAsLongBits;
  function encodeAsString(hrTime) {
    const nanos = hrTimeToNanos(hrTime);
    return nanos.toString();
  }
  exports.encodeAsString = encodeAsString;
  var encodeTimestamp = typeof BigInt !== "undefined" ? encodeAsString : core_1.hrTimeToNanoseconds;
  function identity(value) {
    return value;
  }
  function optionalHexToBinary(str) {
    if (str === undefined)
      return;
    return (0, hex_to_binary_1.hexToBinary)(str);
  }
  var DEFAULT_ENCODER = {
    encodeHrTime: encodeAsLongBits,
    encodeSpanContext: hex_to_binary_1.hexToBinary,
    encodeOptionalSpanContext: optionalHexToBinary
  };
  function getOtlpEncoder(options) {
    if (options === undefined) {
      return DEFAULT_ENCODER;
    }
    const useLongBits = options.useLongBits ?? true;
    const useHex = options.useHex ?? false;
    return {
      encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
      encodeSpanContext: useHex ? identity : hex_to_binary_1.hexToBinary,
      encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary
    };
  }
  exports.getOtlpEncoder = getOtlpEncoder;
});

// node_modules/@opentelemetry/otlp-transformer/build/src/common/internal.js
var require_internal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toAnyValue = exports.toKeyValue = exports.toAttributes = exports.createInstrumentationScope = exports.createResource = undefined;
  function createResource(resource) {
    return {
      attributes: toAttributes(resource.attributes),
      droppedAttributesCount: 0
    };
  }
  exports.createResource = createResource;
  function createInstrumentationScope(scope) {
    return {
      name: scope.name,
      version: scope.version
    };
  }
  exports.createInstrumentationScope = createInstrumentationScope;
  function toAttributes(attributes) {
    return Object.keys(attributes).map((key) => toKeyValue(key, attributes[key]));
  }
  exports.toAttributes = toAttributes;
  function toKeyValue(key, value) {
    return {
      key,
      value: toAnyValue(value)
    };
  }
  exports.toKeyValue = toKeyValue;
  function toAnyValue(value) {
    const t = typeof value;
    if (t === "string")
      return { stringValue: value };
    if (t === "number") {
      if (!Number.isInteger(value))
        return { doubleValue: value };
      return { intValue: value };
    }
    if (t === "boolean")
      return { boolValue: value };
    if (value instanceof Uint8Array)
      return { bytesValue: value };
    if (Array.isArray(value))
      return { arrayValue: { values: value.map(toAnyValue) } };
    if (t === "object" && value != null)
      return {
        kvlistValue: {
          values: Object.entries(value).map(([k, v]) => toKeyValue(k, v))
        }
      };
    return {};
  }
  exports.toAnyValue = toAnyValue;
});

// node_modules/@opentelemetry/otlp-transformer/build/src/logs/internal.js
var require_internal2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toLogAttributes = exports.createExportLogsServiceRequest = undefined;
  var utils_1 = require_utils9();
  var internal_1 = require_internal();
  function createExportLogsServiceRequest(logRecords, options) {
    const encoder = (0, utils_1.getOtlpEncoder)(options);
    return {
      resourceLogs: logRecordsToResourceLogs(logRecords, encoder)
    };
  }
  exports.createExportLogsServiceRequest = createExportLogsServiceRequest;
  function createResourceMap(logRecords) {
    const resourceMap = new Map;
    for (const record of logRecords) {
      const { resource, instrumentationScope: { name, version = "", schemaUrl = "" } } = record;
      let ismMap = resourceMap.get(resource);
      if (!ismMap) {
        ismMap = new Map;
        resourceMap.set(resource, ismMap);
      }
      const ismKey = `${name}@${version}:${schemaUrl}`;
      let records = ismMap.get(ismKey);
      if (!records) {
        records = [];
        ismMap.set(ismKey, records);
      }
      records.push(record);
    }
    return resourceMap;
  }
  function logRecordsToResourceLogs(logRecords, encoder) {
    const resourceMap = createResourceMap(logRecords);
    return Array.from(resourceMap, ([resource, ismMap]) => ({
      resource: (0, internal_1.createResource)(resource),
      scopeLogs: Array.from(ismMap, ([, scopeLogs]) => {
        return {
          scope: (0, internal_1.createInstrumentationScope)(scopeLogs[0].instrumentationScope),
          logRecords: scopeLogs.map((log) => toLogRecord(log, encoder)),
          schemaUrl: scopeLogs[0].instrumentationScope.schemaUrl
        };
      }),
      schemaUrl: undefined
    }));
  }
  function toLogRecord(log, encoder) {
    return {
      timeUnixNano: encoder.encodeHrTime(log.hrTime),
      observedTimeUnixNano: encoder.encodeHrTime(log.hrTimeObserved),
      severityNumber: toSeverityNumber(log.severityNumber),
      severityText: log.severityText,
      body: (0, internal_1.toAnyValue)(log.body),
      attributes: toLogAttributes(log.attributes),
      droppedAttributesCount: log.droppedAttributesCount,
      flags: log.spanContext?.traceFlags,
      traceId: encoder.encodeOptionalSpanContext(log.spanContext?.traceId),
      spanId: encoder.encodeOptionalSpanContext(log.spanContext?.spanId)
    };
  }
  function toSeverityNumber(severityNumber) {
    return severityNumber;
  }
  function toLogAttributes(attributes) {
    return Object.keys(attributes).map((key) => (0, internal_1.toKeyValue)(key, attributes[key]));
  }
  exports.toLogAttributes = toLogAttributes;
});

// node_modules/@opentelemetry/otlp-transformer/build/src/logs/protobuf/logs.js
var require_logs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufLogsSerializer = undefined;
  var root = require_root();
  var internal_1 = require_internal2();
  var logsResponseType = root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse;
  var logsRequestType = root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest;
  exports.ProtobufLogsSerializer = {
    serializeRequest: (arg) => {
      const request2 = (0, internal_1.createExportLogsServiceRequest)(arg);
      return logsRequestType.encode(request2).finish();
    },
    deserializeResponse: (arg) => {
      return logsResponseType.decode(arg);
    }
  };
});

// node_modules/@opentelemetry/otlp-transformer/build/src/logs/protobuf/index.js
var require_protobuf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufLogsSerializer = undefined;
  var logs_1 = require_logs2();
  Object.defineProperty(exports, "ProtobufLogsSerializer", { enumerable: true, get: function() {
    return logs_1.ProtobufLogsSerializer;
  } });
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal-types.js
var require_internal_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EAggregationTemporality = undefined;
  var EAggregationTemporality;
  (function(EAggregationTemporality2) {
    EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_UNSPECIFIED"] = 0] = "AGGREGATION_TEMPORALITY_UNSPECIFIED";
    EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_DELTA"] = 1] = "AGGREGATION_TEMPORALITY_DELTA";
    EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_CUMULATIVE"] = 2] = "AGGREGATION_TEMPORALITY_CUMULATIVE";
  })(EAggregationTemporality = exports.EAggregationTemporality || (exports.EAggregationTemporality = {}));
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal.js
var require_internal3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createExportMetricsServiceRequest = exports.toMetric = exports.toScopeMetrics = exports.toResourceMetrics = undefined;
  var api_1 = require_src();
  var sdk_metrics_1 = require_src7();
  var internal_types_1 = require_internal_types();
  var utils_1 = require_utils9();
  var internal_1 = require_internal();
  function toResourceMetrics(resourceMetrics, options) {
    const encoder = (0, utils_1.getOtlpEncoder)(options);
    return {
      resource: (0, internal_1.createResource)(resourceMetrics.resource),
      schemaUrl: undefined,
      scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder)
    };
  }
  exports.toResourceMetrics = toResourceMetrics;
  function toScopeMetrics(scopeMetrics, encoder) {
    return Array.from(scopeMetrics.map((metrics) => ({
      scope: (0, internal_1.createInstrumentationScope)(metrics.scope),
      metrics: metrics.metrics.map((metricData) => toMetric(metricData, encoder)),
      schemaUrl: metrics.scope.schemaUrl
    })));
  }
  exports.toScopeMetrics = toScopeMetrics;
  function toMetric(metricData, encoder) {
    const out = {
      name: metricData.descriptor.name,
      description: metricData.descriptor.description,
      unit: metricData.descriptor.unit
    };
    const aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);
    switch (metricData.dataPointType) {
      case sdk_metrics_1.DataPointType.SUM:
        out.sum = {
          aggregationTemporality,
          isMonotonic: metricData.isMonotonic,
          dataPoints: toSingularDataPoints(metricData, encoder)
        };
        break;
      case sdk_metrics_1.DataPointType.GAUGE:
        out.gauge = {
          dataPoints: toSingularDataPoints(metricData, encoder)
        };
        break;
      case sdk_metrics_1.DataPointType.HISTOGRAM:
        out.histogram = {
          aggregationTemporality,
          dataPoints: toHistogramDataPoints(metricData, encoder)
        };
        break;
      case sdk_metrics_1.DataPointType.EXPONENTIAL_HISTOGRAM:
        out.exponentialHistogram = {
          aggregationTemporality,
          dataPoints: toExponentialHistogramDataPoints(metricData, encoder)
        };
        break;
    }
    return out;
  }
  exports.toMetric = toMetric;
  function toSingularDataPoint(dataPoint, valueType, encoder) {
    const out = {
      attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
    };
    switch (valueType) {
      case api_1.ValueType.INT:
        out.asInt = dataPoint.value;
        break;
      case api_1.ValueType.DOUBLE:
        out.asDouble = dataPoint.value;
        break;
    }
    return out;
  }
  function toSingularDataPoints(metricData, encoder) {
    return metricData.dataPoints.map((dataPoint) => {
      return toSingularDataPoint(dataPoint, metricData.descriptor.valueType, encoder);
    });
  }
  function toHistogramDataPoints(metricData, encoder) {
    return metricData.dataPoints.map((dataPoint) => {
      const histogram = dataPoint.value;
      return {
        attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
        bucketCounts: histogram.buckets.counts,
        explicitBounds: histogram.buckets.boundaries,
        count: histogram.count,
        sum: histogram.sum,
        min: histogram.min,
        max: histogram.max,
        startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
        timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
      };
    });
  }
  function toExponentialHistogramDataPoints(metricData, encoder) {
    return metricData.dataPoints.map((dataPoint) => {
      const histogram = dataPoint.value;
      return {
        attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
        count: histogram.count,
        min: histogram.min,
        max: histogram.max,
        sum: histogram.sum,
        positive: {
          offset: histogram.positive.offset,
          bucketCounts: histogram.positive.bucketCounts
        },
        negative: {
          offset: histogram.negative.offset,
          bucketCounts: histogram.negative.bucketCounts
        },
        scale: histogram.scale,
        zeroCount: histogram.zeroCount,
        startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
        timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
      };
    });
  }
  function toAggregationTemporality(temporality) {
    switch (temporality) {
      case sdk_metrics_1.AggregationTemporality.DELTA:
        return internal_types_1.EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;
      case sdk_metrics_1.AggregationTemporality.CUMULATIVE:
        return internal_types_1.EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;
    }
  }
  function createExportMetricsServiceRequest(resourceMetrics, options) {
    return {
      resourceMetrics: resourceMetrics.map((metrics) => toResourceMetrics(metrics, options))
    };
  }
  exports.createExportMetricsServiceRequest = createExportMetricsServiceRequest;
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/protobuf/metrics.js
var require_metrics2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufMetricsSerializer = undefined;
  var root = require_root();
  var internal_1 = require_internal3();
  var metricsResponseType = root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse;
  var metricsRequestType = root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest;
  exports.ProtobufMetricsSerializer = {
    serializeRequest: (arg) => {
      const request2 = (0, internal_1.createExportMetricsServiceRequest)([arg]);
      return metricsRequestType.encode(request2).finish();
    },
    deserializeResponse: (arg) => {
      return metricsResponseType.decode(arg);
    }
  };
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/protobuf/index.js
var require_protobuf2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufMetricsSerializer = undefined;
  var metrics_1 = require_metrics2();
  Object.defineProperty(exports, "ProtobufMetricsSerializer", { enumerable: true, get: function() {
    return metrics_1.ProtobufMetricsSerializer;
  } });
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/internal.js
var require_internal4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createExportTraceServiceRequest = exports.toOtlpSpanEvent = exports.toOtlpLink = exports.sdkSpanToOtlpSpan = undefined;
  var internal_1 = require_internal();
  var utils_1 = require_utils9();
  function sdkSpanToOtlpSpan(span, encoder) {
    const ctx = span.spanContext();
    const status = span.status;
    const parentSpanId = span.parentSpanContext?.spanId ? encoder.encodeSpanContext(span.parentSpanContext?.spanId) : undefined;
    return {
      traceId: encoder.encodeSpanContext(ctx.traceId),
      spanId: encoder.encodeSpanContext(ctx.spanId),
      parentSpanId,
      traceState: ctx.traceState?.serialize(),
      name: span.name,
      kind: span.kind == null ? 0 : span.kind + 1,
      startTimeUnixNano: encoder.encodeHrTime(span.startTime),
      endTimeUnixNano: encoder.encodeHrTime(span.endTime),
      attributes: (0, internal_1.toAttributes)(span.attributes),
      droppedAttributesCount: span.droppedAttributesCount,
      events: span.events.map((event) => toOtlpSpanEvent(event, encoder)),
      droppedEventsCount: span.droppedEventsCount,
      status: {
        code: status.code,
        message: status.message
      },
      links: span.links.map((link) => toOtlpLink(link, encoder)),
      droppedLinksCount: span.droppedLinksCount
    };
  }
  exports.sdkSpanToOtlpSpan = sdkSpanToOtlpSpan;
  function toOtlpLink(link, encoder) {
    return {
      attributes: link.attributes ? (0, internal_1.toAttributes)(link.attributes) : [],
      spanId: encoder.encodeSpanContext(link.context.spanId),
      traceId: encoder.encodeSpanContext(link.context.traceId),
      traceState: link.context.traceState?.serialize(),
      droppedAttributesCount: link.droppedAttributesCount || 0
    };
  }
  exports.toOtlpLink = toOtlpLink;
  function toOtlpSpanEvent(timedEvent, encoder) {
    return {
      attributes: timedEvent.attributes ? (0, internal_1.toAttributes)(timedEvent.attributes) : [],
      name: timedEvent.name,
      timeUnixNano: encoder.encodeHrTime(timedEvent.time),
      droppedAttributesCount: timedEvent.droppedAttributesCount || 0
    };
  }
  exports.toOtlpSpanEvent = toOtlpSpanEvent;
  function createExportTraceServiceRequest(spans, options) {
    const encoder = (0, utils_1.getOtlpEncoder)(options);
    return {
      resourceSpans: spanRecordsToResourceSpans(spans, encoder)
    };
  }
  exports.createExportTraceServiceRequest = createExportTraceServiceRequest;
  function createResourceMap(readableSpans) {
    const resourceMap = new Map;
    for (const record of readableSpans) {
      let ilsMap = resourceMap.get(record.resource);
      if (!ilsMap) {
        ilsMap = new Map;
        resourceMap.set(record.resource, ilsMap);
      }
      const instrumentationScopeKey = `${record.instrumentationScope.name}@${record.instrumentationScope.version || ""}:${record.instrumentationScope.schemaUrl || ""}`;
      let records = ilsMap.get(instrumentationScopeKey);
      if (!records) {
        records = [];
        ilsMap.set(instrumentationScopeKey, records);
      }
      records.push(record);
    }
    return resourceMap;
  }
  function spanRecordsToResourceSpans(readableSpans, encoder) {
    const resourceMap = createResourceMap(readableSpans);
    const out = [];
    const entryIterator = resourceMap.entries();
    let entry = entryIterator.next();
    while (!entry.done) {
      const [resource, ilmMap] = entry.value;
      const scopeResourceSpans = [];
      const ilmIterator = ilmMap.values();
      let ilmEntry = ilmIterator.next();
      while (!ilmEntry.done) {
        const scopeSpans = ilmEntry.value;
        if (scopeSpans.length > 0) {
          const spans = scopeSpans.map((readableSpan) => sdkSpanToOtlpSpan(readableSpan, encoder));
          scopeResourceSpans.push({
            scope: (0, internal_1.createInstrumentationScope)(scopeSpans[0].instrumentationScope),
            spans,
            schemaUrl: scopeSpans[0].instrumentationScope.schemaUrl
          });
        }
        ilmEntry = ilmIterator.next();
      }
      const transformedSpans = {
        resource: (0, internal_1.createResource)(resource),
        scopeSpans: scopeResourceSpans,
        schemaUrl: undefined
      };
      out.push(transformedSpans);
      entry = entryIterator.next();
    }
    return out;
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/protobuf/trace.js
var require_trace3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufTraceSerializer = undefined;
  var root = require_root();
  var internal_1 = require_internal4();
  var traceResponseType = root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse;
  var traceRequestType = root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;
  exports.ProtobufTraceSerializer = {
    serializeRequest: (arg) => {
      const request2 = (0, internal_1.createExportTraceServiceRequest)(arg);
      return traceRequestType.encode(request2).finish();
    },
    deserializeResponse: (arg) => {
      return traceResponseType.decode(arg);
    }
  };
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/protobuf/index.js
var require_protobuf3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufTraceSerializer = undefined;
  var trace_1 = require_trace3();
  Object.defineProperty(exports, "ProtobufTraceSerializer", { enumerable: true, get: function() {
    return trace_1.ProtobufTraceSerializer;
  } });
});

// node_modules/@opentelemetry/otlp-transformer/build/src/logs/json/logs.js
var require_logs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonLogsSerializer = undefined;
  var internal_1 = require_internal2();
  exports.JsonLogsSerializer = {
    serializeRequest: (arg) => {
      const request2 = (0, internal_1.createExportLogsServiceRequest)(arg, {
        useHex: true,
        useLongBits: false
      });
      const encoder = new TextEncoder;
      return encoder.encode(JSON.stringify(request2));
    },
    deserializeResponse: (arg) => {
      if (arg.length === 0) {
        return {};
      }
      const decoder = new TextDecoder;
      return JSON.parse(decoder.decode(arg));
    }
  };
});

// node_modules/@opentelemetry/otlp-transformer/build/src/logs/json/index.js
var require_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonLogsSerializer = undefined;
  var logs_1 = require_logs3();
  Object.defineProperty(exports, "JsonLogsSerializer", { enumerable: true, get: function() {
    return logs_1.JsonLogsSerializer;
  } });
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/json/metrics.js
var require_metrics3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonMetricsSerializer = undefined;
  var internal_1 = require_internal3();
  exports.JsonMetricsSerializer = {
    serializeRequest: (arg) => {
      const request2 = (0, internal_1.createExportMetricsServiceRequest)([arg], {
        useLongBits: false
      });
      const encoder = new TextEncoder;
      return encoder.encode(JSON.stringify(request2));
    },
    deserializeResponse: (arg) => {
      if (arg.length === 0) {
        return {};
      }
      const decoder = new TextDecoder;
      return JSON.parse(decoder.decode(arg));
    }
  };
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/json/index.js
var require_json2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonMetricsSerializer = undefined;
  var metrics_1 = require_metrics3();
  Object.defineProperty(exports, "JsonMetricsSerializer", { enumerable: true, get: function() {
    return metrics_1.JsonMetricsSerializer;
  } });
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/json/trace.js
var require_trace4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonTraceSerializer = undefined;
  var internal_1 = require_internal4();
  exports.JsonTraceSerializer = {
    serializeRequest: (arg) => {
      const request2 = (0, internal_1.createExportTraceServiceRequest)(arg, {
        useHex: true,
        useLongBits: false
      });
      const encoder = new TextEncoder;
      return encoder.encode(JSON.stringify(request2));
    },
    deserializeResponse: (arg) => {
      if (arg.length === 0) {
        return {};
      }
      const decoder = new TextDecoder;
      return JSON.parse(decoder.decode(arg));
    }
  };
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/json/index.js
var require_json3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonTraceSerializer = undefined;
  var trace_1 = require_trace4();
  Object.defineProperty(exports, "JsonTraceSerializer", { enumerable: true, get: function() {
    return trace_1.JsonTraceSerializer;
  } });
});

// node_modules/@opentelemetry/otlp-transformer/build/src/index.js
var require_src14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonTraceSerializer = exports.JsonMetricsSerializer = exports.JsonLogsSerializer = exports.ProtobufTraceSerializer = exports.ProtobufMetricsSerializer = exports.ProtobufLogsSerializer = undefined;
  var protobuf_1 = require_protobuf();
  Object.defineProperty(exports, "ProtobufLogsSerializer", { enumerable: true, get: function() {
    return protobuf_1.ProtobufLogsSerializer;
  } });
  var protobuf_2 = require_protobuf2();
  Object.defineProperty(exports, "ProtobufMetricsSerializer", { enumerable: true, get: function() {
    return protobuf_2.ProtobufMetricsSerializer;
  } });
  var protobuf_3 = require_protobuf3();
  Object.defineProperty(exports, "ProtobufTraceSerializer", { enumerable: true, get: function() {
    return protobuf_3.ProtobufTraceSerializer;
  } });
  var json_1 = require_json();
  Object.defineProperty(exports, "JsonLogsSerializer", { enumerable: true, get: function() {
    return json_1.JsonLogsSerializer;
  } });
  var json_2 = require_json2();
  Object.defineProperty(exports, "JsonMetricsSerializer", { enumerable: true, get: function() {
    return json_2.JsonMetricsSerializer;
  } });
  var json_3 = require_json3();
  Object.defineProperty(exports, "JsonTraceSerializer", { enumerable: true, get: function() {
    return json_3.JsonTraceSerializer;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-http/build/src/version.js
var require_version4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.202.0";
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/is-export-retryable.js
var require_is_export_retryable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseRetryAfterToMills = exports.isExportRetryable = undefined;
  function isExportRetryable(statusCode) {
    const retryCodes = [429, 502, 503, 504];
    return retryCodes.includes(statusCode);
  }
  exports.isExportRetryable = isExportRetryable;
  function parseRetryAfterToMills(retryAfter) {
    if (retryAfter == null) {
      return;
    }
    const seconds = Number.parseInt(retryAfter, 10);
    if (Number.isInteger(seconds)) {
      return seconds > 0 ? seconds * 1000 : -1;
    }
    const delay = new Date(retryAfter).getTime() - Date.now();
    if (delay >= 0) {
      return delay;
    }
    return 0;
  }
  exports.parseRetryAfterToMills = parseRetryAfterToMills;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/transport/http-transport-utils.js
var require_http_transport_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpAgent = exports.compressAndSend = exports.sendWithHttp = undefined;
  var http = __require("http");
  var https = __require("https");
  var zlib = __require("zlib");
  var stream_1 = __require("stream");
  var is_export_retryable_1 = require_is_export_retryable();
  var types_1 = require_types4();
  function sendWithHttp(params, agent, data, onDone, timeoutMillis) {
    const parsedUrl = new URL(params.url);
    const nodeVersion = Number(process.versions.node.split(".")[0]);
    const options = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port,
      path: parsedUrl.pathname,
      method: "POST",
      headers: {
        ...params.headers()
      },
      agent
    };
    const request2 = parsedUrl.protocol === "http:" ? http.request : https.request;
    const req = request2(options, (res) => {
      const responseData = [];
      res.on("data", (chunk) => responseData.push(chunk));
      res.on("end", () => {
        if (res.statusCode && res.statusCode < 299) {
          onDone({
            status: "success",
            data: Buffer.concat(responseData)
          });
        } else if (res.statusCode && (0, is_export_retryable_1.isExportRetryable)(res.statusCode)) {
          onDone({
            status: "retryable",
            retryInMillis: (0, is_export_retryable_1.parseRetryAfterToMills)(res.headers["retry-after"])
          });
        } else {
          const error = new types_1.OTLPExporterError(res.statusMessage, res.statusCode, Buffer.concat(responseData).toString());
          onDone({
            status: "failure",
            error
          });
        }
      });
    });
    req.setTimeout(timeoutMillis, () => {
      req.destroy();
      onDone({
        status: "failure",
        error: new Error("Request Timeout")
      });
    });
    req.on("error", (error) => {
      onDone({
        status: "failure",
        error
      });
    });
    const reportTimeoutErrorEvent = nodeVersion >= 14 ? "close" : "abort";
    req.on(reportTimeoutErrorEvent, () => {
      onDone({
        status: "failure",
        error: new Error("Request timed out")
      });
    });
    compressAndSend(req, params.compression, data, (error) => {
      onDone({
        status: "failure",
        error
      });
    });
  }
  exports.sendWithHttp = sendWithHttp;
  function compressAndSend(req, compression, data, onError) {
    let dataStream = readableFromUint8Array(data);
    if (compression === "gzip") {
      req.setHeader("Content-Encoding", "gzip");
      dataStream = dataStream.on("error", onError).pipe(zlib.createGzip()).on("error", onError);
    }
    dataStream.pipe(req).on("error", onError);
  }
  exports.compressAndSend = compressAndSend;
  function readableFromUint8Array(buff) {
    const readable = new stream_1.Readable;
    readable.push(buff);
    readable.push(null);
    return readable;
  }
  function createHttpAgent(rawUrl, agentOptions) {
    const parsedUrl = new URL(rawUrl);
    const Agent = parsedUrl.protocol === "http:" ? http.Agent : https.Agent;
    return new Agent(agentOptions);
  }
  exports.createHttpAgent = createHttpAgent;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/transport/http-exporter-transport.js
var require_http_exporter_transport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpExporterTransport = undefined;

  class HttpExporterTransport {
    _parameters;
    _utils = null;
    constructor(_parameters) {
      this._parameters = _parameters;
    }
    async send(data, timeoutMillis) {
      const { agent, send } = this._loadUtils();
      return new Promise((resolve) => {
        send(this._parameters, agent, data, (result) => {
          resolve(result);
        }, timeoutMillis);
      });
    }
    shutdown() {
    }
    _loadUtils() {
      let utils = this._utils;
      if (utils === null) {
        const {
          sendWithHttp,
          createHttpAgent
        } = require_http_transport_utils();
        utils = this._utils = {
          agent: createHttpAgent(this._parameters.url, this._parameters.agentOptions),
          send: sendWithHttp
        };
      }
      return utils;
    }
  }
  function createHttpExporterTransport(parameters) {
    return new HttpExporterTransport(parameters);
  }
  exports.createHttpExporterTransport = createHttpExporterTransport;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/retrying-transport.js
var require_retrying_transport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRetryingTransport = undefined;
  var MAX_ATTEMPTS = 5;
  var INITIAL_BACKOFF = 1000;
  var MAX_BACKOFF = 5000;
  var BACKOFF_MULTIPLIER = 1.5;
  var JITTER = 0.2;
  function getJitter() {
    return Math.random() * (2 * JITTER) - JITTER;
  }

  class RetryingTransport {
    _transport;
    constructor(_transport) {
      this._transport = _transport;
    }
    retry(data, timeoutMillis, inMillis) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          this._transport.send(data, timeoutMillis).then(resolve, reject);
        }, inMillis);
      });
    }
    async send(data, timeoutMillis) {
      const deadline = Date.now() + timeoutMillis;
      let result = await this._transport.send(data, timeoutMillis);
      let attempts = MAX_ATTEMPTS;
      let nextBackoff = INITIAL_BACKOFF;
      while (result.status === "retryable" && attempts > 0) {
        attempts--;
        const backoff = Math.max(Math.min(nextBackoff, MAX_BACKOFF) + getJitter(), 0);
        nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;
        const retryInMillis = result.retryInMillis ?? backoff;
        const remainingTimeoutMillis = deadline - Date.now();
        if (retryInMillis > remainingTimeoutMillis) {
          return result;
        }
        result = await this.retry(data, remainingTimeoutMillis, retryInMillis);
      }
      return result;
    }
    shutdown() {
      return this._transport.shutdown();
    }
  }
  function createRetryingTransport(options) {
    return new RetryingTransport(options.transport);
  }
  exports.createRetryingTransport = createRetryingTransport;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/otlp-http-export-delegate.js
var require_otlp_http_export_delegate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createOtlpHttpExportDelegate = undefined;
  var otlp_export_delegate_1 = require_otlp_export_delegate();
  var http_exporter_transport_1 = require_http_exporter_transport();
  var bounded_queue_export_promise_handler_1 = require_bounded_queue_export_promise_handler();
  var retrying_transport_1 = require_retrying_transport();
  function createOtlpHttpExportDelegate(options, serializer) {
    return (0, otlp_export_delegate_1.createOtlpExportDelegate)({
      transport: (0, retrying_transport_1.createRetryingTransport)({
        transport: (0, http_exporter_transport_1.createHttpExporterTransport)(options)
      }),
      serializer,
      promiseHandler: (0, bounded_queue_export_promise_handler_1.createBoundedQueueExportPromiseHandler)(options)
    }, { timeout: options.timeoutMillis });
  }
  exports.createOtlpHttpExportDelegate = createOtlpHttpExportDelegate;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/configuration/shared-env-configuration.js
var require_shared_env_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSharedConfigurationFromEnvironment = undefined;
  var api_1 = require_src();
  function parseAndValidateTimeoutFromEnv(timeoutEnvVar) {
    const envTimeout = process.env[timeoutEnvVar]?.trim();
    if (envTimeout != null && envTimeout !== "") {
      const definedTimeout = Number(envTimeout);
      if (Number.isFinite(definedTimeout) && definedTimeout > 0) {
        return definedTimeout;
      }
      api_1.diag.warn(`Configuration: ${timeoutEnvVar} is invalid, expected number greater than 0 (actual: ${envTimeout})`);
    }
    return;
  }
  function getTimeoutFromEnv(signalIdentifier) {
    const specificTimeout = parseAndValidateTimeoutFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_TIMEOUT`);
    const nonSpecificTimeout = parseAndValidateTimeoutFromEnv("OTEL_EXPORTER_OTLP_TIMEOUT");
    return specificTimeout ?? nonSpecificTimeout;
  }
  function parseAndValidateCompressionFromEnv(compressionEnvVar) {
    const compression = process.env[compressionEnvVar]?.trim();
    if (compression === "") {
      return;
    }
    if (compression == null || compression === "none" || compression === "gzip") {
      return compression;
    }
    api_1.diag.warn(`Configuration: ${compressionEnvVar} is invalid, expected 'none' or 'gzip' (actual: '${compression}')`);
    return;
  }
  function getCompressionFromEnv(signalIdentifier) {
    const specificCompression = parseAndValidateCompressionFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_COMPRESSION`);
    const nonSpecificCompression = parseAndValidateCompressionFromEnv("OTEL_EXPORTER_OTLP_COMPRESSION");
    return specificCompression ?? nonSpecificCompression;
  }
  function getSharedConfigurationFromEnvironment(signalIdentifier) {
    return {
      timeoutMillis: getTimeoutFromEnv(signalIdentifier),
      compression: getCompressionFromEnv(signalIdentifier)
    };
  }
  exports.getSharedConfigurationFromEnvironment = getSharedConfigurationFromEnvironment;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAndNormalizeHeaders = undefined;
  var api_1 = require_src();
  function validateAndNormalizeHeaders(partialHeaders) {
    return () => {
      const headers = {};
      Object.entries(partialHeaders?.() ?? {}).forEach(([key, value]) => {
        if (typeof value !== "undefined") {
          headers[key] = String(value);
        } else {
          api_1.diag.warn(`Header "${key}" has invalid value (${value}) and will be ignored`);
        }
      });
      return headers;
    };
  }
  exports.validateAndNormalizeHeaders = validateAndNormalizeHeaders;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/configuration/otlp-http-configuration.js
var require_otlp_http_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHttpConfigurationDefaults = exports.mergeOtlpHttpConfigurationWithDefaults = undefined;
  var shared_configuration_1 = require_shared_configuration();
  var util_1 = require_util2();
  function mergeHeaders(userProvidedHeaders, fallbackHeaders, defaultHeaders) {
    const requiredHeaders = {
      ...defaultHeaders()
    };
    const headers = {};
    return () => {
      if (fallbackHeaders != null) {
        Object.assign(headers, fallbackHeaders());
      }
      if (userProvidedHeaders != null) {
        Object.assign(headers, userProvidedHeaders());
      }
      return Object.assign(headers, requiredHeaders);
    };
  }
  function validateUserProvidedUrl(url) {
    if (url == null) {
      return;
    }
    try {
      new URL(url);
      return url;
    } catch (e) {
      throw new Error(`Configuration: Could not parse user-provided export URL: '${url}'`);
    }
  }
  function mergeOtlpHttpConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
    return {
      ...(0, shared_configuration_1.mergeOtlpSharedConfigurationWithDefaults)(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration),
      headers: mergeHeaders((0, util_1.validateAndNormalizeHeaders)(userProvidedConfiguration.headers), fallbackConfiguration.headers, defaultConfiguration.headers),
      url: validateUserProvidedUrl(userProvidedConfiguration.url) ?? fallbackConfiguration.url ?? defaultConfiguration.url,
      agentOptions: userProvidedConfiguration.agentOptions ?? fallbackConfiguration.agentOptions ?? defaultConfiguration.agentOptions
    };
  }
  exports.mergeOtlpHttpConfigurationWithDefaults = mergeOtlpHttpConfigurationWithDefaults;
  function getHttpConfigurationDefaults(requiredHeaders, signalResourcePath) {
    return {
      ...(0, shared_configuration_1.getSharedConfigurationDefaults)(),
      headers: () => requiredHeaders,
      url: "http://localhost:4318/" + signalResourcePath,
      agentOptions: { keepAlive: true }
    };
  }
  exports.getHttpConfigurationDefaults = getHttpConfigurationDefaults;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/configuration/otlp-http-env-configuration.js
var require_otlp_http_env_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHttpConfigurationFromEnvironment = undefined;
  var core_1 = require_src3();
  var api_1 = require_src();
  var shared_env_configuration_1 = require_shared_env_configuration();
  var shared_configuration_1 = require_shared_configuration();
  function getStaticHeadersFromEnv(signalIdentifier) {
    const signalSpecificRawHeaders = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_HEADERS`]?.trim();
    const nonSignalSpecificRawHeaders = process.env["OTEL_EXPORTER_OTLP_HEADERS"]?.trim();
    const signalSpecificHeaders = (0, core_1.parseKeyPairsIntoRecord)(signalSpecificRawHeaders);
    const nonSignalSpecificHeaders = (0, core_1.parseKeyPairsIntoRecord)(nonSignalSpecificRawHeaders);
    if (Object.keys(signalSpecificHeaders).length === 0 && Object.keys(nonSignalSpecificHeaders).length === 0) {
      return;
    }
    return Object.assign({}, (0, core_1.parseKeyPairsIntoRecord)(nonSignalSpecificRawHeaders), (0, core_1.parseKeyPairsIntoRecord)(signalSpecificRawHeaders));
  }
  function appendRootPathToUrlIfNeeded(url) {
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.toString();
    } catch {
      api_1.diag.warn(`Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`);
      return;
    }
  }
  function appendResourcePathToUrl(url, path) {
    try {
      new URL(url);
    } catch {
      api_1.diag.warn(`Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`);
      return;
    }
    if (!url.endsWith("/")) {
      url = url + "/";
    }
    url += path;
    try {
      new URL(url);
    } catch {
      api_1.diag.warn(`Configuration: Provided URL appended with '${path}' is not a valid URL, using 'undefined' instead of '${url}'`);
      return;
    }
    return url;
  }
  function getNonSpecificUrlFromEnv(signalResourcePath) {
    const envUrl = process.env.OTEL_EXPORTER_OTLP_ENDPOINT?.trim();
    if (envUrl == null || envUrl === "") {
      return;
    }
    return appendResourcePathToUrl(envUrl, signalResourcePath);
  }
  function getSpecificUrlFromEnv(signalIdentifier) {
    const envUrl = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_ENDPOINT`]?.trim();
    if (envUrl == null || envUrl === "") {
      return;
    }
    return appendRootPathToUrlIfNeeded(envUrl);
  }
  function getHttpConfigurationFromEnvironment(signalIdentifier, signalResourcePath) {
    return {
      ...(0, shared_env_configuration_1.getSharedConfigurationFromEnvironment)(signalIdentifier),
      url: getSpecificUrlFromEnv(signalIdentifier) ?? getNonSpecificUrlFromEnv(signalResourcePath),
      headers: (0, shared_configuration_1.wrapStaticHeadersInFunction)(getStaticHeadersFromEnv(signalIdentifier))
    };
  }
  exports.getHttpConfigurationFromEnvironment = getHttpConfigurationFromEnvironment;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/configuration/convert-legacy-node-http-options.js
var require_convert_legacy_node_http_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertLegacyHttpOptions = undefined;
  var otlp_http_configuration_1 = require_otlp_http_configuration();
  var otlp_http_env_configuration_1 = require_otlp_http_env_configuration();
  var api_1 = require_src();
  var shared_configuration_1 = require_shared_configuration();
  function convertLegacyAgentOptions(config) {
    if (config?.keepAlive != null) {
      if (config.httpAgentOptions != null) {
        if (config.httpAgentOptions.keepAlive == null) {
          config.httpAgentOptions.keepAlive = config.keepAlive;
        }
      } else {
        config.httpAgentOptions = {
          keepAlive: config.keepAlive
        };
      }
    }
    return config.httpAgentOptions;
  }
  function convertLegacyHttpOptions(config, signalIdentifier, signalResourcePath, requiredHeaders) {
    if (config.metadata) {
      api_1.diag.warn("Metadata cannot be set when using http");
    }
    return (0, otlp_http_configuration_1.mergeOtlpHttpConfigurationWithDefaults)({
      url: config.url,
      headers: (0, shared_configuration_1.wrapStaticHeadersInFunction)(config.headers),
      concurrencyLimit: config.concurrencyLimit,
      timeoutMillis: config.timeoutMillis,
      compression: config.compression,
      agentOptions: convertLegacyAgentOptions(config)
    }, (0, otlp_http_env_configuration_1.getHttpConfigurationFromEnvironment)(signalIdentifier, signalResourcePath), (0, otlp_http_configuration_1.getHttpConfigurationDefaults)(requiredHeaders, signalResourcePath));
  }
  exports.convertLegacyHttpOptions = convertLegacyHttpOptions;
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/index-node-http.js
var require_index_node_http = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertLegacyHttpOptions = exports.getSharedConfigurationFromEnvironment = exports.createOtlpHttpExportDelegate = undefined;
  var otlp_http_export_delegate_1 = require_otlp_http_export_delegate();
  Object.defineProperty(exports, "createOtlpHttpExportDelegate", { enumerable: true, get: function() {
    return otlp_http_export_delegate_1.createOtlpHttpExportDelegate;
  } });
  var shared_env_configuration_1 = require_shared_env_configuration();
  Object.defineProperty(exports, "getSharedConfigurationFromEnvironment", { enumerable: true, get: function() {
    return shared_env_configuration_1.getSharedConfigurationFromEnvironment;
  } });
  var convert_legacy_node_http_options_1 = require_convert_legacy_node_http_options();
  Object.defineProperty(exports, "convertLegacyHttpOptions", { enumerable: true, get: function() {
    return convert_legacy_node_http_options_1.convertLegacyHttpOptions;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-http/build/src/platform/node/OTLPLogExporter.js
var require_OTLPLogExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var otlp_exporter_base_1 = require_src13();
  var otlp_transformer_1 = require_src14();
  var version_1 = require_version4();
  var node_http_1 = require_index_node_http();

  class OTLPLogExporter extends otlp_exporter_base_1.OTLPExporterBase {
    constructor(config = {}) {
      super((0, node_http_1.createOtlpHttpExportDelegate)((0, node_http_1.convertLegacyHttpOptions)(config, "LOGS", "v1/logs", {
        "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`,
        "Content-Type": "application/json"
      }), otlp_transformer_1.JsonLogsSerializer));
    }
  }
  exports.OTLPLogExporter = OTLPLogExporter;
});

// node_modules/@opentelemetry/exporter-logs-otlp-http/build/src/platform/node/index.js
var require_node10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var OTLPLogExporter_1 = require_OTLPLogExporter();
  Object.defineProperty(exports, "OTLPLogExporter", { enumerable: true, get: function() {
    return OTLPLogExporter_1.OTLPLogExporter;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-http/build/src/platform/index.js
var require_platform9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var node_1 = require_node10();
  Object.defineProperty(exports, "OTLPLogExporter", { enumerable: true, get: function() {
    return node_1.OTLPLogExporter;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-http/build/src/index.js
var require_src15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var platform_1 = require_platform9();
  Object.defineProperty(exports, "OTLPLogExporter", { enumerable: true, get: function() {
    return platform_1.OTLPLogExporter;
  } });
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = undefined;
  var Status;
  (function(Status2) {
    Status2[Status2["OK"] = 0] = "OK";
    Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
    Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
    Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
    Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    Status2[Status2["ABORTED"] = 10] = "ABORTED";
    Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
    Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
    Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
  })(Status || (exports.Status = Status = {}));
  var LogVerbosity;
  (function(LogVerbosity2) {
    LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
    LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
    LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
    LogVerbosity2[LogVerbosity2["NONE"] = 3] = "NONE";
  })(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));
  var Propagate;
  (function(Propagate2) {
    Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
    Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
    Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
    Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
    Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
  })(Propagate || (exports.Propagate = Propagate = {}));
  exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
  exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
});

// node_modules/@grpc/grpc-js/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "@grpc/grpc-js",
    version: "1.13.4",
    description: "gRPC Library for Node - pure JS implementation",
    homepage: "https://grpc.io/",
    repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
    main: "build/src/index.js",
    engines: {
      node: ">=12.10.0"
    },
    keywords: [],
    author: {
      name: "Google Inc."
    },
    types: "build/src/index.d.ts",
    license: "Apache-2.0",
    devDependencies: {
      "@grpc/proto-loader": "file:../proto-loader",
      "@types/gulp": "^4.0.17",
      "@types/gulp-mocha": "0.0.37",
      "@types/lodash": "^4.14.202",
      "@types/mocha": "^10.0.6",
      "@types/ncp": "^2.0.8",
      "@types/node": ">=20.11.20",
      "@types/pify": "^5.0.4",
      "@types/semver": "^7.5.8",
      "@typescript-eslint/eslint-plugin": "^7.1.0",
      "@typescript-eslint/parser": "^7.1.0",
      "@typescript-eslint/typescript-estree": "^7.1.0",
      "clang-format": "^1.8.0",
      eslint: "^8.42.0",
      "eslint-config-prettier": "^8.8.0",
      "eslint-plugin-node": "^11.1.0",
      "eslint-plugin-prettier": "^4.2.1",
      execa: "^2.0.3",
      gulp: "^4.0.2",
      "gulp-mocha": "^6.0.0",
      lodash: "^4.17.21",
      madge: "^5.0.1",
      "mocha-jenkins-reporter": "^0.4.1",
      ncp: "^2.0.0",
      pify: "^4.0.1",
      prettier: "^2.8.8",
      rimraf: "^3.0.2",
      semver: "^7.6.0",
      "ts-node": "^10.9.2",
      typescript: "^5.3.3"
    },
    contributors: [
      {
        name: "Google Inc."
      }
    ],
    scripts: {
      build: "npm run compile",
      clean: "rimraf ./build",
      compile: "tsc -p .",
      format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
      lint: "eslint src/*.ts test/*.ts",
      prepare: "npm run generate-types && npm run compile",
      test: "gulp test",
      check: "npm run lint",
      fix: "eslint --fix src/*.ts test/*.ts",
      pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
      posttest: "npm run check && madge -c ./build/src",
      "generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
      "generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
    },
    dependencies: {
      "@grpc/proto-loader": "^0.7.13",
      "@js-sdsl/ordered-map": "^4.4.2"
    },
    files: [
      "src/**/*.ts",
      "build/src/**/*.{js,d.ts,js.map}",
      "proto/*.proto",
      "LICENSE",
      "deps/envoy-api/envoy/api/v2/**/*.proto",
      "deps/envoy-api/envoy/config/**/*.proto",
      "deps/envoy-api/envoy/service/**/*.proto",
      "deps/envoy-api/envoy/type/**/*.proto",
      "deps/udpa/udpa/**/*.proto",
      "deps/googleapis/google/api/*.proto",
      "deps/googleapis/google/rpc/*.proto",
      "deps/protoc-gen-validate/validate/**/*.proto"
    ]
  };
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS((exports) => {
  var _a;
  var _b;
  var _c;
  var _d;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = undefined;
  exports.trace = trace;
  exports.isTracerEnabled = isTracerEnabled;
  var constants_1 = require_constants2();
  var process_1 = __require("process");
  var clientVersion = require_package2().version;
  var DEFAULT_LOGGER = {
    error: (message, ...optionalParams) => {
      console.error("E " + message, ...optionalParams);
    },
    info: (message, ...optionalParams) => {
      console.error("I " + message, ...optionalParams);
    },
    debug: (message, ...optionalParams) => {
      console.error("D " + message, ...optionalParams);
    }
  };
  var _logger = DEFAULT_LOGGER;
  var _logVerbosity = constants_1.LogVerbosity.ERROR;
  var verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== undefined ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== undefined ? _b : "";
  switch (verbosityString.toUpperCase()) {
    case "DEBUG":
      _logVerbosity = constants_1.LogVerbosity.DEBUG;
      break;
    case "INFO":
      _logVerbosity = constants_1.LogVerbosity.INFO;
      break;
    case "ERROR":
      _logVerbosity = constants_1.LogVerbosity.ERROR;
      break;
    case "NONE":
      _logVerbosity = constants_1.LogVerbosity.NONE;
      break;
    default:
  }
  var getLogger = () => {
    return _logger;
  };
  exports.getLogger = getLogger;
  var setLogger = (logger) => {
    _logger = logger;
  };
  exports.setLogger = setLogger;
  var setLoggerVerbosity = (verbosity) => {
    _logVerbosity = verbosity;
  };
  exports.setLoggerVerbosity = setLoggerVerbosity;
  var log = (severity, ...args) => {
    let logFunction;
    if (severity >= _logVerbosity) {
      switch (severity) {
        case constants_1.LogVerbosity.DEBUG:
          logFunction = _logger.debug;
          break;
        case constants_1.LogVerbosity.INFO:
          logFunction = _logger.info;
          break;
        case constants_1.LogVerbosity.ERROR:
          logFunction = _logger.error;
          break;
      }
      if (!logFunction) {
        logFunction = _logger.error;
      }
      if (logFunction) {
        logFunction.bind(_logger)(...args);
      }
    }
  };
  exports.log = log;
  var tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== undefined ? _c : process.env.GRPC_TRACE) !== null && _d !== undefined ? _d : "";
  var enabledTracers = new Set;
  var disabledTracers = new Set;
  for (const tracerName of tracersString.split(",")) {
    if (tracerName.startsWith("-")) {
      disabledTracers.add(tracerName.substring(1));
    } else {
      enabledTracers.add(tracerName);
    }
  }
  var allEnabled = enabledTracers.has("all");
  function trace(severity, tracer, text) {
    if (isTracerEnabled(tracer)) {
      (0, exports.log)(severity, new Date().toISOString() + " | v" + clientVersion + " " + process_1.pid + " | " + tracer + " | " + text);
    }
  }
  function isTracerEnabled(tracer) {
    return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));
  }
});

// node_modules/@grpc/grpc-js/build/src/error.js
var require_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getErrorMessage = getErrorMessage;
  exports.getErrorCode = getErrorCode;
  function getErrorMessage(error) {
    if (error instanceof Error) {
      return error.message;
    } else {
      return String(error);
    }
  }
  function getErrorCode(error) {
    if (typeof error === "object" && error !== null && "code" in error && typeof error.code === "number") {
      return error.code;
    } else {
      return null;
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Metadata = undefined;
  var logging_1 = require_logging();
  var constants_1 = require_constants2();
  var error_1 = require_error2();
  var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
  var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
  function isLegalKey(key) {
    return LEGAL_KEY_REGEX.test(key);
  }
  function isLegalNonBinaryValue(value) {
    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
  }
  function isBinaryKey(key) {
    return key.endsWith("-bin");
  }
  function isCustomMetadata(key) {
    return !key.startsWith("grpc-");
  }
  function normalizeKey(key) {
    return key.toLowerCase();
  }
  function validate(key, value) {
    if (!isLegalKey(key)) {
      throw new Error('Metadata key "' + key + '" contains illegal characters');
    }
    if (value !== null && value !== undefined) {
      if (isBinaryKey(key)) {
        if (!Buffer.isBuffer(value)) {
          throw new Error("keys that end with '-bin' must have Buffer values");
        }
      } else {
        if (Buffer.isBuffer(value)) {
          throw new Error("keys that don't end with '-bin' must have String values");
        }
        if (!isLegalNonBinaryValue(value)) {
          throw new Error('Metadata string value "' + value + '" contains illegal characters');
        }
      }
    }
  }

  class Metadata {
    constructor(options = {}) {
      this.internalRepr = new Map;
      this.options = options;
    }
    set(key, value) {
      key = normalizeKey(key);
      validate(key, value);
      this.internalRepr.set(key, [value]);
    }
    add(key, value) {
      key = normalizeKey(key);
      validate(key, value);
      const existingValue = this.internalRepr.get(key);
      if (existingValue === undefined) {
        this.internalRepr.set(key, [value]);
      } else {
        existingValue.push(value);
      }
    }
    remove(key) {
      key = normalizeKey(key);
      this.internalRepr.delete(key);
    }
    get(key) {
      key = normalizeKey(key);
      return this.internalRepr.get(key) || [];
    }
    getMap() {
      const result = {};
      for (const [key, values] of this.internalRepr) {
        if (values.length > 0) {
          const v = values[0];
          result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
        }
      }
      return result;
    }
    clone() {
      const newMetadata = new Metadata(this.options);
      const newInternalRepr = newMetadata.internalRepr;
      for (const [key, value] of this.internalRepr) {
        const clonedValue = value.map((v) => {
          if (Buffer.isBuffer(v)) {
            return Buffer.from(v);
          } else {
            return v;
          }
        });
        newInternalRepr.set(key, clonedValue);
      }
      return newMetadata;
    }
    merge(other) {
      for (const [key, values] of other.internalRepr) {
        const mergedValue = (this.internalRepr.get(key) || []).concat(values);
        this.internalRepr.set(key, mergedValue);
      }
    }
    setOptions(options) {
      this.options = options;
    }
    getOptions() {
      return this.options;
    }
    toHttp2Headers() {
      const result = {};
      for (const [key, values] of this.internalRepr) {
        result[key] = values.map(bufToString);
      }
      return result;
    }
    toJSON() {
      const result = {};
      for (const [key, values] of this.internalRepr) {
        result[key] = values;
      }
      return result;
    }
    static fromHttp2Headers(headers) {
      const result = new Metadata;
      for (const key of Object.keys(headers)) {
        if (key.charAt(0) === ":") {
          continue;
        }
        const values = headers[key];
        try {
          if (isBinaryKey(key)) {
            if (Array.isArray(values)) {
              values.forEach((value) => {
                result.add(key, Buffer.from(value, "base64"));
              });
            } else if (values !== undefined) {
              if (isCustomMetadata(key)) {
                values.split(",").forEach((v) => {
                  result.add(key, Buffer.from(v.trim(), "base64"));
                });
              } else {
                result.add(key, Buffer.from(values, "base64"));
              }
            }
          } else {
            if (Array.isArray(values)) {
              values.forEach((value) => {
                result.add(key, value);
              });
            } else if (values !== undefined) {
              result.add(key, values);
            }
          }
        } catch (error) {
          const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
          (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);
        }
      }
      return result;
    }
  }
  exports.Metadata = Metadata;
  var bufToString = (val) => {
    return Buffer.isBuffer(val) ? val.toString("base64") : val;
  };
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallCredentials = undefined;
  var metadata_1 = require_metadata();
  function isCurrentOauth2Client(client) {
    return "getRequestHeaders" in client && typeof client.getRequestHeaders === "function";
  }

  class CallCredentials {
    static createFromMetadataGenerator(metadataGenerator) {
      return new SingleCallCredentials(metadataGenerator);
    }
    static createFromGoogleCredential(googleCredentials) {
      return CallCredentials.createFromMetadataGenerator((options, callback) => {
        let getHeaders;
        if (isCurrentOauth2Client(googleCredentials)) {
          getHeaders = googleCredentials.getRequestHeaders(options.service_url);
        } else {
          getHeaders = new Promise((resolve, reject) => {
            googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
              if (err) {
                reject(err);
                return;
              }
              if (!headers) {
                reject(new Error("Headers not set by metadata plugin"));
                return;
              }
              resolve(headers);
            });
          });
        }
        getHeaders.then((headers) => {
          const metadata = new metadata_1.Metadata;
          for (const key of Object.keys(headers)) {
            metadata.add(key, headers[key]);
          }
          callback(null, metadata);
        }, (err) => {
          callback(err);
        });
      });
    }
    static createEmpty() {
      return new EmptyCallCredentials;
    }
  }
  exports.CallCredentials = CallCredentials;

  class ComposedCallCredentials extends CallCredentials {
    constructor(creds) {
      super();
      this.creds = creds;
    }
    async generateMetadata(options) {
      const base = new metadata_1.Metadata;
      const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));
      for (const gen of generated) {
        base.merge(gen);
      }
      return base;
    }
    compose(other) {
      return new ComposedCallCredentials(this.creds.concat([other]));
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof ComposedCallCredentials) {
        return this.creds.every((value, index) => value._equals(other.creds[index]));
      } else {
        return false;
      }
    }
  }

  class SingleCallCredentials extends CallCredentials {
    constructor(metadataGenerator) {
      super();
      this.metadataGenerator = metadataGenerator;
    }
    generateMetadata(options) {
      return new Promise((resolve, reject) => {
        this.metadataGenerator(options, (err, metadata) => {
          if (metadata !== undefined) {
            resolve(metadata);
          } else {
            reject(err);
          }
        });
      });
    }
    compose(other) {
      return new ComposedCallCredentials([this, other]);
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof SingleCallCredentials) {
        return this.metadataGenerator === other.metadataGenerator;
      } else {
        return false;
      }
    }
  }

  class EmptyCallCredentials extends CallCredentials {
    generateMetadata(options) {
      return Promise.resolve(new metadata_1.Metadata);
    }
    compose(other) {
      return other;
    }
    _equals(other) {
      return other instanceof EmptyCallCredentials;
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CIPHER_SUITES = undefined;
  exports.getDefaultRootsData = getDefaultRootsData;
  var fs = __require("fs");
  exports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
  var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
  var defaultRootsData = null;
  function getDefaultRootsData() {
    if (DEFAULT_ROOTS_FILE_PATH) {
      if (defaultRootsData === null) {
        defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
      }
      return defaultRootsData;
    }
    return null;
  }
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseUri = parseUri;
  exports.splitHostPort = splitHostPort;
  exports.combineHostPort = combineHostPort;
  exports.uriToString = uriToString;
  var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
  function parseUri(uriString) {
    const parsedUri = URI_REGEX.exec(uriString);
    if (parsedUri === null) {
      return null;
    }
    return {
      scheme: parsedUri[1],
      authority: parsedUri[2],
      path: parsedUri[3]
    };
  }
  var NUMBER_REGEX = /^\d+$/;
  function splitHostPort(path) {
    if (path.startsWith("[")) {
      const hostEnd = path.indexOf("]");
      if (hostEnd === -1) {
        return null;
      }
      const host = path.substring(1, hostEnd);
      if (host.indexOf(":") === -1) {
        return null;
      }
      if (path.length > hostEnd + 1) {
        if (path[hostEnd + 1] === ":") {
          const portString = path.substring(hostEnd + 2);
          if (NUMBER_REGEX.test(portString)) {
            return {
              host,
              port: +portString
            };
          } else {
            return null;
          }
        } else {
          return null;
        }
      } else {
        return {
          host
        };
      }
    } else {
      const splitPath = path.split(":");
      if (splitPath.length === 2) {
        if (NUMBER_REGEX.test(splitPath[1])) {
          return {
            host: splitPath[0],
            port: +splitPath[1]
          };
        } else {
          return null;
        }
      } else {
        return {
          host: path
        };
      }
    }
  }
  function combineHostPort(hostPort) {
    if (hostPort.port === undefined) {
      return hostPort.host;
    } else {
      if (hostPort.host.includes(":")) {
        return `[${hostPort.host}]:${hostPort.port}`;
      } else {
        return `${hostPort.host}:${hostPort.port}`;
      }
    }
  }
  function uriToString(uri) {
    let result = "";
    if (uri.scheme !== undefined) {
      result += uri.scheme + ":";
    }
    if (uri.authority !== undefined) {
      result += "//" + uri.authority + "/";
    }
    result += uri.path;
    return result;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerResolver = registerResolver;
  exports.registerDefaultScheme = registerDefaultScheme;
  exports.createResolver = createResolver;
  exports.getDefaultAuthority = getDefaultAuthority;
  exports.mapUriDefaultScheme = mapUriDefaultScheme;
  var uri_parser_1 = require_uri_parser();
  var registeredResolvers = {};
  var defaultScheme = null;
  function registerResolver(scheme, resolverClass) {
    registeredResolvers[scheme] = resolverClass;
  }
  function registerDefaultScheme(scheme) {
    defaultScheme = scheme;
  }
  function createResolver(target, listener, options) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
      return new registeredResolvers[target.scheme](target, listener, options);
    } else {
      throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);
    }
  }
  function getDefaultAuthority(target) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
      return registeredResolvers[target.scheme].getDefaultAuthority(target);
    } else {
      throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);
    }
  }
  function mapUriDefaultScheme(target) {
    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {
      if (defaultScheme !== null) {
        return {
          scheme: defaultScheme,
          authority: undefined,
          path: (0, uri_parser_1.uriToString)(target)
        };
      } else {
        return null;
      }
    }
    return target;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChannelCredentials = undefined;
  exports.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;
  var tls_1 = __require("tls");
  var call_credentials_1 = require_call_credentials();
  var tls_helpers_1 = require_tls_helpers();
  var uri_parser_1 = require_uri_parser();
  var resolver_1 = require_resolver();
  var logging_1 = require_logging();
  var constants_1 = require_constants2();
  function verifyIsBufferOrNull(obj, friendlyName) {
    if (obj && !(obj instanceof Buffer)) {
      throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
    }
  }

  class ChannelCredentials {
    compose(callCredentials) {
      return new ComposedChannelCredentialsImpl(this, callCredentials);
    }
    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
      var _a;
      verifyIsBufferOrNull(rootCerts, "Root certificate");
      verifyIsBufferOrNull(privateKey, "Private key");
      verifyIsBufferOrNull(certChain, "Certificate chain");
      if (privateKey && !certChain) {
        throw new Error("Private key must be given with accompanying certificate chain");
      }
      if (!privateKey && certChain) {
        throw new Error("Certificate chain must be given with accompanying private key");
      }
      const secureContext = (0, tls_1.createSecureContext)({
        ca: (_a = rootCerts !== null && rootCerts !== undefined ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== undefined ? _a : undefined,
        key: privateKey !== null && privateKey !== undefined ? privateKey : undefined,
        cert: certChain !== null && certChain !== undefined ? certChain : undefined,
        ciphers: tls_helpers_1.CIPHER_SUITES
      });
      return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : {});
    }
    static createFromSecureContext(secureContext, verifyOptions) {
      return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : {});
    }
    static createInsecure() {
      return new InsecureChannelCredentialsImpl;
    }
  }
  exports.ChannelCredentials = ChannelCredentials;

  class InsecureChannelCredentialsImpl extends ChannelCredentials {
    constructor() {
      super();
    }
    compose(callCredentials) {
      throw new Error("Cannot compose insecure credentials");
    }
    _isSecure() {
      return false;
    }
    _equals(other) {
      return other instanceof InsecureChannelCredentialsImpl;
    }
    _createSecureConnector(channelTarget, options, callCredentials) {
      return {
        connect(socket) {
          return Promise.resolve({
            socket,
            secure: false
          });
        },
        waitForReady: () => {
          return Promise.resolve();
        },
        getCallCredentials: () => {
          return callCredentials !== null && callCredentials !== undefined ? callCredentials : call_credentials_1.CallCredentials.createEmpty();
        },
        destroy() {
        }
      };
    }
  }
  function getConnectionOptions(secureContext, verifyOptions, channelTarget, options) {
    var _a, _b;
    const connectionOptions = {
      secureContext
    };
    let realTarget = channelTarget;
    if ("grpc.http_connect_target" in options) {
      const parsedTarget = (0, uri_parser_1.parseUri)(options["grpc.http_connect_target"]);
      if (parsedTarget) {
        realTarget = parsedTarget;
      }
    }
    const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);
    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
    const remoteHost = (_a = hostPort === null || hostPort === undefined ? undefined : hostPort.host) !== null && _a !== undefined ? _a : targetPath;
    connectionOptions.host = remoteHost;
    if (verifyOptions.checkServerIdentity) {
      connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;
    }
    if (verifyOptions.rejectUnauthorized !== undefined) {
      connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;
    }
    connectionOptions.ALPNProtocols = ["h2"];
    if (options["grpc.ssl_target_name_override"]) {
      const sslTargetNameOverride = options["grpc.ssl_target_name_override"];
      const originalCheckServerIdentity = (_b = connectionOptions.checkServerIdentity) !== null && _b !== undefined ? _b : tls_1.checkServerIdentity;
      connectionOptions.checkServerIdentity = (host, cert) => {
        return originalCheckServerIdentity(sslTargetNameOverride, cert);
      };
      connectionOptions.servername = sslTargetNameOverride;
    } else {
      connectionOptions.servername = remoteHost;
    }
    if (options["grpc-node.tls_enable_trace"]) {
      connectionOptions.enableTrace = true;
    }
    return connectionOptions;
  }

  class SecureConnectorImpl {
    constructor(connectionOptions, callCredentials) {
      this.connectionOptions = connectionOptions;
      this.callCredentials = callCredentials;
    }
    connect(socket) {
      const tlsConnectOptions = Object.assign({ socket }, this.connectionOptions);
      return new Promise((resolve, reject) => {
        const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {
          var _a;
          if (((_a = this.connectionOptions.rejectUnauthorized) !== null && _a !== undefined ? _a : true) && !tlsSocket.authorized) {
            reject(tlsSocket.authorizationError);
            return;
          }
          resolve({
            socket: tlsSocket,
            secure: true
          });
        });
        tlsSocket.on("error", (error) => {
          reject(error);
        });
      });
    }
    waitForReady() {
      return Promise.resolve();
    }
    getCallCredentials() {
      return this.callCredentials;
    }
    destroy() {
    }
  }

  class SecureChannelCredentialsImpl extends ChannelCredentials {
    constructor(secureContext, verifyOptions) {
      super();
      this.secureContext = secureContext;
      this.verifyOptions = verifyOptions;
    }
    _isSecure() {
      return true;
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof SecureChannelCredentialsImpl) {
        return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
      } else {
        return false;
      }
    }
    _createSecureConnector(channelTarget, options, callCredentials) {
      const connectionOptions = getConnectionOptions(this.secureContext, this.verifyOptions, channelTarget, options);
      return new SecureConnectorImpl(connectionOptions, callCredentials !== null && callCredentials !== undefined ? callCredentials : call_credentials_1.CallCredentials.createEmpty());
    }
  }

  class CertificateProviderChannelCredentialsImpl extends ChannelCredentials {
    constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {
      super();
      this.caCertificateProvider = caCertificateProvider;
      this.identityCertificateProvider = identityCertificateProvider;
      this.verifyOptions = verifyOptions;
      this.refcount = 0;
      this.latestCaUpdate = undefined;
      this.latestIdentityUpdate = undefined;
      this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
      this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
      this.secureContextWatchers = [];
    }
    _isSecure() {
      return true;
    }
    _equals(other) {
      var _a, _b;
      if (this === other) {
        return true;
      }
      if (other instanceof CertificateProviderChannelCredentialsImpl) {
        return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && ((_a = this.verifyOptions) === null || _a === undefined ? undefined : _a.checkServerIdentity) === ((_b = other.verifyOptions) === null || _b === undefined ? undefined : _b.checkServerIdentity);
      } else {
        return false;
      }
    }
    ref() {
      var _a;
      if (this.refcount === 0) {
        this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);
        (_a = this.identityCertificateProvider) === null || _a === undefined || _a.addIdentityCertificateListener(this.identityCertificateUpdateListener);
      }
      this.refcount += 1;
    }
    unref() {
      var _a;
      this.refcount -= 1;
      if (this.refcount === 0) {
        this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);
        (_a = this.identityCertificateProvider) === null || _a === undefined || _a.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
      }
    }
    _createSecureConnector(channelTarget, options, callCredentials) {
      this.ref();
      return new CertificateProviderChannelCredentialsImpl.SecureConnectorImpl(this, channelTarget, options, callCredentials !== null && callCredentials !== undefined ? callCredentials : call_credentials_1.CallCredentials.createEmpty());
    }
    maybeUpdateWatchers() {
      if (this.hasReceivedUpdates()) {
        for (const watcher of this.secureContextWatchers) {
          watcher(this.getLatestSecureContext());
        }
        this.secureContextWatchers = [];
      }
    }
    handleCaCertificateUpdate(update) {
      this.latestCaUpdate = update;
      this.maybeUpdateWatchers();
    }
    handleIdentityCertitificateUpdate(update) {
      this.latestIdentityUpdate = update;
      this.maybeUpdateWatchers();
    }
    hasReceivedUpdates() {
      if (this.latestCaUpdate === undefined) {
        return false;
      }
      if (this.identityCertificateProvider && this.latestIdentityUpdate === undefined) {
        return false;
      }
      return true;
    }
    getSecureContext() {
      if (this.hasReceivedUpdates()) {
        return Promise.resolve(this.getLatestSecureContext());
      } else {
        return new Promise((resolve) => {
          this.secureContextWatchers.push(resolve);
        });
      }
    }
    getLatestSecureContext() {
      var _a, _b;
      if (!this.latestCaUpdate) {
        return null;
      }
      if (this.identityCertificateProvider !== null && !this.latestIdentityUpdate) {
        return null;
      }
      try {
        return (0, tls_1.createSecureContext)({
          ca: this.latestCaUpdate.caCertificate,
          key: (_a = this.latestIdentityUpdate) === null || _a === undefined ? undefined : _a.privateKey,
          cert: (_b = this.latestIdentityUpdate) === null || _b === undefined ? undefined : _b.certificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
      } catch (e) {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to createSecureContext with error " + e.message);
        return null;
      }
    }
  }
  CertificateProviderChannelCredentialsImpl.SecureConnectorImpl = class {
    constructor(parent, channelTarget, options, callCredentials) {
      this.parent = parent;
      this.channelTarget = channelTarget;
      this.options = options;
      this.callCredentials = callCredentials;
    }
    connect(socket) {
      return new Promise((resolve, reject) => {
        const secureContext = this.parent.getLatestSecureContext();
        if (!secureContext) {
          reject(new Error("Failed to load credentials"));
          return;
        }
        if (socket.closed) {
          reject(new Error("Socket closed while loading credentials"));
        }
        const connnectionOptions = getConnectionOptions(secureContext, this.parent.verifyOptions, this.channelTarget, this.options);
        const tlsConnectOptions = Object.assign({ socket }, connnectionOptions);
        const closeCallback = () => {
          reject(new Error("Socket closed"));
        };
        const errorCallback = (error) => {
          reject(error);
        };
        const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {
          var _a;
          tlsSocket.removeListener("close", closeCallback);
          tlsSocket.removeListener("error", errorCallback);
          if (((_a = this.parent.verifyOptions.rejectUnauthorized) !== null && _a !== undefined ? _a : true) && !tlsSocket.authorized) {
            reject(tlsSocket.authorizationError);
            return;
          }
          resolve({
            socket: tlsSocket,
            secure: true
          });
        });
        tlsSocket.once("close", closeCallback);
        tlsSocket.once("error", errorCallback);
      });
    }
    async waitForReady() {
      await this.parent.getSecureContext();
    }
    getCallCredentials() {
      return this.callCredentials;
    }
    destroy() {
      this.parent.unref();
    }
  };
  function createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {
    return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : {});
  }

  class ComposedChannelCredentialsImpl extends ChannelCredentials {
    constructor(channelCredentials, callCredentials) {
      super();
      this.channelCredentials = channelCredentials;
      this.callCredentials = callCredentials;
      if (!channelCredentials._isSecure()) {
        throw new Error("Cannot compose insecure credentials");
      }
    }
    compose(callCredentials) {
      const combinedCallCredentials = this.callCredentials.compose(callCredentials);
      return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
    }
    _isSecure() {
      return true;
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof ComposedChannelCredentialsImpl) {
        return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
      } else {
        return false;
      }
    }
    _createSecureConnector(channelTarget, options, callCredentials) {
      const combinedCallCredentials = this.callCredentials.compose(callCredentials !== null && callCredentials !== undefined ? callCredentials : call_credentials_1.CallCredentials.createEmpty());
      return this.channelCredentials._createSecureConnector(channelTarget, options, combinedCallCredentials);
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChildChannelControlHelper = createChildChannelControlHelper;
  exports.registerLoadBalancerType = registerLoadBalancerType;
  exports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
  exports.createLoadBalancer = createLoadBalancer;
  exports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
  exports.parseLoadBalancingConfig = parseLoadBalancingConfig;
  exports.getDefaultConfig = getDefaultConfig;
  exports.selectLbConfigFromList = selectLbConfigFromList;
  var logging_1 = require_logging();
  var constants_1 = require_constants2();
  function createChildChannelControlHelper(parent, overrides) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return {
      createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === undefined ? undefined : _a.bind(overrides)) !== null && _b !== undefined ? _b : parent.createSubchannel.bind(parent),
      updateState: (_d = (_c = overrides.updateState) === null || _c === undefined ? undefined : _c.bind(overrides)) !== null && _d !== undefined ? _d : parent.updateState.bind(parent),
      requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === undefined ? undefined : _e.bind(overrides)) !== null && _f !== undefined ? _f : parent.requestReresolution.bind(parent),
      addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === undefined ? undefined : _g.bind(overrides)) !== null && _h !== undefined ? _h : parent.addChannelzChild.bind(parent),
      removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === undefined ? undefined : _j.bind(overrides)) !== null && _k !== undefined ? _k : parent.removeChannelzChild.bind(parent)
    };
  }
  var registeredLoadBalancerTypes = {};
  var defaultLoadBalancerType = null;
  function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
    registeredLoadBalancerTypes[typeName] = {
      LoadBalancer: loadBalancerType,
      LoadBalancingConfig: loadBalancingConfigType
    };
  }
  function registerDefaultLoadBalancerType(typeName) {
    defaultLoadBalancerType = typeName;
  }
  function createLoadBalancer(config, channelControlHelper) {
    const typeName = config.getLoadBalancerName();
    if (typeName in registeredLoadBalancerTypes) {
      return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);
    } else {
      return null;
    }
  }
  function isLoadBalancerNameRegistered(typeName) {
    return typeName in registeredLoadBalancerTypes;
  }
  function parseLoadBalancingConfig(rawConfig) {
    const keys = Object.keys(rawConfig);
    if (keys.length !== 1) {
      throw new Error("Provided load balancing config has multiple conflicting entries");
    }
    const typeName = keys[0];
    if (typeName in registeredLoadBalancerTypes) {
      try {
        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
      } catch (e) {
        throw new Error(`${typeName}: ${e.message}`);
      }
    } else {
      throw new Error(`Unrecognized load balancing config name ${typeName}`);
    }
  }
  function getDefaultConfig() {
    if (!defaultLoadBalancerType) {
      throw new Error("No default load balancer type registered");
    }
    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig;
  }
  function selectLbConfigFromList(configs, fallbackTodefault = false) {
    for (const config of configs) {
      try {
        return parseLoadBalancingConfig(config);
      } catch (e) {
        (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, "Config parsing failed with error", e.message);
        continue;
      }
    }
    if (fallbackTodefault) {
      if (defaultLoadBalancerType) {
        return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateRetryThrottling = validateRetryThrottling;
  exports.validateServiceConfig = validateServiceConfig;
  exports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
  var os = __require("os");
  var constants_1 = require_constants2();
  var DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
  var CLIENT_LANGUAGE_STRING = "node";
  function validateName(obj) {
    if ("service" in obj && obj.service !== "") {
      if (typeof obj.service !== "string") {
        throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);
      }
      if ("method" in obj && obj.method !== "") {
        if (typeof obj.method !== "string") {
          throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);
        }
        return {
          service: obj.service,
          method: obj.method
        };
      } else {
        return {
          service: obj.service
        };
      }
    } else {
      if ("method" in obj && obj.method !== undefined) {
        throw new Error(`Invalid method config name: method set with empty or unset service`);
      }
      return {};
    }
  }
  function validateRetryPolicy(obj) {
    if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
      throw new Error("Invalid method config retry policy: maxAttempts must be an integer at least 2");
    }
    if (!("initialBackoff" in obj) || typeof obj.initialBackoff !== "string" || !DURATION_REGEX.test(obj.initialBackoff)) {
      throw new Error("Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s");
    }
    if (!("maxBackoff" in obj) || typeof obj.maxBackoff !== "string" || !DURATION_REGEX.test(obj.maxBackoff)) {
      throw new Error("Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s");
    }
    if (!("backoffMultiplier" in obj) || typeof obj.backoffMultiplier !== "number" || obj.backoffMultiplier <= 0) {
      throw new Error("Invalid method config retry policy: backoffMultiplier must be a number greater than 0");
    }
    if (!(("retryableStatusCodes" in obj) && Array.isArray(obj.retryableStatusCodes))) {
      throw new Error("Invalid method config retry policy: retryableStatusCodes is required");
    }
    if (obj.retryableStatusCodes.length === 0) {
      throw new Error("Invalid method config retry policy: retryableStatusCodes must be non-empty");
    }
    for (const value of obj.retryableStatusCodes) {
      if (typeof value === "number") {
        if (!Object.values(constants_1.Status).includes(value)) {
          throw new Error("Invalid method config retry policy: retryableStatusCodes value not in status code range");
        }
      } else if (typeof value === "string") {
        if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
          throw new Error("Invalid method config retry policy: retryableStatusCodes value not a status code name");
        }
      } else {
        throw new Error("Invalid method config retry policy: retryableStatusCodes value must be a string or number");
      }
    }
    return {
      maxAttempts: obj.maxAttempts,
      initialBackoff: obj.initialBackoff,
      maxBackoff: obj.maxBackoff,
      backoffMultiplier: obj.backoffMultiplier,
      retryableStatusCodes: obj.retryableStatusCodes
    };
  }
  function validateHedgingPolicy(obj) {
    if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
      throw new Error("Invalid method config hedging policy: maxAttempts must be an integer at least 2");
    }
    if ("hedgingDelay" in obj && (typeof obj.hedgingDelay !== "string" || !DURATION_REGEX.test(obj.hedgingDelay))) {
      throw new Error("Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s");
    }
    if ("nonFatalStatusCodes" in obj && Array.isArray(obj.nonFatalStatusCodes)) {
      for (const value of obj.nonFatalStatusCodes) {
        if (typeof value === "number") {
          if (!Object.values(constants_1.Status).includes(value)) {
            throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value not in status code range");
          }
        } else if (typeof value === "string") {
          if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
            throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value not a status code name");
          }
        } else {
          throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number");
        }
      }
    }
    const result = {
      maxAttempts: obj.maxAttempts
    };
    if (obj.hedgingDelay) {
      result.hedgingDelay = obj.hedgingDelay;
    }
    if (obj.nonFatalStatusCodes) {
      result.nonFatalStatusCodes = obj.nonFatalStatusCodes;
    }
    return result;
  }
  function validateMethodConfig(obj) {
    var _a;
    const result = {
      name: []
    };
    if (!("name" in obj) || !Array.isArray(obj.name)) {
      throw new Error("Invalid method config: invalid name array");
    }
    for (const name of obj.name) {
      result.name.push(validateName(name));
    }
    if ("waitForReady" in obj) {
      if (typeof obj.waitForReady !== "boolean") {
        throw new Error("Invalid method config: invalid waitForReady");
      }
      result.waitForReady = obj.waitForReady;
    }
    if ("timeout" in obj) {
      if (typeof obj.timeout === "object") {
        if (!("seconds" in obj.timeout) || !(typeof obj.timeout.seconds === "number")) {
          throw new Error("Invalid method config: invalid timeout.seconds");
        }
        if (!("nanos" in obj.timeout) || !(typeof obj.timeout.nanos === "number")) {
          throw new Error("Invalid method config: invalid timeout.nanos");
        }
        result.timeout = obj.timeout;
      } else if (typeof obj.timeout === "string" && DURATION_REGEX.test(obj.timeout)) {
        const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(".");
        result.timeout = {
          seconds: timeoutParts[0] | 0,
          nanos: ((_a = timeoutParts[1]) !== null && _a !== undefined ? _a : 0) | 0
        };
      } else {
        throw new Error("Invalid method config: invalid timeout");
      }
    }
    if ("maxRequestBytes" in obj) {
      if (typeof obj.maxRequestBytes !== "number") {
        throw new Error("Invalid method config: invalid maxRequestBytes");
      }
      result.maxRequestBytes = obj.maxRequestBytes;
    }
    if ("maxResponseBytes" in obj) {
      if (typeof obj.maxResponseBytes !== "number") {
        throw new Error("Invalid method config: invalid maxRequestBytes");
      }
      result.maxResponseBytes = obj.maxResponseBytes;
    }
    if ("retryPolicy" in obj) {
      if ("hedgingPolicy" in obj) {
        throw new Error("Invalid method config: retryPolicy and hedgingPolicy cannot both be specified");
      } else {
        result.retryPolicy = validateRetryPolicy(obj.retryPolicy);
      }
    } else if ("hedgingPolicy" in obj) {
      result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
    }
    return result;
  }
  function validateRetryThrottling(obj) {
    if (!("maxTokens" in obj) || typeof obj.maxTokens !== "number" || obj.maxTokens <= 0 || obj.maxTokens > 1000) {
      throw new Error("Invalid retryThrottling: maxTokens must be a number in (0, 1000]");
    }
    if (!("tokenRatio" in obj) || typeof obj.tokenRatio !== "number" || obj.tokenRatio <= 0) {
      throw new Error("Invalid retryThrottling: tokenRatio must be a number greater than 0");
    }
    return {
      maxTokens: +obj.maxTokens.toFixed(3),
      tokenRatio: +obj.tokenRatio.toFixed(3)
    };
  }
  function validateLoadBalancingConfig(obj) {
    if (!(typeof obj === "object" && obj !== null)) {
      throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);
    }
    const keys = Object.keys(obj);
    if (keys.length > 1) {
      throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);
    }
    if (keys.length === 0) {
      throw new Error("Invalid loadBalancingConfig: load balancing policy name required");
    }
    return {
      [keys[0]]: obj[keys[0]]
    };
  }
  function validateServiceConfig(obj) {
    const result = {
      loadBalancingConfig: [],
      methodConfig: []
    };
    if ("loadBalancingPolicy" in obj) {
      if (typeof obj.loadBalancingPolicy === "string") {
        result.loadBalancingPolicy = obj.loadBalancingPolicy;
      } else {
        throw new Error("Invalid service config: invalid loadBalancingPolicy");
      }
    }
    if ("loadBalancingConfig" in obj) {
      if (Array.isArray(obj.loadBalancingConfig)) {
        for (const config of obj.loadBalancingConfig) {
          result.loadBalancingConfig.push(validateLoadBalancingConfig(config));
        }
      } else {
        throw new Error("Invalid service config: invalid loadBalancingConfig");
      }
    }
    if ("methodConfig" in obj) {
      if (Array.isArray(obj.methodConfig)) {
        for (const methodConfig of obj.methodConfig) {
          result.methodConfig.push(validateMethodConfig(methodConfig));
        }
      }
    }
    if ("retryThrottling" in obj) {
      result.retryThrottling = validateRetryThrottling(obj.retryThrottling);
    }
    const seenMethodNames = [];
    for (const methodConfig of result.methodConfig) {
      for (const name of methodConfig.name) {
        for (const seenName of seenMethodNames) {
          if (name.service === seenName.service && name.method === seenName.method) {
            throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
          }
        }
        seenMethodNames.push(name);
      }
    }
    return result;
  }
  function validateCanaryConfig(obj) {
    if (!("serviceConfig" in obj)) {
      throw new Error("Invalid service config choice: missing service config");
    }
    const result = {
      serviceConfig: validateServiceConfig(obj.serviceConfig)
    };
    if ("clientLanguage" in obj) {
      if (Array.isArray(obj.clientLanguage)) {
        result.clientLanguage = [];
        for (const lang of obj.clientLanguage) {
          if (typeof lang === "string") {
            result.clientLanguage.push(lang);
          } else {
            throw new Error("Invalid service config choice: invalid clientLanguage");
          }
        }
      } else {
        throw new Error("Invalid service config choice: invalid clientLanguage");
      }
    }
    if ("clientHostname" in obj) {
      if (Array.isArray(obj.clientHostname)) {
        result.clientHostname = [];
        for (const lang of obj.clientHostname) {
          if (typeof lang === "string") {
            result.clientHostname.push(lang);
          } else {
            throw new Error("Invalid service config choice: invalid clientHostname");
          }
        }
      } else {
        throw new Error("Invalid service config choice: invalid clientHostname");
      }
    }
    if ("percentage" in obj) {
      if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
        result.percentage = obj.percentage;
      } else {
        throw new Error("Invalid service config choice: invalid percentage");
      }
    }
    const allowedFields = [
      "clientLanguage",
      "percentage",
      "clientHostname",
      "serviceConfig"
    ];
    for (const field in obj) {
      if (!allowedFields.includes(field)) {
        throw new Error(`Invalid service config choice: unexpected field ${field}`);
      }
    }
    return result;
  }
  function validateAndSelectCanaryConfig(obj, percentage) {
    if (!Array.isArray(obj)) {
      throw new Error("Invalid service config list");
    }
    for (const config of obj) {
      const validatedConfig = validateCanaryConfig(config);
      if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
        continue;
      }
      if (Array.isArray(validatedConfig.clientHostname)) {
        let hostnameMatched = false;
        for (const hostname of validatedConfig.clientHostname) {
          if (hostname === os.hostname()) {
            hostnameMatched = true;
          }
        }
        if (!hostnameMatched) {
          continue;
        }
      }
      if (Array.isArray(validatedConfig.clientLanguage)) {
        let languageMatched = false;
        for (const language of validatedConfig.clientLanguage) {
          if (language === CLIENT_LANGUAGE_STRING) {
            languageMatched = true;
          }
        }
        if (!languageMatched) {
          continue;
        }
      }
      return validatedConfig.serviceConfig;
    }
    throw new Error("No matching service config found");
  }
  function extractAndSelectServiceConfig(txtRecord, percentage) {
    for (const record of txtRecord) {
      if (record.length > 0 && record[0].startsWith("grpc_config=")) {
        const recordString = record.join("").substring("grpc_config=".length);
        const recordJson = JSON.parse(recordString);
        return validateAndSelectCanaryConfig(recordJson, percentage);
      }
    }
    return null;
  }
});

// node_modules/@grpc/grpc-js/build/src/connectivity-state.js
var require_connectivity_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectivityState = undefined;
  var ConnectivityState;
  (function(ConnectivityState2) {
    ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
    ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
    ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
    ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
    ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
  })(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = undefined;
  var metadata_1 = require_metadata();
  var constants_1 = require_constants2();
  var PickResultType;
  (function(PickResultType2) {
    PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
    PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
    PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
    PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
  })(PickResultType || (exports.PickResultType = PickResultType = {}));

  class UnavailablePicker {
    constructor(status) {
      this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: "No connection established", metadata: new metadata_1.Metadata }, status);
    }
    pick(pickArgs) {
      return {
        pickResultType: PickResultType.TRANSIENT_FAILURE,
        subchannel: null,
        status: this.status,
        onCallStarted: null,
        onCallEnded: null
      };
    }
  }
  exports.UnavailablePicker = UnavailablePicker;

  class QueuePicker {
    constructor(loadBalancer, childPicker) {
      this.loadBalancer = loadBalancer;
      this.childPicker = childPicker;
      this.calledExitIdle = false;
    }
    pick(pickArgs) {
      if (!this.calledExitIdle) {
        process.nextTick(() => {
          this.loadBalancer.exitIdle();
        });
        this.calledExitIdle = true;
      }
      if (this.childPicker) {
        return this.childPicker.pick(pickArgs);
      } else {
        return {
          pickResultType: PickResultType.QUEUE,
          subchannel: null,
          status: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    }
  }
  exports.QueuePicker = QueuePicker;
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackoffTimeout = undefined;
  var constants_1 = require_constants2();
  var logging = require_logging();
  var TRACER_NAME = "backoff";
  var INITIAL_BACKOFF_MS = 1000;
  var BACKOFF_MULTIPLIER = 1.6;
  var MAX_BACKOFF_MS = 120000;
  var BACKOFF_JITTER = 0.2;
  function uniformRandom(min, max) {
    return Math.random() * (max - min) + min;
  }

  class BackoffTimeout {
    constructor(callback, options) {
      this.callback = callback;
      this.initialDelay = INITIAL_BACKOFF_MS;
      this.multiplier = BACKOFF_MULTIPLIER;
      this.maxDelay = MAX_BACKOFF_MS;
      this.jitter = BACKOFF_JITTER;
      this.running = false;
      this.hasRef = true;
      this.startTime = new Date;
      this.endTime = new Date;
      this.id = BackoffTimeout.getNextId();
      if (options) {
        if (options.initialDelay) {
          this.initialDelay = options.initialDelay;
        }
        if (options.multiplier) {
          this.multiplier = options.multiplier;
        }
        if (options.jitter) {
          this.jitter = options.jitter;
        }
        if (options.maxDelay) {
          this.maxDelay = options.maxDelay;
        }
      }
      this.trace("constructed initialDelay=" + this.initialDelay + " multiplier=" + this.multiplier + " jitter=" + this.jitter + " maxDelay=" + this.maxDelay);
      this.nextDelay = this.initialDelay;
      this.timerId = setTimeout(() => {
      }, 0);
      clearTimeout(this.timerId);
    }
    static getNextId() {
      return this.nextId++;
    }
    trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "{" + this.id + "} " + text);
    }
    runTimer(delay) {
      var _a, _b;
      this.trace("runTimer(delay=" + delay + ")");
      this.endTime = this.startTime;
      this.endTime.setMilliseconds(this.endTime.getMilliseconds() + delay);
      clearTimeout(this.timerId);
      this.timerId = setTimeout(() => {
        this.trace("timer fired");
        this.running = false;
        this.callback();
      }, delay);
      if (!this.hasRef) {
        (_b = (_a = this.timerId).unref) === null || _b === undefined || _b.call(_a);
      }
    }
    runOnce() {
      this.trace("runOnce()");
      this.running = true;
      this.startTime = new Date;
      this.runTimer(this.nextDelay);
      const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
      const jitterMagnitude = nextBackoff * this.jitter;
      this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
    }
    stop() {
      this.trace("stop()");
      clearTimeout(this.timerId);
      this.running = false;
    }
    reset() {
      this.trace("reset() running=" + this.running);
      this.nextDelay = this.initialDelay;
      if (this.running) {
        const now = new Date;
        const newEndTime = this.startTime;
        newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
        clearTimeout(this.timerId);
        if (now < newEndTime) {
          this.runTimer(newEndTime.getTime() - now.getTime());
        } else {
          this.running = false;
        }
      }
    }
    isRunning() {
      return this.running;
    }
    ref() {
      var _a, _b;
      this.hasRef = true;
      (_b = (_a = this.timerId).ref) === null || _b === undefined || _b.call(_a);
    }
    unref() {
      var _a, _b;
      this.hasRef = false;
      (_b = (_a = this.timerId).unref) === null || _b === undefined || _b.call(_a);
    }
    getEndTime() {
      return this.endTime;
    }
  }
  exports.BackoffTimeout = BackoffTimeout;
  BackoffTimeout.nextId = 0;
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChildLoadBalancerHandler = undefined;
  var load_balancer_1 = require_load_balancer();
  var connectivity_state_1 = require_connectivity_state();
  var TYPE_NAME = "child_load_balancer_helper";

  class ChildLoadBalancerHandler {
    constructor(channelControlHelper) {
      this.channelControlHelper = channelControlHelper;
      this.currentChild = null;
      this.pendingChild = null;
      this.latestConfig = null;
      this.ChildPolicyHelper = class {
        constructor(parent) {
          this.parent = parent;
          this.child = null;
        }
        createSubchannel(subchannelAddress, subchannelArgs) {
          return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
        }
        updateState(connectivityState, picker, errorMessage) {
          var _a;
          if (this.calledByPendingChild()) {
            if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
              return;
            }
            (_a = this.parent.currentChild) === null || _a === undefined || _a.destroy();
            this.parent.currentChild = this.parent.pendingChild;
            this.parent.pendingChild = null;
          } else if (!this.calledByCurrentChild()) {
            return;
          }
          this.parent.channelControlHelper.updateState(connectivityState, picker, errorMessage);
        }
        requestReresolution() {
          var _a;
          const latestChild = (_a = this.parent.pendingChild) !== null && _a !== undefined ? _a : this.parent.currentChild;
          if (this.child === latestChild) {
            this.parent.channelControlHelper.requestReresolution();
          }
        }
        setChild(newChild) {
          this.child = newChild;
        }
        addChannelzChild(child) {
          this.parent.channelControlHelper.addChannelzChild(child);
        }
        removeChannelzChild(child) {
          this.parent.channelControlHelper.removeChannelzChild(child);
        }
        calledByPendingChild() {
          return this.child === this.parent.pendingChild;
        }
        calledByCurrentChild() {
          return this.child === this.parent.currentChild;
        }
      };
    }
    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
      return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
    }
    updateAddressList(endpointList, lbConfig, options) {
      let childToUpdate;
      if (this.currentChild === null || this.latestConfig === null || this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {
        const newHelper = new this.ChildPolicyHelper(this);
        const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);
        newHelper.setChild(newChild);
        if (this.currentChild === null) {
          this.currentChild = newChild;
          childToUpdate = this.currentChild;
        } else {
          if (this.pendingChild) {
            this.pendingChild.destroy();
          }
          this.pendingChild = newChild;
          childToUpdate = this.pendingChild;
        }
      } else {
        if (this.pendingChild === null) {
          childToUpdate = this.currentChild;
        } else {
          childToUpdate = this.pendingChild;
        }
      }
      this.latestConfig = lbConfig;
      childToUpdate.updateAddressList(endpointList, lbConfig, options);
    }
    exitIdle() {
      if (this.currentChild) {
        this.currentChild.exitIdle();
        if (this.pendingChild) {
          this.pendingChild.exitIdle();
        }
      }
    }
    resetBackoff() {
      if (this.currentChild) {
        this.currentChild.resetBackoff();
        if (this.pendingChild) {
          this.pendingChild.resetBackoff();
        }
      }
    }
    destroy() {
      if (this.currentChild) {
        this.currentChild.destroy();
        this.currentChild = null;
      }
      if (this.pendingChild) {
        this.pendingChild.destroy();
        this.pendingChild = null;
      }
    }
    getTypeName() {
      return TYPE_NAME;
    }
  }
  exports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ResolvingLoadBalancer = undefined;
  var load_balancer_1 = require_load_balancer();
  var service_config_1 = require_service_config();
  var connectivity_state_1 = require_connectivity_state();
  var resolver_1 = require_resolver();
  var picker_1 = require_picker();
  var backoff_timeout_1 = require_backoff_timeout();
  var constants_1 = require_constants2();
  var metadata_1 = require_metadata();
  var logging = require_logging();
  var constants_2 = require_constants2();
  var uri_parser_1 = require_uri_parser();
  var load_balancer_child_handler_1 = require_load_balancer_child_handler();
  var TRACER_NAME = "resolving_load_balancer";
  function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var NAME_MATCH_LEVEL_ORDER = [
    "SERVICE_AND_METHOD",
    "SERVICE",
    "EMPTY"
  ];
  function hasMatchingName(service, method, methodConfig, matchLevel) {
    for (const name of methodConfig.name) {
      switch (matchLevel) {
        case "EMPTY":
          if (!name.service && !name.method) {
            return true;
          }
          break;
        case "SERVICE":
          if (name.service === service && !name.method) {
            return true;
          }
          break;
        case "SERVICE_AND_METHOD":
          if (name.service === service && name.method === method) {
            return true;
          }
      }
    }
    return false;
  }
  function findMatchingConfig(service, method, methodConfigs, matchLevel) {
    for (const config of methodConfigs) {
      if (hasMatchingName(service, method, config, matchLevel)) {
        return config;
      }
    }
    return null;
  }
  function getDefaultConfigSelector(serviceConfig) {
    return {
      invoke(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split("/").filter((x) => x.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== undefined ? _a : "";
        const method = (_b = splitName[1]) !== null && _b !== undefined ? _b : "";
        if (serviceConfig && serviceConfig.methodConfig) {
          for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
            const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);
            if (matchingConfig) {
              return {
                methodConfig: matchingConfig,
                pickInformation: {},
                status: constants_1.Status.OK,
                dynamicFilterFactories: []
              };
            }
          }
        }
        return {
          methodConfig: { name: [] },
          pickInformation: {},
          status: constants_1.Status.OK,
          dynamicFilterFactories: []
        };
      },
      unref() {
      }
    };
  }

  class ResolvingLoadBalancer {
    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
      this.target = target;
      this.channelControlHelper = channelControlHelper;
      this.channelOptions = channelOptions;
      this.onSuccessfulResolution = onSuccessfulResolution;
      this.onFailedResolution = onFailedResolution;
      this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
      this.latestChildPicker = new picker_1.QueuePicker(this);
      this.latestChildErrorMessage = null;
      this.currentState = connectivity_state_1.ConnectivityState.IDLE;
      this.previousServiceConfig = null;
      this.continueResolving = false;
      if (channelOptions["grpc.service_config"]) {
        this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions["grpc.service_config"]));
      } else {
        this.defaultServiceConfig = {
          loadBalancingConfig: [],
          methodConfig: []
        };
      }
      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);
      this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
        createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
        requestReresolution: () => {
          if (this.backoffTimeout.isRunning()) {
            trace("requestReresolution delayed by backoff timer until " + this.backoffTimeout.getEndTime().toISOString());
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
        },
        updateState: (newState, picker, errorMessage) => {
          this.latestChildState = newState;
          this.latestChildPicker = picker;
          this.latestChildErrorMessage = errorMessage;
          this.updateState(newState, picker, errorMessage);
        },
        addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
        removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)
      });
      this.innerResolver = (0, resolver_1.createResolver)(target, {
        onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {
          var _a;
          this.backoffTimeout.stop();
          this.backoffTimeout.reset();
          let workingServiceConfig = null;
          if (serviceConfig === null) {
            if (serviceConfigError === null) {
              this.previousServiceConfig = null;
              workingServiceConfig = this.defaultServiceConfig;
            } else {
              if (this.previousServiceConfig === null) {
                this.handleResolutionFailure(serviceConfigError);
              } else {
                workingServiceConfig = this.previousServiceConfig;
              }
            }
          } else {
            workingServiceConfig = serviceConfig;
            this.previousServiceConfig = serviceConfig;
          }
          const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === undefined ? undefined : workingServiceConfig.loadBalancingConfig) !== null && _a !== undefined ? _a : [];
          const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);
          if (loadBalancingConfig === null) {
            this.handleResolutionFailure({
              code: constants_1.Status.UNAVAILABLE,
              details: "All load balancer options in service config are not compatible",
              metadata: new metadata_1.Metadata
            });
            configSelector === null || configSelector === undefined || configSelector.unref();
            return;
          }
          this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, Object.assign(Object.assign({}, this.channelOptions), attributes));
          const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== undefined ? workingServiceConfig : this.defaultServiceConfig;
          this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== undefined ? configSelector : getDefaultConfigSelector(finalServiceConfig));
        },
        onError: (error) => {
          this.handleResolutionFailure(error);
        }
      }, channelOptions);
      const backoffOptions = {
        initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
        maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
      };
      this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
        if (this.continueResolving) {
          this.updateResolution();
          this.continueResolving = false;
        } else {
          this.updateState(this.latestChildState, this.latestChildPicker, this.latestChildErrorMessage);
        }
      }, backoffOptions);
      this.backoffTimeout.unref();
    }
    updateResolution() {
      this.innerResolver.updateResolution();
      if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker, this.latestChildErrorMessage);
      }
      this.backoffTimeout.runOnce();
    }
    updateState(connectivityState, picker, errorMessage) {
      trace((0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[connectivityState]);
      if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
        picker = new picker_1.QueuePicker(this, picker);
      }
      this.currentState = connectivityState;
      this.channelControlHelper.updateState(connectivityState, picker, errorMessage);
    }
    handleResolutionFailure(error) {
      if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error), error.details);
        this.onFailedResolution(error);
      }
    }
    exitIdle() {
      if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
        if (this.backoffTimeout.isRunning()) {
          this.continueResolving = true;
        } else {
          this.updateResolution();
        }
      }
      this.childLoadBalancer.exitIdle();
    }
    updateAddressList(endpointList, lbConfig) {
      throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
    }
    resetBackoff() {
      this.backoffTimeout.reset();
      this.childLoadBalancer.resetBackoff();
    }
    destroy() {
      this.childLoadBalancer.destroy();
      this.innerResolver.destroy();
      this.backoffTimeout.reset();
      this.backoffTimeout.stop();
      this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
      this.latestChildPicker = new picker_1.QueuePicker(this);
      this.currentState = connectivity_state_1.ConnectivityState.IDLE;
      this.previousServiceConfig = null;
      this.continueResolving = false;
    }
    getTypeName() {
      return "resolving_load_balancer";
    }
  }
  exports.ResolvingLoadBalancer = ResolvingLoadBalancer;
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recognizedOptions = undefined;
  exports.channelOptionsEqual = channelOptionsEqual;
  exports.recognizedOptions = {
    "grpc.ssl_target_name_override": true,
    "grpc.primary_user_agent": true,
    "grpc.secondary_user_agent": true,
    "grpc.default_authority": true,
    "grpc.keepalive_time_ms": true,
    "grpc.keepalive_timeout_ms": true,
    "grpc.keepalive_permit_without_calls": true,
    "grpc.service_config": true,
    "grpc.max_concurrent_streams": true,
    "grpc.initial_reconnect_backoff_ms": true,
    "grpc.max_reconnect_backoff_ms": true,
    "grpc.use_local_subchannel_pool": true,
    "grpc.max_send_message_length": true,
    "grpc.max_receive_message_length": true,
    "grpc.enable_http_proxy": true,
    "grpc.enable_channelz": true,
    "grpc.dns_min_time_between_resolutions_ms": true,
    "grpc.enable_retries": true,
    "grpc.per_rpc_retry_buffer_size": true,
    "grpc.retry_buffer_size": true,
    "grpc.max_connection_age_ms": true,
    "grpc.max_connection_age_grace_ms": true,
    "grpc-node.max_session_memory": true,
    "grpc.service_config_disable_resolution": true,
    "grpc.client_idle_timeout_ms": true,
    "grpc-node.tls_enable_trace": true,
    "grpc.lb.ring_hash.ring_size_cap": true,
    "grpc-node.retry_max_attempts_limit": true,
    "grpc-node.flow_control_window": true
  };
  function channelOptionsEqual(options1, options2) {
    const keys1 = Object.keys(options1).sort();
    const keys2 = Object.keys(options2).sort();
    if (keys1.length !== keys2.length) {
      return false;
    }
    for (let i = 0;i < keys1.length; i += 1) {
      if (keys1[i] !== keys2[i]) {
        return false;
      }
      if (options1[keys1[i]] !== options2[keys2[i]]) {
        return false;
      }
    }
    return true;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-address.js
var require_subchannel_address = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointMap = undefined;
  exports.isTcpSubchannelAddress = isTcpSubchannelAddress;
  exports.subchannelAddressEqual = subchannelAddressEqual;
  exports.subchannelAddressToString = subchannelAddressToString;
  exports.stringToSubchannelAddress = stringToSubchannelAddress;
  exports.endpointEqual = endpointEqual;
  exports.endpointToString = endpointToString;
  exports.endpointHasAddress = endpointHasAddress;
  var net_1 = __require("net");
  function isTcpSubchannelAddress(address) {
    return "port" in address;
  }
  function subchannelAddressEqual(address1, address2) {
    if (!address1 && !address2) {
      return true;
    }
    if (!address1 || !address2) {
      return false;
    }
    if (isTcpSubchannelAddress(address1)) {
      return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
    } else {
      return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
    }
  }
  function subchannelAddressToString(address) {
    if (isTcpSubchannelAddress(address)) {
      if ((0, net_1.isIPv6)(address.host)) {
        return "[" + address.host + "]:" + address.port;
      } else {
        return address.host + ":" + address.port;
      }
    } else {
      return address.path;
    }
  }
  var DEFAULT_PORT = 443;
  function stringToSubchannelAddress(addressString, port) {
    if ((0, net_1.isIP)(addressString)) {
      return {
        host: addressString,
        port: port !== null && port !== undefined ? port : DEFAULT_PORT
      };
    } else {
      return {
        path: addressString
      };
    }
  }
  function endpointEqual(endpoint1, endpoint2) {
    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
      return false;
    }
    for (let i = 0;i < endpoint1.addresses.length; i++) {
      if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {
        return false;
      }
    }
    return true;
  }
  function endpointToString(endpoint) {
    return "[" + endpoint.addresses.map(subchannelAddressToString).join(", ") + "]";
  }
  function endpointHasAddress(endpoint, expectedAddress) {
    for (const address of endpoint.addresses) {
      if (subchannelAddressEqual(address, expectedAddress)) {
        return true;
      }
    }
    return false;
  }
  function endpointEqualUnordered(endpoint1, endpoint2) {
    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
      return false;
    }
    for (const address1 of endpoint1.addresses) {
      let matchFound = false;
      for (const address2 of endpoint2.addresses) {
        if (subchannelAddressEqual(address1, address2)) {
          matchFound = true;
          break;
        }
      }
      if (!matchFound) {
        return false;
      }
    }
    return true;
  }

  class EndpointMap {
    constructor() {
      this.map = new Set;
    }
    get size() {
      return this.map.size;
    }
    getForSubchannelAddress(address) {
      for (const entry of this.map) {
        if (endpointHasAddress(entry.key, address)) {
          return entry.value;
        }
      }
      return;
    }
    deleteMissing(endpoints) {
      const removedValues = [];
      for (const entry of this.map) {
        let foundEntry = false;
        for (const endpoint of endpoints) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            foundEntry = true;
          }
        }
        if (!foundEntry) {
          removedValues.push(entry.value);
          this.map.delete(entry);
        }
      }
      return removedValues;
    }
    get(endpoint) {
      for (const entry of this.map) {
        if (endpointEqualUnordered(endpoint, entry.key)) {
          return entry.value;
        }
      }
      return;
    }
    set(endpoint, mapEntry) {
      for (const entry of this.map) {
        if (endpointEqualUnordered(endpoint, entry.key)) {
          entry.value = mapEntry;
          return;
        }
      }
      this.map.add({ key: endpoint, value: mapEntry });
    }
    delete(endpoint) {
      for (const entry of this.map) {
        if (endpointEqualUnordered(endpoint, entry.key)) {
          this.map.delete(entry);
          return;
        }
      }
    }
    has(endpoint) {
      for (const entry of this.map) {
        if (endpointEqualUnordered(endpoint, entry.key)) {
          return true;
        }
      }
      return false;
    }
    clear() {
      this.map.clear();
    }
    *keys() {
      for (const entry of this.map) {
        yield entry.key;
      }
    }
    *values() {
      for (const entry of this.map) {
        yield entry.value;
      }
    }
    *entries() {
      for (const entry of this.map) {
        yield [entry.key, entry.value];
      }
    }
  }
  exports.EndpointMap = EndpointMap;
});

// node_modules/@js-sdsl/ordered-map/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "t", {
    value: true
  });

  class TreeNode {
    constructor(t, e, s = 1) {
      this.i = undefined;
      this.h = undefined;
      this.o = undefined;
      this.u = t;
      this.l = e;
      this.p = s;
    }
    I() {
      let t = this;
      const e = t.o.o === t;
      if (e && t.p === 1) {
        t = t.h;
      } else if (t.i) {
        t = t.i;
        while (t.h) {
          t = t.h;
        }
      } else {
        if (e) {
          return t.o;
        }
        let s = t.o;
        while (s.i === t) {
          t = s;
          s = t.o;
        }
        t = s;
      }
      return t;
    }
    B() {
      let t = this;
      if (t.h) {
        t = t.h;
        while (t.i) {
          t = t.i;
        }
        return t;
      } else {
        let e = t.o;
        while (e.h === t) {
          t = e;
          e = t.o;
        }
        if (t.h !== e) {
          return e;
        } else
          return t;
      }
    }
    _() {
      const t = this.o;
      const e = this.h;
      const s = e.i;
      if (t.o === this)
        t.o = e;
      else if (t.i === this)
        t.i = e;
      else
        t.h = e;
      e.o = t;
      e.i = this;
      this.o = e;
      this.h = s;
      if (s)
        s.o = this;
      return e;
    }
    g() {
      const t = this.o;
      const e = this.i;
      const s = e.h;
      if (t.o === this)
        t.o = e;
      else if (t.i === this)
        t.i = e;
      else
        t.h = e;
      e.o = t;
      e.h = this;
      this.o = e;
      this.i = s;
      if (s)
        s.o = this;
      return e;
    }
  }

  class TreeNodeEnableIndex extends TreeNode {
    constructor() {
      super(...arguments);
      this.M = 1;
    }
    _() {
      const t = super._();
      this.O();
      t.O();
      return t;
    }
    g() {
      const t = super.g();
      this.O();
      t.O();
      return t;
    }
    O() {
      this.M = 1;
      if (this.i) {
        this.M += this.i.M;
      }
      if (this.h) {
        this.M += this.h.M;
      }
    }
  }

  class ContainerIterator {
    constructor(t = 0) {
      this.iteratorType = t;
    }
    equals(t) {
      return this.T === t.T;
    }
  }

  class Base {
    constructor() {
      this.m = 0;
    }
    get length() {
      return this.m;
    }
    size() {
      return this.m;
    }
    empty() {
      return this.m === 0;
    }
  }

  class Container extends Base {
  }
  function throwIteratorAccessError() {
    throw new RangeError("Iterator access denied!");
  }

  class TreeContainer extends Container {
    constructor(t = function(t2, e2) {
      if (t2 < e2)
        return -1;
      if (t2 > e2)
        return 1;
      return 0;
    }, e = false) {
      super();
      this.v = undefined;
      this.A = t;
      this.enableIndex = e;
      this.N = e ? TreeNodeEnableIndex : TreeNode;
      this.C = new this.N;
    }
    R(t, e) {
      let s = this.C;
      while (t) {
        const i = this.A(t.u, e);
        if (i < 0) {
          t = t.h;
        } else if (i > 0) {
          s = t;
          t = t.i;
        } else
          return t;
      }
      return s;
    }
    K(t, e) {
      let s = this.C;
      while (t) {
        const i = this.A(t.u, e);
        if (i <= 0) {
          t = t.h;
        } else {
          s = t;
          t = t.i;
        }
      }
      return s;
    }
    L(t, e) {
      let s = this.C;
      while (t) {
        const i = this.A(t.u, e);
        if (i < 0) {
          s = t;
          t = t.h;
        } else if (i > 0) {
          t = t.i;
        } else
          return t;
      }
      return s;
    }
    k(t, e) {
      let s = this.C;
      while (t) {
        const i = this.A(t.u, e);
        if (i < 0) {
          s = t;
          t = t.h;
        } else {
          t = t.i;
        }
      }
      return s;
    }
    P(t) {
      while (true) {
        const e = t.o;
        if (e === this.C)
          return;
        if (t.p === 1) {
          t.p = 0;
          return;
        }
        if (t === e.i) {
          const s = e.h;
          if (s.p === 1) {
            s.p = 0;
            e.p = 1;
            if (e === this.v) {
              this.v = e._();
            } else
              e._();
          } else {
            if (s.h && s.h.p === 1) {
              s.p = e.p;
              e.p = 0;
              s.h.p = 0;
              if (e === this.v) {
                this.v = e._();
              } else
                e._();
              return;
            } else if (s.i && s.i.p === 1) {
              s.p = 1;
              s.i.p = 0;
              s.g();
            } else {
              s.p = 1;
              t = e;
            }
          }
        } else {
          const s = e.i;
          if (s.p === 1) {
            s.p = 0;
            e.p = 1;
            if (e === this.v) {
              this.v = e.g();
            } else
              e.g();
          } else {
            if (s.i && s.i.p === 1) {
              s.p = e.p;
              e.p = 0;
              s.i.p = 0;
              if (e === this.v) {
                this.v = e.g();
              } else
                e.g();
              return;
            } else if (s.h && s.h.p === 1) {
              s.p = 1;
              s.h.p = 0;
              s._();
            } else {
              s.p = 1;
              t = e;
            }
          }
        }
      }
    }
    S(t) {
      if (this.m === 1) {
        this.clear();
        return;
      }
      let e = t;
      while (e.i || e.h) {
        if (e.h) {
          e = e.h;
          while (e.i)
            e = e.i;
        } else {
          e = e.i;
        }
        const s2 = t.u;
        t.u = e.u;
        e.u = s2;
        const i = t.l;
        t.l = e.l;
        e.l = i;
        t = e;
      }
      if (this.C.i === e) {
        this.C.i = e.o;
      } else if (this.C.h === e) {
        this.C.h = e.o;
      }
      this.P(e);
      let s = e.o;
      if (e === s.i) {
        s.i = undefined;
      } else
        s.h = undefined;
      this.m -= 1;
      this.v.p = 0;
      if (this.enableIndex) {
        while (s !== this.C) {
          s.M -= 1;
          s = s.o;
        }
      }
    }
    U(t) {
      const e = typeof t === "number" ? t : undefined;
      const s = typeof t === "function" ? t : undefined;
      const i = typeof t === "undefined" ? [] : undefined;
      let r = 0;
      let n = this.v;
      const h = [];
      while (h.length || n) {
        if (n) {
          h.push(n);
          n = n.i;
        } else {
          n = h.pop();
          if (r === e)
            return n;
          i && i.push(n);
          s && s(n, r, this);
          r += 1;
          n = n.h;
        }
      }
      return i;
    }
    j(t) {
      while (true) {
        const e = t.o;
        if (e.p === 0)
          return;
        const s = e.o;
        if (e === s.i) {
          const i = s.h;
          if (i && i.p === 1) {
            i.p = e.p = 0;
            if (s === this.v)
              return;
            s.p = 1;
            t = s;
            continue;
          } else if (t === e.h) {
            t.p = 0;
            if (t.i) {
              t.i.o = e;
            }
            if (t.h) {
              t.h.o = s;
            }
            e.h = t.i;
            s.i = t.h;
            t.i = e;
            t.h = s;
            if (s === this.v) {
              this.v = t;
              this.C.o = t;
            } else {
              const e2 = s.o;
              if (e2.i === s) {
                e2.i = t;
              } else
                e2.h = t;
            }
            t.o = s.o;
            e.o = t;
            s.o = t;
            s.p = 1;
          } else {
            e.p = 0;
            if (s === this.v) {
              this.v = s.g();
            } else
              s.g();
            s.p = 1;
            return;
          }
        } else {
          const i = s.i;
          if (i && i.p === 1) {
            i.p = e.p = 0;
            if (s === this.v)
              return;
            s.p = 1;
            t = s;
            continue;
          } else if (t === e.i) {
            t.p = 0;
            if (t.i) {
              t.i.o = s;
            }
            if (t.h) {
              t.h.o = e;
            }
            s.h = t.i;
            e.i = t.h;
            t.i = s;
            t.h = e;
            if (s === this.v) {
              this.v = t;
              this.C.o = t;
            } else {
              const e2 = s.o;
              if (e2.i === s) {
                e2.i = t;
              } else
                e2.h = t;
            }
            t.o = s.o;
            e.o = t;
            s.o = t;
            s.p = 1;
          } else {
            e.p = 0;
            if (s === this.v) {
              this.v = s._();
            } else
              s._();
            s.p = 1;
            return;
          }
        }
        if (this.enableIndex) {
          e.O();
          s.O();
          t.O();
        }
        return;
      }
    }
    q(t, e, s) {
      if (this.v === undefined) {
        this.m += 1;
        this.v = new this.N(t, e, 0);
        this.v.o = this.C;
        this.C.o = this.C.i = this.C.h = this.v;
        return this.m;
      }
      let i;
      const r = this.C.i;
      const n = this.A(r.u, t);
      if (n === 0) {
        r.l = e;
        return this.m;
      } else if (n > 0) {
        r.i = new this.N(t, e);
        r.i.o = r;
        i = r.i;
        this.C.i = i;
      } else {
        const r2 = this.C.h;
        const n2 = this.A(r2.u, t);
        if (n2 === 0) {
          r2.l = e;
          return this.m;
        } else if (n2 < 0) {
          r2.h = new this.N(t, e);
          r2.h.o = r2;
          i = r2.h;
          this.C.h = i;
        } else {
          if (s !== undefined) {
            const r3 = s.T;
            if (r3 !== this.C) {
              const s2 = this.A(r3.u, t);
              if (s2 === 0) {
                r3.l = e;
                return this.m;
              } else if (s2 > 0) {
                const s3 = r3.I();
                const n3 = this.A(s3.u, t);
                if (n3 === 0) {
                  s3.l = e;
                  return this.m;
                } else if (n3 < 0) {
                  i = new this.N(t, e);
                  if (s3.h === undefined) {
                    s3.h = i;
                    i.o = s3;
                  } else {
                    r3.i = i;
                    i.o = r3;
                  }
                }
              }
            }
          }
          if (i === undefined) {
            i = this.v;
            while (true) {
              const s2 = this.A(i.u, t);
              if (s2 > 0) {
                if (i.i === undefined) {
                  i.i = new this.N(t, e);
                  i.i.o = i;
                  i = i.i;
                  break;
                }
                i = i.i;
              } else if (s2 < 0) {
                if (i.h === undefined) {
                  i.h = new this.N(t, e);
                  i.h.o = i;
                  i = i.h;
                  break;
                }
                i = i.h;
              } else {
                i.l = e;
                return this.m;
              }
            }
          }
        }
      }
      if (this.enableIndex) {
        let t2 = i.o;
        while (t2 !== this.C) {
          t2.M += 1;
          t2 = t2.o;
        }
      }
      this.j(i);
      this.m += 1;
      return this.m;
    }
    H(t, e) {
      while (t) {
        const s = this.A(t.u, e);
        if (s < 0) {
          t = t.h;
        } else if (s > 0) {
          t = t.i;
        } else
          return t;
      }
      return t || this.C;
    }
    clear() {
      this.m = 0;
      this.v = undefined;
      this.C.o = undefined;
      this.C.i = this.C.h = undefined;
    }
    updateKeyByIterator(t, e) {
      const s = t.T;
      if (s === this.C) {
        throwIteratorAccessError();
      }
      if (this.m === 1) {
        s.u = e;
        return true;
      }
      const i = s.B().u;
      if (s === this.C.i) {
        if (this.A(i, e) > 0) {
          s.u = e;
          return true;
        }
        return false;
      }
      const r = s.I().u;
      if (s === this.C.h) {
        if (this.A(r, e) < 0) {
          s.u = e;
          return true;
        }
        return false;
      }
      if (this.A(r, e) >= 0 || this.A(i, e) <= 0)
        return false;
      s.u = e;
      return true;
    }
    eraseElementByPos(t) {
      if (t < 0 || t > this.m - 1) {
        throw new RangeError;
      }
      const e = this.U(t);
      this.S(e);
      return this.m;
    }
    eraseElementByKey(t) {
      if (this.m === 0)
        return false;
      const e = this.H(this.v, t);
      if (e === this.C)
        return false;
      this.S(e);
      return true;
    }
    eraseElementByIterator(t) {
      const e = t.T;
      if (e === this.C) {
        throwIteratorAccessError();
      }
      const s = e.h === undefined;
      const i = t.iteratorType === 0;
      if (i) {
        if (s)
          t.next();
      } else {
        if (!s || e.i === undefined)
          t.next();
      }
      this.S(e);
      return t;
    }
    getHeight() {
      if (this.m === 0)
        return 0;
      function traversal(t) {
        if (!t)
          return 0;
        return Math.max(traversal(t.i), traversal(t.h)) + 1;
      }
      return traversal(this.v);
    }
  }

  class TreeIterator extends ContainerIterator {
    constructor(t, e, s) {
      super(s);
      this.T = t;
      this.C = e;
      if (this.iteratorType === 0) {
        this.pre = function() {
          if (this.T === this.C.i) {
            throwIteratorAccessError();
          }
          this.T = this.T.I();
          return this;
        };
        this.next = function() {
          if (this.T === this.C) {
            throwIteratorAccessError();
          }
          this.T = this.T.B();
          return this;
        };
      } else {
        this.pre = function() {
          if (this.T === this.C.h) {
            throwIteratorAccessError();
          }
          this.T = this.T.B();
          return this;
        };
        this.next = function() {
          if (this.T === this.C) {
            throwIteratorAccessError();
          }
          this.T = this.T.I();
          return this;
        };
      }
    }
    get index() {
      let t = this.T;
      const e = this.C.o;
      if (t === this.C) {
        if (e) {
          return e.M - 1;
        }
        return 0;
      }
      let s = 0;
      if (t.i) {
        s += t.i.M;
      }
      while (t !== e) {
        const e2 = t.o;
        if (t === e2.h) {
          s += 1;
          if (e2.i) {
            s += e2.i.M;
          }
        }
        t = e2;
      }
      return s;
    }
    isAccessible() {
      return this.T !== this.C;
    }
  }

  class OrderedMapIterator extends TreeIterator {
    constructor(t, e, s, i) {
      super(t, e, i);
      this.container = s;
    }
    get pointer() {
      if (this.T === this.C) {
        throwIteratorAccessError();
      }
      const t = this;
      return new Proxy([], {
        get(e, s) {
          if (s === "0")
            return t.T.u;
          else if (s === "1")
            return t.T.l;
          e[0] = t.T.u;
          e[1] = t.T.l;
          return e[s];
        },
        set(e, s, i) {
          if (s !== "1") {
            throw new TypeError("prop must be 1");
          }
          t.T.l = i;
          return true;
        }
      });
    }
    copy() {
      return new OrderedMapIterator(this.T, this.C, this.container, this.iteratorType);
    }
  }

  class OrderedMap extends TreeContainer {
    constructor(t = [], e, s) {
      super(e, s);
      const i = this;
      t.forEach(function(t2) {
        i.setElement(t2[0], t2[1]);
      });
    }
    begin() {
      return new OrderedMapIterator(this.C.i || this.C, this.C, this);
    }
    end() {
      return new OrderedMapIterator(this.C, this.C, this);
    }
    rBegin() {
      return new OrderedMapIterator(this.C.h || this.C, this.C, this, 1);
    }
    rEnd() {
      return new OrderedMapIterator(this.C, this.C, this, 1);
    }
    front() {
      if (this.m === 0)
        return;
      const t = this.C.i;
      return [t.u, t.l];
    }
    back() {
      if (this.m === 0)
        return;
      const t = this.C.h;
      return [t.u, t.l];
    }
    lowerBound(t) {
      const e = this.R(this.v, t);
      return new OrderedMapIterator(e, this.C, this);
    }
    upperBound(t) {
      const e = this.K(this.v, t);
      return new OrderedMapIterator(e, this.C, this);
    }
    reverseLowerBound(t) {
      const e = this.L(this.v, t);
      return new OrderedMapIterator(e, this.C, this);
    }
    reverseUpperBound(t) {
      const e = this.k(this.v, t);
      return new OrderedMapIterator(e, this.C, this);
    }
    forEach(t) {
      this.U(function(e, s, i) {
        t([e.u, e.l], s, i);
      });
    }
    setElement(t, e, s) {
      return this.q(t, e, s);
    }
    getElementByPos(t) {
      if (t < 0 || t > this.m - 1) {
        throw new RangeError;
      }
      const e = this.U(t);
      return [e.u, e.l];
    }
    find(t) {
      const e = this.H(this.v, t);
      return new OrderedMapIterator(e, this.C, this);
    }
    getElementByKey(t) {
      const e = this.H(this.v, t);
      return e.l;
    }
    union(t) {
      const e = this;
      t.forEach(function(t2) {
        e.setElement(t2[0], t2[1]);
      });
      return this.m;
    }
    *[Symbol.iterator]() {
      const t = this.m;
      const e = this.U();
      for (let s = 0;s < t; ++s) {
        const t2 = e[s];
        yield [t2.u, t2.l];
      }
    }
  }
  exports.OrderedMap = OrderedMap;
});

// node_modules/@grpc/grpc-js/build/src/admin.js
var require_admin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerAdminService = registerAdminService;
  exports.addAdminServicesToServer = addAdminServicesToServer;
  var registeredAdminServices = [];
  function registerAdminService(getServiceDefinition, getHandlers) {
    registeredAdminServices.push({ getServiceDefinition, getHandlers });
  }
  function addAdminServicesToServer(server) {
    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
      server.addService(getServiceDefinition(), getHandlers());
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = undefined;
  exports.callErrorFromStatus = callErrorFromStatus;
  var events_1 = __require("events");
  var stream_1 = __require("stream");
  var constants_1 = require_constants2();
  function callErrorFromStatus(status, callerStack) {
    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
    const error = new Error(message);
    const stack = `${error.stack}
for call at
${callerStack}`;
    return Object.assign(new Error(message), status, { stack });
  }

  class ClientUnaryCallImpl extends events_1.EventEmitter {
    constructor() {
      super();
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : "unknown";
    }
  }
  exports.ClientUnaryCallImpl = ClientUnaryCallImpl;

  class ClientReadableStreamImpl extends stream_1.Readable {
    constructor(deserialize) {
      super({ objectMode: true });
      this.deserialize = deserialize;
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : "unknown";
    }
    _read(_size) {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.startRead();
    }
  }
  exports.ClientReadableStreamImpl = ClientReadableStreamImpl;

  class ClientWritableStreamImpl extends stream_1.Writable {
    constructor(serialize) {
      super({ objectMode: true });
      this.serialize = serialize;
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : "unknown";
    }
    _write(chunk, encoding, cb) {
      var _a;
      const context = {
        callback: cb
      };
      const flags = Number(encoding);
      if (!Number.isNaN(flags)) {
        context.flags = flags;
      }
      (_a = this.call) === null || _a === undefined || _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.halfClose();
      cb();
    }
  }
  exports.ClientWritableStreamImpl = ClientWritableStreamImpl;

  class ClientDuplexStreamImpl extends stream_1.Duplex {
    constructor(serialize, deserialize) {
      super({ objectMode: true });
      this.serialize = serialize;
      this.deserialize = deserialize;
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : "unknown";
    }
    _read(_size) {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.startRead();
    }
    _write(chunk, encoding, cb) {
      var _a;
      const context = {
        callback: cb
      };
      const flags = Number(encoding);
      if (!Number.isNaN(flags)) {
        context.flags = flags;
      }
      (_a = this.call) === null || _a === undefined || _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
      var _a;
      (_a = this.call) === null || _a === undefined || _a.halfClose();
      cb();
    }
  }
  exports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
});

// node_modules/@grpc/grpc-js/build/src/call-interface.js
var require_call_interface = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InterceptingListenerImpl = undefined;
  exports.isInterceptingListener = isInterceptingListener;
  function isInterceptingListener(listener) {
    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;
  }

  class InterceptingListenerImpl {
    constructor(listener, nextListener) {
      this.listener = listener;
      this.nextListener = nextListener;
      this.processingMetadata = false;
      this.hasPendingMessage = false;
      this.processingMessage = false;
      this.pendingStatus = null;
    }
    processPendingMessage() {
      if (this.hasPendingMessage) {
        this.nextListener.onReceiveMessage(this.pendingMessage);
        this.pendingMessage = null;
        this.hasPendingMessage = false;
      }
    }
    processPendingStatus() {
      if (this.pendingStatus) {
        this.nextListener.onReceiveStatus(this.pendingStatus);
      }
    }
    onReceiveMetadata(metadata) {
      this.processingMetadata = true;
      this.listener.onReceiveMetadata(metadata, (metadata2) => {
        this.processingMetadata = false;
        this.nextListener.onReceiveMetadata(metadata2);
        this.processPendingMessage();
        this.processPendingStatus();
      });
    }
    onReceiveMessage(message) {
      this.processingMessage = true;
      this.listener.onReceiveMessage(message, (msg) => {
        this.processingMessage = false;
        if (this.processingMetadata) {
          this.pendingMessage = msg;
          this.hasPendingMessage = true;
        } else {
          this.nextListener.onReceiveMessage(msg);
          this.processPendingStatus();
        }
      });
    }
    onReceiveStatus(status) {
      this.listener.onReceiveStatus(status, (processedStatus) => {
        if (this.processingMetadata || this.processingMessage) {
          this.pendingStatus = processedStatus;
        } else {
          this.nextListener.onReceiveStatus(processedStatus);
        }
      });
    }
  }
  exports.InterceptingListenerImpl = InterceptingListenerImpl;
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = undefined;
  exports.getInterceptingCall = getInterceptingCall;
  var metadata_1 = require_metadata();
  var call_interface_1 = require_call_interface();
  var constants_1 = require_constants2();
  var error_1 = require_error2();

  class InterceptorConfigurationError extends Error {
    constructor(message) {
      super(message);
      this.name = "InterceptorConfigurationError";
      Error.captureStackTrace(this, InterceptorConfigurationError);
    }
  }
  exports.InterceptorConfigurationError = InterceptorConfigurationError;

  class ListenerBuilder {
    constructor() {
      this.metadata = undefined;
      this.message = undefined;
      this.status = undefined;
    }
    withOnReceiveMetadata(onReceiveMetadata) {
      this.metadata = onReceiveMetadata;
      return this;
    }
    withOnReceiveMessage(onReceiveMessage) {
      this.message = onReceiveMessage;
      return this;
    }
    withOnReceiveStatus(onReceiveStatus) {
      this.status = onReceiveStatus;
      return this;
    }
    build() {
      return {
        onReceiveMetadata: this.metadata,
        onReceiveMessage: this.message,
        onReceiveStatus: this.status
      };
    }
  }
  exports.ListenerBuilder = ListenerBuilder;

  class RequesterBuilder {
    constructor() {
      this.start = undefined;
      this.message = undefined;
      this.halfClose = undefined;
      this.cancel = undefined;
    }
    withStart(start) {
      this.start = start;
      return this;
    }
    withSendMessage(sendMessage) {
      this.message = sendMessage;
      return this;
    }
    withHalfClose(halfClose) {
      this.halfClose = halfClose;
      return this;
    }
    withCancel(cancel) {
      this.cancel = cancel;
      return this;
    }
    build() {
      return {
        start: this.start,
        sendMessage: this.message,
        halfClose: this.halfClose,
        cancel: this.cancel
      };
    }
  }
  exports.RequesterBuilder = RequesterBuilder;
  var defaultListener = {
    onReceiveMetadata: (metadata, next) => {
      next(metadata);
    },
    onReceiveMessage: (message, next) => {
      next(message);
    },
    onReceiveStatus: (status, next) => {
      next(status);
    }
  };
  var defaultRequester = {
    start: (metadata, listener, next) => {
      next(metadata, listener);
    },
    sendMessage: (message, next) => {
      next(message);
    },
    halfClose: (next) => {
      next();
    },
    cancel: (next) => {
      next();
    }
  };

  class InterceptingCall {
    constructor(nextCall, requester) {
      var _a, _b, _c, _d;
      this.nextCall = nextCall;
      this.processingMetadata = false;
      this.pendingMessageContext = null;
      this.processingMessage = false;
      this.pendingHalfClose = false;
      if (requester) {
        this.requester = {
          start: (_a = requester.start) !== null && _a !== undefined ? _a : defaultRequester.start,
          sendMessage: (_b = requester.sendMessage) !== null && _b !== undefined ? _b : defaultRequester.sendMessage,
          halfClose: (_c = requester.halfClose) !== null && _c !== undefined ? _c : defaultRequester.halfClose,
          cancel: (_d = requester.cancel) !== null && _d !== undefined ? _d : defaultRequester.cancel
        };
      } else {
        this.requester = defaultRequester;
      }
    }
    cancelWithStatus(status, details) {
      this.requester.cancel(() => {
        this.nextCall.cancelWithStatus(status, details);
      });
    }
    getPeer() {
      return this.nextCall.getPeer();
    }
    processPendingMessage() {
      if (this.pendingMessageContext) {
        this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
        this.pendingMessageContext = null;
        this.pendingMessage = null;
      }
    }
    processPendingHalfClose() {
      if (this.pendingHalfClose) {
        this.nextCall.halfClose();
      }
    }
    start(metadata, interceptingListener) {
      var _a, _b, _c, _d, _e, _f;
      const fullInterceptingListener = {
        onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.bind(interceptingListener)) !== null && _b !== undefined ? _b : (metadata2) => {
        },
        onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMessage) === null || _c === undefined ? undefined : _c.bind(interceptingListener)) !== null && _d !== undefined ? _d : (message) => {
        },
        onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _e === undefined ? undefined : _e.bind(interceptingListener)) !== null && _f !== undefined ? _f : (status) => {
        }
      };
      this.processingMetadata = true;
      this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
        var _a2, _b2, _c2;
        this.processingMetadata = false;
        let finalInterceptingListener;
        if ((0, call_interface_1.isInterceptingListener)(listener)) {
          finalInterceptingListener = listener;
        } else {
          const fullListener = {
            onReceiveMetadata: (_a2 = listener.onReceiveMetadata) !== null && _a2 !== undefined ? _a2 : defaultListener.onReceiveMetadata,
            onReceiveMessage: (_b2 = listener.onReceiveMessage) !== null && _b2 !== undefined ? _b2 : defaultListener.onReceiveMessage,
            onReceiveStatus: (_c2 = listener.onReceiveStatus) !== null && _c2 !== undefined ? _c2 : defaultListener.onReceiveStatus
          };
          finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
        }
        this.nextCall.start(md, finalInterceptingListener);
        this.processPendingMessage();
        this.processPendingHalfClose();
      });
    }
    sendMessageWithContext(context, message) {
      this.processingMessage = true;
      this.requester.sendMessage(message, (finalMessage) => {
        this.processingMessage = false;
        if (this.processingMetadata) {
          this.pendingMessageContext = context;
          this.pendingMessage = message;
        } else {
          this.nextCall.sendMessageWithContext(context, finalMessage);
          this.processPendingHalfClose();
        }
      });
    }
    sendMessage(message) {
      this.sendMessageWithContext({}, message);
    }
    startRead() {
      this.nextCall.startRead();
    }
    halfClose() {
      this.requester.halfClose(() => {
        if (this.processingMetadata || this.processingMessage) {
          this.pendingHalfClose = true;
        } else {
          this.nextCall.halfClose();
        }
      });
    }
  }
  exports.InterceptingCall = InterceptingCall;
  function getCall(channel, path, options) {
    var _a, _b;
    const deadline = (_a = options.deadline) !== null && _a !== undefined ? _a : Infinity;
    const host = options.host;
    const parent = (_b = options.parent) !== null && _b !== undefined ? _b : null;
    const propagateFlags = options.propagate_flags;
    const credentials = options.credentials;
    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
    if (credentials) {
      call.setCredentials(credentials);
    }
    return call;
  }

  class BaseInterceptingCall {
    constructor(call, methodDefinition) {
      this.call = call;
      this.methodDefinition = methodDefinition;
    }
    cancelWithStatus(status, details) {
      this.call.cancelWithStatus(status, details);
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMessageWithContext(context, message) {
      let serialized;
      try {
        serialized = this.methodDefinition.requestSerialize(message);
      } catch (e) {
        this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);
        return;
      }
      this.call.sendMessageWithContext(context, serialized);
    }
    sendMessage(message) {
      this.sendMessageWithContext({}, message);
    }
    start(metadata, interceptingListener) {
      let readError = null;
      this.call.start(metadata, {
        onReceiveMetadata: (metadata2) => {
          var _a;
          (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMetadata) === null || _a === undefined || _a.call(interceptingListener, metadata2);
        },
        onReceiveMessage: (message) => {
          var _a;
          let deserialized;
          try {
            deserialized = this.methodDefinition.responseDeserialize(message);
          } catch (e) {
            readError = {
              code: constants_1.Status.INTERNAL,
              details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,
              metadata: new metadata_1.Metadata
            };
            this.call.cancelWithStatus(readError.code, readError.details);
            return;
          }
          (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMessage) === null || _a === undefined || _a.call(interceptingListener, deserialized);
        },
        onReceiveStatus: (status) => {
          var _a, _b;
          if (readError) {
            (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _a === undefined || _a.call(interceptingListener, readError);
          } else {
            (_b = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _b === undefined || _b.call(interceptingListener, status);
          }
        }
      });
    }
    startRead() {
      this.call.startRead();
    }
    halfClose() {
      this.call.halfClose();
    }
  }

  class BaseUnaryInterceptingCall extends BaseInterceptingCall {
    constructor(call, methodDefinition) {
      super(call, methodDefinition);
    }
    start(metadata, listener) {
      var _a, _b;
      let receivedMessage = false;
      const wrapperListener = {
        onReceiveMetadata: (_b = (_a = listener === null || listener === undefined ? undefined : listener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.bind(listener)) !== null && _b !== undefined ? _b : (metadata2) => {
        },
        onReceiveMessage: (message) => {
          var _a2;
          receivedMessage = true;
          (_a2 = listener === null || listener === undefined ? undefined : listener.onReceiveMessage) === null || _a2 === undefined || _a2.call(listener, message);
        },
        onReceiveStatus: (status) => {
          var _a2, _b2;
          if (!receivedMessage) {
            (_a2 = listener === null || listener === undefined ? undefined : listener.onReceiveMessage) === null || _a2 === undefined || _a2.call(listener, null);
          }
          (_b2 = listener === null || listener === undefined ? undefined : listener.onReceiveStatus) === null || _b2 === undefined || _b2.call(listener, status);
        }
      };
      super.start(metadata, wrapperListener);
      this.call.startRead();
    }
  }

  class BaseStreamingInterceptingCall extends BaseInterceptingCall {
  }
  function getBottomInterceptingCall(channel, options, methodDefinition) {
    const call = getCall(channel, methodDefinition.path, options);
    if (methodDefinition.responseStream) {
      return new BaseStreamingInterceptingCall(call, methodDefinition);
    } else {
      return new BaseUnaryInterceptingCall(call, methodDefinition);
    }
  }
  function getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {
    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
      throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options " + "to the client constructor. Only one of these is allowed.");
    }
    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
      throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call " + "options. Only one of these is allowed.");
    }
    let interceptors = [];
    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
      interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
    } else {
      interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
    }
    const interceptorOptions = Object.assign({}, options, {
      method_definition: methodDefinition
    });
    const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
      return (currentOptions) => nextInterceptor(currentOptions, nextCall);
    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
    return getCall2(interceptorOptions);
  }
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Client = undefined;
  var call_1 = require_call();
  var channel_1 = require_channel();
  var connectivity_state_1 = require_connectivity_state();
  var constants_1 = require_constants2();
  var metadata_1 = require_metadata();
  var client_interceptors_1 = require_client_interceptors();
  var CHANNEL_SYMBOL = Symbol();
  var INTERCEPTOR_SYMBOL = Symbol();
  var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
  var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
  function isFunction(arg) {
    return typeof arg === "function";
  }
  function getErrorStackString(error) {
    var _a;
    return ((_a = error.stack) === null || _a === undefined ? undefined : _a.split(`
`).slice(1).join(`
`)) || "no stack trace available";
  }

  class Client {
    constructor(address, credentials, options = {}) {
      var _a, _b;
      options = Object.assign({}, options);
      this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== undefined ? _a : [];
      delete options.interceptors;
      this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== undefined ? _b : [];
      delete options.interceptor_providers;
      if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
        throw new Error("Both interceptors and interceptor_providers were passed as options " + "to the client constructor. Only one of these is allowed.");
      }
      this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;
      delete options.callInvocationTransformer;
      if (options.channelOverride) {
        this[CHANNEL_SYMBOL] = options.channelOverride;
      } else if (options.channelFactoryOverride) {
        const channelFactoryOverride = options.channelFactoryOverride;
        delete options.channelFactoryOverride;
        this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
      } else {
        this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
      }
    }
    close() {
      this[CHANNEL_SYMBOL].close();
    }
    getChannel() {
      return this[CHANNEL_SYMBOL];
    }
    waitForReady(deadline, callback) {
      const checkState = (err) => {
        if (err) {
          callback(new Error("Failed to connect before the deadline"));
          return;
        }
        let newState;
        try {
          newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
        } catch (e) {
          callback(new Error("The channel has been closed"));
          return;
        }
        if (newState === connectivity_state_1.ConnectivityState.READY) {
          callback();
        } else {
          try {
            this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
          } catch (e) {
            callback(new Error("The channel has been closed"));
          }
        }
      };
      setImmediate(checkState);
    }
    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
      if (isFunction(arg1)) {
        return { metadata: new metadata_1.Metadata, options: {}, callback: arg1 };
      } else if (isFunction(arg2)) {
        if (arg1 instanceof metadata_1.Metadata) {
          return { metadata: arg1, options: {}, callback: arg2 };
        } else {
          return { metadata: new metadata_1.Metadata, options: arg1, callback: arg2 };
        }
      } else {
        if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {
          throw new Error("Incorrect arguments passed");
        }
        return { metadata: arg1, options: arg2, callback: arg3 };
      }
    }
    makeUnaryRequest(method, serialize, deserialize, argument2, metadata, options, callback) {
      var _a, _b;
      const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
      const methodDefinition = {
        path: method,
        requestStream: false,
        responseStream: false,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        argument: argument2,
        metadata: checkedArguments.metadata,
        call: new call_1.ClientUnaryCallImpl,
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options,
        callback: checkedArguments.callback
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const emitter = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : []
      };
      const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      emitter.call = call;
      let responseMessage = null;
      let receivedStatus = false;
      let callerStackError = new Error;
      call.start(callProperties.metadata, {
        onReceiveMetadata: (metadata2) => {
          emitter.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          if (responseMessage !== null) {
            call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, "Too many responses received");
          }
          responseMessage = message;
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          if (status.code === constants_1.Status.OK) {
            if (responseMessage === null) {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)({
                code: constants_1.Status.UNIMPLEMENTED,
                details: "No message received",
                metadata: status.metadata
              }, callerStack));
            } else {
              callProperties.callback(null, responseMessage);
            }
          } else {
            const callerStack = getErrorStackString(callerStackError);
            callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
          }
          callerStackError = null;
          emitter.emit("status", status);
        }
      });
      call.sendMessage(argument2);
      call.halfClose();
      return emitter;
    }
    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
      var _a, _b;
      const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
      const methodDefinition = {
        path: method,
        requestStream: true,
        responseStream: false,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        metadata: checkedArguments.metadata,
        call: new call_1.ClientWritableStreamImpl(serialize),
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options,
        callback: checkedArguments.callback
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const emitter = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : []
      };
      const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      emitter.call = call;
      let responseMessage = null;
      let receivedStatus = false;
      let callerStackError = new Error;
      call.start(callProperties.metadata, {
        onReceiveMetadata: (metadata2) => {
          emitter.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          if (responseMessage !== null) {
            call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, "Too many responses received");
          }
          responseMessage = message;
          call.startRead();
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          if (status.code === constants_1.Status.OK) {
            if (responseMessage === null) {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)({
                code: constants_1.Status.UNIMPLEMENTED,
                details: "No message received",
                metadata: status.metadata
              }, callerStack));
            } else {
              callProperties.callback(null, responseMessage);
            }
          } else {
            const callerStack = getErrorStackString(callerStackError);
            callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
          }
          callerStackError = null;
          emitter.emit("status", status);
        }
      });
      return emitter;
    }
    checkMetadataAndOptions(arg1, arg2) {
      let metadata;
      let options;
      if (arg1 instanceof metadata_1.Metadata) {
        metadata = arg1;
        if (arg2) {
          options = arg2;
        } else {
          options = {};
        }
      } else {
        if (arg1) {
          options = arg1;
        } else {
          options = {};
        }
        metadata = new metadata_1.Metadata;
      }
      return { metadata, options };
    }
    makeServerStreamRequest(method, serialize, deserialize, argument2, metadata, options) {
      var _a, _b;
      const checkedArguments = this.checkMetadataAndOptions(metadata, options);
      const methodDefinition = {
        path: method,
        requestStream: false,
        responseStream: true,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        argument: argument2,
        metadata: checkedArguments.metadata,
        call: new call_1.ClientReadableStreamImpl(deserialize),
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const stream = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : []
      };
      const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      stream.call = call;
      let receivedStatus = false;
      let callerStackError = new Error;
      call.start(callProperties.metadata, {
        onReceiveMetadata(metadata2) {
          stream.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          stream.push(null);
          if (status.code !== constants_1.Status.OK) {
            const callerStack = getErrorStackString(callerStackError);
            stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
          }
          callerStackError = null;
          stream.emit("status", status);
        }
      });
      call.sendMessage(argument2);
      call.halfClose();
      return stream;
    }
    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
      var _a, _b;
      const checkedArguments = this.checkMetadataAndOptions(metadata, options);
      const methodDefinition = {
        path: method,
        requestStream: true,
        responseStream: true,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        metadata: checkedArguments.metadata,
        call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const stream = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : []
      };
      const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      stream.call = call;
      let receivedStatus = false;
      let callerStackError = new Error;
      call.start(callProperties.metadata, {
        onReceiveMetadata(metadata2) {
          stream.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          stream.push(null);
          if (status.code !== constants_1.Status.OK) {
            const callerStack = getErrorStackString(callerStackError);
            stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
          }
          callerStackError = null;
          stream.emit("status", status);
        }
      });
      return stream;
    }
  }
  exports.Client = Client;
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeClientConstructor = makeClientConstructor;
  exports.loadPackageDefinition = loadPackageDefinition;
  var client_1 = require_client();
  var requesterFuncs = {
    unary: client_1.Client.prototype.makeUnaryRequest,
    server_stream: client_1.Client.prototype.makeServerStreamRequest,
    client_stream: client_1.Client.prototype.makeClientStreamRequest,
    bidi: client_1.Client.prototype.makeBidiStreamRequest
  };
  function isPrototypePolluted(key) {
    return ["__proto__", "prototype", "constructor"].includes(key);
  }
  function makeClientConstructor(methods, serviceName, classOptions) {
    if (!classOptions) {
      classOptions = {};
    }

    class ServiceClientImpl extends client_1.Client {
    }
    Object.keys(methods).forEach((name) => {
      if (isPrototypePolluted(name)) {
        return;
      }
      const attrs = methods[name];
      let methodType;
      if (typeof name === "string" && name.charAt(0) === "$") {
        throw new Error("Method names cannot start with $");
      }
      if (attrs.requestStream) {
        if (attrs.responseStream) {
          methodType = "bidi";
        } else {
          methodType = "client_stream";
        }
      } else {
        if (attrs.responseStream) {
          methodType = "server_stream";
        } else {
          methodType = "unary";
        }
      }
      const serialize = attrs.requestSerialize;
      const deserialize = attrs.responseDeserialize;
      const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
      ServiceClientImpl.prototype[name] = methodFunc;
      Object.assign(ServiceClientImpl.prototype[name], attrs);
      if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
        ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];
      }
    });
    ServiceClientImpl.service = methods;
    ServiceClientImpl.serviceName = serviceName;
    return ServiceClientImpl;
  }
  function partial(fn, path, serialize, deserialize) {
    return function(...args) {
      return fn.call(this, path, serialize, deserialize, ...args);
    };
  }
  function isProtobufTypeDefinition(obj) {
    return "format" in obj;
  }
  function loadPackageDefinition(packageDef) {
    const result = {};
    for (const serviceFqn in packageDef) {
      if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
        const service = packageDef[serviceFqn];
        const nameComponents = serviceFqn.split(".");
        if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
          continue;
        }
        const serviceName = nameComponents[nameComponents.length - 1];
        let current = result;
        for (const packageName of nameComponents.slice(0, -1)) {
          if (!current[packageName]) {
            current[packageName] = {};
          }
          current = current[packageName];
        }
        if (isProtobufTypeDefinition(service)) {
          current[serviceName] = service;
        } else {
          current[serviceName] = makeClientConstructor(service, serviceName, {});
        }
      }
    }
    return result;
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "[']";
  var rsAstral = "[" + rsAstralRange + "]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "C",
    "": "c",
    "": "D",
    "": "d",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "N",
    "": "n",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "Y",
    "": "y",
    "": "y",
    "": "Ae",
    "": "ae",
    "": "Th",
    "": "th",
    "": "ss",
    "": "A",
    "": "A",
    "": "A",
    "": "a",
    "": "a",
    "": "a",
    "": "C",
    "": "C",
    "": "C",
    "": "C",
    "": "c",
    "": "c",
    "": "c",
    "": "c",
    "": "D",
    "": "D",
    "": "d",
    "": "d",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "G",
    "": "G",
    "": "G",
    "": "G",
    "": "g",
    "": "g",
    "": "g",
    "": "g",
    "": "H",
    "": "H",
    "": "h",
    "": "h",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "J",
    "": "j",
    "": "K",
    "": "k",
    "": "k",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "N",
    "": "N",
    "": "N",
    "": "N",
    "": "n",
    "": "n",
    "": "n",
    "": "n",
    "": "O",
    "": "O",
    "": "O",
    "": "o",
    "": "o",
    "": "o",
    "": "R",
    "": "R",
    "": "R",
    "": "r",
    "": "r",
    "": "r",
    "": "S",
    "": "S",
    "": "S",
    "": "S",
    "": "s",
    "": "s",
    "": "s",
    "": "s",
    "": "T",
    "": "T",
    "": "T",
    "": "t",
    "": "t",
    "": "t",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "W",
    "": "w",
    "": "Y",
    "": "y",
    "": "Y",
    "": "Z",
    "": "Z",
    "": "Z",
    "": "z",
    "": "z",
    "": "z",
    "": "IJ",
    "": "ij",
    "": "Oe",
    "": "oe",
    "": "'n",
    "": "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function asciiToArray(string) {
    return string.split("");
  }
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  var camelCase = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });
  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var upperFirst = createCaseFirst("toUpperCase");
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  module.exports = camelCase;
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS((exports, module) => {
  module.exports = codegen;
  function codegen(functionParams, functionName) {
    if (typeof functionParams === "string") {
      functionName = functionParams;
      functionParams = undefined;
    }
    var body = [];
    function Codegen(formatStringOrScope) {
      if (typeof formatStringOrScope !== "string") {
        var source = toString();
        if (codegen.verbose)
          console.log("codegen: " + source);
        source = "return " + source;
        if (formatStringOrScope) {
          var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
          while (scopeOffset < scopeKeys.length) {
            scopeParams[scopeOffset] = scopeKeys[scopeOffset];
            scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
          }
          scopeParams[scopeOffset] = source;
          return Function.apply(null, scopeParams).apply(null, scopeValues);
        }
        return Function(source)();
      }
      var formatParams = new Array(arguments.length - 1), formatOffset = 0;
      while (formatOffset < formatParams.length)
        formatParams[formatOffset] = arguments[++formatOffset];
      formatOffset = 0;
      formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
        var value = formatParams[formatOffset++];
        switch ($1) {
          case "d":
          case "f":
            return String(Number(value));
          case "i":
            return String(Math.floor(value));
          case "j":
            return JSON.stringify(value);
          case "s":
            return String(value);
        }
        return "%";
      });
      if (formatOffset !== formatParams.length)
        throw Error("parameter count mismatch");
      body.push(formatStringOrScope);
      return Codegen;
    }
    function toString(functionNameOverride) {
      return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + `){
  ` + body.join(`
  `) + `
}`;
    }
    Codegen.toString = toString;
    return Codegen;
  }
  codegen.verbose = false;
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  module.exports = fetch2;
  var asPromise = require_aspromise();
  var inquire = require_inquire();
  var fs = inquire("fs");
  function fetch2(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options)
      options = {};
    if (!callback)
      return asPromise(fetch2, this, filename, options);
    if (!options.xhr && fs && fs.readFile)
      return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
        return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
      });
    return fetch2.xhr(filename, options, callback);
  }
  fetch2.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function fetchOnReadyStateChange() {
      if (xhr.readyState !== 4)
        return;
      if (xhr.status !== 0 && xhr.status !== 200)
        return callback(Error("status " + xhr.status));
      if (options.binary) {
        var buffer = xhr.response;
        if (!buffer) {
          buffer = [];
          for (var i = 0;i < xhr.responseText.length; ++i)
            buffer.push(xhr.responseText.charCodeAt(i) & 255);
        }
        return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
      }
      return callback(null, xhr.responseText);
    };
    if (options.binary) {
      if ("overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.responseType = "arraybuffer";
    }
    xhr.open("GET", filename);
    xhr.send();
  };
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS((exports) => {
  var path = exports;
  var isAbsolute = path.isAbsolute = function isAbsolute(path2) {
    return /^(?:\/|\w+:)/.test(path2);
  };
  var normalize = path.normalize = function normalize(path2) {
    path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
    var parts = path2.split("/"), absolute = isAbsolute(path2), prefix = "";
    if (absolute)
      prefix = parts.shift() + "/";
    for (var i = 0;i < parts.length; ) {
      if (parts[i] === "..") {
        if (i > 0 && parts[i - 1] !== "..")
          parts.splice(--i, 2);
        else if (absolute)
          parts.splice(i, 1);
        else
          ++i;
      } else if (parts[i] === ".")
        parts.splice(i, 1);
      else
        ++i;
    }
    return prefix + parts.join("/");
  };
  path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
      includePath = normalize(includePath);
    if (isAbsolute(includePath))
      return includePath;
    if (!alreadyNormalized)
      originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
  };
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS((exports, module) => {
  module.exports = Namespace;
  var ReflectionObject = require_object();
  ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
  var Field = require_field();
  var util = require_util3();
  var OneOf = require_oneof();
  var Type;
  var Service;
  var Enum;
  Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
  };
  function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
      return;
    var obj = {};
    for (var i = 0;i < array.length; ++i)
      obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
  }
  Namespace.arrayToJSON = arrayToJSON;
  Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved) {
      for (var i = 0;i < reserved.length; ++i)
        if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
          return true;
    }
    return false;
  };
  Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved) {
      for (var i = 0;i < reserved.length; ++i)
        if (reserved[i] === name)
          return true;
    }
    return false;
  };
  function Namespace(name, options) {
    ReflectionObject.call(this, name, options);
    this.nested = undefined;
    this._nestedArray = null;
    this._lookupCache = {};
    this._needsRecursiveFeatureResolution = true;
    this._needsRecursiveResolve = true;
  }
  function clearCache(namespace) {
    namespace._nestedArray = null;
    namespace._lookupCache = {};
    var parent = namespace;
    while (parent = parent.parent) {
      parent._lookupCache = {};
    }
    return namespace;
  }
  Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
      return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
  });
  Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
      "options",
      this.options,
      "nested",
      arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
  };
  Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    if (nestedJson) {
      for (var names = Object.keys(nestedJson), i = 0, nested;i < names.length; ++i) {
        nested = nestedJson[names[i]];
        ns.add((nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
      }
    }
    return this;
  };
  Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name] || null;
  };
  Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
      return this.nested[name].values;
    throw Error("no such enum: " + name);
  };
  Namespace.prototype.add = function add(object) {
    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
      throw TypeError("object must be a valid nested object");
    if (!this.nested)
      this.nested = {};
    else {
      var prev = this.get(object.name);
      if (prev) {
        if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
          var nested = prev.nestedArray;
          for (var i = 0;i < nested.length; ++i)
            object.add(nested[i]);
          this.remove(prev);
          if (!this.nested)
            this.nested = {};
          object.setOptions(prev.options, true);
        } else
          throw Error("duplicate name '" + object.name + "' in " + this);
      }
    }
    this.nested[object.name] = object;
    if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field)) {
      if (!object._edition) {
        object._edition = object._defaultEdition;
      }
    }
    this._needsRecursiveFeatureResolution = true;
    this._needsRecursiveResolve = true;
    var parent = this;
    while (parent = parent.parent) {
      parent._needsRecursiveFeatureResolution = true;
      parent._needsRecursiveResolve = true;
    }
    object.onAdd(this);
    return clearCache(this);
  };
  Namespace.prototype.remove = function remove(object) {
    if (!(object instanceof ReflectionObject))
      throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
      throw Error(object + " is not a member of " + this);
    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
      this.nested = undefined;
    object.onRemove(this);
    return clearCache(this);
  };
  Namespace.prototype.define = function define(path, json) {
    if (util.isString(path))
      path = path.split(".");
    else if (!Array.isArray(path))
      throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
      throw Error("path must be relative");
    var ptr = this;
    while (path.length > 0) {
      var part = path.shift();
      if (ptr.nested && ptr.nested[part]) {
        ptr = ptr.nested[part];
        if (!(ptr instanceof Namespace))
          throw Error("path conflicts with non-namespace objects");
      } else
        ptr.add(ptr = new Namespace(part));
    }
    if (json)
      ptr.addJSON(json);
    return ptr;
  };
  Namespace.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    this._resolveFeaturesRecursive(this._edition);
    var nested = this.nestedArray, i = 0;
    this.resolve();
    while (i < nested.length)
      if (nested[i] instanceof Namespace)
        nested[i++].resolveAll();
      else
        nested[i++].resolve();
    this._needsRecursiveResolve = false;
    return this;
  };
  Namespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    if (!this._needsRecursiveFeatureResolution)
      return this;
    this._needsRecursiveFeatureResolution = false;
    edition = this._edition || edition;
    ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);
    this.nestedArray.forEach((nested) => {
      nested._resolveFeaturesRecursive(edition);
    });
    return this;
  };
  Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
    if (typeof filterTypes === "boolean") {
      parentAlreadyChecked = filterTypes;
      filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
      filterTypes = [filterTypes];
    if (util.isString(path) && path.length) {
      if (path === ".")
        return this.root;
      path = path.split(".");
    } else if (!path.length)
      return this;
    var flatPath = path.join(".");
    if (path[0] === "")
      return this.root.lookup(path.slice(1), filterTypes);
    var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects["." + flatPath];
    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
      return found;
    }
    found = this._lookupImpl(path, flatPath);
    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
      return found;
    }
    if (parentAlreadyChecked)
      return null;
    var current = this;
    while (current.parent) {
      found = current.parent._lookupImpl(path, flatPath);
      if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
        return found;
      }
      current = current.parent;
    }
    return null;
  };
  Namespace.prototype._lookupImpl = function lookup(path, flatPath) {
    if (Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {
      return this._lookupCache[flatPath];
    }
    var found = this.get(path[0]);
    var exact = null;
    if (found) {
      if (path.length === 1) {
        exact = found;
      } else if (found instanceof Namespace) {
        path = path.slice(1);
        exact = found._lookupImpl(path, path.join("."));
      }
    } else {
      for (var i = 0;i < this.nestedArray.length; ++i)
        if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i]._lookupImpl(path, flatPath)))
          exact = found;
    }
    this._lookupCache[flatPath] = exact;
    return exact;
  };
  Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [Type]);
    if (!found)
      throw Error("no such type: " + path);
    return found;
  };
  Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [Enum]);
    if (!found)
      throw Error("no such Enum '" + path + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [Type, Enum]);
    if (!found)
      throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [Service]);
    if (!found)
      throw Error("no such Service '" + path + "' in " + this);
    return found;
  };
  Namespace._configure = function(Type_, Service_, Enum_) {
    Type = Type_;
    Service = Service_;
    Enum = Enum_;
  };
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS((exports, module) => {
  module.exports = MapField;
  var Field = require_field();
  ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
  var types = require_types5();
  var util = require_util3();
  function MapField(name, id, keyType, type2, options, comment) {
    Field.call(this, name, id, type2, undefined, undefined, options, comment);
    if (!util.isString(keyType))
      throw TypeError("keyType must be a string");
    this.keyType = keyType;
    this.resolvedKeyType = null;
    this.map = true;
  }
  MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
  };
  MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "keyType",
      this.keyType,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  MapField.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (types.mapKey[this.keyType] === undefined)
      throw Error("invalid key type: " + this.keyType);
    return Field.prototype.resolve.call(this);
  };
  MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
    if (typeof fieldValueType === "function")
      fieldValueType = util.decorateType(fieldValueType).name;
    else if (fieldValueType && typeof fieldValueType === "object")
      fieldValueType = util.decorateEnum(fieldValueType).name;
    return function mapFieldDecorator(prototype, fieldName) {
      util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
  };
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS((exports, module) => {
  module.exports = Method;
  var ReflectionObject = require_object();
  ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
  var util = require_util3();
  function Method(name, type2, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
    if (util.isObject(requestStream)) {
      options = requestStream;
      requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
      options = responseStream;
      responseStream = undefined;
    }
    if (!(type2 === undefined || util.isString(type2)))
      throw TypeError("type must be a string");
    if (!util.isString(requestType))
      throw TypeError("requestType must be a string");
    if (!util.isString(responseType))
      throw TypeError("responseType must be a string");
    ReflectionObject.call(this, name, options);
    this.type = type2 || "rpc";
    this.requestType = requestType;
    this.requestStream = requestStream ? true : undefined;
    this.responseType = responseType;
    this.responseStream = responseStream ? true : undefined;
    this.resolvedRequestType = null;
    this.resolvedResponseType = null;
    this.comment = comment;
    this.parsedOptions = parsedOptions;
  }
  Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
  };
  Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "type",
      this.type !== "rpc" && this.type || undefined,
      "requestType",
      this.requestType,
      "requestStream",
      this.requestStream,
      "responseType",
      this.responseType,
      "responseStream",
      this.responseStream,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : undefined,
      "parsedOptions",
      this.parsedOptions
    ]);
  };
  Method.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);
    return ReflectionObject.prototype.resolve.call(this);
  };
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS((exports, module) => {
  module.exports = Service;
  var Namespace = require_namespace();
  ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
  var Method = require_method();
  var util = require_util3();
  var rpc = require_rpc();
  function Service(name, options) {
    Namespace.call(this, name, options);
    this.methods = {};
    this._methodsArray = null;
  }
  Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    if (json.methods)
      for (var names = Object.keys(json.methods), i = 0;i < names.length; ++i)
        service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
      service.addJSON(json.nested);
    if (json.edition)
      service._edition = json.edition;
    service.comment = json.comment;
    service._defaultEdition = "proto3";
    return service;
  };
  Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "options",
      inherited && inherited.options || undefined,
      "methods",
      Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
      "nested",
      inherited && inherited.nested || undefined,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
      return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
  });
  function clearCache(service) {
    service._methodsArray = null;
    return service;
  }
  Service.prototype.get = function get(name) {
    return this.methods[name] || Namespace.prototype.get.call(this, name);
  };
  Service.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    Namespace.prototype.resolve.call(this);
    var methods = this.methodsArray;
    for (var i = 0;i < methods.length; ++i)
      methods[i].resolve();
    return this;
  };
  Service.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    if (!this._needsRecursiveFeatureResolution)
      return this;
    edition = this._edition || edition;
    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
    this.methodsArray.forEach((method) => {
      method._resolveFeaturesRecursive(edition);
    });
    return this;
  };
  Service.prototype.add = function add(object) {
    if (this.get(object.name))
      throw Error("duplicate name '" + object.name + "' in " + this);
    if (object instanceof Method) {
      this.methods[object.name] = object;
      object.parent = this;
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
  };
  Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {
      if (this.methods[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.methods[object.name];
      object.parent = null;
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
  };
  Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method;i < this.methodsArray.length; ++i) {
      var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
      rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
        m: method,
        q: method.resolvedRequestType.ctor,
        s: method.resolvedResponseType.ctor
      });
    }
    return rpcService;
  };
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS((exports, module) => {
  module.exports = Message;
  var util = require_minimal();
  function Message(properties) {
    if (properties)
      for (var keys = Object.keys(properties), i = 0;i < keys.length; ++i)
        this[keys[i]] = properties[keys[i]];
  }
  Message.create = function create(properties) {
    return this.$type.create(properties);
  };
  Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
  };
  Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
  };
  Message.decode = function decode(reader) {
    return this.$type.decode(reader);
  };
  Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
  };
  Message.verify = function verify(message) {
    return this.$type.verify(message);
  };
  Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
  };
  Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
  };
  Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
  };
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS((exports, module) => {
  module.exports = decoder;
  var Enum = require_enum();
  var types = require_types5();
  var util = require_util3();
  function missing(field) {
    return "missing required '" + field.name + "'";
  }
  function decoder(mtype) {
    var gen = util.codegen(["r", "l", "e"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
      return field2.map;
    }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")("switch(t>>>3){");
    var i = 0;
    for (;i < mtype.fieldsArray.length; ++i) {
      var field = mtype._fieldsArray[i].resolve(), type2 = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
      gen("case %i: {", field.id);
      if (field.map) {
        gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
        if (types.defaults[field.keyType] !== undefined)
          gen("k=%j", types.defaults[field.keyType]);
        else
          gen("k=null");
        if (types.defaults[type2] !== undefined)
          gen("value=%j", types.defaults[type2]);
        else
          gen("value=null");
        gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
        if (types.basic[type2] === undefined)
          gen("value=types[%i].decode(r,r.uint32())", i);
        else
          gen("value=r.%s()", type2);
        gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
        if (types.long[field.keyType] !== undefined)
          gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
        else
          gen("%s[k]=value", ref);
      } else if (field.repeated) {
        gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
        if (types.packed[type2] !== undefined)
          gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type2)("}else");
        if (types.basic[type2] === undefined)
          gen(field.delimited ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
        else
          gen("%s.push(r.%s())", ref, type2);
      } else if (types.basic[type2] === undefined)
        gen(field.delimited ? "%s=types[%i].decode(r,undefined,((t&~7)|4))" : "%s=types[%i].decode(r,r.uint32())", ref, i);
      else
        gen("%s=r.%s()", ref, type2);
      gen("break")("}");
    }
    gen("default:")("r.skipType(t&7)")("break")("}")("}");
    for (i = 0;i < mtype._fieldsArray.length; ++i) {
      var rfield = mtype._fieldsArray[i];
      if (rfield.required)
        gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }
    return gen("return m");
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS((exports, module) => {
  module.exports = verifier;
  var Enum = require_enum();
  var util = require_util3();
  function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
  }
  function genVerifyValue(gen, field, fieldIndex, ref) {
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum) {
        gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
        for (var keys = Object.keys(field.resolvedType.values), j = 0;j < keys.length; ++j)
          gen("case %i:", field.resolvedType.values[keys[j]]);
        gen("break")("}");
      } else {
        gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
      }
    } else {
      switch (field.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
          break;
        case "float":
        case "double":
          gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
          break;
        case "bool":
          gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
          break;
        case "string":
          gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
          break;
        case "bytes":
          gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
          break;
      }
    }
    return gen;
  }
  function genVerifyKey(gen, field, ref) {
    switch (field.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
        break;
      case "bool":
        gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
        break;
    }
    return gen;
  }
  function verifier(mtype) {
    var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
    var oneofs = mtype.oneofsArray, seenFirstField = {};
    if (oneofs.length)
      gen("var p={}");
    for (var i = 0;i < mtype.fieldsArray.length; ++i) {
      var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
      if (field.optional)
        gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
      if (field.map) {
        gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
        genVerifyKey(gen, field, "k[i]");
        genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
      } else if (field.repeated) {
        gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
        genVerifyValue(gen, field, i, ref + "[i]")("}");
      } else {
        if (field.partOf) {
          var oneofProp = util.safeProp(field.partOf.name);
          if (seenFirstField[field.partOf.name] === 1)
            gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
          seenFirstField[field.partOf.name] = 1;
          gen("p%s=1", oneofProp);
        }
        genVerifyValue(gen, field, i, ref);
      }
      if (field.optional)
        gen("}");
    }
    return gen("return null");
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS((exports) => {
  var converter = exports;
  var Enum = require_enum();
  var util = require_util3();
  function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    var defaultAlreadyEmitted = false;
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum) {
        gen("switch(d%s){", prop);
        for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0;i < keys.length; ++i) {
          if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
            gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
            if (!field.repeated)
              gen("break");
            defaultAlreadyEmitted = true;
          }
          gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
        }
        gen("}");
      } else
        gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
      var isUnsigned = false;
      switch (field.type) {
        case "double":
        case "float":
          gen("m%s=Number(d%s)", prop, prop);
          break;
        case "uint32":
        case "fixed32":
          gen("m%s=d%s>>>0", prop, prop);
          break;
        case "int32":
        case "sint32":
        case "sfixed32":
          gen("m%s=d%s|0", prop, prop);
          break;
        case "uint64":
          isUnsigned = true;
        case "int64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
          break;
        case "bytes":
          gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
          break;
        case "string":
          gen("m%s=String(d%s)", prop, prop);
          break;
        case "bool":
          gen("m%s=Boolean(d%s)", prop, prop);
          break;
      }
    }
    return gen;
  }
  converter.fromObject = function fromObject(mtype) {
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
    if (!fields.length)
      return gen("return new this.ctor");
    gen("var m=new this.ctor");
    for (var i = 0;i < fields.length; ++i) {
      var field = fields[i].resolve(), prop = util.safeProp(field.name);
      if (field.map) {
        gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
        genValuePartial_fromObject(gen, field, i, prop + "[ks[i]]")("}")("}");
      } else if (field.repeated) {
        gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
        genValuePartial_fromObject(gen, field, i, prop + "[i]")("}")("}");
      } else {
        if (!(field.resolvedType instanceof Enum))
          gen("if(d%s!=null){", prop);
        genValuePartial_fromObject(gen, field, i, prop);
        if (!(field.resolvedType instanceof Enum))
          gen("}");
      }
    }
    return gen("return m");
  };
  function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum)
        gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
      else
        gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
      var isUnsigned = false;
      switch (field.type) {
        case "double":
        case "float":
          gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
          break;
        case "uint64":
          isUnsigned = true;
        case "int64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
          break;
        case "bytes":
          gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
          break;
        default:
          gen("d%s=m%s", prop, prop);
          break;
      }
    }
    return gen;
  }
  converter.toObject = function toObject(mtype) {
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
      return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
    var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
    for (;i < fields.length; ++i)
      if (!fields[i].partOf)
        (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
    if (repeatedFields.length) {
      gen("if(o.arrays||o.defaults){");
      for (i = 0;i < repeatedFields.length; ++i)
        gen("d%s=[]", util.safeProp(repeatedFields[i].name));
      gen("}");
    }
    if (mapFields.length) {
      gen("if(o.objects||o.defaults){");
      for (i = 0;i < mapFields.length; ++i)
        gen("d%s={}", util.safeProp(mapFields[i].name));
      gen("}");
    }
    if (normalFields.length) {
      gen("if(o.defaults){");
      for (i = 0;i < normalFields.length; ++i) {
        var field = normalFields[i], prop = util.safeProp(field.name);
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
        else if (field.long)
          gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
        else if (field.bytes) {
          var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
          gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
        } else
          gen("d%s=%j", prop, field.typeDefault);
      }
      gen("}");
    }
    var hasKs2 = false;
    for (i = 0;i < fields.length; ++i) {
      var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
      if (field.map) {
        if (!hasKs2) {
          hasKs2 = true;
          gen("var ks2");
        }
        gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
        genValuePartial_toObject(gen, field, index, prop + "[ks2[j]]")("}");
      } else if (field.repeated) {
        gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
        genValuePartial_toObject(gen, field, index, prop + "[j]")("}");
      } else {
        gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
        genValuePartial_toObject(gen, field, index, prop);
        if (field.partOf)
          gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
      }
      gen("}");
    }
    return gen("return d");
  };
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS((exports) => {
  var wrappers = exports;
  var Message = require_message();
  wrappers[".google.protobuf.Any"] = {
    fromObject: function(object) {
      if (object && object["@type"]) {
        var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
        var type2 = this.lookup(name);
        if (type2) {
          var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
          if (type_url.indexOf("/") === -1) {
            type_url = "/" + type_url;
          }
          return this.create({
            type_url,
            value: type2.encode(type2.fromObject(object)).finish()
          });
        }
      }
      return this.fromObject(object);
    },
    toObject: function(message, options) {
      var googleApi = "type.googleapis.com/";
      var prefix = "";
      var name = "";
      if (options && options.json && message.type_url && message.value) {
        name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
        prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
        var type2 = this.lookup(name);
        if (type2)
          message = type2.decode(message.value);
      }
      if (!(message instanceof this.ctor) && message instanceof Message) {
        var object = message.$type.toObject(message, options);
        var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.slice(1) : message.$type.fullName;
        if (prefix === "") {
          prefix = googleApi;
        }
        name = prefix + messageName;
        object["@type"] = name;
        return object;
      }
      return this.toObject(message, options);
    }
  };
});

// node_modules/protobufjs/src/type.js
var require_type2 = __commonJS((exports, module) => {
  module.exports = Type;
  var Namespace = require_namespace();
  ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
  var Enum = require_enum();
  var OneOf = require_oneof();
  var Field = require_field();
  var MapField = require_mapfield();
  var Service = require_service2();
  var Message = require_message();
  var Reader = require_reader();
  var Writer = require_writer();
  var util = require_util3();
  var encoder = require_encoder();
  var decoder = require_decoder();
  var verifier = require_verifier();
  var converter = require_converter();
  var wrappers = require_wrappers();
  function Type(name, options) {
    Namespace.call(this, name, options);
    this.fields = {};
    this.oneofs = undefined;
    this.extensions = undefined;
    this.reserved = undefined;
    this.group = undefined;
    this._fieldsById = null;
    this._fieldsArray = null;
    this._oneofsArray = null;
    this._ctor = null;
  }
  Object.defineProperties(Type.prototype, {
    fieldsById: {
      get: function() {
        if (this._fieldsById)
          return this._fieldsById;
        this._fieldsById = {};
        for (var names = Object.keys(this.fields), i = 0;i < names.length; ++i) {
          var field = this.fields[names[i]], id = field.id;
          if (this._fieldsById[id])
            throw Error("duplicate id " + id + " in " + this);
          this._fieldsById[id] = field;
        }
        return this._fieldsById;
      }
    },
    fieldsArray: {
      get: function() {
        return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
      }
    },
    oneofsArray: {
      get: function() {
        return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
      }
    },
    ctor: {
      get: function() {
        return this._ctor || (this.ctor = Type.generateConstructor(this)());
      },
      set: function(ctor) {
        var prototype = ctor.prototype;
        if (!(prototype instanceof Message)) {
          (ctor.prototype = new Message).constructor = ctor;
          util.merge(ctor.prototype, prototype);
        }
        ctor.$type = ctor.prototype.$type = this;
        util.merge(ctor, Message, true);
        this._ctor = ctor;
        var i = 0;
        for (;i < this.fieldsArray.length; ++i)
          this._fieldsArray[i].resolve();
        var ctorProperties = {};
        for (i = 0;i < this.oneofsArray.length; ++i)
          ctorProperties[this._oneofsArray[i].resolve().name] = {
            get: util.oneOfGetter(this._oneofsArray[i].oneof),
            set: util.oneOfSetter(this._oneofsArray[i].oneof)
          };
        if (i)
          Object.defineProperties(ctor.prototype, ctorProperties);
      }
    }
  });
  Type.generateConstructor = function generateConstructor(mtype) {
    var gen = util.codegen(["p"], mtype.name);
    for (var i = 0, field;i < mtype.fieldsArray.length; ++i)
      if ((field = mtype._fieldsArray[i]).map)
        gen("this%s={}", util.safeProp(field.name));
      else if (field.repeated)
        gen("this%s=[]", util.safeProp(field.name));
    return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
  };
  function clearCache(type2) {
    type2._fieldsById = type2._fieldsArray = type2._oneofsArray = null;
    delete type2.encode;
    delete type2.decode;
    delete type2.verify;
    return type2;
  }
  Type.fromJSON = function fromJSON(name, json) {
    var type2 = new Type(name, json.options);
    type2.extensions = json.extensions;
    type2.reserved = json.reserved;
    var names = Object.keys(json.fields), i = 0;
    for (;i < names.length; ++i)
      type2.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
    if (json.oneofs)
      for (names = Object.keys(json.oneofs), i = 0;i < names.length; ++i)
        type2.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
      for (names = Object.keys(json.nested), i = 0;i < names.length; ++i) {
        var nested = json.nested[names[i]];
        type2.add((nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
      }
    if (json.extensions && json.extensions.length)
      type2.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
      type2.reserved = json.reserved;
    if (json.group)
      type2.group = true;
    if (json.comment)
      type2.comment = json.comment;
    if (json.edition)
      type2._edition = json.edition;
    type2._defaultEdition = "proto3";
    return type2;
  };
  Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "options",
      inherited && inherited.options || undefined,
      "oneofs",
      Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
      "fields",
      Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
        return !obj.declaringField;
      }), toJSONOptions) || {},
      "extensions",
      this.extensions && this.extensions.length ? this.extensions : undefined,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : undefined,
      "group",
      this.group || undefined,
      "nested",
      inherited && inherited.nested || undefined,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  Type.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    Namespace.prototype.resolveAll.call(this);
    var oneofs = this.oneofsArray;
    i = 0;
    while (i < oneofs.length)
      oneofs[i++].resolve();
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
      fields[i++].resolve();
    return this;
  };
  Type.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    if (!this._needsRecursiveFeatureResolution)
      return this;
    edition = this._edition || edition;
    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
    this.oneofsArray.forEach((oneof) => {
      oneof._resolveFeatures(edition);
    });
    this.fieldsArray.forEach((field) => {
      field._resolveFeatures(edition);
    });
    return this;
  };
  Type.prototype.get = function get(name) {
    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
  };
  Type.prototype.add = function add(object) {
    if (this.get(object.name))
      throw Error("duplicate name '" + object.name + "' in " + this);
    if (object instanceof Field && object.extend === undefined) {
      if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
        throw Error("duplicate id " + object.id + " in " + this);
      if (this.isReservedId(object.id))
        throw Error("id " + object.id + " is reserved in " + this);
      if (this.isReservedName(object.name))
        throw Error("name '" + object.name + "' is reserved in " + this);
      if (object.parent)
        object.parent.remove(object);
      this.fields[object.name] = object;
      object.message = this;
      object.onAdd(this);
      return clearCache(this);
    }
    if (object instanceof OneOf) {
      if (!this.oneofs)
        this.oneofs = {};
      this.oneofs[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
  };
  Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
      if (!this.fields || this.fields[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.fields[object.name];
      object.parent = null;
      object.onRemove(this);
      return clearCache(this);
    }
    if (object instanceof OneOf) {
      if (!this.oneofs || this.oneofs[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.oneofs[object.name];
      object.parent = null;
      object.onRemove(this);
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
  };
  Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
  Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
  };
  Type.prototype.setup = function setup() {
    var fullName = this.fullName, types = [];
    for (var i = 0;i < this.fieldsArray.length; ++i)
      types.push(this._fieldsArray[i].resolve().resolvedType);
    this.encode = encoder(this)({
      Writer,
      types,
      util
    });
    this.decode = decoder(this)({
      Reader,
      types,
      util
    });
    this.verify = verifier(this)({
      types,
      util
    });
    this.fromObject = converter.fromObject(this)({
      types,
      util
    });
    this.toObject = converter.toObject(this)({
      types,
      util
    });
    var wrapper = wrappers[fullName];
    if (wrapper) {
      var originalThis = Object.create(this);
      originalThis.fromObject = this.fromObject;
      this.fromObject = wrapper.fromObject.bind(originalThis);
      originalThis.toObject = this.toObject;
      this.toObject = wrapper.toObject.bind(originalThis);
    }
    return this;
  };
  Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer);
  };
  Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
  };
  Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length);
  };
  Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
      reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
  };
  Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message);
  };
  Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
  };
  Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
  };
  Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
      util.decorateType(target, typeName);
    };
  };
});

// node_modules/protobufjs/src/root.js
var require_root2 = __commonJS((exports, module) => {
  module.exports = Root;
  var Namespace = require_namespace();
  ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
  var Field = require_field();
  var Enum = require_enum();
  var OneOf = require_oneof();
  var util = require_util3();
  var Type;
  var parse2;
  var common;
  function Root(options) {
    Namespace.call(this, "", options);
    this.deferred = [];
    this.files = [];
    this._edition = "proto2";
    this._fullyQualifiedObjects = {};
  }
  Root.fromJSON = function fromJSON(json, root) {
    if (!root)
      root = new Root;
    if (json.options)
      root.setOptions(json.options);
    return root.addJSON(json.nested).resolveAll();
  };
  Root.prototype.resolvePath = util.path.resolve;
  Root.prototype.fetch = util.fetch;
  function SYNC() {
  }
  Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = undefined;
    }
    var self2 = this;
    if (!callback) {
      return util.asPromise(load, self2, filename, options);
    }
    var sync = callback === SYNC;
    function finish(err, root) {
      if (!callback) {
        return;
      }
      if (sync) {
        throw err;
      }
      if (root) {
        root.resolveAll();
      }
      var cb = callback;
      callback = null;
      cb(err, root);
    }
    function getBundledFileName(filename2) {
      var idx = filename2.lastIndexOf("google/protobuf/");
      if (idx > -1) {
        var altname = filename2.substring(idx);
        if (altname in common)
          return altname;
      }
      return null;
    }
    function process2(filename2, source) {
      try {
        if (util.isString(source) && source.charAt(0) === "{")
          source = JSON.parse(source);
        if (!util.isString(source))
          self2.setOptions(source.options).addJSON(source.nested);
        else {
          parse2.filename = filename2;
          var parsed = parse2(source, self2, options), resolved2, i2 = 0;
          if (parsed.imports) {
            for (;i2 < parsed.imports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                fetch2(resolved2);
          }
          if (parsed.weakImports) {
            for (i2 = 0;i2 < parsed.weakImports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                fetch2(resolved2, true);
          }
        }
      } catch (err) {
        finish(err);
      }
      if (!sync && !queued) {
        finish(null, self2);
      }
    }
    function fetch2(filename2, weak) {
      filename2 = getBundledFileName(filename2) || filename2;
      if (self2.files.indexOf(filename2) > -1) {
        return;
      }
      self2.files.push(filename2);
      if (filename2 in common) {
        if (sync) {
          process2(filename2, common[filename2]);
        } else {
          ++queued;
          setTimeout(function() {
            --queued;
            process2(filename2, common[filename2]);
          });
        }
        return;
      }
      if (sync) {
        var source;
        try {
          source = util.fs.readFileSync(filename2).toString("utf8");
        } catch (err) {
          if (!weak)
            finish(err);
          return;
        }
        process2(filename2, source);
      } else {
        ++queued;
        self2.fetch(filename2, function(err, source2) {
          --queued;
          if (!callback) {
            return;
          }
          if (err) {
            if (!weak)
              finish(err);
            else if (!queued)
              finish(null, self2);
            return;
          }
          process2(filename2, source2);
        });
      }
    }
    var queued = 0;
    if (util.isString(filename)) {
      filename = [filename];
    }
    for (var i = 0, resolved;i < filename.length; ++i)
      if (resolved = self2.resolvePath("", filename[i]))
        fetch2(resolved);
    if (sync) {
      self2.resolveAll();
      return self2;
    }
    if (!queued) {
      finish(null, self2);
    }
    return self2;
  };
  Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
      throw Error("not supported");
    return this.load(filename, options, SYNC);
  };
  Root.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    if (this.deferred.length)
      throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
        return "'extend " + field.extend + "' in " + field.parent.fullName;
      }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
  };
  var exposeRe = /^[A-Z]/;
  function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
      var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
      if (extendedType.get(sisterField.name)) {
        return true;
      }
      sisterField.declaringField = field;
      field.extensionField = sisterField;
      extendedType.add(sisterField);
      return true;
    }
    return false;
  }
  Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {
      if (object.extend !== undefined && !object.extensionField) {
        if (!tryHandleExtension(this, object))
          this.deferred.push(object);
      }
    } else if (object instanceof Enum) {
      if (exposeRe.test(object.name))
        object.parent[object.name] = object.values;
    } else if (!(object instanceof OneOf)) {
      if (object instanceof Type)
        for (var i = 0;i < this.deferred.length; )
          if (tryHandleExtension(this, this.deferred[i]))
            this.deferred.splice(i, 1);
          else
            ++i;
      for (var j = 0;j < object.nestedArray.length; ++j)
        this._handleAdd(object._nestedArray[j]);
      if (exposeRe.test(object.name))
        object.parent[object.name] = object;
    }
    if (object instanceof Type || object instanceof Enum || object instanceof Field) {
      this._fullyQualifiedObjects[object.fullName] = object;
    }
  };
  Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {
      if (object.extend !== undefined) {
        if (object.extensionField) {
          object.extensionField.parent.remove(object.extensionField);
          object.extensionField = null;
        } else {
          var index = this.deferred.indexOf(object);
          if (index > -1)
            this.deferred.splice(index, 1);
        }
      }
    } else if (object instanceof Enum) {
      if (exposeRe.test(object.name))
        delete object.parent[object.name];
    } else if (object instanceof Namespace) {
      for (var i = 0;i < object.nestedArray.length; ++i)
        this._handleRemove(object._nestedArray[i]);
      if (exposeRe.test(object.name))
        delete object.parent[object.name];
    }
    delete this._fullyQualifiedObjects[object.fullName];
  };
  Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse2 = parse_;
    common = common_;
  };
});

// node_modules/protobufjs/src/util.js
var require_util3 = __commonJS((exports, module) => {
  var util = module.exports = require_minimal();
  var roots = require_roots();
  var Type;
  var Enum;
  util.codegen = require_codegen();
  util.fetch = require_fetch();
  util.path = require_path();
  util.fs = util.inquire("fs");
  util.toArray = function toArray(object) {
    if (object) {
      var keys = Object.keys(object), array = new Array(keys.length), index = 0;
      while (index < keys.length)
        array[index] = object[keys[index++]];
      return array;
    }
    return [];
  };
  util.toObject = function toObject(array) {
    var object = {}, index = 0;
    while (index < array.length) {
      var key = array[index++], val = array[index++];
      if (val !== undefined)
        object[key] = val;
    }
    return object;
  };
  var safePropBackslashRe = /\\/g;
  var safePropQuoteRe = /"/g;
  util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
  };
  util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
      return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + '"]';
    return "." + prop;
  };
  util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  };
  var camelCaseRe = /_([a-z])/g;
  util.camelCase = function camelCase(str) {
    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
      return $1.toUpperCase();
    });
  };
  util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
  };
  util.decorateType = function decorateType(ctor, typeName) {
    if (ctor.$type) {
      if (typeName && ctor.$type.name !== typeName) {
        util.decorateRoot.remove(ctor.$type);
        ctor.$type.name = typeName;
        util.decorateRoot.add(ctor.$type);
      }
      return ctor.$type;
    }
    if (!Type)
      Type = require_type2();
    var type2 = new Type(typeName || ctor.name);
    util.decorateRoot.add(type2);
    type2.ctor = ctor;
    Object.defineProperty(ctor, "$type", { value: type2, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type2, enumerable: false });
    return type2;
  };
  var decorateEnumIndex = 0;
  util.decorateEnum = function decorateEnum(object) {
    if (object.$type)
      return object.$type;
    if (!Enum)
      Enum = require_enum();
    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
  };
  util.setProperty = function setProperty(dst, path, value, ifNotSet) {
    function setProp(dst2, path2, value2) {
      var part = path2.shift();
      if (part === "__proto__" || part === "prototype") {
        return dst2;
      }
      if (path2.length > 0) {
        dst2[part] = setProp(dst2[part] || {}, path2, value2);
      } else {
        var prevValue = dst2[part];
        if (prevValue && ifNotSet)
          return dst2;
        if (prevValue)
          value2 = [].concat(prevValue).concat(value2);
        dst2[part] = value2;
      }
      return dst2;
    }
    if (typeof dst !== "object")
      throw TypeError("dst must be an object");
    if (!path)
      throw TypeError("path must be specified");
    path = path.split(".");
    return setProp(dst, path, value);
  };
  Object.defineProperty(util, "decorateRoot", {
    get: function() {
      return roots["decorated"] || (roots["decorated"] = new (require_root2()));
    }
  });
});

// node_modules/protobufjs/src/types.js
var require_types5 = __commonJS((exports) => {
  var types = exports;
  var util = require_util3();
  var s = [
    "double",
    "float",
    "int32",
    "uint32",
    "sint32",
    "fixed32",
    "sfixed32",
    "int64",
    "uint64",
    "sint64",
    "fixed64",
    "sfixed64",
    "bool",
    "string",
    "bytes"
  ];
  function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length)
      o[s[i + offset]] = values[i++];
    return o;
  }
  types.basic = bake([
    1,
    5,
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0,
    2,
    2
  ]);
  types.defaults = bake([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    false,
    "",
    util.emptyArray,
    null
  ]);
  types.long = bake([
    0,
    0,
    0,
    1,
    1
  ], 7);
  types.mapKey = bake([
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0,
    2
  ], 2);
  types.packed = bake([
    1,
    5,
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0
  ]);
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS((exports, module) => {
  module.exports = Field;
  var ReflectionObject = require_object();
  ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
  var Enum = require_enum();
  var types = require_types5();
  var util = require_util3();
  var Type;
  var ruleRe = /^required|optional|repeated$/;
  Field.fromJSON = function fromJSON(name, json) {
    var field = new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    if (json.edition)
      field._edition = json.edition;
    field._defaultEdition = "proto3";
    return field;
  };
  function Field(name, id, type2, rule, extend, options, comment) {
    if (util.isObject(rule)) {
      comment = extend;
      options = rule;
      rule = extend = undefined;
    } else if (util.isObject(extend)) {
      comment = options;
      options = extend;
      extend = undefined;
    }
    ReflectionObject.call(this, name, options);
    if (!util.isInteger(id) || id < 0)
      throw TypeError("id must be a non-negative integer");
    if (!util.isString(type2))
      throw TypeError("type must be a string");
    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
      throw TypeError("rule must be a string rule");
    if (extend !== undefined && !util.isString(extend))
      throw TypeError("extend must be a string");
    if (rule === "proto3_optional") {
      rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : undefined;
    this.type = type2;
    this.id = id;
    this.extend = extend || undefined;
    this.repeated = rule === "repeated";
    this.map = false;
    this.message = null;
    this.partOf = null;
    this.typeDefault = null;
    this.defaultValue = null;
    this.long = util.Long ? types.long[type2] !== undefined : false;
    this.bytes = type2 === "bytes";
    this.resolvedType = null;
    this.extensionField = null;
    this.declaringField = null;
    this.comment = comment;
  }
  Object.defineProperty(Field.prototype, "required", {
    get: function() {
      return this._features.field_presence === "LEGACY_REQUIRED";
    }
  });
  Object.defineProperty(Field.prototype, "optional", {
    get: function() {
      return !this.required;
    }
  });
  Object.defineProperty(Field.prototype, "delimited", {
    get: function() {
      return this.resolvedType instanceof Type && this._features.message_encoding === "DELIMITED";
    }
  });
  Object.defineProperty(Field.prototype, "packed", {
    get: function() {
      return this._features.repeated_field_encoding === "PACKED";
    }
  });
  Object.defineProperty(Field.prototype, "hasPresence", {
    get: function() {
      if (this.repeated || this.map) {
        return false;
      }
      return this.partOf || this.declaringField || this.extensionField || this._features.field_presence !== "IMPLICIT";
    }
  });
  Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
  };
  Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "rule",
      this.rule !== "optional" && this.rule || undefined,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  Field.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if ((this.typeDefault = types.defaults[this.type]) === undefined) {
      this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
      if (this.resolvedType instanceof Type)
        this.typeDefault = null;
      else
        this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
    } else if (this.options && this.options.proto3_optional) {
      this.typeDefault = null;
    }
    if (this.options && this.options["default"] != null) {
      this.typeDefault = this.options["default"];
      if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
        this.typeDefault = this.resolvedType.values[this.typeDefault];
    }
    if (this.options) {
      if (this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
        delete this.options.packed;
      if (!Object.keys(this.options).length)
        this.options = undefined;
    }
    if (this.long) {
      this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
      if (Object.freeze)
        Object.freeze(this.typeDefault);
    } else if (this.bytes && typeof this.typeDefault === "string") {
      var buf;
      if (util.base64.test(this.typeDefault))
        util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
      else
        util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
      this.typeDefault = buf;
    }
    if (this.map)
      this.defaultValue = util.emptyObject;
    else if (this.repeated)
      this.defaultValue = util.emptyArray;
    else
      this.defaultValue = this.typeDefault;
    if (this.parent instanceof Type)
      this.parent.ctor.prototype[this.name] = this.defaultValue;
    return ReflectionObject.prototype.resolve.call(this);
  };
  Field.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(edition) {
    if (edition !== "proto2" && edition !== "proto3") {
      return {};
    }
    var features = {};
    if (this.rule === "required") {
      features.field_presence = "LEGACY_REQUIRED";
    }
    if (this.parent && types.defaults[this.type] === undefined) {
      var type2 = this.parent.get(this.type.split(".").pop());
      if (type2 && type2 instanceof Type && type2.group) {
        features.message_encoding = "DELIMITED";
      }
    }
    if (this.getOption("packed") === true) {
      features.repeated_field_encoding = "PACKED";
    } else if (this.getOption("packed") === false) {
      features.repeated_field_encoding = "EXPANDED";
    }
    return features;
  };
  Field.prototype._resolveFeatures = function _resolveFeatures(edition) {
    return ReflectionObject.prototype._resolveFeatures.call(this, this._edition || edition);
  };
  Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
    if (typeof fieldType === "function")
      fieldType = util.decorateType(fieldType).name;
    else if (fieldType && typeof fieldType === "object")
      fieldType = util.decorateEnum(fieldType).name;
    return function fieldDecorator(prototype, fieldName) {
      util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { default: defaultValue }));
    };
  };
  Field._configure = function configure(Type_) {
    Type = Type_;
  };
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS((exports, module) => {
  module.exports = OneOf;
  var ReflectionObject = require_object();
  ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
  var Field = require_field();
  var util = require_util3();
  function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
      options = fieldNames;
      fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
      throw TypeError("fieldNames must be an Array");
    this.oneof = fieldNames || [];
    this.fieldsArray = [];
    this.comment = comment;
  }
  OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
  };
  OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "options",
      this.options,
      "oneof",
      this.oneof,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  function addFieldsToParent(oneof) {
    if (oneof.parent) {
      for (var i = 0;i < oneof.fieldsArray.length; ++i)
        if (!oneof.fieldsArray[i].parent)
          oneof.parent.add(oneof.fieldsArray[i]);
    }
  }
  OneOf.prototype.add = function add(field) {
    if (!(field instanceof Field))
      throw TypeError("field must be a Field");
    if (field.parent && field.parent !== this.parent)
      field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this;
    addFieldsToParent(this);
    return this;
  };
  OneOf.prototype.remove = function remove(field) {
    if (!(field instanceof Field))
      throw TypeError("field must be a Field");
    var index = this.fieldsArray.indexOf(field);
    if (index < 0)
      throw Error(field + " is not a member of " + this);
    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);
    if (index > -1)
      this.oneof.splice(index, 1);
    field.partOf = null;
    return this;
  };
  OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self2 = this;
    for (var i = 0;i < this.oneof.length; ++i) {
      var field = parent.get(this.oneof[i]);
      if (field && !field.partOf) {
        field.partOf = self2;
        self2.fieldsArray.push(field);
      }
    }
    addFieldsToParent(this);
  };
  OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field;i < this.fieldsArray.length; ++i)
      if ((field = this.fieldsArray[i]).parent)
        field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
  };
  Object.defineProperty(OneOf.prototype, "isProto3Optional", {
    get: function() {
      if (this.fieldsArray == null || this.fieldsArray.length !== 1) {
        return false;
      }
      var field = this.fieldsArray[0];
      return field.options != null && field.options["proto3_optional"] === true;
    }
  });
  OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length), index = 0;
    while (index < arguments.length)
      fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
      util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
      Object.defineProperty(prototype, oneofName, {
        get: util.oneOfGetter(fieldNames),
        set: util.oneOfSetter(fieldNames)
      });
    };
  };
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS((exports, module) => {
  module.exports = ReflectionObject;
  ReflectionObject.className = "ReflectionObject";
  var OneOf = require_oneof();
  var util = require_util3();
  var Root;
  var editions2023Defaults = { enum_type: "OPEN", field_presence: "EXPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
  var proto2Defaults = { enum_type: "CLOSED", field_presence: "EXPLICIT", json_format: "LEGACY_BEST_EFFORT", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "EXPANDED", utf8_validation: "NONE" };
  var proto3Defaults = { enum_type: "OPEN", field_presence: "IMPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
  function ReflectionObject(name, options) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    if (options && !util.isObject(options))
      throw TypeError("options must be an object");
    this.options = options;
    this.parsedOptions = null;
    this.name = name;
    this._edition = null;
    this._defaultEdition = "proto2";
    this._features = {};
    this._featuresResolved = false;
    this.parent = null;
    this.resolved = false;
    this.comment = null;
    this.filename = null;
  }
  Object.defineProperties(ReflectionObject.prototype, {
    root: {
      get: function() {
        var ptr = this;
        while (ptr.parent !== null)
          ptr = ptr.parent;
        return ptr;
      }
    },
    fullName: {
      get: function() {
        var path = [this.name], ptr = this.parent;
        while (ptr) {
          path.unshift(ptr.name);
          ptr = ptr.parent;
        }
        return path.join(".");
      }
    }
  });
  ReflectionObject.prototype.toJSON = function toJSON() {
    throw Error();
  };
  ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
      this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
      root._handleAdd(this);
  };
  ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
      root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
  };
  ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (this.root instanceof Root)
      this.resolved = true;
    return this;
  };
  ReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    return this._resolveFeatures(this._edition || edition);
  };
  ReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {
    if (this._featuresResolved) {
      return;
    }
    var defaults = {};
    if (!edition) {
      throw new Error("Unknown edition for " + this.fullName);
    }
    var protoFeatures = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this._inferLegacyProtoFeatures(edition));
    if (this._edition) {
      if (edition === "proto2") {
        defaults = Object.assign({}, proto2Defaults);
      } else if (edition === "proto3") {
        defaults = Object.assign({}, proto3Defaults);
      } else if (edition === "2023") {
        defaults = Object.assign({}, editions2023Defaults);
      } else {
        throw new Error("Unknown edition: " + edition);
      }
      this._features = Object.assign(defaults, protoFeatures || {});
      this._featuresResolved = true;
      return;
    }
    if (this.partOf instanceof OneOf) {
      var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);
      this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});
    } else if (this.declaringField) {
    } else if (this.parent) {
      var parentFeaturesCopy = Object.assign({}, this.parent._features);
      this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});
    } else {
      throw new Error("Unable to find a parent for " + this.fullName);
    }
    if (this.extensionField) {
      this.extensionField._features = this._features;
    }
    this._featuresResolved = true;
  };
  ReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures() {
    return {};
  };
  ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
      return this.options[name];
    return;
  };
  ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!this.options)
      this.options = {};
    if (/^features\./.test(name)) {
      util.setProperty(this.options, name, value, ifNotSet);
    } else if (!ifNotSet || this.options[name] === undefined) {
      if (this.getOption(name) !== value)
        this.resolved = false;
      this.options[name] = value;
    }
    return this;
  };
  ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
      this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
      var opt = parsedOptions.find(function(opt2) {
        return Object.prototype.hasOwnProperty.call(opt2, name);
      });
      if (opt) {
        var newValue = opt[name];
        util.setProperty(newValue, propName, value);
      } else {
        opt = {};
        opt[name] = util.setProperty({}, propName, value);
        parsedOptions.push(opt);
      }
    } else {
      var newOpt = {};
      newOpt[name] = value;
      parsedOptions.push(newOpt);
    }
    return this;
  };
  ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
      for (var keys = Object.keys(options), i = 0;i < keys.length; ++i)
        this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
  };
  ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className, fullName = this.fullName;
    if (fullName.length)
      return className + " " + fullName;
    return className;
  };
  ReflectionObject.prototype._editionToJSON = function _editionToJSON() {
    if (!this._edition || this._edition === "proto3") {
      return;
    }
    return this._edition;
  };
  ReflectionObject._configure = function(Root_) {
    Root = Root_;
  };
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS((exports, module) => {
  module.exports = Enum;
  var ReflectionObject = require_object();
  ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
  var Namespace = require_namespace();
  var util = require_util3();
  function Enum(name, values, options, comment, comments, valuesOptions) {
    ReflectionObject.call(this, name, options);
    if (values && typeof values !== "object")
      throw TypeError("values must be an object");
    this.valuesById = {};
    this.values = Object.create(this.valuesById);
    this.comment = comment;
    this.comments = comments || {};
    this.valuesOptions = valuesOptions;
    this._valuesFeatures = {};
    this.reserved = undefined;
    if (values) {
      for (var keys = Object.keys(values), i = 0;i < keys.length; ++i)
        if (typeof values[keys[i]] === "number")
          this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
    }
  }
  Enum.prototype._resolveFeatures = function _resolveFeatures(edition) {
    edition = this._edition || edition;
    ReflectionObject.prototype._resolveFeatures.call(this, edition);
    Object.keys(this.values).forEach((key) => {
      var parentFeaturesCopy = Object.assign({}, this._features);
      this._valuesFeatures[key] = Object.assign(parentFeaturesCopy, this.valuesOptions && this.valuesOptions[key] && this.valuesOptions[key].features);
    });
    return this;
  };
  Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    if (json.edition)
      enm._edition = json.edition;
    enm._defaultEdition = "proto3";
    return enm;
  };
  Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "options",
      this.options,
      "valuesOptions",
      this.valuesOptions,
      "values",
      this.values,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : undefined,
      "comment",
      keepComments ? this.comment : undefined,
      "comments",
      keepComments ? this.comments : undefined
    ]);
  };
  Enum.prototype.add = function add(name, id, comment, options) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    if (!util.isInteger(id))
      throw TypeError("id must be an integer");
    if (this.values[name] !== undefined)
      throw Error("duplicate name '" + name + "' in " + this);
    if (this.isReservedId(id))
      throw Error("id " + id + " is reserved in " + this);
    if (this.isReservedName(name))
      throw Error("name '" + name + "' is reserved in " + this);
    if (this.valuesById[id] !== undefined) {
      if (!(this.options && this.options.allow_alias))
        throw Error("duplicate id " + id + " in " + this);
      this.values[name] = id;
    } else
      this.valuesById[this.values[name] = id] = name;
    if (options) {
      if (this.valuesOptions === undefined)
        this.valuesOptions = {};
      this.valuesOptions[name] = options || null;
    }
    this.comments[name] = comment || null;
    return this;
  };
  Enum.prototype.remove = function remove(name) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    var val = this.values[name];
    if (val == null)
      throw Error("name '" + name + "' does not exist in " + this);
    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    if (this.valuesOptions)
      delete this.valuesOptions[name];
    return this;
  };
  Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS((exports, module) => {
  module.exports = encoder;
  var Enum = require_enum();
  var types = require_types5();
  var util = require_util3();
  function genTypePartial(gen, field, fieldIndex, ref) {
    return field.delimited ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
  }
  function encoder(mtype) {
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
    var i, ref;
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    for (var i = 0;i < fields.length; ++i) {
      var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type2 = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type2];
      ref = "m" + util.safeProp(field.name);
      if (field.map) {
        gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
        if (wireType === undefined)
          gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
        else
          gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type2, ref);
        gen("}")("}");
      } else if (field.repeated) {
        gen("if(%s!=null&&%s.length){", ref, ref);
        if (field.packed && types.packed[type2] !== undefined) {
          gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type2, ref)("w.ldelim()");
        } else {
          gen("for(var i=0;i<%s.length;++i)", ref);
          if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
          else
            gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type2, ref);
        }
        gen("}");
      } else {
        if (field.optional)
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
        if (wireType === undefined)
          genTypePartial(gen, field, index, ref);
        else
          gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type2, ref);
      }
    }
    return gen("return w");
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS((exports, module) => {
  var protobuf = module.exports = require_index_minimal();
  protobuf.build = "light";
  function load(filename, root, callback) {
    if (typeof root === "function") {
      callback = root;
      root = new protobuf.Root;
    } else if (!root)
      root = new protobuf.Root;
    return root.load(filename, callback);
  }
  protobuf.load = load;
  function loadSync(filename, root) {
    if (!root)
      root = new protobuf.Root;
    return root.loadSync(filename);
  }
  protobuf.loadSync = loadSync;
  protobuf.encoder = require_encoder();
  protobuf.decoder = require_decoder();
  protobuf.verifier = require_verifier();
  protobuf.converter = require_converter();
  protobuf.ReflectionObject = require_object();
  protobuf.Namespace = require_namespace();
  protobuf.Root = require_root2();
  protobuf.Enum = require_enum();
  protobuf.Type = require_type2();
  protobuf.Field = require_field();
  protobuf.OneOf = require_oneof();
  protobuf.MapField = require_mapfield();
  protobuf.Service = require_service2();
  protobuf.Method = require_method();
  protobuf.Message = require_message();
  protobuf.wrappers = require_wrappers();
  protobuf.types = require_types5();
  protobuf.util = require_util3();
  protobuf.ReflectionObject._configure(protobuf.Root);
  protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
  protobuf.Root._configure(protobuf.Type);
  protobuf.Field._configure(protobuf.Type);
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS((exports, module) => {
  module.exports = tokenize;
  var delimRe = /[\s{}=;:[\],'"()<>]/g;
  var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
  var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
  var setCommentRe = /^ *[*/]+ */;
  var setCommentAltRe = /^\s*\*?\/*/;
  var setCommentSplitRe = /\n/g;
  var whitespaceRe = /\s/;
  var unescapeRe = /\\(.?)/g;
  var unescapeMap = {
    "0": "\x00",
    r: "\r",
    n: `
`,
    t: "\t"
  };
  function unescape2(str) {
    return str.replace(unescapeRe, function($0, $1) {
      switch ($1) {
        case "\\":
        case "":
          return $1;
        default:
          return unescapeMap[$1] || "";
      }
    });
  }
  tokenize.unescape = unescape2;
  function tokenize(source, alternateCommentMode) {
    source = source.toString();
    var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};
    var stack = [];
    var stringDelim = null;
    function illegal(subject) {
      return Error("illegal " + subject + " (line " + line + ")");
    }
    function readString() {
      var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
      re.lastIndex = offset - 1;
      var match = re.exec(source);
      if (!match)
        throw illegal("string");
      offset = re.lastIndex;
      push(stringDelim);
      stringDelim = null;
      return unescape2(match[1]);
    }
    function charAt(pos) {
      return source.charAt(pos);
    }
    function setComment(start, end, isLeading) {
      var comment = {
        type: source.charAt(start++),
        lineEmpty: false,
        leading: isLeading
      };
      var lookback;
      if (alternateCommentMode) {
        lookback = 2;
      } else {
        lookback = 3;
      }
      var commentOffset = start - lookback, c;
      do {
        if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === `
`) {
          comment.lineEmpty = true;
          break;
        }
      } while (c === " " || c === "\t");
      var lines = source.substring(start, end).split(setCommentSplitRe);
      for (var i = 0;i < lines.length; ++i)
        lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
      comment.text = lines.join(`
`).trim();
      comments[line] = comment;
      lastCommentLine = line;
    }
    function isDoubleSlashCommentLine(startOffset) {
      var endOffset = findEndOfLine(startOffset);
      var lineText = source.substring(startOffset, endOffset);
      var isComment = /^\s*\/\//.test(lineText);
      return isComment;
    }
    function findEndOfLine(cursor) {
      var endOffset = cursor;
      while (endOffset < length && charAt(endOffset) !== `
`) {
        endOffset++;
      }
      return endOffset;
    }
    function next() {
      if (stack.length > 0)
        return stack.shift();
      if (stringDelim)
        return readString();
      var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
      do {
        if (offset === length)
          return null;
        repeat = false;
        while (whitespaceRe.test(curr = charAt(offset))) {
          if (curr === `
`) {
            isLeadingComment = true;
            ++line;
          }
          if (++offset === length)
            return null;
        }
        if (charAt(offset) === "/") {
          if (++offset === length) {
            throw illegal("comment");
          }
          if (charAt(offset) === "/") {
            if (!alternateCommentMode) {
              isDoc = charAt(start = offset + 1) === "/";
              while (charAt(++offset) !== `
`) {
                if (offset === length) {
                  return null;
                }
              }
              ++offset;
              if (isDoc) {
                setComment(start, offset - 1, isLeadingComment);
                isLeadingComment = true;
              }
              ++line;
              repeat = true;
            } else {
              start = offset;
              isDoc = false;
              if (isDoubleSlashCommentLine(offset - 1)) {
                isDoc = true;
                do {
                  offset = findEndOfLine(offset);
                  if (offset === length) {
                    break;
                  }
                  offset++;
                  if (!isLeadingComment) {
                    break;
                  }
                } while (isDoubleSlashCommentLine(offset));
              } else {
                offset = Math.min(length, findEndOfLine(offset) + 1);
              }
              if (isDoc) {
                setComment(start, offset, isLeadingComment);
                isLeadingComment = true;
              }
              line++;
              repeat = true;
            }
          } else if ((curr = charAt(offset)) === "*") {
            start = offset + 1;
            isDoc = alternateCommentMode || charAt(start) === "*";
            do {
              if (curr === `
`) {
                ++line;
              }
              if (++offset === length) {
                throw illegal("comment");
              }
              prev = curr;
              curr = charAt(offset);
            } while (prev !== "*" || curr !== "/");
            ++offset;
            if (isDoc) {
              setComment(start, offset - 2, isLeadingComment);
              isLeadingComment = true;
            }
            repeat = true;
          } else {
            return "/";
          }
        }
      } while (repeat);
      var end = offset;
      delimRe.lastIndex = 0;
      var delim = delimRe.test(charAt(end++));
      if (!delim)
        while (end < length && !delimRe.test(charAt(end)))
          ++end;
      var token = source.substring(offset, offset = end);
      if (token === '"' || token === "'")
        stringDelim = token;
      return token;
    }
    function push(token) {
      stack.push(token);
    }
    function peek() {
      if (!stack.length) {
        var token = next();
        if (token === null)
          return null;
        push(token);
      }
      return stack[0];
    }
    function skip(expected, optional) {
      var actual = peek(), equals = actual === expected;
      if (equals) {
        next();
        return true;
      }
      if (!optional)
        throw illegal("token '" + actual + "', '" + expected + "' expected");
      return false;
    }
    function cmnt(trailingLine) {
      var ret = null;
      var comment;
      if (trailingLine === undefined) {
        comment = comments[line - 1];
        delete comments[line - 1];
        if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
          ret = comment.leading ? comment.text : null;
        }
      } else {
        if (lastCommentLine < trailingLine) {
          peek();
        }
        comment = comments[trailingLine];
        delete comments[trailingLine];
        if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
          ret = comment.leading ? null : comment.text;
        }
      }
      return ret;
    }
    return Object.defineProperty({
      next,
      peek,
      push,
      skip,
      cmnt
    }, "line", {
      get: function() {
        return line;
      }
    });
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS((exports, module) => {
  module.exports = parse2;
  parse2.filename = null;
  parse2.defaults = { keepCase: false };
  var tokenize = require_tokenize();
  var Root = require_root2();
  var Type = require_type2();
  var Field = require_field();
  var MapField = require_mapfield();
  var OneOf = require_oneof();
  var Enum = require_enum();
  var Service = require_service2();
  var Method = require_method();
  var ReflectionObject = require_object();
  var types = require_types5();
  var util = require_util3();
  var base10Re = /^[1-9][0-9]*$/;
  var base10NegRe = /^-?[1-9][0-9]*$/;
  var base16Re = /^0[x][0-9a-fA-F]+$/;
  var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
  var base8Re = /^0[0-7]+$/;
  var base8NegRe = /^-?0[0-7]+$/;
  var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
  var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
  var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
  function parse2(source, root, options) {
    if (!(root instanceof Root)) {
      options = root;
      root = new Root;
    }
    if (!options)
      options = parse2.defaults;
    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
    var head = true, pkg, imports, weakImports, edition = "proto2";
    var ptr = root;
    var topLevelObjects = [];
    var topLevelOptions = {};
    var applyCase = options.keepCase ? function(name) {
      return name;
    } : util.camelCase;
    function resolveFileFeatures() {
      topLevelObjects.forEach((obj) => {
        obj._edition = edition;
        Object.keys(topLevelOptions).forEach((opt) => {
          if (obj.getOption(opt) !== undefined)
            return;
          obj.setOption(opt, topLevelOptions[opt], true);
        });
      });
    }
    function illegal(token2, name, insideTryCatch) {
      var filename = parse2.filename;
      if (!insideTryCatch)
        parse2.filename = null;
      return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }
    function readString() {
      var values = [], token2;
      do {
        if ((token2 = next()) !== '"' && token2 !== "'")
          throw illegal(token2);
        values.push(next());
        skip(token2);
        token2 = peek();
      } while (token2 === '"' || token2 === "'");
      return values.join("");
    }
    function readValue(acceptTypeRef) {
      var token2 = next();
      switch (token2) {
        case "'":
        case '"':
          push(token2);
          return readString();
        case "true":
        case "TRUE":
          return true;
        case "false":
        case "FALSE":
          return false;
      }
      try {
        return parseNumber(token2, true);
      } catch (e) {
        if (acceptTypeRef && typeRefRe.test(token2))
          return token2;
        throw illegal(token2, "value");
      }
    }
    function readRanges(target, acceptStrings) {
      var token2, start;
      do {
        if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'")) {
          var str = readString();
          target.push(str);
          if (edition >= 2023) {
            throw illegal(str, "id");
          }
        } else {
          try {
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
          } catch (err) {
            if (acceptStrings && typeRefRe.test(token2) && edition >= 2023) {
              target.push(token2);
            } else {
              throw err;
            }
          }
        }
      } while (skip(",", true));
      var dummy = { options: undefined };
      dummy.setOption = function(name, value) {
        if (this.options === undefined)
          this.options = {};
        this.options[name] = value;
      };
      ifBlock(dummy, function parseRange_block(token3) {
        if (token3 === "option") {
          parseOption(dummy, token3);
          skip(";");
        } else
          throw illegal(token3);
      }, function parseRange_line() {
        parseInlineOptions(dummy);
      });
    }
    function parseNumber(token2, insideTryCatch) {
      var sign = 1;
      if (token2.charAt(0) === "-") {
        sign = -1;
        token2 = token2.substring(1);
      }
      switch (token2) {
        case "inf":
        case "INF":
        case "Inf":
          return sign * Infinity;
        case "nan":
        case "NAN":
        case "Nan":
        case "NaN":
          return NaN;
        case "0":
          return 0;
      }
      if (base10Re.test(token2))
        return sign * parseInt(token2, 10);
      if (base16Re.test(token2))
        return sign * parseInt(token2, 16);
      if (base8Re.test(token2))
        return sign * parseInt(token2, 8);
      if (numberRe.test(token2))
        return sign * parseFloat(token2);
      throw illegal(token2, "number", insideTryCatch);
    }
    function parseId(token2, acceptNegative) {
      switch (token2) {
        case "max":
        case "MAX":
        case "Max":
          return 536870911;
        case "0":
          return 0;
      }
      if (!acceptNegative && token2.charAt(0) === "-")
        throw illegal(token2, "id");
      if (base10NegRe.test(token2))
        return parseInt(token2, 10);
      if (base16NegRe.test(token2))
        return parseInt(token2, 16);
      if (base8NegRe.test(token2))
        return parseInt(token2, 8);
      throw illegal(token2, "id");
    }
    function parsePackage() {
      if (pkg !== undefined)
        throw illegal("package");
      pkg = next();
      if (!typeRefRe.test(pkg))
        throw illegal(pkg, "name");
      ptr = ptr.define(pkg);
      skip(";");
    }
    function parseImport() {
      var token2 = peek();
      var whichImports;
      switch (token2) {
        case "weak":
          whichImports = weakImports || (weakImports = []);
          next();
          break;
        case "public":
          next();
        default:
          whichImports = imports || (imports = []);
          break;
      }
      token2 = readString();
      skip(";");
      whichImports.push(token2);
    }
    function parseSyntax() {
      skip("=");
      edition = readString();
      if (edition < 2023)
        throw illegal(edition, "syntax");
      skip(";");
    }
    function parseEdition() {
      skip("=");
      edition = readString();
      const supportedEditions = ["2023"];
      if (!supportedEditions.includes(edition))
        throw illegal(edition, "edition");
      skip(";");
    }
    function parseCommon(parent, token2) {
      switch (token2) {
        case "option":
          parseOption(parent, token2);
          skip(";");
          return true;
        case "message":
          parseType(parent, token2);
          return true;
        case "enum":
          parseEnum(parent, token2);
          return true;
        case "service":
          parseService(parent, token2);
          return true;
        case "extend":
          parseExtension(parent, token2);
          return true;
      }
      return false;
    }
    function ifBlock(obj, fnIf, fnElse) {
      var trailingLine = tn.line;
      if (obj) {
        if (typeof obj.comment !== "string") {
          obj.comment = cmnt();
        }
        obj.filename = parse2.filename;
      }
      if (skip("{", true)) {
        var token2;
        while ((token2 = next()) !== "}")
          fnIf(token2);
        skip(";", true);
      } else {
        if (fnElse)
          fnElse();
        skip(";");
        if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
          obj.comment = cmnt(trailingLine) || obj.comment;
      }
    }
    function parseType(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "type name");
      var type2 = new Type(token2);
      ifBlock(type2, function parseType_block(token3) {
        if (parseCommon(type2, token3))
          return;
        switch (token3) {
          case "map":
            parseMapField(type2, token3);
            break;
          case "required":
            if (edition !== "proto2")
              throw illegal(token3);
          case "repeated":
            parseField(type2, token3);
            break;
          case "optional":
            if (edition === "proto3") {
              parseField(type2, "proto3_optional");
            } else if (edition !== "proto2") {
              throw illegal(token3);
            } else {
              parseField(type2, "optional");
            }
            break;
          case "oneof":
            parseOneOf(type2, token3);
            break;
          case "extensions":
            readRanges(type2.extensions || (type2.extensions = []));
            break;
          case "reserved":
            readRanges(type2.reserved || (type2.reserved = []), true);
            break;
          default:
            if (edition === "proto2" || !typeRefRe.test(token3)) {
              throw illegal(token3);
            }
            push(token3);
            parseField(type2, "optional");
            break;
        }
      });
      parent.add(type2);
      if (parent === ptr) {
        topLevelObjects.push(type2);
      }
    }
    function parseField(parent, rule, extend) {
      var type2 = next();
      if (type2 === "group") {
        parseGroup(parent, rule);
        return;
      }
      while (type2.endsWith(".") || peek().startsWith(".")) {
        type2 += next();
      }
      if (!typeRefRe.test(type2))
        throw illegal(type2, "type");
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      name = applyCase(name);
      skip("=");
      var field = new Field(name, parseId(next()), type2, rule, extend);
      ifBlock(field, function parseField_block(token2) {
        if (token2 === "option") {
          parseOption(field, token2);
          skip(";");
        } else
          throw illegal(token2);
      }, function parseField_line() {
        parseInlineOptions(field);
      });
      if (rule === "proto3_optional") {
        var oneof = new OneOf("_" + name);
        field.setOption("proto3_optional", true);
        oneof.add(field);
        parent.add(oneof);
      } else {
        parent.add(field);
      }
      if (parent === ptr) {
        topLevelObjects.push(field);
      }
    }
    function parseGroup(parent, rule) {
      if (edition >= 2023) {
        throw illegal("group");
      }
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      var fieldName = util.lcFirst(name);
      if (name === fieldName)
        name = util.ucFirst(name);
      skip("=");
      var id = parseId(next());
      var type2 = new Type(name);
      type2.group = true;
      var field = new Field(fieldName, id, name, rule);
      field.filename = parse2.filename;
      ifBlock(type2, function parseGroup_block(token2) {
        switch (token2) {
          case "option":
            parseOption(type2, token2);
            skip(";");
            break;
          case "required":
          case "repeated":
            parseField(type2, token2);
            break;
          case "optional":
            if (edition === "proto3") {
              parseField(type2, "proto3_optional");
            } else {
              parseField(type2, "optional");
            }
            break;
          case "message":
            parseType(type2, token2);
            break;
          case "enum":
            parseEnum(type2, token2);
            break;
          case "reserved":
            readRanges(type2.reserved || (type2.reserved = []), true);
            break;
          default:
            throw illegal(token2);
        }
      });
      parent.add(type2).add(field);
    }
    function parseMapField(parent) {
      skip("<");
      var keyType = next();
      if (types.mapKey[keyType] === undefined)
        throw illegal(keyType, "type");
      skip(",");
      var valueType = next();
      if (!typeRefRe.test(valueType))
        throw illegal(valueType, "type");
      skip(">");
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      skip("=");
      var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
      ifBlock(field, function parseMapField_block(token2) {
        if (token2 === "option") {
          parseOption(field, token2);
          skip(";");
        } else
          throw illegal(token2);
      }, function parseMapField_line() {
        parseInlineOptions(field);
      });
      parent.add(field);
    }
    function parseOneOf(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var oneof = new OneOf(applyCase(token2));
      ifBlock(oneof, function parseOneOf_block(token3) {
        if (token3 === "option") {
          parseOption(oneof, token3);
          skip(";");
        } else {
          push(token3);
          parseField(oneof, "optional");
        }
      });
      parent.add(oneof);
    }
    function parseEnum(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var enm = new Enum(token2);
      ifBlock(enm, function parseEnum_block(token3) {
        switch (token3) {
          case "option":
            parseOption(enm, token3);
            skip(";");
            break;
          case "reserved":
            readRanges(enm.reserved || (enm.reserved = []), true);
            if (enm.reserved === undefined)
              enm.reserved = [];
            break;
          default:
            parseEnumValue(enm, token3);
        }
      });
      parent.add(enm);
      if (parent === ptr) {
        topLevelObjects.push(enm);
      }
    }
    function parseEnumValue(parent, token2) {
      if (!nameRe.test(token2))
        throw illegal(token2, "name");
      skip("=");
      var value = parseId(next(), true), dummy = {
        options: undefined
      };
      dummy.getOption = function(name) {
        return this.options[name];
      };
      dummy.setOption = function(name, value2) {
        ReflectionObject.prototype.setOption.call(dummy, name, value2);
      };
      dummy.setParsedOption = function() {
        return;
      };
      ifBlock(dummy, function parseEnumValue_block(token3) {
        if (token3 === "option") {
          parseOption(dummy, token3);
          skip(";");
        } else
          throw illegal(token3);
      }, function parseEnumValue_line() {
        parseInlineOptions(dummy);
      });
      parent.add(token2, value, dummy.comment, dummy.parsedOptions || dummy.options);
    }
    function parseOption(parent, token2) {
      var option;
      var propName;
      var isOption = true;
      if (token2 === "option") {
        token2 = next();
      }
      while (token2 !== "=") {
        if (token2 === "(") {
          var parensValue = next();
          skip(")");
          token2 = "(" + parensValue + ")";
        }
        if (isOption) {
          isOption = false;
          if (token2.includes(".") && !token2.includes("(")) {
            var tokens = token2.split(".");
            option = tokens[0] + ".";
            token2 = tokens[1];
            continue;
          }
          option = token2;
        } else {
          propName = propName ? propName += token2 : token2;
        }
        token2 = next();
      }
      var name = propName ? option.concat(propName) : option;
      var optionValue = parseOptionValue(parent, name);
      propName = propName && propName[0] === "." ? propName.slice(1) : propName;
      option = option && option[option.length - 1] === "." ? option.slice(0, -1) : option;
      setParsedOption(parent, option, optionValue, propName);
    }
    function parseOptionValue(parent, name) {
      if (skip("{", true)) {
        var objectResult = {};
        while (!skip("}", true)) {
          if (!nameRe.test(token = next())) {
            throw illegal(token, "name");
          }
          if (token === null) {
            throw illegal(token, "end of input");
          }
          var value;
          var propName = token;
          skip(":", true);
          if (peek() === "{") {
            value = parseOptionValue(parent, name + "." + token);
          } else if (peek() === "[") {
            value = [];
            var lastValue;
            if (skip("[", true)) {
              do {
                lastValue = readValue(true);
                value.push(lastValue);
              } while (skip(",", true));
              skip("]");
              if (typeof lastValue !== "undefined") {
                setOption(parent, name + "." + token, lastValue);
              }
            }
          } else {
            value = readValue(true);
            setOption(parent, name + "." + token, value);
          }
          var prevValue = objectResult[propName];
          if (prevValue)
            value = [].concat(prevValue).concat(value);
          objectResult[propName] = value;
          skip(",", true);
          skip(";", true);
        }
        return objectResult;
      }
      var simpleValue = readValue(true);
      setOption(parent, name, simpleValue);
      return simpleValue;
    }
    function setOption(parent, name, value) {
      if (ptr === parent && /^features\./.test(name)) {
        topLevelOptions[name] = value;
        return;
      }
      if (parent.setOption)
        parent.setOption(name, value);
    }
    function setParsedOption(parent, name, value, propName) {
      if (parent.setParsedOption)
        parent.setParsedOption(name, value, propName);
    }
    function parseInlineOptions(parent) {
      if (skip("[", true)) {
        do {
          parseOption(parent, "option");
        } while (skip(",", true));
        skip("]");
      }
      return parent;
    }
    function parseService(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "service name");
      var service = new Service(token2);
      ifBlock(service, function parseService_block(token3) {
        if (parseCommon(service, token3)) {
          return;
        }
        if (token3 === "rpc")
          parseMethod(service, token3);
        else
          throw illegal(token3);
      });
      parent.add(service);
      if (parent === ptr) {
        topLevelObjects.push(service);
      }
    }
    function parseMethod(parent, token2) {
      var commentText = cmnt();
      var type2 = token2;
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var name = token2, requestType, requestStream, responseType, responseStream;
      skip("(");
      if (skip("stream", true))
        requestStream = true;
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2);
      requestType = token2;
      skip(")");
      skip("returns");
      skip("(");
      if (skip("stream", true))
        responseStream = true;
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2);
      responseType = token2;
      skip(")");
      var method = new Method(name, type2, requestType, responseType, requestStream, responseStream);
      method.comment = commentText;
      ifBlock(method, function parseMethod_block(token3) {
        if (token3 === "option") {
          parseOption(method, token3);
          skip(";");
        } else
          throw illegal(token3);
      });
      parent.add(method);
    }
    function parseExtension(parent, token2) {
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2, "reference");
      var reference = token2;
      ifBlock(null, function parseExtension_block(token3) {
        switch (token3) {
          case "required":
          case "repeated":
            parseField(parent, token3, reference);
            break;
          case "optional":
            if (edition === "proto3") {
              parseField(parent, "proto3_optional", reference);
            } else {
              parseField(parent, "optional", reference);
            }
            break;
          default:
            if (edition === "proto2" || !typeRefRe.test(token3))
              throw illegal(token3);
            push(token3);
            parseField(parent, "optional", reference);
            break;
        }
      });
    }
    var token;
    while ((token = next()) !== null) {
      switch (token) {
        case "package":
          if (!head)
            throw illegal(token);
          parsePackage();
          break;
        case "import":
          if (!head)
            throw illegal(token);
          parseImport();
          break;
        case "syntax":
          if (!head)
            throw illegal(token);
          parseSyntax();
          break;
        case "edition":
          if (!head)
            throw illegal(token);
          parseEdition();
          break;
        case "option":
          parseOption(ptr, token);
          skip(";", true);
          break;
        default:
          if (parseCommon(ptr, token)) {
            head = false;
            continue;
          }
          throw illegal(token);
      }
    }
    resolveFileFeatures();
    parse2.filename = null;
    return {
      package: pkg,
      imports,
      weakImports,
      root
    };
  }
});

// node_modules/protobufjs/src/common.js
var require_common2 = __commonJS((exports, module) => {
  module.exports = common;
  var commonRe = /\/|\./;
  function common(name, json) {
    if (!commonRe.test(name)) {
      name = "google/protobuf/" + name + ".proto";
      json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
  }
  common("any", {
    Any: {
      fields: {
        type_url: {
          type: "string",
          id: 1
        },
        value: {
          type: "bytes",
          id: 2
        }
      }
    }
  });
  var timeType;
  common("duration", {
    Duration: timeType = {
      fields: {
        seconds: {
          type: "int64",
          id: 1
        },
        nanos: {
          type: "int32",
          id: 2
        }
      }
    }
  });
  common("timestamp", {
    Timestamp: timeType
  });
  common("empty", {
    Empty: {
      fields: {}
    }
  });
  common("struct", {
    Struct: {
      fields: {
        fields: {
          keyType: "string",
          type: "Value",
          id: 1
        }
      }
    },
    Value: {
      oneofs: {
        kind: {
          oneof: [
            "nullValue",
            "numberValue",
            "stringValue",
            "boolValue",
            "structValue",
            "listValue"
          ]
        }
      },
      fields: {
        nullValue: {
          type: "NullValue",
          id: 1
        },
        numberValue: {
          type: "double",
          id: 2
        },
        stringValue: {
          type: "string",
          id: 3
        },
        boolValue: {
          type: "bool",
          id: 4
        },
        structValue: {
          type: "Struct",
          id: 5
        },
        listValue: {
          type: "ListValue",
          id: 6
        }
      }
    },
    NullValue: {
      values: {
        NULL_VALUE: 0
      }
    },
    ListValue: {
      fields: {
        values: {
          rule: "repeated",
          type: "Value",
          id: 1
        }
      }
    }
  });
  common("wrappers", {
    DoubleValue: {
      fields: {
        value: {
          type: "double",
          id: 1
        }
      }
    },
    FloatValue: {
      fields: {
        value: {
          type: "float",
          id: 1
        }
      }
    },
    Int64Value: {
      fields: {
        value: {
          type: "int64",
          id: 1
        }
      }
    },
    UInt64Value: {
      fields: {
        value: {
          type: "uint64",
          id: 1
        }
      }
    },
    Int32Value: {
      fields: {
        value: {
          type: "int32",
          id: 1
        }
      }
    },
    UInt32Value: {
      fields: {
        value: {
          type: "uint32",
          id: 1
        }
      }
    },
    BoolValue: {
      fields: {
        value: {
          type: "bool",
          id: 1
        }
      }
    },
    StringValue: {
      fields: {
        value: {
          type: "string",
          id: 1
        }
      }
    },
    BytesValue: {
      fields: {
        value: {
          type: "bytes",
          id: 1
        }
      }
    }
  });
  common("field_mask", {
    FieldMask: {
      fields: {
        paths: {
          rule: "repeated",
          type: "string",
          id: 1
        }
      }
    }
  });
  common.get = function get(file) {
    return common[file] || null;
  };
});

// node_modules/protobufjs/src/index.js
var require_src16 = __commonJS((exports, module) => {
  var protobuf = module.exports = require_index_light();
  protobuf.build = "full";
  protobuf.tokenize = require_tokenize();
  protobuf.parse = require_parse();
  protobuf.common = require_common2();
  protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
});

// node_modules/protobufjs/google/protobuf/descriptor.json
var require_descriptor = __commonJS((exports, module) => {
  module.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            options: {
              go_package: "google.golang.org/protobuf/types/descriptorpb",
              java_package: "com.google.protobuf",
              java_outer_classname: "DescriptorProtos",
              csharp_namespace: "Google.Protobuf.Reflection",
              objc_class_prefix: "GPB",
              cc_enable_arenas: true,
              optimize_for: "SPEED"
            },
            nested: {
              FileDescriptorSet: {
                edition: "proto2",
                fields: {
                  file: {
                    rule: "repeated",
                    type: "FileDescriptorProto",
                    id: 1
                  }
                },
                extensions: [
                  [
                    536000000,
                    536000000
                  ]
                ]
              },
              Edition: {
                edition: "proto2",
                values: {
                  EDITION_UNKNOWN: 0,
                  EDITION_LEGACY: 900,
                  EDITION_PROTO2: 998,
                  EDITION_PROTO3: 999,
                  EDITION_2023: 1000,
                  EDITION_2024: 1001,
                  EDITION_1_TEST_ONLY: 1,
                  EDITION_2_TEST_ONLY: 2,
                  EDITION_99997_TEST_ONLY: 99997,
                  EDITION_99998_TEST_ONLY: 99998,
                  EDITION_99999_TEST_ONLY: 99999,
                  EDITION_MAX: 2147483647
                }
              },
              FileDescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  package: {
                    type: "string",
                    id: 2
                  },
                  dependency: {
                    rule: "repeated",
                    type: "string",
                    id: 3
                  },
                  publicDependency: {
                    rule: "repeated",
                    type: "int32",
                    id: 10
                  },
                  weakDependency: {
                    rule: "repeated",
                    type: "int32",
                    id: 11
                  },
                  optionDependency: {
                    rule: "repeated",
                    type: "string",
                    id: 15
                  },
                  messageType: {
                    rule: "repeated",
                    type: "DescriptorProto",
                    id: 4
                  },
                  enumType: {
                    rule: "repeated",
                    type: "EnumDescriptorProto",
                    id: 5
                  },
                  service: {
                    rule: "repeated",
                    type: "ServiceDescriptorProto",
                    id: 6
                  },
                  extension: {
                    rule: "repeated",
                    type: "FieldDescriptorProto",
                    id: 7
                  },
                  options: {
                    type: "FileOptions",
                    id: 8
                  },
                  sourceCodeInfo: {
                    type: "SourceCodeInfo",
                    id: 9
                  },
                  syntax: {
                    type: "string",
                    id: 12
                  },
                  edition: {
                    type: "Edition",
                    id: 14
                  }
                }
              },
              DescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  field: {
                    rule: "repeated",
                    type: "FieldDescriptorProto",
                    id: 2
                  },
                  extension: {
                    rule: "repeated",
                    type: "FieldDescriptorProto",
                    id: 6
                  },
                  nestedType: {
                    rule: "repeated",
                    type: "DescriptorProto",
                    id: 3
                  },
                  enumType: {
                    rule: "repeated",
                    type: "EnumDescriptorProto",
                    id: 4
                  },
                  extensionRange: {
                    rule: "repeated",
                    type: "ExtensionRange",
                    id: 5
                  },
                  oneofDecl: {
                    rule: "repeated",
                    type: "OneofDescriptorProto",
                    id: 8
                  },
                  options: {
                    type: "MessageOptions",
                    id: 7
                  },
                  reservedRange: {
                    rule: "repeated",
                    type: "ReservedRange",
                    id: 9
                  },
                  reservedName: {
                    rule: "repeated",
                    type: "string",
                    id: 10
                  },
                  visibility: {
                    type: "SymbolVisibility",
                    id: 11
                  }
                },
                nested: {
                  ExtensionRange: {
                    fields: {
                      start: {
                        type: "int32",
                        id: 1
                      },
                      end: {
                        type: "int32",
                        id: 2
                      },
                      options: {
                        type: "ExtensionRangeOptions",
                        id: 3
                      }
                    }
                  },
                  ReservedRange: {
                    fields: {
                      start: {
                        type: "int32",
                        id: 1
                      },
                      end: {
                        type: "int32",
                        id: 2
                      }
                    }
                  }
                }
              },
              ExtensionRangeOptions: {
                edition: "proto2",
                fields: {
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  },
                  declaration: {
                    rule: "repeated",
                    type: "Declaration",
                    id: 2,
                    options: {
                      retention: "RETENTION_SOURCE"
                    }
                  },
                  features: {
                    type: "FeatureSet",
                    id: 50
                  },
                  verification: {
                    type: "VerificationState",
                    id: 3,
                    options: {
                      default: "UNVERIFIED",
                      retention: "RETENTION_SOURCE"
                    }
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ],
                nested: {
                  Declaration: {
                    fields: {
                      number: {
                        type: "int32",
                        id: 1
                      },
                      fullName: {
                        type: "string",
                        id: 2
                      },
                      type: {
                        type: "string",
                        id: 3
                      },
                      reserved: {
                        type: "bool",
                        id: 5
                      },
                      repeated: {
                        type: "bool",
                        id: 6
                      }
                    },
                    reserved: [
                      [
                        4,
                        4
                      ]
                    ]
                  },
                  VerificationState: {
                    values: {
                      DECLARATION: 0,
                      UNVERIFIED: 1
                    }
                  }
                }
              },
              FieldDescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  number: {
                    type: "int32",
                    id: 3
                  },
                  label: {
                    type: "Label",
                    id: 4
                  },
                  type: {
                    type: "Type",
                    id: 5
                  },
                  typeName: {
                    type: "string",
                    id: 6
                  },
                  extendee: {
                    type: "string",
                    id: 2
                  },
                  defaultValue: {
                    type: "string",
                    id: 7
                  },
                  oneofIndex: {
                    type: "int32",
                    id: 9
                  },
                  jsonName: {
                    type: "string",
                    id: 10
                  },
                  options: {
                    type: "FieldOptions",
                    id: 8
                  },
                  proto3Optional: {
                    type: "bool",
                    id: 17
                  }
                },
                nested: {
                  Type: {
                    values: {
                      TYPE_DOUBLE: 1,
                      TYPE_FLOAT: 2,
                      TYPE_INT64: 3,
                      TYPE_UINT64: 4,
                      TYPE_INT32: 5,
                      TYPE_FIXED64: 6,
                      TYPE_FIXED32: 7,
                      TYPE_BOOL: 8,
                      TYPE_STRING: 9,
                      TYPE_GROUP: 10,
                      TYPE_MESSAGE: 11,
                      TYPE_BYTES: 12,
                      TYPE_UINT32: 13,
                      TYPE_ENUM: 14,
                      TYPE_SFIXED32: 15,
                      TYPE_SFIXED64: 16,
                      TYPE_SINT32: 17,
                      TYPE_SINT64: 18
                    }
                  },
                  Label: {
                    values: {
                      LABEL_OPTIONAL: 1,
                      LABEL_REPEATED: 3,
                      LABEL_REQUIRED: 2
                    }
                  }
                }
              },
              OneofDescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  options: {
                    type: "OneofOptions",
                    id: 2
                  }
                }
              },
              EnumDescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    rule: "repeated",
                    type: "EnumValueDescriptorProto",
                    id: 2
                  },
                  options: {
                    type: "EnumOptions",
                    id: 3
                  },
                  reservedRange: {
                    rule: "repeated",
                    type: "EnumReservedRange",
                    id: 4
                  },
                  reservedName: {
                    rule: "repeated",
                    type: "string",
                    id: 5
                  },
                  visibility: {
                    type: "SymbolVisibility",
                    id: 6
                  }
                },
                nested: {
                  EnumReservedRange: {
                    fields: {
                      start: {
                        type: "int32",
                        id: 1
                      },
                      end: {
                        type: "int32",
                        id: 2
                      }
                    }
                  }
                }
              },
              EnumValueDescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  number: {
                    type: "int32",
                    id: 2
                  },
                  options: {
                    type: "EnumValueOptions",
                    id: 3
                  }
                }
              },
              ServiceDescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  method: {
                    rule: "repeated",
                    type: "MethodDescriptorProto",
                    id: 2
                  },
                  options: {
                    type: "ServiceOptions",
                    id: 3
                  }
                }
              },
              MethodDescriptorProto: {
                edition: "proto2",
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  inputType: {
                    type: "string",
                    id: 2
                  },
                  outputType: {
                    type: "string",
                    id: 3
                  },
                  options: {
                    type: "MethodOptions",
                    id: 4
                  },
                  clientStreaming: {
                    type: "bool",
                    id: 5
                  },
                  serverStreaming: {
                    type: "bool",
                    id: 6
                  }
                }
              },
              FileOptions: {
                edition: "proto2",
                fields: {
                  javaPackage: {
                    type: "string",
                    id: 1
                  },
                  javaOuterClassname: {
                    type: "string",
                    id: 8
                  },
                  javaMultipleFiles: {
                    type: "bool",
                    id: 10
                  },
                  javaGenerateEqualsAndHash: {
                    type: "bool",
                    id: 20,
                    options: {
                      deprecated: true
                    }
                  },
                  javaStringCheckUtf8: {
                    type: "bool",
                    id: 27
                  },
                  optimizeFor: {
                    type: "OptimizeMode",
                    id: 9,
                    options: {
                      default: "SPEED"
                    }
                  },
                  goPackage: {
                    type: "string",
                    id: 11
                  },
                  ccGenericServices: {
                    type: "bool",
                    id: 16
                  },
                  javaGenericServices: {
                    type: "bool",
                    id: 17
                  },
                  pyGenericServices: {
                    type: "bool",
                    id: 18
                  },
                  deprecated: {
                    type: "bool",
                    id: 23
                  },
                  ccEnableArenas: {
                    type: "bool",
                    id: 31,
                    options: {
                      default: true
                    }
                  },
                  objcClassPrefix: {
                    type: "string",
                    id: 36
                  },
                  csharpNamespace: {
                    type: "string",
                    id: 37
                  },
                  swiftPrefix: {
                    type: "string",
                    id: 39
                  },
                  phpClassPrefix: {
                    type: "string",
                    id: 40
                  },
                  phpNamespace: {
                    type: "string",
                    id: 41
                  },
                  phpMetadataNamespace: {
                    type: "string",
                    id: 44
                  },
                  rubyPackage: {
                    type: "string",
                    id: 45
                  },
                  features: {
                    type: "FeatureSet",
                    id: 50
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ],
                reserved: [
                  [
                    42,
                    42
                  ],
                  "php_generic_services",
                  [
                    38,
                    38
                  ]
                ],
                nested: {
                  OptimizeMode: {
                    values: {
                      SPEED: 1,
                      CODE_SIZE: 2,
                      LITE_RUNTIME: 3
                    }
                  }
                }
              },
              MessageOptions: {
                edition: "proto2",
                fields: {
                  messageSetWireFormat: {
                    type: "bool",
                    id: 1
                  },
                  noStandardDescriptorAccessor: {
                    type: "bool",
                    id: 2
                  },
                  deprecated: {
                    type: "bool",
                    id: 3
                  },
                  mapEntry: {
                    type: "bool",
                    id: 7
                  },
                  deprecatedLegacyJsonFieldConflicts: {
                    type: "bool",
                    id: 11,
                    options: {
                      deprecated: true
                    }
                  },
                  features: {
                    type: "FeatureSet",
                    id: 12
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ],
                reserved: [
                  [
                    4,
                    4
                  ],
                  [
                    5,
                    5
                  ],
                  [
                    6,
                    6
                  ],
                  [
                    8,
                    8
                  ],
                  [
                    9,
                    9
                  ]
                ]
              },
              FieldOptions: {
                edition: "proto2",
                fields: {
                  ctype: {
                    type: "CType",
                    id: 1,
                    options: {
                      default: "STRING"
                    }
                  },
                  packed: {
                    type: "bool",
                    id: 2
                  },
                  jstype: {
                    type: "JSType",
                    id: 6,
                    options: {
                      default: "JS_NORMAL"
                    }
                  },
                  lazy: {
                    type: "bool",
                    id: 5
                  },
                  unverifiedLazy: {
                    type: "bool",
                    id: 15
                  },
                  deprecated: {
                    type: "bool",
                    id: 3
                  },
                  weak: {
                    type: "bool",
                    id: 10,
                    options: {
                      deprecated: true
                    }
                  },
                  debugRedact: {
                    type: "bool",
                    id: 16
                  },
                  retention: {
                    type: "OptionRetention",
                    id: 17
                  },
                  targets: {
                    rule: "repeated",
                    type: "OptionTargetType",
                    id: 19
                  },
                  editionDefaults: {
                    rule: "repeated",
                    type: "EditionDefault",
                    id: 20
                  },
                  features: {
                    type: "FeatureSet",
                    id: 21
                  },
                  featureSupport: {
                    type: "FeatureSupport",
                    id: 22
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ],
                reserved: [
                  [
                    4,
                    4
                  ],
                  [
                    18,
                    18
                  ]
                ],
                nested: {
                  CType: {
                    values: {
                      STRING: 0,
                      CORD: 1,
                      STRING_PIECE: 2
                    }
                  },
                  JSType: {
                    values: {
                      JS_NORMAL: 0,
                      JS_STRING: 1,
                      JS_NUMBER: 2
                    }
                  },
                  OptionRetention: {
                    values: {
                      RETENTION_UNKNOWN: 0,
                      RETENTION_RUNTIME: 1,
                      RETENTION_SOURCE: 2
                    }
                  },
                  OptionTargetType: {
                    values: {
                      TARGET_TYPE_UNKNOWN: 0,
                      TARGET_TYPE_FILE: 1,
                      TARGET_TYPE_EXTENSION_RANGE: 2,
                      TARGET_TYPE_MESSAGE: 3,
                      TARGET_TYPE_FIELD: 4,
                      TARGET_TYPE_ONEOF: 5,
                      TARGET_TYPE_ENUM: 6,
                      TARGET_TYPE_ENUM_ENTRY: 7,
                      TARGET_TYPE_SERVICE: 8,
                      TARGET_TYPE_METHOD: 9
                    }
                  },
                  EditionDefault: {
                    fields: {
                      edition: {
                        type: "Edition",
                        id: 3
                      },
                      value: {
                        type: "string",
                        id: 2
                      }
                    }
                  },
                  FeatureSupport: {
                    fields: {
                      editionIntroduced: {
                        type: "Edition",
                        id: 1
                      },
                      editionDeprecated: {
                        type: "Edition",
                        id: 2
                      },
                      deprecationWarning: {
                        type: "string",
                        id: 3
                      },
                      editionRemoved: {
                        type: "Edition",
                        id: 4
                      }
                    }
                  }
                }
              },
              OneofOptions: {
                edition: "proto2",
                fields: {
                  features: {
                    type: "FeatureSet",
                    id: 1
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ]
              },
              EnumOptions: {
                edition: "proto2",
                fields: {
                  allowAlias: {
                    type: "bool",
                    id: 2
                  },
                  deprecated: {
                    type: "bool",
                    id: 3
                  },
                  deprecatedLegacyJsonFieldConflicts: {
                    type: "bool",
                    id: 6,
                    options: {
                      deprecated: true
                    }
                  },
                  features: {
                    type: "FeatureSet",
                    id: 7
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ],
                reserved: [
                  [
                    5,
                    5
                  ]
                ]
              },
              EnumValueOptions: {
                edition: "proto2",
                fields: {
                  deprecated: {
                    type: "bool",
                    id: 1
                  },
                  features: {
                    type: "FeatureSet",
                    id: 2
                  },
                  debugRedact: {
                    type: "bool",
                    id: 3
                  },
                  featureSupport: {
                    type: "FieldOptions.FeatureSupport",
                    id: 4
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ]
              },
              ServiceOptions: {
                edition: "proto2",
                fields: {
                  features: {
                    type: "FeatureSet",
                    id: 34
                  },
                  deprecated: {
                    type: "bool",
                    id: 33
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ]
              },
              MethodOptions: {
                edition: "proto2",
                fields: {
                  deprecated: {
                    type: "bool",
                    id: 33
                  },
                  idempotencyLevel: {
                    type: "IdempotencyLevel",
                    id: 34,
                    options: {
                      default: "IDEMPOTENCY_UNKNOWN"
                    }
                  },
                  features: {
                    type: "FeatureSet",
                    id: 35
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1000,
                    536870911
                  ]
                ],
                nested: {
                  IdempotencyLevel: {
                    values: {
                      IDEMPOTENCY_UNKNOWN: 0,
                      NO_SIDE_EFFECTS: 1,
                      IDEMPOTENT: 2
                    }
                  }
                }
              },
              UninterpretedOption: {
                edition: "proto2",
                fields: {
                  name: {
                    rule: "repeated",
                    type: "NamePart",
                    id: 2
                  },
                  identifierValue: {
                    type: "string",
                    id: 3
                  },
                  positiveIntValue: {
                    type: "uint64",
                    id: 4
                  },
                  negativeIntValue: {
                    type: "int64",
                    id: 5
                  },
                  doubleValue: {
                    type: "double",
                    id: 6
                  },
                  stringValue: {
                    type: "bytes",
                    id: 7
                  },
                  aggregateValue: {
                    type: "string",
                    id: 8
                  }
                },
                nested: {
                  NamePart: {
                    fields: {
                      namePart: {
                        rule: "required",
                        type: "string",
                        id: 1
                      },
                      isExtension: {
                        rule: "required",
                        type: "bool",
                        id: 2
                      }
                    }
                  }
                }
              },
              FeatureSet: {
                edition: "proto2",
                fields: {
                  fieldPresence: {
                    type: "FieldPresence",
                    id: 1,
                    options: {
                      retention: "RETENTION_RUNTIME",
                      targets: "TARGET_TYPE_FILE",
                      "feature_support.edition_introduced": "EDITION_2023",
                      "edition_defaults.edition": "EDITION_2023",
                      "edition_defaults.value": "EXPLICIT"
                    }
                  },
                  enumType: {
                    type: "EnumType",
                    id: 2,
                    options: {
                      retention: "RETENTION_RUNTIME",
                      targets: "TARGET_TYPE_FILE",
                      "feature_support.edition_introduced": "EDITION_2023",
                      "edition_defaults.edition": "EDITION_PROTO3",
                      "edition_defaults.value": "OPEN"
                    }
                  },
                  repeatedFieldEncoding: {
                    type: "RepeatedFieldEncoding",
                    id: 3,
                    options: {
                      retention: "RETENTION_RUNTIME",
                      targets: "TARGET_TYPE_FILE",
                      "feature_support.edition_introduced": "EDITION_2023",
                      "edition_defaults.edition": "EDITION_PROTO3",
                      "edition_defaults.value": "PACKED"
                    }
                  },
                  utf8Validation: {
                    type: "Utf8Validation",
                    id: 4,
                    options: {
                      retention: "RETENTION_RUNTIME",
                      targets: "TARGET_TYPE_FILE",
                      "feature_support.edition_introduced": "EDITION_2023",
                      "edition_defaults.edition": "EDITION_PROTO3",
                      "edition_defaults.value": "VERIFY"
                    }
                  },
                  messageEncoding: {
                    type: "MessageEncoding",
                    id: 5,
                    options: {
                      retention: "RETENTION_RUNTIME",
                      targets: "TARGET_TYPE_FILE",
                      "feature_support.edition_introduced": "EDITION_2023",
                      "edition_defaults.edition": "EDITION_LEGACY",
                      "edition_defaults.value": "LENGTH_PREFIXED"
                    }
                  },
                  jsonFormat: {
                    type: "JsonFormat",
                    id: 6,
                    options: {
                      retention: "RETENTION_RUNTIME",
                      targets: "TARGET_TYPE_FILE",
                      "feature_support.edition_introduced": "EDITION_2023",
                      "edition_defaults.edition": "EDITION_PROTO3",
                      "edition_defaults.value": "ALLOW"
                    }
                  },
                  enforceNamingStyle: {
                    type: "EnforceNamingStyle",
                    id: 7,
                    options: {
                      retention: "RETENTION_SOURCE",
                      targets: "TARGET_TYPE_METHOD",
                      "feature_support.edition_introduced": "EDITION_2024",
                      "edition_defaults.edition": "EDITION_2024",
                      "edition_defaults.value": "STYLE2024"
                    }
                  },
                  defaultSymbolVisibility: {
                    type: "VisibilityFeature.DefaultSymbolVisibility",
                    id: 8,
                    options: {
                      retention: "RETENTION_SOURCE",
                      targets: "TARGET_TYPE_FILE",
                      "feature_support.edition_introduced": "EDITION_2024",
                      "edition_defaults.edition": "EDITION_2024",
                      "edition_defaults.value": "EXPORT_TOP_LEVEL"
                    }
                  }
                },
                extensions: [
                  [
                    1000,
                    9994
                  ],
                  [
                    9995,
                    9999
                  ],
                  [
                    1e4,
                    1e4
                  ]
                ],
                reserved: [
                  [
                    999,
                    999
                  ]
                ],
                nested: {
                  FieldPresence: {
                    values: {
                      FIELD_PRESENCE_UNKNOWN: 0,
                      EXPLICIT: 1,
                      IMPLICIT: 2,
                      LEGACY_REQUIRED: 3
                    }
                  },
                  EnumType: {
                    values: {
                      ENUM_TYPE_UNKNOWN: 0,
                      OPEN: 1,
                      CLOSED: 2
                    }
                  },
                  RepeatedFieldEncoding: {
                    values: {
                      REPEATED_FIELD_ENCODING_UNKNOWN: 0,
                      PACKED: 1,
                      EXPANDED: 2
                    }
                  },
                  Utf8Validation: {
                    values: {
                      UTF8_VALIDATION_UNKNOWN: 0,
                      VERIFY: 2,
                      NONE: 3
                    }
                  },
                  MessageEncoding: {
                    values: {
                      MESSAGE_ENCODING_UNKNOWN: 0,
                      LENGTH_PREFIXED: 1,
                      DELIMITED: 2
                    }
                  },
                  JsonFormat: {
                    values: {
                      JSON_FORMAT_UNKNOWN: 0,
                      ALLOW: 1,
                      LEGACY_BEST_EFFORT: 2
                    }
                  },
                  EnforceNamingStyle: {
                    values: {
                      ENFORCE_NAMING_STYLE_UNKNOWN: 0,
                      STYLE2024: 1,
                      STYLE_LEGACY: 2
                    }
                  },
                  VisibilityFeature: {
                    fields: {},
                    reserved: [
                      [
                        1,
                        536870911
                      ]
                    ],
                    nested: {
                      DefaultSymbolVisibility: {
                        values: {
                          DEFAULT_SYMBOL_VISIBILITY_UNKNOWN: 0,
                          EXPORT_ALL: 1,
                          EXPORT_TOP_LEVEL: 2,
                          LOCAL_ALL: 3,
                          STRICT: 4
                        }
                      }
                    }
                  }
                }
              },
              FeatureSetDefaults: {
                edition: "proto2",
                fields: {
                  defaults: {
                    rule: "repeated",
                    type: "FeatureSetEditionDefault",
                    id: 1
                  },
                  minimumEdition: {
                    type: "Edition",
                    id: 4
                  },
                  maximumEdition: {
                    type: "Edition",
                    id: 5
                  }
                },
                nested: {
                  FeatureSetEditionDefault: {
                    fields: {
                      edition: {
                        type: "Edition",
                        id: 3
                      },
                      overridableFeatures: {
                        type: "FeatureSet",
                        id: 4
                      },
                      fixedFeatures: {
                        type: "FeatureSet",
                        id: 5
                      }
                    },
                    reserved: [
                      [
                        1,
                        1
                      ],
                      [
                        2,
                        2
                      ],
                      "features"
                    ]
                  }
                }
              },
              SourceCodeInfo: {
                edition: "proto2",
                fields: {
                  location: {
                    rule: "repeated",
                    type: "Location",
                    id: 1
                  }
                },
                extensions: [
                  [
                    536000000,
                    536000000
                  ]
                ],
                nested: {
                  Location: {
                    fields: {
                      path: {
                        rule: "repeated",
                        type: "int32",
                        id: 1,
                        options: {
                          packed: true
                        }
                      },
                      span: {
                        rule: "repeated",
                        type: "int32",
                        id: 2,
                        options: {
                          packed: true
                        }
                      },
                      leadingComments: {
                        type: "string",
                        id: 3
                      },
                      trailingComments: {
                        type: "string",
                        id: 4
                      },
                      leadingDetachedComments: {
                        rule: "repeated",
                        type: "string",
                        id: 6
                      }
                    }
                  }
                }
              },
              GeneratedCodeInfo: {
                edition: "proto2",
                fields: {
                  annotation: {
                    rule: "repeated",
                    type: "Annotation",
                    id: 1
                  }
                },
                nested: {
                  Annotation: {
                    fields: {
                      path: {
                        rule: "repeated",
                        type: "int32",
                        id: 1,
                        options: {
                          packed: true
                        }
                      },
                      sourceFile: {
                        type: "string",
                        id: 2
                      },
                      begin: {
                        type: "int32",
                        id: 3
                      },
                      end: {
                        type: "int32",
                        id: 4
                      },
                      semantic: {
                        type: "Semantic",
                        id: 5
                      }
                    },
                    nested: {
                      Semantic: {
                        values: {
                          NONE: 0,
                          SET: 1,
                          ALIAS: 2
                        }
                      }
                    }
                  }
                }
              },
              SymbolVisibility: {
                edition: "proto2",
                values: {
                  VISIBILITY_UNSET: 0,
                  VISIBILITY_LOCAL: 1,
                  VISIBILITY_EXPORT: 2
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/protobufjs/ext/descriptor/index.js
var require_descriptor2 = __commonJS((exports, module) => {
  var $protobuf = require_src16();
  module.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require_descriptor()).lookup(".google.protobuf");
  var Namespace = $protobuf.Namespace;
  var Root = $protobuf.Root;
  var Enum = $protobuf.Enum;
  var Type = $protobuf.Type;
  var Field = $protobuf.Field;
  var MapField = $protobuf.MapField;
  var OneOf = $protobuf.OneOf;
  var Service = $protobuf.Service;
  var Method = $protobuf.Method;
  Root.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports.FileDescriptorSet.decode(descriptor);
    var root = new Root;
    if (descriptor.file) {
      var fileDescriptor, filePackage;
      for (var j = 0, i;j < descriptor.file.length; ++j) {
        filePackage = root;
        if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
          filePackage = root.define(fileDescriptor["package"]);
        var edition = editionFromDescriptor(fileDescriptor);
        if (fileDescriptor.name && fileDescriptor.name.length)
          root.files.push(filePackage.filename = fileDescriptor.name);
        if (fileDescriptor.messageType)
          for (i = 0;i < fileDescriptor.messageType.length; ++i)
            filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], edition));
        if (fileDescriptor.enumType)
          for (i = 0;i < fileDescriptor.enumType.length; ++i)
            filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i], edition));
        if (fileDescriptor.extension)
          for (i = 0;i < fileDescriptor.extension.length; ++i)
            filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i], edition));
        if (fileDescriptor.service)
          for (i = 0;i < fileDescriptor.service.length; ++i)
            filePackage.add(Service.fromDescriptor(fileDescriptor.service[i], edition));
        var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);
        if (opts) {
          var ks = Object.keys(opts);
          for (i = 0;i < ks.length; ++i)
            filePackage.setOption(ks[i], opts[ks[i]]);
        }
      }
    }
    return root.resolveAll();
  };
  Root.prototype.toDescriptor = function toDescriptor(edition) {
    var set = exports.FileDescriptorSet.create();
    Root_toDescriptorRecursive(this, set.file, edition);
    return set;
  };
  function Root_toDescriptorRecursive(ns, files2, edition) {
    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
    editionToDescriptor(edition, file);
    if (!(ns instanceof Root))
      file["package"] = ns.fullName.substring(1);
    for (var i = 0, nested;i < ns.nestedArray.length; ++i)
      if ((nested = ns._nestedArray[i]) instanceof Type)
        file.messageType.push(nested.toDescriptor(edition));
      else if (nested instanceof Enum)
        file.enumType.push(nested.toDescriptor());
      else if (nested instanceof Field)
        file.extension.push(nested.toDescriptor(edition));
      else if (nested instanceof Service)
        file.service.push(nested.toDescriptor());
      else if (nested instanceof Namespace)
        Root_toDescriptorRecursive(nested, files2, edition);
    file.options = toDescriptorOptions(ns.options, exports.FileOptions);
    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
      files2.push(file);
  }
  var unnamedMessageIndex = 0;
  Type.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {
    if (typeof descriptor.length === "number")
      descriptor = exports.DescriptorProto.decode(descriptor);
    var type2 = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)), i;
    if (!nested)
      type2._edition = edition;
    if (descriptor.oneofDecl)
      for (i = 0;i < descriptor.oneofDecl.length; ++i)
        type2.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
    if (descriptor.field)
      for (i = 0;i < descriptor.field.length; ++i) {
        var field = Field.fromDescriptor(descriptor.field[i], edition, true);
        type2.add(field);
        if (descriptor.field[i].hasOwnProperty("oneofIndex"))
          type2.oneofsArray[descriptor.field[i].oneofIndex].add(field);
      }
    if (descriptor.extension)
      for (i = 0;i < descriptor.extension.length; ++i)
        type2.add(Field.fromDescriptor(descriptor.extension[i], edition, true));
    if (descriptor.nestedType)
      for (i = 0;i < descriptor.nestedType.length; ++i) {
        type2.add(Type.fromDescriptor(descriptor.nestedType[i], edition, true));
        if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
          type2.setOption("map_entry", true);
      }
    if (descriptor.enumType)
      for (i = 0;i < descriptor.enumType.length; ++i)
        type2.add(Enum.fromDescriptor(descriptor.enumType[i], edition, true));
    if (descriptor.extensionRange && descriptor.extensionRange.length) {
      type2.extensions = [];
      for (i = 0;i < descriptor.extensionRange.length; ++i)
        type2.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);
    }
    if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
      type2.reserved = [];
      if (descriptor.reservedRange)
        for (i = 0;i < descriptor.reservedRange.length; ++i)
          type2.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);
      if (descriptor.reservedName)
        for (i = 0;i < descriptor.reservedName.length; ++i)
          type2.reserved.push(descriptor.reservedName[i]);
    }
    return type2;
  };
  Type.prototype.toDescriptor = function toDescriptor(edition) {
    var descriptor = exports.DescriptorProto.create({ name: this.name }), i;
    for (i = 0;i < this.fieldsArray.length; ++i) {
      var fieldDescriptor;
      descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(edition));
      if (this._fieldsArray[i] instanceof MapField) {
        var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType, false), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType, false), valueTypeName = valueType === 11 || valueType === 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;
        descriptor.nestedType.push(exports.DescriptorProto.create({
          name: fieldDescriptor.typeName,
          field: [
            exports.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }),
            exports.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
          ],
          options: exports.MessageOptions.create({ mapEntry: true })
        }));
      }
    }
    for (i = 0;i < this.oneofsArray.length; ++i)
      descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
    for (i = 0;i < this.nestedArray.length; ++i) {
      if (this._nestedArray[i] instanceof Field)
        descriptor.field.push(this._nestedArray[i].toDescriptor(edition));
      else if (this._nestedArray[i] instanceof Type)
        descriptor.nestedType.push(this._nestedArray[i].toDescriptor(edition));
      else if (this._nestedArray[i] instanceof Enum)
        descriptor.enumType.push(this._nestedArray[i].toDescriptor());
    }
    if (this.extensions)
      for (i = 0;i < this.extensions.length; ++i)
        descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
    if (this.reserved)
      for (i = 0;i < this.reserved.length; ++i)
        if (typeof this.reserved[i] === "string")
          descriptor.reservedName.push(this.reserved[i]);
        else
          descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));
    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);
    return descriptor;
  };
  var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
  Field.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {
    if (typeof descriptor.length === "number")
      descriptor = exports.DescriptorProto.decode(descriptor);
    if (typeof descriptor.number !== "number")
      throw Error("missing field id");
    var fieldType;
    if (descriptor.typeName && descriptor.typeName.length)
      fieldType = descriptor.typeName;
    else
      fieldType = fromDescriptorType(descriptor.type);
    var fieldRule;
    switch (descriptor.label) {
      case 1:
        fieldRule = undefined;
        break;
      case 2:
        fieldRule = "required";
        break;
      case 3:
        fieldRule = "repeated";
        break;
      default:
        throw Error("illegal label: " + descriptor.label);
    }
    var extendee = descriptor.extendee;
    if (descriptor.extendee !== undefined) {
      extendee = extendee.length ? extendee : undefined;
    }
    var field = new Field(descriptor.name.length ? descriptor.name : "field" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);
    if (!nested)
      field._edition = edition;
    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);
    if (descriptor.proto3_optional)
      field.options.proto3_optional = true;
    if (descriptor.defaultValue && descriptor.defaultValue.length) {
      var defaultValue = descriptor.defaultValue;
      switch (defaultValue) {
        case "true":
        case "TRUE":
          defaultValue = true;
          break;
        case "false":
        case "FALSE":
          defaultValue = false;
          break;
        default:
          var match = numberRe.exec(defaultValue);
          if (match)
            defaultValue = parseInt(defaultValue);
          break;
      }
      field.setOption("default", defaultValue);
    }
    if (packableDescriptorType(descriptor.type)) {
      if (edition === "proto3") {
        if (descriptor.options && !descriptor.options.packed)
          field.setOption("packed", false);
      } else if ((!edition || edition === "proto2") && descriptor.options && descriptor.options.packed)
        field.setOption("packed", true);
    }
    return field;
  };
  Field.prototype.toDescriptor = function toDescriptor(edition) {
    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });
    if (this.map) {
      descriptor.type = 11;
      descriptor.typeName = $protobuf.util.ucFirst(this.name);
      descriptor.label = 3;
    } else {
      switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType, this.delimited)) {
        case 10:
        case 11:
        case 14:
          descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
          break;
      }
      if (this.rule === "repeated") {
        descriptor.label = 3;
      } else if (this.required && edition === "proto2") {
        descriptor.label = 2;
      } else {
        descriptor.label = 1;
      }
    }
    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;
    if (this.partOf) {
      if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
        throw Error("missing oneof");
    }
    if (this.options) {
      descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);
      if (this.options["default"] != null)
        descriptor.defaultValue = String(this.options["default"]);
      if (this.options.proto3_optional)
        descriptor.proto3_optional = true;
    }
    if (edition === "proto3") {
      if (!this.packed)
        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;
    } else if ((!edition || edition === "proto2") && this.packed)
      (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;
    return descriptor;
  };
  var unnamedEnumIndex = 0;
  Enum.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {
    if (typeof descriptor.length === "number")
      descriptor = exports.EnumDescriptorProto.decode(descriptor);
    var values = {};
    if (descriptor.value)
      for (var i = 0;i < descriptor.value.length; ++i) {
        var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;
        values[name && name.length ? name : "NAME" + value] = value;
      }
    var enm = new Enum(descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));
    if (!nested)
      enm._edition = edition;
    return enm;
  };
  Enum.prototype.toDescriptor = function toDescriptor() {
    var values = [];
    for (var i = 0, ks = Object.keys(this.values);i < ks.length; ++i)
      values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));
    return exports.EnumDescriptorProto.create({
      name: this.name,
      value: values,
      options: toDescriptorOptions(this.options, exports.EnumOptions)
    });
  };
  var unnamedOneofIndex = 0;
  OneOf.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports.OneofDescriptorProto.decode(descriptor);
    return new OneOf(descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++);
  };
  OneOf.prototype.toDescriptor = function toDescriptor() {
    return exports.OneofDescriptorProto.create({
      name: this.name
    });
  };
  var unnamedServiceIndex = 0;
  Service.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {
    if (typeof descriptor.length === "number")
      descriptor = exports.ServiceDescriptorProto.decode(descriptor);
    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));
    if (!nested)
      service._edition = edition;
    if (descriptor.method)
      for (var i = 0;i < descriptor.method.length; ++i)
        service.add(Method.fromDescriptor(descriptor.method[i]));
    return service;
  };
  Service.prototype.toDescriptor = function toDescriptor() {
    var methods = [];
    for (var i = 0;i < this.methodsArray.length; ++i)
      methods.push(this._methodsArray[i].toDescriptor());
    return exports.ServiceDescriptorProto.create({
      name: this.name,
      method: methods,
      options: toDescriptorOptions(this.options, exports.ServiceOptions)
    });
  };
  var unnamedMethodIndex = 0;
  Method.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports.MethodDescriptorProto.decode(descriptor);
    return new Method(descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++, "rpc", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));
  };
  Method.prototype.toDescriptor = function toDescriptor() {
    return exports.MethodDescriptorProto.create({
      name: this.name,
      inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
      outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
      clientStreaming: this.requestStream,
      serverStreaming: this.responseStream,
      options: toDescriptorOptions(this.options, exports.MethodOptions)
    });
  };
  function fromDescriptorType(type2) {
    switch (type2) {
      case 1:
        return "double";
      case 2:
        return "float";
      case 3:
        return "int64";
      case 4:
        return "uint64";
      case 5:
        return "int32";
      case 6:
        return "fixed64";
      case 7:
        return "fixed32";
      case 8:
        return "bool";
      case 9:
        return "string";
      case 12:
        return "bytes";
      case 13:
        return "uint32";
      case 15:
        return "sfixed32";
      case 16:
        return "sfixed64";
      case 17:
        return "sint32";
      case 18:
        return "sint64";
    }
    throw Error("illegal type: " + type2);
  }
  function packableDescriptorType(type2) {
    switch (type2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
        return true;
    }
    return false;
  }
  function toDescriptorType(type2, resolvedType, delimited) {
    switch (type2) {
      case "double":
        return 1;
      case "float":
        return 2;
      case "int64":
        return 3;
      case "uint64":
        return 4;
      case "int32":
        return 5;
      case "fixed64":
        return 6;
      case "fixed32":
        return 7;
      case "bool":
        return 8;
      case "string":
        return 9;
      case "bytes":
        return 12;
      case "uint32":
        return 13;
      case "sfixed32":
        return 15;
      case "sfixed64":
        return 16;
      case "sint32":
        return 17;
      case "sint64":
        return 18;
    }
    if (resolvedType instanceof Enum)
      return 14;
    if (resolvedType instanceof Type)
      return delimited ? 10 : 11;
    throw Error("illegal type: " + type2);
  }
  function fromDescriptorOptionsRecursive(obj, type2) {
    var val = {};
    for (var i = 0, field, key;i < type2.fieldsArray.length; ++i) {
      if ((key = (field = type2._fieldsArray[i]).name) === "uninterpretedOption")
        continue;
      if (!Object.prototype.hasOwnProperty.call(obj, key))
        continue;
      var newKey = underScore(key);
      if (field.resolvedType instanceof Type) {
        val[newKey] = fromDescriptorOptionsRecursive(obj[key], field.resolvedType);
      } else if (field.resolvedType instanceof Enum) {
        val[newKey] = field.resolvedType.valuesById[obj[key]];
      } else {
        val[newKey] = obj[key];
      }
    }
    return val;
  }
  function fromDescriptorOptions(options, type2) {
    if (!options)
      return;
    return fromDescriptorOptionsRecursive(type2.toObject(options), type2);
  }
  function toDescriptorOptionsRecursive(obj, type2) {
    var val = {};
    var keys = Object.keys(obj);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      var newKey = $protobuf.util.camelCase(key);
      if (!Object.prototype.hasOwnProperty.call(type2.fields, newKey))
        continue;
      var field = type2.fields[newKey];
      if (field.resolvedType instanceof Type) {
        val[newKey] = toDescriptorOptionsRecursive(obj[key], field.resolvedType);
      } else {
        val[newKey] = obj[key];
      }
      if (field.repeated && !Array.isArray(val[newKey])) {
        val[newKey] = [val[newKey]];
      }
    }
    return val;
  }
  function toDescriptorOptions(options, type2) {
    if (!options)
      return;
    return type2.fromObject(toDescriptorOptionsRecursive(options, type2));
  }
  function shortname(from, to) {
    var fromPath = from.fullName.split("."), toPath = to.fullName.split("."), i = 0, j = 0, k = toPath.length - 1;
    if (!(from instanceof Root) && to instanceof Namespace)
      while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
        var other = to.lookup(fromPath[i++], true);
        if (other !== null && other !== to)
          break;
        ++j;
      }
    else
      for (;i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j)
        ;
    return toPath.slice(j).join(".");
  }
  function underScore(str) {
    return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {
      return "_" + $1.toLowerCase();
    });
  }
  function editionFromDescriptor(fileDescriptor) {
    if (fileDescriptor.syntax === "editions") {
      switch (fileDescriptor.edition) {
        case exports.Edition.EDITION_2023:
          return "2023";
        default:
          throw new Error("Unsupported edition " + fileDescriptor.edition);
      }
    }
    if (fileDescriptor.syntax === "proto3") {
      return "proto3";
    }
    return "proto2";
  }
  function editionToDescriptor(edition, fileDescriptor) {
    if (!edition)
      return;
    if (edition === "proto2" || edition === "proto3") {
      fileDescriptor.syntax = edition;
    } else {
      fileDescriptor.syntax = "editions";
      switch (edition) {
        case "2023":
          fileDescriptor.edition = exports.Edition.EDITION_2023;
          break;
        default:
          throw new Error("Unsupported edition " + edition);
      }
    }
  }
});

// node_modules/protobufjs/google/protobuf/api.json
var require_api = __commonJS((exports, module) => {
  module.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            nested: {
              Api: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  methods: {
                    rule: "repeated",
                    type: "Method",
                    id: 2
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 3
                  },
                  version: {
                    type: "string",
                    id: 4
                  },
                  sourceContext: {
                    type: "SourceContext",
                    id: 5
                  },
                  mixins: {
                    rule: "repeated",
                    type: "Mixin",
                    id: 6
                  },
                  syntax: {
                    type: "Syntax",
                    id: 7
                  }
                }
              },
              Method: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  requestTypeUrl: {
                    type: "string",
                    id: 2
                  },
                  requestStreaming: {
                    type: "bool",
                    id: 3
                  },
                  responseTypeUrl: {
                    type: "string",
                    id: 4
                  },
                  responseStreaming: {
                    type: "bool",
                    id: 5
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 6
                  },
                  syntax: {
                    type: "Syntax",
                    id: 7
                  }
                }
              },
              Mixin: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  root: {
                    type: "string",
                    id: 2
                  }
                }
              },
              SourceContext: {
                fields: {
                  fileName: {
                    type: "string",
                    id: 1
                  }
                }
              },
              Option: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    type: "Any",
                    id: 2
                  }
                }
              },
              Syntax: {
                values: {
                  SYNTAX_PROTO2: 0,
                  SYNTAX_PROTO3: 1
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/protobufjs/google/protobuf/source_context.json
var require_source_context = __commonJS((exports, module) => {
  module.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            nested: {
              SourceContext: {
                fields: {
                  fileName: {
                    type: "string",
                    id: 1
                  }
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/protobufjs/google/protobuf/type.json
var require_type3 = __commonJS((exports, module) => {
  module.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            nested: {
              Type: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  fields: {
                    rule: "repeated",
                    type: "Field",
                    id: 2
                  },
                  oneofs: {
                    rule: "repeated",
                    type: "string",
                    id: 3
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 4
                  },
                  sourceContext: {
                    type: "SourceContext",
                    id: 5
                  },
                  syntax: {
                    type: "Syntax",
                    id: 6
                  }
                }
              },
              Field: {
                fields: {
                  kind: {
                    type: "Kind",
                    id: 1
                  },
                  cardinality: {
                    type: "Cardinality",
                    id: 2
                  },
                  number: {
                    type: "int32",
                    id: 3
                  },
                  name: {
                    type: "string",
                    id: 4
                  },
                  typeUrl: {
                    type: "string",
                    id: 6
                  },
                  oneofIndex: {
                    type: "int32",
                    id: 7
                  },
                  packed: {
                    type: "bool",
                    id: 8
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 9
                  },
                  jsonName: {
                    type: "string",
                    id: 10
                  },
                  defaultValue: {
                    type: "string",
                    id: 11
                  }
                },
                nested: {
                  Kind: {
                    values: {
                      TYPE_UNKNOWN: 0,
                      TYPE_DOUBLE: 1,
                      TYPE_FLOAT: 2,
                      TYPE_INT64: 3,
                      TYPE_UINT64: 4,
                      TYPE_INT32: 5,
                      TYPE_FIXED64: 6,
                      TYPE_FIXED32: 7,
                      TYPE_BOOL: 8,
                      TYPE_STRING: 9,
                      TYPE_GROUP: 10,
                      TYPE_MESSAGE: 11,
                      TYPE_BYTES: 12,
                      TYPE_UINT32: 13,
                      TYPE_ENUM: 14,
                      TYPE_SFIXED32: 15,
                      TYPE_SFIXED64: 16,
                      TYPE_SINT32: 17,
                      TYPE_SINT64: 18
                    }
                  },
                  Cardinality: {
                    values: {
                      CARDINALITY_UNKNOWN: 0,
                      CARDINALITY_OPTIONAL: 1,
                      CARDINALITY_REQUIRED: 2,
                      CARDINALITY_REPEATED: 3
                    }
                  }
                }
              },
              Enum: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  enumvalue: {
                    rule: "repeated",
                    type: "EnumValue",
                    id: 2
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 3
                  },
                  sourceContext: {
                    type: "SourceContext",
                    id: 4
                  },
                  syntax: {
                    type: "Syntax",
                    id: 5
                  }
                }
              },
              EnumValue: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  number: {
                    type: "int32",
                    id: 2
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 3
                  }
                }
              },
              Option: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    type: "Any",
                    id: 2
                  }
                }
              },
              Syntax: {
                values: {
                  SYNTAX_PROTO2: 0,
                  SYNTAX_PROTO3: 1
                }
              },
              Any: {
                fields: {
                  type_url: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    type: "bytes",
                    id: 2
                  }
                }
              },
              SourceContext: {
                fields: {
                  fileName: {
                    type: "string",
                    id: 1
                  }
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/@grpc/proto-loader/build/src/util.js
var require_util4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = undefined;
  var fs = __require("fs");
  var path = __require("path");
  var Protobuf = require_src16();
  function addIncludePathResolver(root, includePaths) {
    const originalResolvePath = root.resolvePath;
    root.resolvePath = (origin, target) => {
      if (path.isAbsolute(target)) {
        return target;
      }
      for (const directory of includePaths) {
        const fullPath = path.join(directory, target);
        try {
          fs.accessSync(fullPath, fs.constants.R_OK);
          return fullPath;
        } catch (err) {
          continue;
        }
      }
      process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
      return originalResolvePath(origin, target);
    };
  }
  async function loadProtosWithOptions(filename, options) {
    const root = new Protobuf.Root;
    options = options || {};
    if (!!options.includeDirs) {
      if (!Array.isArray(options.includeDirs)) {
        return Promise.reject(new Error("The includeDirs option must be an array"));
      }
      addIncludePathResolver(root, options.includeDirs);
    }
    const loadedRoot = await root.load(filename, options);
    loadedRoot.resolveAll();
    return loadedRoot;
  }
  exports.loadProtosWithOptions = loadProtosWithOptions;
  function loadProtosWithOptionsSync(filename, options) {
    const root = new Protobuf.Root;
    options = options || {};
    if (!!options.includeDirs) {
      if (!Array.isArray(options.includeDirs)) {
        throw new Error("The includeDirs option must be an array");
      }
      addIncludePathResolver(root, options.includeDirs);
    }
    const loadedRoot = root.loadSync(filename, options);
    loadedRoot.resolveAll();
    return loadedRoot;
  }
  exports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
  function addCommonProtos() {
    const apiDescriptor = require_api();
    const descriptorDescriptor = require_descriptor();
    const sourceContextDescriptor = require_source_context();
    const typeDescriptor = require_type3();
    Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
    Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
    Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
    Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
  }
  exports.addCommonProtos = addCommonProtos;
});

// node_modules/long/umd/index.js
var require_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    function preferDefault(exports2) {
      return exports2.default || exports2;
    }
    if (typeof define === "function" && define.amd) {
      define([], function() {
        var exports2 = {};
        factory(exports2);
        return preferDefault(exports2);
      });
    } else if (typeof exports === "object") {
      factory(exports);
      if (typeof module === "object")
        module.exports = preferDefault(exports);
    } else {
      (function() {
        var exports2 = {};
        factory(exports2);
        global2.Long = preferDefault(exports2);
      })();
    }
  })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports, function(_exports) {
    Object.defineProperty(_exports, "__esModule", {
      value: true
    });
    _exports.default = undefined;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch {
    }
    function Long(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", {
      value: true
    });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    function ctz32(value) {
      var c = Math.clz32(value & -value);
      return value ? 31 - c : c;
    }
    Long.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    Long.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (typeof unsigned === "number") {
        radix = unsigned;
        unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return unsigned ? UZERO : ZERO;
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0;i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    var ONE = fromInt(1);
    Long.ONE = ONE;
    var UONE = fromInt(1, true);
    Long.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31;bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isSafeInteger = function isSafeInteger() {
      var top11Bits = this.high >> 21;
      if (!top11Bits)
        return true;
      if (this.unsigned)
        return false;
      return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(other);
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(other) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(other) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return this;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero())
        return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    LongPrototype.clz = LongPrototype.countLeadingZeros;
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    LongPrototype.ctz = LongPrototype.countTrailingZeros;
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
      if (numBits === 32)
        return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
    };
    LongPrototype.rotl = LongPrototype.rotateLeft;
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
    };
    LongPrototype.rotr = LongPrototype.rotateRight;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    };
    if (typeof BigInt === "function") {
      Long.fromBigInt = function fromBigInt(value, unsigned) {
        var lowBits = Number(BigInt.asIntN(32, value));
        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
        return fromBits(lowBits, highBits, unsigned);
      };
      Long.fromValue = function fromValueWithBigInt(value, unsigned) {
        if (typeof value === "bigint")
          return Long.fromBigInt(value, unsigned);
        return fromValue(value, unsigned);
      };
      LongPrototype.toBigInt = function toBigInt() {
        var lowBigInt = BigInt(this.low >>> 0);
        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
        return highBigInt << BigInt(32) | lowBigInt;
      };
    }
    var _default = _exports.default = Long;
  });
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = undefined;
  var camelCase = require_lodash();
  var Protobuf = require_src16();
  var descriptor = require_descriptor2();
  var util_1 = require_util4();
  var Long = require_umd();
  exports.Long = Long;
  function isAnyExtension(obj) {
    return "@type" in obj && typeof obj["@type"] === "string";
  }
  exports.isAnyExtension = isAnyExtension;
  var IdempotencyLevel;
  (function(IdempotencyLevel2) {
    IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = "IDEMPOTENCY_UNKNOWN";
    IdempotencyLevel2["NO_SIDE_EFFECTS"] = "NO_SIDE_EFFECTS";
    IdempotencyLevel2["IDEMPOTENT"] = "IDEMPOTENT";
  })(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));
  var descriptorOptions = {
    longs: String,
    enums: String,
    bytes: String,
    defaults: true,
    oneofs: true,
    json: true
  };
  function joinName(baseName, name) {
    if (baseName === "") {
      return name;
    } else {
      return baseName + "." + name;
    }
  }
  function isHandledReflectionObject(obj) {
    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
  }
  function isNamespaceBase(obj) {
    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
  }
  function getAllHandledReflectionObjects(obj, parentName) {
    const objName = joinName(parentName, obj.name);
    if (isHandledReflectionObject(obj)) {
      return [[objName, obj]];
    } else {
      if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
        return Object.keys(obj.nested).map((name) => {
          return getAllHandledReflectionObjects(obj.nested[name], objName);
        }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
      }
    }
    return [];
  }
  function createDeserializer(cls, options) {
    return function deserialize(argBuf) {
      return cls.toObject(cls.decode(argBuf), options);
    };
  }
  function createSerializer(cls) {
    return function serialize(arg) {
      if (Array.isArray(arg)) {
        throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
      }
      const message = cls.fromObject(arg);
      return cls.encode(message).finish();
    };
  }
  function mapMethodOptions(options) {
    return (options || []).reduce((obj, item) => {
      for (const [key, value] of Object.entries(item)) {
        switch (key) {
          case "uninterpreted_option":
            obj.uninterpreted_option.push(item.uninterpreted_option);
            break;
          default:
            obj[key] = value;
        }
      }
      return obj;
    }, {
      deprecated: false,
      idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,
      uninterpreted_option: []
    });
  }
  function createMethodDefinition(method, serviceName, options, fileDescriptors) {
    const requestType = method.resolvedRequestType;
    const responseType = method.resolvedResponseType;
    return {
      path: "/" + serviceName + "/" + method.name,
      requestStream: !!method.requestStream,
      responseStream: !!method.responseStream,
      requestSerialize: createSerializer(requestType),
      requestDeserialize: createDeserializer(requestType, options),
      responseSerialize: createSerializer(responseType),
      responseDeserialize: createDeserializer(responseType, options),
      originalName: camelCase(method.name),
      requestType: createMessageDefinition(requestType, fileDescriptors),
      responseType: createMessageDefinition(responseType, fileDescriptors),
      options: mapMethodOptions(method.parsedOptions)
    };
  }
  function createServiceDefinition(service, name, options, fileDescriptors) {
    const def = {};
    for (const method of service.methodsArray) {
      def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
    }
    return def;
  }
  function createMessageDefinition(message, fileDescriptors) {
    const messageDescriptor = message.toDescriptor("proto3");
    return {
      format: "Protocol Buffer 3 DescriptorProto",
      type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
      fileDescriptorProtos: fileDescriptors
    };
  }
  function createEnumDefinition(enumType, fileDescriptors) {
    const enumDescriptor = enumType.toDescriptor("proto3");
    return {
      format: "Protocol Buffer 3 EnumDescriptorProto",
      type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
      fileDescriptorProtos: fileDescriptors
    };
  }
  function createDefinition(obj, name, options, fileDescriptors) {
    if (obj instanceof Protobuf.Service) {
      return createServiceDefinition(obj, name, options, fileDescriptors);
    } else if (obj instanceof Protobuf.Type) {
      return createMessageDefinition(obj, fileDescriptors);
    } else if (obj instanceof Protobuf.Enum) {
      return createEnumDefinition(obj, fileDescriptors);
    } else {
      throw new Error("Type mismatch in reflection object handling");
    }
  }
  function createPackageDefinition(root, options) {
    const def = {};
    root.resolveAll();
    const descriptorList = root.toDescriptor("proto3").file;
    const bufferList = descriptorList.map((value) => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
    for (const [name, obj] of getAllHandledReflectionObjects(root, "")) {
      def[name] = createDefinition(obj, name, options, bufferList);
    }
    return def;
  }
  function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
    options = options || {};
    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
    root.resolveAll();
    return createPackageDefinition(root, options);
  }
  function load(filename, options) {
    return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot) => {
      return createPackageDefinition(loadedRoot, options);
    });
  }
  exports.load = load;
  function loadSync(filename, options) {
    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
    return createPackageDefinition(loadedRoot, options);
  }
  exports.loadSync = loadSync;
  function fromJSON(json, options) {
    options = options || {};
    const loadedRoot = Protobuf.Root.fromJSON(json);
    loadedRoot.resolveAll();
    return createPackageDefinition(loadedRoot, options);
  }
  exports.fromJSON = fromJSON;
  function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
  }
  exports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
  function loadFileDescriptorSetFromObject(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
  }
  exports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
  (0, util_1.addCommonProtos)();
});

// node_modules/@grpc/grpc-js/build/src/channelz.js
var require_channelz = __commonJS((exports) => {
  var __dirname = "/src/node_modules/@grpc/grpc-js/build/src";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTrackerStub = exports.ChannelzCallTracker = exports.ChannelzChildrenTrackerStub = exports.ChannelzChildrenTracker = exports.ChannelzTrace = exports.ChannelzTraceStub = undefined;
  exports.unregisterChannelzRef = unregisterChannelzRef;
  exports.getChannelzHandlers = getChannelzHandlers;
  exports.getChannelzServiceDefinition = getChannelzServiceDefinition;
  exports.setup = setup;
  var net_1 = __require("net");
  var ordered_map_1 = require_cjs();
  var connectivity_state_1 = require_connectivity_state();
  var constants_1 = require_constants2();
  var subchannel_address_1 = require_subchannel_address();
  var admin_1 = require_admin();
  var make_client_1 = require_make_client();
  function channelRefToMessage(ref) {
    return {
      channel_id: ref.id,
      name: ref.name
    };
  }
  function subchannelRefToMessage(ref) {
    return {
      subchannel_id: ref.id,
      name: ref.name
    };
  }
  function serverRefToMessage(ref) {
    return {
      server_id: ref.id
    };
  }
  function socketRefToMessage(ref) {
    return {
      socket_id: ref.id,
      name: ref.name
    };
  }
  var TARGET_RETAINED_TRACES = 32;
  var DEFAULT_MAX_RESULTS = 100;

  class ChannelzTraceStub {
    constructor() {
      this.events = [];
      this.creationTimestamp = new Date;
      this.eventsLogged = 0;
    }
    addTrace() {
    }
    getTraceMessage() {
      return {
        creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
        num_events_logged: this.eventsLogged,
        events: []
      };
    }
  }
  exports.ChannelzTraceStub = ChannelzTraceStub;

  class ChannelzTrace {
    constructor() {
      this.events = [];
      this.eventsLogged = 0;
      this.creationTimestamp = new Date;
    }
    addTrace(severity, description, child) {
      const timestamp = new Date;
      this.events.push({
        description,
        severity,
        timestamp,
        childChannel: (child === null || child === undefined ? undefined : child.kind) === "channel" ? child : undefined,
        childSubchannel: (child === null || child === undefined ? undefined : child.kind) === "subchannel" ? child : undefined
      });
      if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
        this.events = this.events.slice(TARGET_RETAINED_TRACES);
      }
      this.eventsLogged += 1;
    }
    getTraceMessage() {
      return {
        creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
        num_events_logged: this.eventsLogged,
        events: this.events.map((event) => {
          return {
            description: event.description,
            severity: event.severity,
            timestamp: dateToProtoTimestamp(event.timestamp),
            channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,
            subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null
          };
        })
      };
    }
  }
  exports.ChannelzTrace = ChannelzTrace;

  class ChannelzChildrenTracker {
    constructor() {
      this.channelChildren = new ordered_map_1.OrderedMap;
      this.subchannelChildren = new ordered_map_1.OrderedMap;
      this.socketChildren = new ordered_map_1.OrderedMap;
      this.trackerMap = {
        ["channel"]: this.channelChildren,
        ["subchannel"]: this.subchannelChildren,
        ["socket"]: this.socketChildren
      };
    }
    refChild(child) {
      const tracker = this.trackerMap[child.kind];
      const trackedChild = tracker.find(child.id);
      if (trackedChild.equals(tracker.end())) {
        tracker.setElement(child.id, {
          ref: child,
          count: 1
        }, trackedChild);
      } else {
        trackedChild.pointer[1].count += 1;
      }
    }
    unrefChild(child) {
      const tracker = this.trackerMap[child.kind];
      const trackedChild = tracker.getElementByKey(child.id);
      if (trackedChild !== undefined) {
        trackedChild.count -= 1;
        if (trackedChild.count === 0) {
          tracker.eraseElementByKey(child.id);
        }
      }
    }
    getChildLists() {
      return {
        channels: this.channelChildren,
        subchannels: this.subchannelChildren,
        sockets: this.socketChildren
      };
    }
  }
  exports.ChannelzChildrenTracker = ChannelzChildrenTracker;

  class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
    refChild() {
    }
    unrefChild() {
    }
  }
  exports.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;

  class ChannelzCallTracker {
    constructor() {
      this.callsStarted = 0;
      this.callsSucceeded = 0;
      this.callsFailed = 0;
      this.lastCallStartedTimestamp = null;
    }
    addCallStarted() {
      this.callsStarted += 1;
      this.lastCallStartedTimestamp = new Date;
    }
    addCallSucceeded() {
      this.callsSucceeded += 1;
    }
    addCallFailed() {
      this.callsFailed += 1;
    }
  }
  exports.ChannelzCallTracker = ChannelzCallTracker;

  class ChannelzCallTrackerStub extends ChannelzCallTracker {
    addCallStarted() {
    }
    addCallSucceeded() {
    }
    addCallFailed() {
    }
  }
  exports.ChannelzCallTrackerStub = ChannelzCallTrackerStub;
  var entityMaps = {
    ["channel"]: new ordered_map_1.OrderedMap,
    ["subchannel"]: new ordered_map_1.OrderedMap,
    ["server"]: new ordered_map_1.OrderedMap,
    ["socket"]: new ordered_map_1.OrderedMap
  };
  var generateRegisterFn = (kind2) => {
    let nextId = 1;
    function getNextId() {
      return nextId++;
    }
    const entityMap = entityMaps[kind2];
    return (name, getInfo, channelzEnabled) => {
      const id = getNextId();
      const ref = { id, name, kind: kind2 };
      if (channelzEnabled) {
        entityMap.setElement(id, { ref, getInfo });
      }
      return ref;
    };
  };
  exports.registerChannelzChannel = generateRegisterFn("channel");
  exports.registerChannelzSubchannel = generateRegisterFn("subchannel");
  exports.registerChannelzServer = generateRegisterFn("server");
  exports.registerChannelzSocket = generateRegisterFn("socket");
  function unregisterChannelzRef(ref) {
    entityMaps[ref.kind].eraseElementByKey(ref.id);
  }
  function parseIPv6Section(addressSection) {
    const numberValue = Number.parseInt(addressSection, 16);
    return [numberValue / 256 | 0, numberValue % 256];
  }
  function parseIPv6Chunk(addressChunk) {
    if (addressChunk === "") {
      return [];
    }
    const bytePairs = addressChunk.split(":").map((section) => parseIPv6Section(section));
    const result = [];
    return result.concat(...bytePairs);
  }
  function isIPv6MappedIPv4(ipAddress) {
    return (0, net_1.isIPv6)(ipAddress) && ipAddress.toLowerCase().startsWith("::ffff:") && (0, net_1.isIPv4)(ipAddress.substring(7));
  }
  function ipv4AddressStringToBuffer(ipAddress) {
    return Buffer.from(Uint8Array.from(ipAddress.split(".").map((segment) => Number.parseInt(segment))));
  }
  function ipAddressStringToBuffer(ipAddress) {
    if ((0, net_1.isIPv4)(ipAddress)) {
      return ipv4AddressStringToBuffer(ipAddress);
    } else if (isIPv6MappedIPv4(ipAddress)) {
      return ipv4AddressStringToBuffer(ipAddress.substring(7));
    } else if ((0, net_1.isIPv6)(ipAddress)) {
      let leftSection;
      let rightSection;
      const doubleColonIndex = ipAddress.indexOf("::");
      if (doubleColonIndex === -1) {
        leftSection = ipAddress;
        rightSection = "";
      } else {
        leftSection = ipAddress.substring(0, doubleColonIndex);
        rightSection = ipAddress.substring(doubleColonIndex + 2);
      }
      const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
      const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
      const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
      return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
    } else {
      return null;
    }
  }
  function connectivityStateToMessage(state) {
    switch (state) {
      case connectivity_state_1.ConnectivityState.CONNECTING:
        return {
          state: "CONNECTING"
        };
      case connectivity_state_1.ConnectivityState.IDLE:
        return {
          state: "IDLE"
        };
      case connectivity_state_1.ConnectivityState.READY:
        return {
          state: "READY"
        };
      case connectivity_state_1.ConnectivityState.SHUTDOWN:
        return {
          state: "SHUTDOWN"
        };
      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
        return {
          state: "TRANSIENT_FAILURE"
        };
      default:
        return {
          state: "UNKNOWN"
        };
    }
  }
  function dateToProtoTimestamp(date) {
    if (!date) {
      return null;
    }
    const millisSinceEpoch = date.getTime();
    return {
      seconds: millisSinceEpoch / 1000 | 0,
      nanos: millisSinceEpoch % 1000 * 1e6
    };
  }
  function getChannelMessage(channelEntry) {
    const resolvedInfo = channelEntry.getInfo();
    const channelRef = [];
    const subchannelRef = [];
    resolvedInfo.children.channels.forEach((el) => {
      channelRef.push(channelRefToMessage(el[1].ref));
    });
    resolvedInfo.children.subchannels.forEach((el) => {
      subchannelRef.push(subchannelRefToMessage(el[1].ref));
    });
    return {
      ref: channelRefToMessage(channelEntry.ref),
      data: {
        target: resolvedInfo.target,
        state: connectivityStateToMessage(resolvedInfo.state),
        calls_started: resolvedInfo.callTracker.callsStarted,
        calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
        calls_failed: resolvedInfo.callTracker.callsFailed,
        last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
        trace: resolvedInfo.trace.getTraceMessage()
      },
      channel_ref: channelRef,
      subchannel_ref: subchannelRef
    };
  }
  function GetChannel(call, callback) {
    const channelId = parseInt(call.request.channel_id, 10);
    const channelEntry = entityMaps["channel"].getElementByKey(channelId);
    if (channelEntry === undefined) {
      callback({
        code: constants_1.Status.NOT_FOUND,
        details: "No channel data found for id " + channelId
      });
      return;
    }
    callback(null, { channel: getChannelMessage(channelEntry) });
  }
  function GetTopChannels(call, callback) {
    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
    const resultList = [];
    const startId = parseInt(call.request.start_channel_id, 10);
    const channelEntries = entityMaps["channel"];
    let i;
    for (i = channelEntries.lowerBound(startId);!i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {
      resultList.push(getChannelMessage(i.pointer[1]));
    }
    callback(null, {
      channel: resultList,
      end: i.equals(channelEntries.end())
    });
  }
  function getServerMessage(serverEntry) {
    const resolvedInfo = serverEntry.getInfo();
    const listenSocket = [];
    resolvedInfo.listenerChildren.sockets.forEach((el) => {
      listenSocket.push(socketRefToMessage(el[1].ref));
    });
    return {
      ref: serverRefToMessage(serverEntry.ref),
      data: {
        calls_started: resolvedInfo.callTracker.callsStarted,
        calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
        calls_failed: resolvedInfo.callTracker.callsFailed,
        last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
        trace: resolvedInfo.trace.getTraceMessage()
      },
      listen_socket: listenSocket
    };
  }
  function GetServer(call, callback) {
    const serverId = parseInt(call.request.server_id, 10);
    const serverEntries = entityMaps["server"];
    const serverEntry = serverEntries.getElementByKey(serverId);
    if (serverEntry === undefined) {
      callback({
        code: constants_1.Status.NOT_FOUND,
        details: "No server data found for id " + serverId
      });
      return;
    }
    callback(null, { server: getServerMessage(serverEntry) });
  }
  function GetServers(call, callback) {
    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
    const startId = parseInt(call.request.start_server_id, 10);
    const serverEntries = entityMaps["server"];
    const resultList = [];
    let i;
    for (i = serverEntries.lowerBound(startId);!i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {
      resultList.push(getServerMessage(i.pointer[1]));
    }
    callback(null, {
      server: resultList,
      end: i.equals(serverEntries.end())
    });
  }
  function GetSubchannel(call, callback) {
    const subchannelId = parseInt(call.request.subchannel_id, 10);
    const subchannelEntry = entityMaps["subchannel"].getElementByKey(subchannelId);
    if (subchannelEntry === undefined) {
      callback({
        code: constants_1.Status.NOT_FOUND,
        details: "No subchannel data found for id " + subchannelId
      });
      return;
    }
    const resolvedInfo = subchannelEntry.getInfo();
    const listenSocket = [];
    resolvedInfo.children.sockets.forEach((el) => {
      listenSocket.push(socketRefToMessage(el[1].ref));
    });
    const subchannelMessage = {
      ref: subchannelRefToMessage(subchannelEntry.ref),
      data: {
        target: resolvedInfo.target,
        state: connectivityStateToMessage(resolvedInfo.state),
        calls_started: resolvedInfo.callTracker.callsStarted,
        calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
        calls_failed: resolvedInfo.callTracker.callsFailed,
        last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
        trace: resolvedInfo.trace.getTraceMessage()
      },
      socket_ref: listenSocket
    };
    callback(null, { subchannel: subchannelMessage });
  }
  function subchannelAddressToAddressMessage(subchannelAddress) {
    var _a;
    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
      return {
        address: "tcpip_address",
        tcpip_address: {
          ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== undefined ? _a : undefined,
          port: subchannelAddress.port
        }
      };
    } else {
      return {
        address: "uds_address",
        uds_address: {
          filename: subchannelAddress.path
        }
      };
    }
  }
  function GetSocket(call, callback) {
    var _a, _b, _c, _d, _e;
    const socketId = parseInt(call.request.socket_id, 10);
    const socketEntry = entityMaps["socket"].getElementByKey(socketId);
    if (socketEntry === undefined) {
      callback({
        code: constants_1.Status.NOT_FOUND,
        details: "No socket data found for id " + socketId
      });
      return;
    }
    const resolvedInfo = socketEntry.getInfo();
    const securityMessage = resolvedInfo.security ? {
      model: "tls",
      tls: {
        cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? "standard_name" : "other_name",
        standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== undefined ? _a : undefined,
        other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== undefined ? _b : undefined,
        local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== undefined ? _c : undefined,
        remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== undefined ? _d : undefined
      }
    } : null;
    const socketMessage = {
      ref: socketRefToMessage(socketEntry.ref),
      local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,
      remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,
      remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== undefined ? _e : undefined,
      security: securityMessage,
      data: {
        keep_alives_sent: resolvedInfo.keepAlivesSent,
        streams_started: resolvedInfo.streamsStarted,
        streams_succeeded: resolvedInfo.streamsSucceeded,
        streams_failed: resolvedInfo.streamsFailed,
        last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
        last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
        messages_received: resolvedInfo.messagesReceived,
        messages_sent: resolvedInfo.messagesSent,
        last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
        last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
        local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,
        remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null
      }
    };
    callback(null, { socket: socketMessage });
  }
  function GetServerSockets(call, callback) {
    const serverId = parseInt(call.request.server_id, 10);
    const serverEntry = entityMaps["server"].getElementByKey(serverId);
    if (serverEntry === undefined) {
      callback({
        code: constants_1.Status.NOT_FOUND,
        details: "No server data found for id " + serverId
      });
      return;
    }
    const startId = parseInt(call.request.start_socket_id, 10);
    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
    const resolvedInfo = serverEntry.getInfo();
    const allSockets = resolvedInfo.sessionChildren.sockets;
    const resultList = [];
    let i;
    for (i = allSockets.lowerBound(startId);!i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {
      resultList.push(socketRefToMessage(i.pointer[1].ref));
    }
    callback(null, {
      socket_ref: resultList,
      end: i.equals(allSockets.end())
    });
  }
  function getChannelzHandlers() {
    return {
      GetChannel,
      GetTopChannels,
      GetServer,
      GetServers,
      GetSubchannel,
      GetSocket,
      GetServerSockets
    };
  }
  var loadedChannelzDefinition = null;
  function getChannelzServiceDefinition() {
    if (loadedChannelzDefinition) {
      return loadedChannelzDefinition;
    }
    const loaderLoadSync = require_src17().loadSync;
    const loadedProto = loaderLoadSync("channelz.proto", {
      keepCase: true,
      longs: String,
      enums: String,
      defaults: true,
      oneofs: true,
      includeDirs: [`${__dirname}/../../proto`]
    });
    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;
    return loadedChannelzDefinition;
  }
  function setup() {
    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Subchannel = undefined;
  var connectivity_state_1 = require_connectivity_state();
  var backoff_timeout_1 = require_backoff_timeout();
  var logging = require_logging();
  var constants_1 = require_constants2();
  var uri_parser_1 = require_uri_parser();
  var subchannel_address_1 = require_subchannel_address();
  var channelz_1 = require_channelz();
  var TRACER_NAME = "subchannel";
  var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);

  class Subchannel {
    constructor(channelTarget, subchannelAddress, options, credentials, connector) {
      var _a;
      this.channelTarget = channelTarget;
      this.subchannelAddress = subchannelAddress;
      this.options = options;
      this.connector = connector;
      this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
      this.transport = null;
      this.continueConnecting = false;
      this.stateListeners = new Set;
      this.refcount = 0;
      this.channelzEnabled = true;
      const backoffOptions = {
        initialDelay: options["grpc.initial_reconnect_backoff_ms"],
        maxDelay: options["grpc.max_reconnect_backoff_ms"]
      };
      this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
        this.handleBackoffTimer();
      }, backoffOptions);
      this.backoffTimeout.unref();
      this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
      this.keepaliveTime = (_a = options["grpc.keepalive_time_ms"]) !== null && _a !== undefined ? _a : -1;
      if (options["grpc.enable_channelz"] === 0) {
        this.channelzEnabled = false;
        this.channelzTrace = new channelz_1.ChannelzTraceStub;
        this.callTracker = new channelz_1.ChannelzCallTrackerStub;
        this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub;
        this.streamTracker = new channelz_1.ChannelzCallTrackerStub;
      } else {
        this.channelzTrace = new channelz_1.ChannelzTrace;
        this.callTracker = new channelz_1.ChannelzCallTracker;
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker;
        this.streamTracker = new channelz_1.ChannelzCallTracker;
      }
      this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
      this.channelzTrace.addTrace("CT_INFO", "Subchannel created");
      this.trace("Subchannel constructed with options " + JSON.stringify(options, undefined, 2));
      this.secureConnector = credentials._createSecureConnector(channelTarget, options);
    }
    getChannelzInfo() {
      return {
        state: this.connectivityState,
        trace: this.channelzTrace,
        callTracker: this.callTracker,
        children: this.childrenTracker.getChildLists(),
        target: this.subchannelAddressString
      };
    }
    trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
    }
    refTrace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
    }
    handleBackoffTimer() {
      if (this.continueConnecting) {
        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
      } else {
        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
      }
    }
    startBackoff() {
      this.backoffTimeout.runOnce();
    }
    stopBackoff() {
      this.backoffTimeout.stop();
      this.backoffTimeout.reset();
    }
    startConnectingInternal() {
      let options = this.options;
      if (options["grpc.keepalive_time_ms"]) {
        const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);
        options = Object.assign(Object.assign({}, options), { "grpc.keepalive_time_ms": adjustedKeepaliveTime });
      }
      this.connector.connect(this.subchannelAddress, this.secureConnector, options).then((transport) => {
        if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {
          this.transport = transport;
          if (this.channelzEnabled) {
            this.childrenTracker.refChild(transport.getChannelzRef());
          }
          transport.addDisconnectListener((tooManyPings) => {
            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
            if (tooManyPings && this.keepaliveTime > 0) {
              this.keepaliveTime *= 2;
              logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);
            }
          });
        } else {
          transport.shutdown();
        }
      }, (error) => {
        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);
      });
    }
    transitionToState(oldStates, newState, errorMessage) {
      var _a, _b;
      if (oldStates.indexOf(this.connectivityState) === -1) {
        return false;
      }
      if (errorMessage) {
        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState] + ' with error "' + errorMessage + '"');
      } else {
        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
      }
      if (this.channelzEnabled) {
        this.channelzTrace.addTrace("CT_INFO", "Connectivity state change to " + connectivity_state_1.ConnectivityState[newState]);
      }
      const previousState = this.connectivityState;
      this.connectivityState = newState;
      switch (newState) {
        case connectivity_state_1.ConnectivityState.READY:
          this.stopBackoff();
          break;
        case connectivity_state_1.ConnectivityState.CONNECTING:
          this.startBackoff();
          this.startConnectingInternal();
          this.continueConnecting = false;
          break;
        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
          if (this.channelzEnabled && this.transport) {
            this.childrenTracker.unrefChild(this.transport.getChannelzRef());
          }
          (_a = this.transport) === null || _a === undefined || _a.shutdown();
          this.transport = null;
          if (!this.backoffTimeout.isRunning()) {
            process.nextTick(() => {
              this.handleBackoffTimer();
            });
          }
          break;
        case connectivity_state_1.ConnectivityState.IDLE:
          if (this.channelzEnabled && this.transport) {
            this.childrenTracker.unrefChild(this.transport.getChannelzRef());
          }
          (_b = this.transport) === null || _b === undefined || _b.shutdown();
          this.transport = null;
          break;
        default:
          throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
      }
      for (const listener of this.stateListeners) {
        listener(this, previousState, newState, this.keepaliveTime, errorMessage);
      }
      return true;
    }
    ref() {
      this.refTrace("refcount " + this.refcount + " -> " + (this.refcount + 1));
      this.refcount += 1;
    }
    unref() {
      this.refTrace("refcount " + this.refcount + " -> " + (this.refcount - 1));
      this.refcount -= 1;
      if (this.refcount === 0) {
        this.channelzTrace.addTrace("CT_INFO", "Shutting down");
        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
        this.secureConnector.destroy();
        process.nextTick(() => {
          this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
        });
      }
    }
    unrefIfOneRef() {
      if (this.refcount === 1) {
        this.unref();
        return true;
      }
      return false;
    }
    createCall(metadata, host, method, listener) {
      if (!this.transport) {
        throw new Error("Cannot create call, subchannel not READY");
      }
      let statsTracker;
      if (this.channelzEnabled) {
        this.callTracker.addCallStarted();
        this.streamTracker.addCallStarted();
        statsTracker = {
          onCallEnd: (status) => {
            if (status.code === constants_1.Status.OK) {
              this.callTracker.addCallSucceeded();
            } else {
              this.callTracker.addCallFailed();
            }
          }
        };
      } else {
        statsTracker = {};
      }
      return this.transport.createCall(metadata, host, method, listener, statsTracker);
    }
    startConnecting() {
      process.nextTick(() => {
        if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
          if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.continueConnecting = true;
          }
        }
      });
    }
    getConnectivityState() {
      return this.connectivityState;
    }
    addConnectivityStateListener(listener) {
      this.stateListeners.add(listener);
    }
    removeConnectivityStateListener(listener) {
      this.stateListeners.delete(listener);
    }
    resetBackoff() {
      process.nextTick(() => {
        this.backoffTimeout.reset();
        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
      });
    }
    getAddress() {
      return this.subchannelAddressString;
    }
    getChannelzRef() {
      return this.channelzRef;
    }
    isHealthy() {
      return true;
    }
    addHealthStateWatcher(listener) {
    }
    removeHealthStateWatcher(listener) {
    }
    getRealSubchannel() {
      return this;
    }
    realSubchannelEquals(other) {
      return other.getRealSubchannel() === this;
    }
    throttleKeepalive(newKeepaliveTime) {
      if (newKeepaliveTime > this.keepaliveTime) {
        this.keepaliveTime = newKeepaliveTime;
      }
    }
    getCallCredentials() {
      return this.secureConnector.getCallCredentials();
    }
  }
  exports.Subchannel = Subchannel;
});

// node_modules/@grpc/grpc-js/build/src/environment.js
var require_environment2 = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = undefined;
  exports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a !== undefined ? _a : "false") === "true";
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_PORT = undefined;
  exports.setup = setup;
  var resolver_1 = require_resolver();
  var dns_1 = __require("dns");
  var service_config_1 = require_service_config();
  var constants_1 = require_constants2();
  var metadata_1 = require_metadata();
  var logging = require_logging();
  var constants_2 = require_constants2();
  var uri_parser_1 = require_uri_parser();
  var net_1 = __require("net");
  var backoff_timeout_1 = require_backoff_timeout();
  var environment_1 = require_environment2();
  var TRACER_NAME = "dns_resolver";
  function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  exports.DEFAULT_PORT = 443;
  var DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;

  class DnsResolver {
    constructor(target, listener, channelOptions) {
      var _a, _b, _c;
      this.target = target;
      this.listener = listener;
      this.pendingLookupPromise = null;
      this.pendingTxtPromise = null;
      this.latestLookupResult = null;
      this.latestServiceConfig = null;
      this.latestServiceConfigError = null;
      this.continueResolving = false;
      this.isNextResolutionTimerRunning = false;
      this.isServiceConfigEnabled = true;
      this.returnedIpResult = false;
      this.alternativeResolver = new dns_1.promises.Resolver;
      trace("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
      if (target.authority) {
        this.alternativeResolver.setServers([target.authority]);
      }
      const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
      if (hostPort === null) {
        this.ipResult = null;
        this.dnsHostname = null;
        this.port = null;
      } else {
        if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
          this.ipResult = [
            {
              addresses: [
                {
                  host: hostPort.host,
                  port: (_a = hostPort.port) !== null && _a !== undefined ? _a : exports.DEFAULT_PORT
                }
              ]
            }
          ];
          this.dnsHostname = null;
          this.port = null;
        } else {
          this.ipResult = null;
          this.dnsHostname = hostPort.host;
          this.port = (_b = hostPort.port) !== null && _b !== undefined ? _b : exports.DEFAULT_PORT;
        }
      }
      this.percentage = Math.random() * 100;
      if (channelOptions["grpc.service_config_disable_resolution"] === 1) {
        this.isServiceConfigEnabled = false;
      }
      this.defaultResolutionError = {
        code: constants_1.Status.UNAVAILABLE,
        details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
        metadata: new metadata_1.Metadata
      };
      const backoffOptions = {
        initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
        maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
      };
      this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
        if (this.continueResolving) {
          this.startResolutionWithBackoff();
        }
      }, backoffOptions);
      this.backoff.unref();
      this.minTimeBetweenResolutionsMs = (_c = channelOptions["grpc.dns_min_time_between_resolutions_ms"]) !== null && _c !== undefined ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
      this.nextResolutionTimer = setTimeout(() => {
      }, 0);
      clearTimeout(this.nextResolutionTimer);
    }
    startResolution() {
      if (this.ipResult !== null) {
        if (!this.returnedIpResult) {
          trace("Returning IP address for target " + (0, uri_parser_1.uriToString)(this.target));
          setImmediate(() => {
            this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
          });
          this.returnedIpResult = true;
        }
        this.backoff.stop();
        this.backoff.reset();
        this.stopNextResolutionTimer();
        return;
      }
      if (this.dnsHostname === null) {
        trace("Failed to parse DNS address " + (0, uri_parser_1.uriToString)(this.target));
        setImmediate(() => {
          this.listener.onError({
            code: constants_1.Status.UNAVAILABLE,
            details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
            metadata: new metadata_1.Metadata
          });
        });
        this.stopNextResolutionTimer();
      } else {
        if (this.pendingLookupPromise !== null) {
          return;
        }
        trace("Looking up DNS hostname " + this.dnsHostname);
        this.latestLookupResult = null;
        const hostname = this.dnsHostname;
        this.pendingLookupPromise = this.lookup(hostname);
        this.pendingLookupPromise.then((addressList) => {
          if (this.pendingLookupPromise === null) {
            return;
          }
          this.pendingLookupPromise = null;
          this.backoff.reset();
          this.backoff.stop();
          this.latestLookupResult = addressList.map((address) => ({
            addresses: [address]
          }));
          const allAddressesString = "[" + addressList.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
          trace("Resolved addresses for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + allAddressesString);
          if (this.latestLookupResult.length === 0) {
            this.listener.onError(this.defaultResolutionError);
            return;
          }
          this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
        }, (err) => {
          if (this.pendingLookupPromise === null) {
            return;
          }
          trace("Resolution error for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + err.message);
          this.pendingLookupPromise = null;
          this.stopNextResolutionTimer();
          this.listener.onError(this.defaultResolutionError);
        });
        if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
          this.pendingTxtPromise = this.resolveTxt(hostname);
          this.pendingTxtPromise.then((txtRecord) => {
            if (this.pendingTxtPromise === null) {
              return;
            }
            this.pendingTxtPromise = null;
            try {
              this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
            } catch (err) {
              this.latestServiceConfigError = {
                code: constants_1.Status.UNAVAILABLE,
                details: `Parsing service config failed with error ${err.message}`,
                metadata: new metadata_1.Metadata
              };
            }
            if (this.latestLookupResult !== null) {
              this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
            }
          }, (err) => {
          });
        }
      }
    }
    async lookup(hostname) {
      if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
        trace("Using alternative DNS resolver.");
        const records = await Promise.allSettled([
          this.alternativeResolver.resolve4(hostname),
          this.alternativeResolver.resolve6(hostname)
        ]);
        if (records.every((result) => result.status === "rejected")) {
          throw new Error(records[0].reason);
        }
        return records.reduce((acc, result) => {
          return result.status === "fulfilled" ? [...acc, ...result.value] : acc;
        }, []).map((addr) => ({
          host: addr,
          port: +this.port
        }));
      }
      const addressList = await dns_1.promises.lookup(hostname, { all: true });
      return addressList.map((addr) => ({ host: addr.address, port: +this.port }));
    }
    async resolveTxt(hostname) {
      if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
        trace("Using alternative DNS resolver.");
        return this.alternativeResolver.resolveTxt(hostname);
      }
      return dns_1.promises.resolveTxt(hostname);
    }
    startNextResolutionTimer() {
      var _a, _b;
      clearTimeout(this.nextResolutionTimer);
      this.nextResolutionTimer = setTimeout(() => {
        this.stopNextResolutionTimer();
        if (this.continueResolving) {
          this.startResolutionWithBackoff();
        }
      }, this.minTimeBetweenResolutionsMs);
      (_b = (_a = this.nextResolutionTimer).unref) === null || _b === undefined || _b.call(_a);
      this.isNextResolutionTimerRunning = true;
    }
    stopNextResolutionTimer() {
      clearTimeout(this.nextResolutionTimer);
      this.isNextResolutionTimerRunning = false;
    }
    startResolutionWithBackoff() {
      if (this.pendingLookupPromise === null) {
        this.continueResolving = false;
        this.backoff.runOnce();
        this.startNextResolutionTimer();
        this.startResolution();
      }
    }
    updateResolution() {
      if (this.pendingLookupPromise === null) {
        if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
          if (this.isNextResolutionTimerRunning) {
            trace('resolution update delayed by "min time between resolutions" rate limit');
          } else {
            trace("resolution update delayed by backoff timer until " + this.backoff.getEndTime().toISOString());
          }
          this.continueResolving = true;
        } else {
          this.startResolutionWithBackoff();
        }
      }
    }
    destroy() {
      this.continueResolving = false;
      this.backoff.reset();
      this.backoff.stop();
      this.stopNextResolutionTimer();
      this.pendingLookupPromise = null;
      this.pendingTxtPromise = null;
      this.latestLookupResult = null;
      this.latestServiceConfig = null;
      this.latestServiceConfigError = null;
      this.returnedIpResult = false;
    }
    static getDefaultAuthority(target) {
      return target.path;
    }
  }
  function setup() {
    (0, resolver_1.registerResolver)("dns", DnsResolver);
    (0, resolver_1.registerDefaultScheme)("dns");
  }
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCIDR = parseCIDR;
  exports.mapProxyName = mapProxyName;
  exports.getProxiedConnection = getProxiedConnection;
  var logging_1 = require_logging();
  var constants_1 = require_constants2();
  var net_1 = __require("net");
  var http = __require("http");
  var logging = require_logging();
  var subchannel_address_1 = require_subchannel_address();
  var uri_parser_1 = require_uri_parser();
  var url_1 = __require("url");
  var resolver_dns_1 = require_resolver_dns();
  var TRACER_NAME = "proxy";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  function getProxyInfo() {
    let proxyEnv = "";
    let envVar = "";
    if (process.env.grpc_proxy) {
      envVar = "grpc_proxy";
      proxyEnv = process.env.grpc_proxy;
    } else if (process.env.https_proxy) {
      envVar = "https_proxy";
      proxyEnv = process.env.https_proxy;
    } else if (process.env.http_proxy) {
      envVar = "http_proxy";
      proxyEnv = process.env.http_proxy;
    } else {
      return {};
    }
    let proxyUrl;
    try {
      proxyUrl = new url_1.URL(proxyEnv);
    } catch (e) {
      (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
      return {};
    }
    if (proxyUrl.protocol !== "http:") {
      (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
      return {};
    }
    let userCred = null;
    if (proxyUrl.username) {
      if (proxyUrl.password) {
        (0, logging_1.log)(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
        userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);
      } else {
        userCred = proxyUrl.username;
      }
    }
    const hostname = proxyUrl.hostname;
    let port = proxyUrl.port;
    if (port === "") {
      port = "80";
    }
    const result = {
      address: `${hostname}:${port}`
    };
    if (userCred) {
      result.creds = userCred;
    }
    trace("Proxy server " + result.address + " set by environment variable " + envVar);
    return result;
  }
  function getNoProxyHostList() {
    let noProxyStr = process.env.no_grpc_proxy;
    let envVar = "no_grpc_proxy";
    if (!noProxyStr) {
      noProxyStr = process.env.no_proxy;
      envVar = "no_proxy";
    }
    if (noProxyStr) {
      trace("No proxy server list set by environment variable " + envVar);
      return noProxyStr.split(",");
    } else {
      return [];
    }
  }
  function parseCIDR(cidrString) {
    const splitRange = cidrString.split("/");
    if (splitRange.length !== 2) {
      return null;
    }
    const prefixLength = parseInt(splitRange[1], 10);
    if (!(0, net_1.isIPv4)(splitRange[0]) || Number.isNaN(prefixLength) || prefixLength < 0 || prefixLength > 32) {
      return null;
    }
    return {
      ip: ipToInt(splitRange[0]),
      prefixLength
    };
  }
  function ipToInt(ip) {
    return ip.split(".").reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0);
  }
  function isIpInCIDR(cidr, serverHost) {
    const ip = cidr.ip;
    const mask = -1 << 32 - cidr.prefixLength;
    const hostIP = ipToInt(serverHost);
    return (hostIP & mask) === (ip & mask);
  }
  function hostMatchesNoProxyList(serverHost) {
    for (const host of getNoProxyHostList()) {
      const parsedCIDR = parseCIDR(host);
      if ((0, net_1.isIPv4)(serverHost) && parsedCIDR && isIpInCIDR(parsedCIDR, serverHost)) {
        return true;
      } else if (serverHost.endsWith(host)) {
        return true;
      }
    }
    return false;
  }
  function mapProxyName(target, options) {
    var _a;
    const noProxyResult = {
      target,
      extraOptions: {}
    };
    if (((_a = options["grpc.enable_http_proxy"]) !== null && _a !== undefined ? _a : 1) === 0) {
      return noProxyResult;
    }
    if (target.scheme === "unix") {
      return noProxyResult;
    }
    const proxyInfo = getProxyInfo();
    if (!proxyInfo.address) {
      return noProxyResult;
    }
    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
    if (!hostPort) {
      return noProxyResult;
    }
    const serverHost = hostPort.host;
    if (hostMatchesNoProxyList(serverHost)) {
      trace("Not using proxy for target in no_proxy list: " + (0, uri_parser_1.uriToString)(target));
      return noProxyResult;
    }
    const extraOptions = {
      "grpc.http_connect_target": (0, uri_parser_1.uriToString)(target)
    };
    if (proxyInfo.creds) {
      extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
    }
    return {
      target: {
        scheme: "dns",
        path: proxyInfo.address
      },
      extraOptions
    };
  }
  function getProxiedConnection(address, channelOptions) {
    var _a;
    if (!("grpc.http_connect_target" in channelOptions)) {
      return Promise.resolve(null);
    }
    const realTarget = channelOptions["grpc.http_connect_target"];
    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);
    if (parsedTarget === null) {
      return Promise.resolve(null);
    }
    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);
    if (splitHostPost === null) {
      return Promise.resolve(null);
    }
    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== undefined ? _a : resolver_dns_1.DEFAULT_PORT}`;
    const options = {
      method: "CONNECT",
      path: hostPort
    };
    const headers = {
      Host: hostPort
    };
    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
      options.host = address.host;
      options.port = address.port;
    } else {
      options.socketPath = address.path;
    }
    if ("grpc.http_connect_creds" in channelOptions) {
      headers["Proxy-Authorization"] = "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64");
    }
    options.headers = headers;
    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);
    trace("Using proxy " + proxyAddressString + " to connect to " + options.path);
    return new Promise((resolve, reject) => {
      const request2 = http.request(options);
      request2.once("connect", (res, socket, head) => {
        request2.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode === 200) {
          trace("Successfully connected to " + options.path + " through proxy " + proxyAddressString);
          if (head.length > 0) {
            socket.unshift(head);
          }
          trace("Successfully established a plaintext connection to " + options.path + " through proxy " + proxyAddressString);
          resolve(socket);
        } else {
          (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
          reject();
        }
      });
      request2.once("error", (err) => {
        request2.removeAllListeners();
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
        reject();
      });
      request2.end();
    });
  }
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamDecoder = undefined;
  var ReadState;
  (function(ReadState2) {
    ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
    ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
    ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
  })(ReadState || (ReadState = {}));

  class StreamDecoder {
    constructor(maxReadMessageLength) {
      this.maxReadMessageLength = maxReadMessageLength;
      this.readState = ReadState.NO_DATA;
      this.readCompressFlag = Buffer.alloc(1);
      this.readPartialSize = Buffer.alloc(4);
      this.readSizeRemaining = 4;
      this.readMessageSize = 0;
      this.readPartialMessage = [];
      this.readMessageRemaining = 0;
    }
    write(data) {
      let readHead = 0;
      let toRead;
      const result = [];
      while (readHead < data.length) {
        switch (this.readState) {
          case ReadState.NO_DATA:
            this.readCompressFlag = data.slice(readHead, readHead + 1);
            readHead += 1;
            this.readState = ReadState.READING_SIZE;
            this.readPartialSize.fill(0);
            this.readSizeRemaining = 4;
            this.readMessageSize = 0;
            this.readMessageRemaining = 0;
            this.readPartialMessage = [];
            break;
          case ReadState.READING_SIZE:
            toRead = Math.min(data.length - readHead, this.readSizeRemaining);
            data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
            this.readSizeRemaining -= toRead;
            readHead += toRead;
            if (this.readSizeRemaining === 0) {
              this.readMessageSize = this.readPartialSize.readUInt32BE(0);
              if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {
                throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);
              }
              this.readMessageRemaining = this.readMessageSize;
              if (this.readMessageRemaining > 0) {
                this.readState = ReadState.READING_MESSAGE;
              } else {
                const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                this.readState = ReadState.NO_DATA;
                result.push(message);
              }
            }
            break;
          case ReadState.READING_MESSAGE:
            toRead = Math.min(data.length - readHead, this.readMessageRemaining);
            this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
            this.readMessageRemaining -= toRead;
            readHead += toRead;
            if (this.readMessageRemaining === 0) {
              const framedMessageBuffers = [
                this.readCompressFlag,
                this.readPartialSize
              ].concat(this.readPartialMessage);
              const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
              this.readState = ReadState.NO_DATA;
              result.push(framedMessage);
            }
            break;
          default:
            throw new Error("Unexpected read state");
        }
      }
      return result;
    }
  }
  exports.StreamDecoder = StreamDecoder;
});

// node_modules/@grpc/grpc-js/build/src/subchannel-call.js
var require_subchannel_call = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Http2SubchannelCall = undefined;
  var http2 = __require("http2");
  var os = __require("os");
  var constants_1 = require_constants2();
  var metadata_1 = require_metadata();
  var stream_decoder_1 = require_stream_decoder();
  var logging = require_logging();
  var constants_2 = require_constants2();
  var TRACER_NAME = "subchannel_call";
  function getSystemErrorName(errno) {
    for (const [name, num] of Object.entries(os.constants.errno)) {
      if (num === errno) {
        return name;
      }
    }
    return "Unknown system error " + errno;
  }
  function mapHttpStatusCode(code) {
    const details = `Received HTTP status code ${code}`;
    let mappedStatusCode;
    switch (code) {
      case 400:
        mappedStatusCode = constants_1.Status.INTERNAL;
        break;
      case 401:
        mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
        break;
      case 403:
        mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
        break;
      case 404:
        mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
        break;
      case 429:
      case 502:
      case 503:
      case 504:
        mappedStatusCode = constants_1.Status.UNAVAILABLE;
        break;
      default:
        mappedStatusCode = constants_1.Status.UNKNOWN;
    }
    return {
      code: mappedStatusCode,
      details,
      metadata: new metadata_1.Metadata
    };
  }

  class Http2SubchannelCall {
    constructor(http2Stream, callEventTracker, listener, transport, callId) {
      var _a;
      this.http2Stream = http2Stream;
      this.callEventTracker = callEventTracker;
      this.listener = listener;
      this.transport = transport;
      this.callId = callId;
      this.isReadFilterPending = false;
      this.isPushPending = false;
      this.canPush = false;
      this.readsClosed = false;
      this.statusOutput = false;
      this.unpushedReadMessages = [];
      this.finalStatus = null;
      this.internalError = null;
      this.serverEndedCall = false;
      this.connectionDropped = false;
      const maxReceiveMessageLength = (_a = transport.getOptions()["grpc.max_receive_message_length"]) !== null && _a !== undefined ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
      this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);
      http2Stream.on("response", (headers, flags) => {
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "\t\t" + header + ": " + headers[header] + `
`;
        }
        this.trace(`Received server headers:
` + headersString);
        this.httpStatusCode = headers[":status"];
        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
          this.handleTrailers(headers);
        } else {
          let metadata;
          try {
            metadata = metadata_1.Metadata.fromHttp2Headers(headers);
          } catch (error) {
            this.endCall({
              code: constants_1.Status.UNKNOWN,
              details: error.message,
              metadata: new metadata_1.Metadata
            });
            return;
          }
          this.listener.onReceiveMetadata(metadata);
        }
      });
      http2Stream.on("trailers", (headers) => {
        this.handleTrailers(headers);
      });
      http2Stream.on("data", (data) => {
        if (this.statusOutput) {
          return;
        }
        this.trace("receive HTTP/2 data frame of length " + data.length);
        let messages;
        try {
          messages = this.decoder.write(data);
        } catch (e) {
          if (this.httpStatusCode !== undefined && this.httpStatusCode !== 200) {
            const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
            this.cancelWithStatus(mappedStatus.code, mappedStatus.details);
          } else {
            this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);
          }
          return;
        }
        for (const message of messages) {
          this.trace("parsed message of length " + message.length);
          this.callEventTracker.addMessageReceived();
          this.tryPush(message);
        }
      });
      http2Stream.on("end", () => {
        this.readsClosed = true;
        this.maybeOutputStatus();
      });
      http2Stream.on("close", () => {
        this.serverEndedCall = true;
        process.nextTick(() => {
          var _a2;
          this.trace("HTTP/2 stream closed with code " + http2Stream.rstCode);
          if (((_a2 = this.finalStatus) === null || _a2 === undefined ? undefined : _a2.code) === constants_1.Status.OK) {
            return;
          }
          let code;
          let details = "";
          switch (http2Stream.rstCode) {
            case http2.constants.NGHTTP2_NO_ERROR:
              if (this.finalStatus !== null) {
                return;
              }
              if (this.httpStatusCode && this.httpStatusCode !== 200) {
                const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
                code = mappedStatus.code;
                details = mappedStatus.details;
              } else {
                code = constants_1.Status.INTERNAL;
                details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;
              }
              break;
            case http2.constants.NGHTTP2_REFUSED_STREAM:
              code = constants_1.Status.UNAVAILABLE;
              details = "Stream refused by server";
              break;
            case http2.constants.NGHTTP2_CANCEL:
              if (this.connectionDropped) {
                code = constants_1.Status.UNAVAILABLE;
                details = "Connection dropped";
              } else {
                code = constants_1.Status.CANCELLED;
                details = "Call cancelled";
              }
              break;
            case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
              code = constants_1.Status.RESOURCE_EXHAUSTED;
              details = "Bandwidth exhausted or memory limit exceeded";
              break;
            case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
              code = constants_1.Status.PERMISSION_DENIED;
              details = "Protocol not secure enough";
              break;
            case http2.constants.NGHTTP2_INTERNAL_ERROR:
              code = constants_1.Status.INTERNAL;
              if (this.internalError === null) {
                details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
              } else {
                if (this.internalError.code === "ECONNRESET" || this.internalError.code === "ETIMEDOUT") {
                  code = constants_1.Status.UNAVAILABLE;
                  details = this.internalError.message;
                } else {
                  details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                }
              }
              break;
            default:
              code = constants_1.Status.INTERNAL;
              details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
          }
          this.endCall({
            code,
            details,
            metadata: new metadata_1.Metadata,
            rstCode: http2Stream.rstCode
          });
        });
      });
      http2Stream.on("error", (err) => {
        if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
          this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
          this.internalError = err;
        }
        this.callEventTracker.onStreamEnd(false);
      });
    }
    getDeadlineInfo() {
      return [`remote_addr=${this.getPeer()}`];
    }
    onDisconnect() {
      this.connectionDropped = true;
      setImmediate(() => {
        this.endCall({
          code: constants_1.Status.UNAVAILABLE,
          details: "Connection dropped",
          metadata: new metadata_1.Metadata
        });
      });
    }
    outputStatus() {
      if (!this.statusOutput) {
        this.statusOutput = true;
        this.trace("ended with status: code=" + this.finalStatus.code + ' details="' + this.finalStatus.details + '"');
        this.callEventTracker.onCallEnd(this.finalStatus);
        process.nextTick(() => {
          this.listener.onReceiveStatus(this.finalStatus);
        });
        this.http2Stream.resume();
      }
    }
    trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callId + "] " + text);
    }
    endCall(status) {
      if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
        this.finalStatus = status;
        this.maybeOutputStatus();
      }
      this.destroyHttp2Stream();
    }
    maybeOutputStatus() {
      if (this.finalStatus !== null) {
        if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {
          this.outputStatus();
        }
      }
    }
    push(message) {
      this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
      this.canPush = false;
      this.isPushPending = true;
      process.nextTick(() => {
        this.isPushPending = false;
        if (this.statusOutput) {
          return;
        }
        this.listener.onReceiveMessage(message);
        this.maybeOutputStatus();
      });
    }
    tryPush(messageBytes) {
      if (this.canPush) {
        this.http2Stream.pause();
        this.push(messageBytes);
      } else {
        this.trace("unpushedReadMessages.push message of length " + messageBytes.length);
        this.unpushedReadMessages.push(messageBytes);
      }
    }
    handleTrailers(headers) {
      this.serverEndedCall = true;
      this.callEventTracker.onStreamEnd(true);
      let headersString = "";
      for (const header of Object.keys(headers)) {
        headersString += "\t\t" + header + ": " + headers[header] + `
`;
      }
      this.trace(`Received server trailers:
` + headersString);
      let metadata;
      try {
        metadata = metadata_1.Metadata.fromHttp2Headers(headers);
      } catch (e) {
        metadata = new metadata_1.Metadata;
      }
      const metadataMap = metadata.getMap();
      let status;
      if (typeof metadataMap["grpc-status"] === "string") {
        const receivedStatus = Number(metadataMap["grpc-status"]);
        this.trace("received status code " + receivedStatus + " from server");
        metadata.remove("grpc-status");
        let details = "";
        if (typeof metadataMap["grpc-message"] === "string") {
          try {
            details = decodeURI(metadataMap["grpc-message"]);
          } catch (e) {
            details = metadataMap["grpc-message"];
          }
          metadata.remove("grpc-message");
          this.trace('received status details string "' + details + '" from server');
        }
        status = {
          code: receivedStatus,
          details,
          metadata
        };
      } else if (this.httpStatusCode) {
        status = mapHttpStatusCode(this.httpStatusCode);
        status.metadata = metadata;
      } else {
        status = {
          code: constants_1.Status.UNKNOWN,
          details: "No status information received",
          metadata
        };
      }
      this.endCall(status);
    }
    destroyHttp2Stream() {
      var _a;
      if (this.http2Stream.destroyed) {
        return;
      }
      if (this.serverEndedCall) {
        this.http2Stream.end();
      } else {
        let code;
        if (((_a = this.finalStatus) === null || _a === undefined ? undefined : _a.code) === constants_1.Status.OK) {
          code = http2.constants.NGHTTP2_NO_ERROR;
        } else {
          code = http2.constants.NGHTTP2_CANCEL;
        }
        this.trace("close http2 stream with code " + code);
        this.http2Stream.close(code);
      }
    }
    cancelWithStatus(status, details) {
      this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
      this.endCall({ code: status, details, metadata: new metadata_1.Metadata });
    }
    getStatus() {
      return this.finalStatus;
    }
    getPeer() {
      return this.transport.getPeerName();
    }
    getCallNumber() {
      return this.callId;
    }
    startRead() {
      if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
        this.readsClosed = true;
        this.maybeOutputStatus();
        return;
      }
      this.canPush = true;
      if (this.unpushedReadMessages.length > 0) {
        const nextMessage = this.unpushedReadMessages.shift();
        this.push(nextMessage);
        return;
      }
      this.http2Stream.resume();
    }
    sendMessageWithContext(context, message) {
      this.trace("write() called with message of length " + message.length);
      const cb = (error) => {
        process.nextTick(() => {
          var _a;
          let code = constants_1.Status.UNAVAILABLE;
          if ((error === null || error === undefined ? undefined : error.code) === "ERR_STREAM_WRITE_AFTER_END") {
            code = constants_1.Status.INTERNAL;
          }
          if (error) {
            this.cancelWithStatus(code, `Write error: ${error.message}`);
          }
          (_a = context.callback) === null || _a === undefined || _a.call(context);
        });
      };
      this.trace("sending data chunk of length " + message.length);
      this.callEventTracker.addMessageSent();
      try {
        this.http2Stream.write(message, cb);
      } catch (error) {
        this.endCall({
          code: constants_1.Status.UNAVAILABLE,
          details: `Write failed with error ${error.message}`,
          metadata: new metadata_1.Metadata
        });
      }
    }
    halfClose() {
      this.trace("end() called");
      this.trace("calling end() on HTTP/2 stream");
      this.http2Stream.end();
    }
  }
  exports.Http2SubchannelCall = Http2SubchannelCall;
});

// node_modules/@grpc/grpc-js/build/src/call-number.js
var require_call_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getNextCallNumber = getNextCallNumber;
  var nextCallNumber = 0;
  function getNextCallNumber() {
    return nextCallNumber++;
  }
});

// node_modules/@grpc/grpc-js/build/src/transport.js
var require_transport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Http2SubchannelConnector = undefined;
  var http2 = __require("http2");
  var channelz_1 = require_channelz();
  var constants_1 = require_constants2();
  var http_proxy_1 = require_http_proxy();
  var logging = require_logging();
  var resolver_1 = require_resolver();
  var subchannel_address_1 = require_subchannel_address();
  var uri_parser_1 = require_uri_parser();
  var net = __require("net");
  var subchannel_call_1 = require_subchannel_call();
  var call_number_1 = require_call_number();
  var TRACER_NAME = "transport";
  var FLOW_CONTROL_TRACER_NAME = "transport_flowctrl";
  var clientVersion = require_package2().version;
  var { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;
  var KEEPALIVE_TIMEOUT_MS = 20000;
  var tooManyPingsData = Buffer.from("too_many_pings", "ascii");

  class Http2Transport {
    constructor(session, subchannelAddress, options, remoteName) {
      this.session = session;
      this.options = options;
      this.remoteName = remoteName;
      this.keepaliveTimer = null;
      this.pendingSendKeepalivePing = false;
      this.activeCalls = new Set;
      this.disconnectListeners = [];
      this.disconnectHandled = false;
      this.channelzEnabled = true;
      this.keepalivesSent = 0;
      this.messagesSent = 0;
      this.messagesReceived = 0;
      this.lastMessageSentTimestamp = null;
      this.lastMessageReceivedTimestamp = null;
      this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
      if (options["grpc.enable_channelz"] === 0) {
        this.channelzEnabled = false;
        this.streamTracker = new channelz_1.ChannelzCallTrackerStub;
      } else {
        this.streamTracker = new channelz_1.ChannelzCallTracker;
      }
      this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
      this.userAgent = [
        options["grpc.primary_user_agent"],
        `grpc-node-js/${clientVersion}`,
        options["grpc.secondary_user_agent"]
      ].filter((e) => e).join(" ");
      if ("grpc.keepalive_time_ms" in options) {
        this.keepaliveTimeMs = options["grpc.keepalive_time_ms"];
      } else {
        this.keepaliveTimeMs = -1;
      }
      if ("grpc.keepalive_timeout_ms" in options) {
        this.keepaliveTimeoutMs = options["grpc.keepalive_timeout_ms"];
      } else {
        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
      }
      if ("grpc.keepalive_permit_without_calls" in options) {
        this.keepaliveWithoutCalls = options["grpc.keepalive_permit_without_calls"] === 1;
      } else {
        this.keepaliveWithoutCalls = false;
      }
      session.once("close", () => {
        this.trace("session closed");
        this.handleDisconnect();
      });
      session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
        let tooManyPings = false;
        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {
          tooManyPings = true;
        }
        this.trace("connection closed by GOAWAY with code " + errorCode + " and data " + (opaqueData === null || opaqueData === undefined ? undefined : opaqueData.toString()));
        this.reportDisconnectToOwner(tooManyPings);
      });
      session.once("error", (error) => {
        this.trace("connection closed with error " + error.message);
        this.handleDisconnect();
      });
      session.socket.once("close", (hadError) => {
        this.trace("connection closed. hadError=" + hadError);
        this.handleDisconnect();
      });
      if (logging.isTracerEnabled(TRACER_NAME)) {
        session.on("remoteSettings", (settings) => {
          this.trace("new settings received" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
        });
        session.on("localSettings", (settings) => {
          this.trace("local settings acknowledged by remote" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
        });
      }
      if (this.keepaliveWithoutCalls) {
        this.maybeStartKeepalivePingTimer();
      }
    }
    getChannelzInfo() {
      var _a, _b, _c;
      const sessionSocket = this.session.socket;
      const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
      const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
      let tlsInfo;
      if (this.session.encrypted) {
        const tlsSocket = sessionSocket;
        const cipherInfo = tlsSocket.getCipher();
        const certificate = tlsSocket.getCertificate();
        const peerCertificate = tlsSocket.getPeerCertificate();
        tlsInfo = {
          cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== undefined ? _a : null,
          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
          localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
          remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
        };
      } else {
        tlsInfo = null;
      }
      const socketInfo = {
        remoteAddress,
        localAddress,
        security: tlsInfo,
        remoteName: this.remoteName,
        streamsStarted: this.streamTracker.callsStarted,
        streamsSucceeded: this.streamTracker.callsSucceeded,
        streamsFailed: this.streamTracker.callsFailed,
        messagesSent: this.messagesSent,
        messagesReceived: this.messagesReceived,
        keepAlivesSent: this.keepalivesSent,
        lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
        lastRemoteStreamCreatedTimestamp: null,
        lastMessageSentTimestamp: this.lastMessageSentTimestamp,
        lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
        localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== undefined ? _b : null,
        remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== undefined ? _c : null
      };
      return socketInfo;
    }
    trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
    }
    keepaliveTrace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
    }
    flowControlTrace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
    }
    internalsTrace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, "transport_internals", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
    }
    reportDisconnectToOwner(tooManyPings) {
      if (this.disconnectHandled) {
        return;
      }
      this.disconnectHandled = true;
      this.disconnectListeners.forEach((listener) => listener(tooManyPings));
    }
    handleDisconnect() {
      this.clearKeepaliveTimeout();
      this.reportDisconnectToOwner(false);
      for (const call of this.activeCalls) {
        call.onDisconnect();
      }
      setImmediate(() => {
        this.session.destroy();
      });
    }
    addDisconnectListener(listener) {
      this.disconnectListeners.push(listener);
    }
    canSendPing() {
      return !this.session.destroyed && this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);
    }
    maybeSendPing() {
      var _a, _b;
      if (!this.canSendPing()) {
        this.pendingSendKeepalivePing = true;
        return;
      }
      if (this.keepaliveTimer) {
        console.error("keepaliveTimeout is not null");
        return;
      }
      if (this.channelzEnabled) {
        this.keepalivesSent += 1;
      }
      this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
      this.keepaliveTimer = setTimeout(() => {
        this.keepaliveTimer = null;
        this.keepaliveTrace("Ping timeout passed without response");
        this.handleDisconnect();
      }, this.keepaliveTimeoutMs);
      (_b = (_a = this.keepaliveTimer).unref) === null || _b === undefined || _b.call(_a);
      let pingSendError = "";
      try {
        const pingSentSuccessfully = this.session.ping((err, duration, payload) => {
          this.clearKeepaliveTimeout();
          if (err) {
            this.keepaliveTrace("Ping failed with error " + err.message);
            this.handleDisconnect();
          } else {
            this.keepaliveTrace("Received ping response");
            this.maybeStartKeepalivePingTimer();
          }
        });
        if (!pingSentSuccessfully) {
          pingSendError = "Ping returned false";
        }
      } catch (e) {
        pingSendError = (e instanceof Error ? e.message : "") || "Unknown error";
      }
      if (pingSendError) {
        this.keepaliveTrace("Ping send failed: " + pingSendError);
        this.handleDisconnect();
      }
    }
    maybeStartKeepalivePingTimer() {
      var _a, _b;
      if (!this.canSendPing()) {
        return;
      }
      if (this.pendingSendKeepalivePing) {
        this.pendingSendKeepalivePing = false;
        this.maybeSendPing();
      } else if (!this.keepaliveTimer) {
        this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
        this.keepaliveTimer = setTimeout(() => {
          this.keepaliveTimer = null;
          this.maybeSendPing();
        }, this.keepaliveTimeMs);
        (_b = (_a = this.keepaliveTimer).unref) === null || _b === undefined || _b.call(_a);
      }
    }
    clearKeepaliveTimeout() {
      if (this.keepaliveTimer) {
        clearTimeout(this.keepaliveTimer);
        this.keepaliveTimer = null;
      }
    }
    removeActiveCall(call) {
      this.activeCalls.delete(call);
      if (this.activeCalls.size === 0) {
        this.session.unref();
      }
    }
    addActiveCall(call) {
      this.activeCalls.add(call);
      if (this.activeCalls.size === 1) {
        this.session.ref();
        if (!this.keepaliveWithoutCalls) {
          this.maybeStartKeepalivePingTimer();
        }
      }
    }
    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
      const headers = metadata.toHttp2Headers();
      headers[HTTP2_HEADER_AUTHORITY] = host;
      headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
      headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
      headers[HTTP2_HEADER_METHOD] = "POST";
      headers[HTTP2_HEADER_PATH] = method;
      headers[HTTP2_HEADER_TE] = "trailers";
      let http2Stream;
      try {
        http2Stream = this.session.request(headers);
      } catch (e) {
        this.handleDisconnect();
        throw e;
      }
      this.flowControlTrace("local window size: " + this.session.state.localWindowSize + " remote window size: " + this.session.state.remoteWindowSize);
      this.internalsTrace("session.closed=" + this.session.closed + " session.destroyed=" + this.session.destroyed + " session.socket.destroyed=" + this.session.socket.destroyed);
      let eventTracker;
      let call;
      if (this.channelzEnabled) {
        this.streamTracker.addCallStarted();
        eventTracker = {
          addMessageSent: () => {
            var _a;
            this.messagesSent += 1;
            this.lastMessageSentTimestamp = new Date;
            (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === undefined || _a.call(subchannelCallStatsTracker);
          },
          addMessageReceived: () => {
            var _a;
            this.messagesReceived += 1;
            this.lastMessageReceivedTimestamp = new Date;
            (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === undefined || _a.call(subchannelCallStatsTracker);
          },
          onCallEnd: (status) => {
            var _a;
            (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === undefined || _a.call(subchannelCallStatsTracker, status);
            this.removeActiveCall(call);
          },
          onStreamEnd: (success) => {
            var _a;
            if (success) {
              this.streamTracker.addCallSucceeded();
            } else {
              this.streamTracker.addCallFailed();
            }
            (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === undefined || _a.call(subchannelCallStatsTracker, success);
          }
        };
      } else {
        eventTracker = {
          addMessageSent: () => {
            var _a;
            (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === undefined || _a.call(subchannelCallStatsTracker);
          },
          addMessageReceived: () => {
            var _a;
            (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === undefined || _a.call(subchannelCallStatsTracker);
          },
          onCallEnd: (status) => {
            var _a;
            (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === undefined || _a.call(subchannelCallStatsTracker, status);
            this.removeActiveCall(call);
          },
          onStreamEnd: (success) => {
            var _a;
            (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === undefined || _a.call(subchannelCallStatsTracker, success);
          }
        };
      }
      call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());
      this.addActiveCall(call);
      return call;
    }
    getChannelzRef() {
      return this.channelzRef;
    }
    getPeerName() {
      return this.subchannelAddressString;
    }
    getOptions() {
      return this.options;
    }
    shutdown() {
      this.session.close();
      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
    }
  }

  class Http2SubchannelConnector {
    constructor(channelTarget) {
      this.channelTarget = channelTarget;
      this.session = null;
      this.isShutdown = false;
    }
    trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + " " + text);
    }
    createSession(secureConnectResult, address, options) {
      if (this.isShutdown) {
        return Promise.reject();
      }
      if (secureConnectResult.socket.closed) {
        return Promise.reject("Connection closed before starting HTTP/2 handshake");
      }
      return new Promise((resolve, reject) => {
        let remoteName = null;
        let realTarget = this.channelTarget;
        if ("grpc.http_connect_target" in options) {
          const parsedTarget = (0, uri_parser_1.parseUri)(options["grpc.http_connect_target"]);
          if (parsedTarget) {
            realTarget = parsedTarget;
            remoteName = (0, uri_parser_1.uriToString)(parsedTarget);
          }
        }
        const scheme = secureConnectResult.secure ? "https" : "http";
        const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);
        const closeHandler = () => {
          var _a;
          (_a = this.session) === null || _a === undefined || _a.destroy();
          this.session = null;
          setImmediate(() => {
            if (!reportedError) {
              reportedError = true;
              reject(`${errorMessage.trim()} (${new Date().toISOString()})`);
            }
          });
        };
        const errorHandler = (error) => {
          var _a;
          (_a = this.session) === null || _a === undefined || _a.destroy();
          errorMessage = error.message;
          this.trace("connection failed with error " + errorMessage);
          if (!reportedError) {
            reportedError = true;
            reject(`${errorMessage} (${new Date().toISOString()})`);
          }
        };
        const sessionOptions = {
          createConnection: (authority, option) => {
            return secureConnectResult.socket;
          }
        };
        if (options["grpc-node.flow_control_window"] !== undefined) {
          sessionOptions.settings = {
            initialWindowSize: options["grpc-node.flow_control_window"]
          };
        }
        const session = http2.connect(`${scheme}://${targetPath}`, sessionOptions);
        this.session = session;
        let errorMessage = "Failed to connect";
        let reportedError = false;
        session.unref();
        session.once("remoteSettings", () => {
          session.removeAllListeners();
          secureConnectResult.socket.removeListener("close", closeHandler);
          secureConnectResult.socket.removeListener("error", errorHandler);
          resolve(new Http2Transport(session, address, options, remoteName));
          this.session = null;
        });
        session.once("close", closeHandler);
        session.once("error", errorHandler);
        secureConnectResult.socket.once("close", closeHandler);
        secureConnectResult.socket.once("error", errorHandler);
      });
    }
    tcpConnect(address, options) {
      return (0, http_proxy_1.getProxiedConnection)(address, options).then((proxiedSocket) => {
        if (proxiedSocket) {
          return proxiedSocket;
        } else {
          return new Promise((resolve, reject) => {
            const closeCallback = () => {
              reject(new Error("Socket closed"));
            };
            const errorCallback = (error) => {
              reject(error);
            };
            const socket = net.connect(address, () => {
              socket.removeListener("close", closeCallback);
              socket.removeListener("error", errorCallback);
              resolve(socket);
            });
            socket.once("close", closeCallback);
            socket.once("error", errorCallback);
          });
        }
      });
    }
    async connect(address, secureConnector, options) {
      if (this.isShutdown) {
        return Promise.reject();
      }
      let tcpConnection = null;
      let secureConnectResult = null;
      const addressString = (0, subchannel_address_1.subchannelAddressToString)(address);
      try {
        this.trace(addressString + " Waiting for secureConnector to be ready");
        await secureConnector.waitForReady();
        this.trace(addressString + " secureConnector is ready");
        tcpConnection = await this.tcpConnect(address, options);
        tcpConnection.setNoDelay();
        this.trace(addressString + " Established TCP connection");
        secureConnectResult = await secureConnector.connect(tcpConnection);
        this.trace(addressString + " Established secure connection");
        return this.createSession(secureConnectResult, address, options);
      } catch (e) {
        tcpConnection === null || tcpConnection === undefined || tcpConnection.destroy();
        secureConnectResult === null || secureConnectResult === undefined || secureConnectResult.socket.destroy();
        throw e;
      }
    }
    shutdown() {
      var _a;
      this.isShutdown = true;
      (_a = this.session) === null || _a === undefined || _a.close();
      this.session = null;
    }
  }
  exports.Http2SubchannelConnector = Http2SubchannelConnector;
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SubchannelPool = undefined;
  exports.getSubchannelPool = getSubchannelPool;
  var channel_options_1 = require_channel_options();
  var subchannel_1 = require_subchannel();
  var subchannel_address_1 = require_subchannel_address();
  var uri_parser_1 = require_uri_parser();
  var transport_1 = require_transport();
  var REF_CHECK_INTERVAL = 1e4;

  class SubchannelPool {
    constructor() {
      this.pool = Object.create(null);
      this.cleanupTimer = null;
    }
    unrefUnusedSubchannels() {
      let allSubchannelsUnrefed = true;
      for (const channelTarget in this.pool) {
        const subchannelObjArray = this.pool[channelTarget];
        const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
        if (refedSubchannels.length > 0) {
          allSubchannelsUnrefed = false;
        }
        this.pool[channelTarget] = refedSubchannels;
      }
      if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
        clearInterval(this.cleanupTimer);
        this.cleanupTimer = null;
      }
    }
    ensureCleanupTask() {
      var _a, _b;
      if (this.cleanupTimer === null) {
        this.cleanupTimer = setInterval(() => {
          this.unrefUnusedSubchannels();
        }, REF_CHECK_INTERVAL);
        (_b = (_a = this.cleanupTimer).unref) === null || _b === undefined || _b.call(_a);
      }
    }
    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
      this.ensureCleanupTask();
      const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
      if (channelTarget in this.pool) {
        const subchannelObjArray = this.pool[channelTarget];
        for (const subchannelObj of subchannelObjArray) {
          if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
            return subchannelObj.subchannel;
          }
        }
      }
      const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
      if (!(channelTarget in this.pool)) {
        this.pool[channelTarget] = [];
      }
      this.pool[channelTarget].push({
        subchannelAddress: subchannelTarget,
        channelArguments,
        channelCredentials,
        subchannel
      });
      subchannel.ref();
      return subchannel;
    }
  }
  exports.SubchannelPool = SubchannelPool;
  var globalSubchannelPool = new SubchannelPool;
  function getSubchannelPool(global2) {
    if (global2) {
      return globalSubchannelPool;
    } else {
      return new SubchannelPool;
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FilterStackFactory = exports.FilterStack = undefined;

  class FilterStack {
    constructor(filters) {
      this.filters = filters;
    }
    sendMetadata(metadata) {
      let result = metadata;
      for (let i = 0;i < this.filters.length; i++) {
        result = this.filters[i].sendMetadata(result);
      }
      return result;
    }
    receiveMetadata(metadata) {
      let result = metadata;
      for (let i = this.filters.length - 1;i >= 0; i--) {
        result = this.filters[i].receiveMetadata(result);
      }
      return result;
    }
    sendMessage(message) {
      let result = message;
      for (let i = 0;i < this.filters.length; i++) {
        result = this.filters[i].sendMessage(result);
      }
      return result;
    }
    receiveMessage(message) {
      let result = message;
      for (let i = this.filters.length - 1;i >= 0; i--) {
        result = this.filters[i].receiveMessage(result);
      }
      return result;
    }
    receiveTrailers(status) {
      let result = status;
      for (let i = this.filters.length - 1;i >= 0; i--) {
        result = this.filters[i].receiveTrailers(result);
      }
      return result;
    }
    push(filters) {
      this.filters.unshift(...filters);
    }
    getFilters() {
      return this.filters;
    }
  }
  exports.FilterStack = FilterStack;

  class FilterStackFactory {
    constructor(factories) {
      this.factories = factories;
    }
    push(filterFactories) {
      this.factories.unshift(...filterFactories);
    }
    clone() {
      return new FilterStackFactory([...this.factories]);
    }
    createFilter() {
      return new FilterStack(this.factories.map((factory) => factory.createFilter()));
    }
  }
  exports.FilterStackFactory = FilterStackFactory;
});

// node_modules/@grpc/grpc-js/build/src/compression-algorithms.js
var require_compression_algorithms = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompressionAlgorithms = undefined;
  var CompressionAlgorithms;
  (function(CompressionAlgorithms2) {
    CompressionAlgorithms2[CompressionAlgorithms2["identity"] = 0] = "identity";
    CompressionAlgorithms2[CompressionAlgorithms2["deflate"] = 1] = "deflate";
    CompressionAlgorithms2[CompressionAlgorithms2["gzip"] = 2] = "gzip";
  })(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseFilter = undefined;

  class BaseFilter {
    async sendMetadata(metadata) {
      return metadata;
    }
    receiveMetadata(metadata) {
      return metadata;
    }
    async sendMessage(message) {
      return message;
    }
    async receiveMessage(message) {
      return message;
    }
    receiveTrailers(status) {
      return status;
    }
  }
  exports.BaseFilter = BaseFilter;
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompressionFilterFactory = exports.CompressionFilter = undefined;
  var zlib = __require("zlib");
  var compression_algorithms_1 = require_compression_algorithms();
  var constants_1 = require_constants2();
  var filter_1 = require_filter();
  var logging = require_logging();
  var isCompressionAlgorithmKey = (key) => {
    return typeof key === "number" && typeof compression_algorithms_1.CompressionAlgorithms[key] === "string";
  };

  class CompressionHandler {
    async writeMessage(message, compress) {
      let messageBuffer = message;
      if (compress) {
        messageBuffer = await this.compressMessage(messageBuffer);
      }
      const output = Buffer.allocUnsafe(messageBuffer.length + 5);
      output.writeUInt8(compress ? 1 : 0, 0);
      output.writeUInt32BE(messageBuffer.length, 1);
      messageBuffer.copy(output, 5);
      return output;
    }
    async readMessage(data) {
      const compressed = data.readUInt8(0) === 1;
      let messageBuffer = data.slice(5);
      if (compressed) {
        messageBuffer = await this.decompressMessage(messageBuffer);
      }
      return messageBuffer;
    }
  }

  class IdentityHandler extends CompressionHandler {
    async compressMessage(message) {
      return message;
    }
    async writeMessage(message, compress) {
      const output = Buffer.allocUnsafe(message.length + 5);
      output.writeUInt8(0, 0);
      output.writeUInt32BE(message.length, 1);
      message.copy(output, 5);
      return output;
    }
    decompressMessage(message) {
      return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
    }
  }

  class DeflateHandler extends CompressionHandler {
    constructor(maxRecvMessageLength) {
      super();
      this.maxRecvMessageLength = maxRecvMessageLength;
    }
    compressMessage(message) {
      return new Promise((resolve, reject) => {
        zlib.deflate(message, (err, output) => {
          if (err) {
            reject(err);
          } else {
            resolve(output);
          }
        });
      });
    }
    decompressMessage(message) {
      return new Promise((resolve, reject) => {
        let totalLength = 0;
        const messageParts = [];
        const decompresser = zlib.createInflate();
        decompresser.on("data", (chunk) => {
          messageParts.push(chunk);
          totalLength += chunk.byteLength;
          if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
            decompresser.destroy();
            reject({
              code: constants_1.Status.RESOURCE_EXHAUSTED,
              details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
            });
          }
        });
        decompresser.on("end", () => {
          resolve(Buffer.concat(messageParts));
        });
        decompresser.write(message);
        decompresser.end();
      });
    }
  }

  class GzipHandler extends CompressionHandler {
    constructor(maxRecvMessageLength) {
      super();
      this.maxRecvMessageLength = maxRecvMessageLength;
    }
    compressMessage(message) {
      return new Promise((resolve, reject) => {
        zlib.gzip(message, (err, output) => {
          if (err) {
            reject(err);
          } else {
            resolve(output);
          }
        });
      });
    }
    decompressMessage(message) {
      return new Promise((resolve, reject) => {
        let totalLength = 0;
        const messageParts = [];
        const decompresser = zlib.createGunzip();
        decompresser.on("data", (chunk) => {
          messageParts.push(chunk);
          totalLength += chunk.byteLength;
          if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
            decompresser.destroy();
            reject({
              code: constants_1.Status.RESOURCE_EXHAUSTED,
              details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
            });
          }
        });
        decompresser.on("end", () => {
          resolve(Buffer.concat(messageParts));
        });
        decompresser.write(message);
        decompresser.end();
      });
    }
  }

  class UnknownHandler extends CompressionHandler {
    constructor(compressionName) {
      super();
      this.compressionName = compressionName;
    }
    compressMessage(message) {
      return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
    }
    decompressMessage(message) {
      return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
    }
  }
  function getCompressionHandler(compressionName, maxReceiveMessageSize) {
    switch (compressionName) {
      case "identity":
        return new IdentityHandler;
      case "deflate":
        return new DeflateHandler(maxReceiveMessageSize);
      case "gzip":
        return new GzipHandler(maxReceiveMessageSize);
      default:
        return new UnknownHandler(compressionName);
    }
  }

  class CompressionFilter extends filter_1.BaseFilter {
    constructor(channelOptions, sharedFilterConfig) {
      var _a, _b, _c;
      super();
      this.sharedFilterConfig = sharedFilterConfig;
      this.sendCompression = new IdentityHandler;
      this.receiveCompression = new IdentityHandler;
      this.currentCompressionAlgorithm = "identity";
      const compressionAlgorithmKey = channelOptions["grpc.default_compression_algorithm"];
      this.maxReceiveMessageLength = (_a = channelOptions["grpc.max_receive_message_length"]) !== null && _a !== undefined ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
      this.maxSendMessageLength = (_b = channelOptions["grpc.max_send_message_length"]) !== null && _b !== undefined ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
      if (compressionAlgorithmKey !== undefined) {
        if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
          const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
          const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === undefined ? undefined : _c.split(",");
          if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {
            this.currentCompressionAlgorithm = clientSelectedEncoding;
            this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);
          }
        } else {
          logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
        }
      }
    }
    async sendMetadata(metadata) {
      const headers = await metadata;
      headers.set("grpc-accept-encoding", "identity,deflate,gzip");
      headers.set("accept-encoding", "identity");
      if (this.currentCompressionAlgorithm === "identity") {
        headers.remove("grpc-encoding");
      } else {
        headers.set("grpc-encoding", this.currentCompressionAlgorithm);
      }
      return headers;
    }
    receiveMetadata(metadata) {
      const receiveEncoding = metadata.get("grpc-encoding");
      if (receiveEncoding.length > 0) {
        const encoding = receiveEncoding[0];
        if (typeof encoding === "string") {
          this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);
        }
      }
      metadata.remove("grpc-encoding");
      const serverSupportedEncodingsHeader = metadata.get("grpc-accept-encoding")[0];
      if (serverSupportedEncodingsHeader) {
        this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;
        const serverSupportedEncodings = serverSupportedEncodingsHeader.split(",");
        if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
          this.sendCompression = new IdentityHandler;
          this.currentCompressionAlgorithm = "identity";
        }
      }
      metadata.remove("grpc-accept-encoding");
      return metadata;
    }
    async sendMessage(message) {
      var _a;
      const resolvedMessage = await message;
      if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {
        throw {
          code: constants_1.Status.RESOURCE_EXHAUSTED,
          details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`
        };
      }
      let compress;
      if (this.sendCompression instanceof IdentityHandler) {
        compress = false;
      } else {
        compress = (((_a = resolvedMessage.flags) !== null && _a !== undefined ? _a : 0) & 2) === 0;
      }
      return {
        message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
        flags: resolvedMessage.flags
      };
    }
    async receiveMessage(message) {
      return this.receiveCompression.readMessage(await message);
    }
  }
  exports.CompressionFilter = CompressionFilter;

  class CompressionFilterFactory {
    constructor(channel, options) {
      this.options = options;
      this.sharedFilterConfig = {};
    }
    createFilter() {
      return new CompressionFilter(this.options, this.sharedFilterConfig);
    }
  }
  exports.CompressionFilterFactory = CompressionFilterFactory;
});

// node_modules/@grpc/grpc-js/build/src/deadline.js
var require_deadline = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.minDeadline = minDeadline;
  exports.getDeadlineTimeoutString = getDeadlineTimeoutString;
  exports.getRelativeTimeout = getRelativeTimeout;
  exports.deadlineToString = deadlineToString;
  exports.formatDateDifference = formatDateDifference;
  function minDeadline(...deadlineList) {
    let minValue = Infinity;
    for (const deadline of deadlineList) {
      const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
      if (deadlineMsecs < minValue) {
        minValue = deadlineMsecs;
      }
    }
    return minValue;
  }
  var units = [
    ["m", 1],
    ["S", 1000],
    ["M", 60 * 1000],
    ["H", 60 * 60 * 1000]
  ];
  function getDeadlineTimeoutString(deadline) {
    const now = new Date().getTime();
    if (deadline instanceof Date) {
      deadline = deadline.getTime();
    }
    const timeoutMs = Math.max(deadline - now, 0);
    for (const [unit, factor] of units) {
      const amount = timeoutMs / factor;
      if (amount < 1e8) {
        return String(Math.ceil(amount)) + unit;
      }
    }
    throw new Error("Deadline is too far in the future");
  }
  var MAX_TIMEOUT_TIME = 2147483647;
  function getRelativeTimeout(deadline) {
    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
    const now = new Date().getTime();
    const timeout = deadlineMs - now;
    if (timeout < 0) {
      return 0;
    } else if (timeout > MAX_TIMEOUT_TIME) {
      return Infinity;
    } else {
      return timeout;
    }
  }
  function deadlineToString(deadline) {
    if (deadline instanceof Date) {
      return deadline.toISOString();
    } else {
      const dateDeadline = new Date(deadline);
      if (Number.isNaN(dateDeadline.getTime())) {
        return "" + deadline;
      } else {
        return dateDeadline.toISOString();
      }
    }
  }
  function formatDateDifference(startDate, endDate) {
    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + "s";
  }
});

// node_modules/@grpc/grpc-js/build/src/control-plane-status.js
var require_control_plane_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;
  var constants_1 = require_constants2();
  var INAPPROPRIATE_CONTROL_PLANE_CODES = [
    constants_1.Status.OK,
    constants_1.Status.INVALID_ARGUMENT,
    constants_1.Status.NOT_FOUND,
    constants_1.Status.ALREADY_EXISTS,
    constants_1.Status.FAILED_PRECONDITION,
    constants_1.Status.ABORTED,
    constants_1.Status.OUT_OF_RANGE,
    constants_1.Status.DATA_LOSS
  ];
  function restrictControlPlaneStatusCode(code, details) {
    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
      return {
        code: constants_1.Status.INTERNAL,
        details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`
      };
    } else {
      return { code, details };
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancing-call.js
var require_load_balancing_call = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LoadBalancingCall = undefined;
  var connectivity_state_1 = require_connectivity_state();
  var constants_1 = require_constants2();
  var deadline_1 = require_deadline();
  var metadata_1 = require_metadata();
  var picker_1 = require_picker();
  var uri_parser_1 = require_uri_parser();
  var logging = require_logging();
  var control_plane_status_1 = require_control_plane_status();
  var http2 = __require("http2");
  var TRACER_NAME = "load_balancing_call";

  class LoadBalancingCall {
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {
      var _a, _b;
      this.channel = channel;
      this.callConfig = callConfig;
      this.methodName = methodName;
      this.host = host;
      this.credentials = credentials;
      this.deadline = deadline;
      this.callNumber = callNumber;
      this.child = null;
      this.readPending = false;
      this.pendingMessage = null;
      this.pendingHalfClose = false;
      this.ended = false;
      this.metadata = null;
      this.listener = null;
      this.onCallEnded = null;
      this.childStartTime = null;
      const splitPath = this.methodName.split("/");
      let serviceName = "";
      if (splitPath.length >= 2) {
        serviceName = splitPath[1];
      }
      const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === undefined ? undefined : _a.host) !== null && _b !== undefined ? _b : "localhost";
      this.serviceUrl = `https://${hostname}/${serviceName}`;
      this.startTime = new Date;
    }
    getDeadlineInfo() {
      var _a, _b;
      const deadlineInfo = [];
      if (this.childStartTime) {
        if (this.childStartTime > this.startTime) {
          if ((_a = this.metadata) === null || _a === undefined ? undefined : _a.getOptions().waitForReady) {
            deadlineInfo.push("wait_for_ready");
          }
          deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);
        }
        deadlineInfo.push(...this.child.getDeadlineInfo());
        return deadlineInfo;
      } else {
        if ((_b = this.metadata) === null || _b === undefined ? undefined : _b.getOptions().waitForReady) {
          deadlineInfo.push("wait_for_ready");
        }
        deadlineInfo.push("Waiting for LB pick");
      }
      return deadlineInfo;
    }
    trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
    }
    outputStatus(status, progress) {
      var _a, _b;
      if (!this.ended) {
        this.ended = true;
        this.trace("ended with status: code=" + status.code + ' details="' + status.details + '" start time=' + this.startTime.toISOString());
        const finalStatus = Object.assign(Object.assign({}, status), { progress });
        (_a = this.listener) === null || _a === undefined || _a.onReceiveStatus(finalStatus);
        (_b = this.onCallEnded) === null || _b === undefined || _b.call(this, finalStatus.code);
      }
    }
    doPick() {
      var _a, _b;
      if (this.ended) {
        return;
      }
      if (!this.metadata) {
        throw new Error("doPick called before start");
      }
      this.trace("Pick called");
      const finalMetadata = this.metadata.clone();
      const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);
      const subchannelString = pickResult.subchannel ? "(" + pickResult.subchannel.getChannelzRef().id + ") " + pickResult.subchannel.getAddress() : "" + pickResult.subchannel;
      this.trace("Pick result: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + subchannelString + " status: " + ((_a = pickResult.status) === null || _a === undefined ? undefined : _a.code) + " " + ((_b = pickResult.status) === null || _b === undefined ? undefined : _b.details));
      switch (pickResult.pickResultType) {
        case picker_1.PickResultType.COMPLETE:
          const combinedCallCredentials = this.credentials.compose(pickResult.subchannel.getCallCredentials());
          combinedCallCredentials.generateMetadata({ method_name: this.methodName, service_url: this.serviceUrl }).then((credsMetadata) => {
            var _a2;
            if (this.ended) {
              this.trace("Credentials metadata generation finished after call ended");
              return;
            }
            finalMetadata.merge(credsMetadata);
            if (finalMetadata.get("authorization").length > 1) {
              this.outputStatus({
                code: constants_1.Status.INTERNAL,
                details: '"authorization" metadata cannot have multiple values',
                metadata: new metadata_1.Metadata
              }, "PROCESSED");
            }
            if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {
              this.trace("Picked subchannel " + subchannelString + " has state " + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + " after getting credentials metadata. Retrying pick");
              this.doPick();
              return;
            }
            if (this.deadline !== Infinity) {
              finalMetadata.set("grpc-timeout", (0, deadline_1.getDeadlineTimeoutString)(this.deadline));
            }
            try {
              this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {
                onReceiveMetadata: (metadata) => {
                  this.trace("Received metadata");
                  this.listener.onReceiveMetadata(metadata);
                },
                onReceiveMessage: (message) => {
                  this.trace("Received message");
                  this.listener.onReceiveMessage(message);
                },
                onReceiveStatus: (status) => {
                  this.trace("Received status");
                  if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {
                    this.outputStatus(status, "REFUSED");
                  } else {
                    this.outputStatus(status, "PROCESSED");
                  }
                }
              });
              this.childStartTime = new Date;
            } catch (error) {
              this.trace("Failed to start call on picked subchannel " + subchannelString + " with error " + error.message);
              this.outputStatus({
                code: constants_1.Status.INTERNAL,
                details: "Failed to start HTTP/2 stream with error " + error.message,
                metadata: new metadata_1.Metadata
              }, "NOT_STARTED");
              return;
            }
            (_a2 = pickResult.onCallStarted) === null || _a2 === undefined || _a2.call(pickResult);
            this.onCallEnded = pickResult.onCallEnded;
            this.trace("Created child call [" + this.child.getCallNumber() + "]");
            if (this.readPending) {
              this.child.startRead();
            }
            if (this.pendingMessage) {
              this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
            }
            if (this.pendingHalfClose) {
              this.child.halfClose();
            }
          }, (error) => {
            const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === "number" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
            this.outputStatus({
              code: code2,
              details: details2,
              metadata: new metadata_1.Metadata
            }, "PROCESSED");
          });
          break;
        case picker_1.PickResultType.DROP:
          const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
          setImmediate(() => {
            this.outputStatus({ code, details, metadata: pickResult.status.metadata }, "DROP");
          });
          break;
        case picker_1.PickResultType.TRANSIENT_FAILURE:
          if (this.metadata.getOptions().waitForReady) {
            this.channel.queueCallForPick(this);
          } else {
            const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
            setImmediate(() => {
              this.outputStatus({ code: code2, details: details2, metadata: pickResult.status.metadata }, "PROCESSED");
            });
          }
          break;
        case picker_1.PickResultType.QUEUE:
          this.channel.queueCallForPick(this);
      }
    }
    cancelWithStatus(status, details) {
      var _a;
      this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
      (_a = this.child) === null || _a === undefined || _a.cancelWithStatus(status, details);
      this.outputStatus({ code: status, details, metadata: new metadata_1.Metadata }, "PROCESSED");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.child) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : this.channel.getTarget();
    }
    start(metadata, listener) {
      this.trace("start called");
      this.listener = listener;
      this.metadata = metadata;
      this.doPick();
    }
    sendMessageWithContext(context, message) {
      this.trace("write() called with message of length " + message.length);
      if (this.child) {
        this.child.sendMessageWithContext(context, message);
      } else {
        this.pendingMessage = { context, message };
      }
    }
    startRead() {
      this.trace("startRead called");
      if (this.child) {
        this.child.startRead();
      } else {
        this.readPending = true;
      }
    }
    halfClose() {
      this.trace("halfClose called");
      if (this.child) {
        this.child.halfClose();
      } else {
        this.pendingHalfClose = true;
      }
    }
    setCredentials(credentials) {
      throw new Error("Method not implemented.");
    }
    getCallNumber() {
      return this.callNumber;
    }
  }
  exports.LoadBalancingCall = LoadBalancingCall;
});

// node_modules/@grpc/grpc-js/build/src/resolving-call.js
var require_resolving_call = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ResolvingCall = undefined;
  var call_credentials_1 = require_call_credentials();
  var constants_1 = require_constants2();
  var deadline_1 = require_deadline();
  var metadata_1 = require_metadata();
  var logging = require_logging();
  var control_plane_status_1 = require_control_plane_status();
  var TRACER_NAME = "resolving_call";

  class ResolvingCall {
    constructor(channel, method, options, filterStackFactory, callNumber) {
      this.channel = channel;
      this.method = method;
      this.filterStackFactory = filterStackFactory;
      this.callNumber = callNumber;
      this.child = null;
      this.readPending = false;
      this.pendingMessage = null;
      this.pendingHalfClose = false;
      this.ended = false;
      this.readFilterPending = false;
      this.writeFilterPending = false;
      this.pendingChildStatus = null;
      this.metadata = null;
      this.listener = null;
      this.statusWatchers = [];
      this.deadlineTimer = setTimeout(() => {
      }, 0);
      this.filterStack = null;
      this.deadlineStartTime = null;
      this.configReceivedTime = null;
      this.childStartTime = null;
      this.credentials = call_credentials_1.CallCredentials.createEmpty();
      this.deadline = options.deadline;
      this.host = options.host;
      if (options.parentCall) {
        if (options.flags & constants_1.Propagate.CANCELLATION) {
          options.parentCall.on("cancelled", () => {
            this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
          });
        }
        if (options.flags & constants_1.Propagate.DEADLINE) {
          this.trace("Propagating deadline from parent: " + options.parentCall.getDeadline());
          this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());
        }
      }
      this.trace("Created");
      this.runDeadlineTimer();
    }
    trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
    }
    runDeadlineTimer() {
      clearTimeout(this.deadlineTimer);
      this.deadlineStartTime = new Date;
      this.trace("Deadline: " + (0, deadline_1.deadlineToString)(this.deadline));
      const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);
      if (timeout !== Infinity) {
        this.trace("Deadline will be reached in " + timeout + "ms");
        const handleDeadline = () => {
          if (!this.deadlineStartTime) {
            this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
            return;
          }
          const deadlineInfo = [];
          const deadlineEndTime = new Date;
          deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);
          if (this.configReceivedTime) {
            if (this.configReceivedTime > this.deadlineStartTime) {
              deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);
            }
            if (this.childStartTime) {
              if (this.childStartTime > this.configReceivedTime) {
                deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);
              }
            } else {
              deadlineInfo.push("waiting for metadata filters");
            }
          } else {
            deadlineInfo.push("waiting for name resolution");
          }
          if (this.child) {
            deadlineInfo.push(...this.child.getDeadlineInfo());
          }
          this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(","));
        };
        if (timeout <= 0) {
          process.nextTick(handleDeadline);
        } else {
          this.deadlineTimer = setTimeout(handleDeadline, timeout);
        }
      }
    }
    outputStatus(status) {
      if (!this.ended) {
        this.ended = true;
        if (!this.filterStack) {
          this.filterStack = this.filterStackFactory.createFilter();
        }
        clearTimeout(this.deadlineTimer);
        const filteredStatus = this.filterStack.receiveTrailers(status);
        this.trace("ended with status: code=" + filteredStatus.code + ' details="' + filteredStatus.details + '"');
        this.statusWatchers.forEach((watcher) => watcher(filteredStatus));
        process.nextTick(() => {
          var _a;
          (_a = this.listener) === null || _a === undefined || _a.onReceiveStatus(filteredStatus);
        });
      }
    }
    sendMessageOnChild(context, message) {
      if (!this.child) {
        throw new Error("sendMessageonChild called with child not populated");
      }
      const child = this.child;
      this.writeFilterPending = true;
      this.filterStack.sendMessage(Promise.resolve({ message, flags: context.flags })).then((filteredMessage) => {
        this.writeFilterPending = false;
        child.sendMessageWithContext(context, filteredMessage.message);
        if (this.pendingHalfClose) {
          child.halfClose();
        }
      }, (status) => {
        this.cancelWithStatus(status.code, status.details);
      });
    }
    getConfig() {
      if (this.ended) {
        return;
      }
      if (!this.metadata || !this.listener) {
        throw new Error("getConfig called before start");
      }
      const configResult = this.channel.getConfig(this.method, this.metadata);
      if (configResult.type === "NONE") {
        this.channel.queueCallForConfig(this);
        return;
      } else if (configResult.type === "ERROR") {
        if (this.metadata.getOptions().waitForReady) {
          this.channel.queueCallForConfig(this);
        } else {
          this.outputStatus(configResult.error);
        }
        return;
      }
      this.configReceivedTime = new Date;
      const config = configResult.config;
      if (config.status !== constants_1.Status.OK) {
        const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, "Failed to route call to method " + this.method);
        this.outputStatus({
          code,
          details,
          metadata: new metadata_1.Metadata
        });
        return;
      }
      if (config.methodConfig.timeout) {
        const configDeadline = new Date;
        configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
        configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1e6);
        this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);
        this.runDeadlineTimer();
      }
      this.filterStackFactory.push(config.dynamicFilterFactories);
      this.filterStack = this.filterStackFactory.createFilter();
      this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then((filteredMetadata) => {
        this.child = this.channel.createRetryingCall(config, this.method, this.host, this.credentials, this.deadline);
        this.trace("Created child [" + this.child.getCallNumber() + "]");
        this.childStartTime = new Date;
        this.child.start(filteredMetadata, {
          onReceiveMetadata: (metadata) => {
            this.trace("Received metadata");
            this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
          },
          onReceiveMessage: (message) => {
            this.trace("Received message");
            this.readFilterPending = true;
            this.filterStack.receiveMessage(message).then((filteredMesssage) => {
              this.trace("Finished filtering received message");
              this.readFilterPending = false;
              this.listener.onReceiveMessage(filteredMesssage);
              if (this.pendingChildStatus) {
                this.outputStatus(this.pendingChildStatus);
              }
            }, (status) => {
              this.cancelWithStatus(status.code, status.details);
            });
          },
          onReceiveStatus: (status) => {
            this.trace("Received status");
            if (this.readFilterPending) {
              this.pendingChildStatus = status;
            } else {
              this.outputStatus(status);
            }
          }
        });
        if (this.readPending) {
          this.child.startRead();
        }
        if (this.pendingMessage) {
          this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
        } else if (this.pendingHalfClose) {
          this.child.halfClose();
        }
      }, (status) => {
        this.outputStatus(status);
      });
    }
    reportResolverError(status) {
      var _a;
      if ((_a = this.metadata) === null || _a === undefined ? undefined : _a.getOptions().waitForReady) {
        this.channel.queueCallForConfig(this);
      } else {
        this.outputStatus(status);
      }
    }
    cancelWithStatus(status, details) {
      var _a;
      this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
      (_a = this.child) === null || _a === undefined || _a.cancelWithStatus(status, details);
      this.outputStatus({
        code: status,
        details,
        metadata: new metadata_1.Metadata
      });
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.child) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : this.channel.getTarget();
    }
    start(metadata, listener) {
      this.trace("start called");
      this.metadata = metadata.clone();
      this.listener = listener;
      this.getConfig();
    }
    sendMessageWithContext(context, message) {
      this.trace("write() called with message of length " + message.length);
      if (this.child) {
        this.sendMessageOnChild(context, message);
      } else {
        this.pendingMessage = { context, message };
      }
    }
    startRead() {
      this.trace("startRead called");
      if (this.child) {
        this.child.startRead();
      } else {
        this.readPending = true;
      }
    }
    halfClose() {
      this.trace("halfClose called");
      if (this.child && !this.writeFilterPending) {
        this.child.halfClose();
      } else {
        this.pendingHalfClose = true;
      }
    }
    setCredentials(credentials) {
      this.credentials = credentials;
    }
    addStatusWatcher(watcher) {
      this.statusWatchers.push(watcher);
    }
    getCallNumber() {
      return this.callNumber;
    }
  }
  exports.ResolvingCall = ResolvingCall;
});

// node_modules/@grpc/grpc-js/build/src/retrying-call.js
var require_retrying_call = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = undefined;
  var constants_1 = require_constants2();
  var deadline_1 = require_deadline();
  var metadata_1 = require_metadata();
  var logging = require_logging();
  var TRACER_NAME = "retrying_call";

  class RetryThrottler {
    constructor(maxTokens, tokenRatio, previousRetryThrottler) {
      this.maxTokens = maxTokens;
      this.tokenRatio = tokenRatio;
      if (previousRetryThrottler) {
        this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);
      } else {
        this.tokens = maxTokens;
      }
    }
    addCallSucceeded() {
      this.tokens = Math.min(this.tokens + this.tokenRatio, this.maxTokens);
    }
    addCallFailed() {
      this.tokens = Math.max(this.tokens - 1, 0);
    }
    canRetryCall() {
      return this.tokens > this.maxTokens / 2;
    }
  }
  exports.RetryThrottler = RetryThrottler;

  class MessageBufferTracker {
    constructor(totalLimit, limitPerCall) {
      this.totalLimit = totalLimit;
      this.limitPerCall = limitPerCall;
      this.totalAllocated = 0;
      this.allocatedPerCall = new Map;
    }
    allocate(size, callId) {
      var _a;
      const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
      if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {
        return false;
      }
      this.allocatedPerCall.set(callId, currentPerCall + size);
      this.totalAllocated += size;
      return true;
    }
    free(size, callId) {
      var _a;
      if (this.totalAllocated < size) {
        throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);
      }
      this.totalAllocated -= size;
      const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
      if (currentPerCall < size) {
        throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);
      }
      this.allocatedPerCall.set(callId, currentPerCall - size);
    }
    freeAll(callId) {
      var _a;
      const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
      if (this.totalAllocated < currentPerCall) {
        throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
      }
      this.totalAllocated -= currentPerCall;
      this.allocatedPerCall.delete(callId);
    }
  }
  exports.MessageBufferTracker = MessageBufferTracker;
  var PREVIONS_RPC_ATTEMPTS_METADATA_KEY = "grpc-previous-rpc-attempts";
  var DEFAULT_MAX_ATTEMPTS_LIMIT = 5;

  class RetryingCall {
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {
      var _a;
      this.channel = channel;
      this.callConfig = callConfig;
      this.methodName = methodName;
      this.host = host;
      this.credentials = credentials;
      this.deadline = deadline;
      this.callNumber = callNumber;
      this.bufferTracker = bufferTracker;
      this.retryThrottler = retryThrottler;
      this.listener = null;
      this.initialMetadata = null;
      this.underlyingCalls = [];
      this.writeBuffer = [];
      this.writeBufferOffset = 0;
      this.readStarted = false;
      this.transparentRetryUsed = false;
      this.attempts = 0;
      this.hedgingTimer = null;
      this.committedCallIndex = null;
      this.initialRetryBackoffSec = 0;
      this.nextRetryBackoffSec = 0;
      const maxAttemptsLimit = (_a = channel.getOptions()["grpc-node.retry_max_attempts_limit"]) !== null && _a !== undefined ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;
      if (channel.getOptions()["grpc.enable_retries"] === 0) {
        this.state = "NO_RETRY";
        this.maxAttempts = 1;
      } else if (callConfig.methodConfig.retryPolicy) {
        this.state = "RETRY";
        const retryPolicy = callConfig.methodConfig.retryPolicy;
        this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
        this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);
      } else if (callConfig.methodConfig.hedgingPolicy) {
        this.state = "HEDGING";
        this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);
      } else {
        this.state = "TRANSPARENT_ONLY";
        this.maxAttempts = 1;
      }
      this.startTime = new Date;
    }
    getDeadlineInfo() {
      if (this.underlyingCalls.length === 0) {
        return [];
      }
      const deadlineInfo = [];
      const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
      if (this.underlyingCalls.length > 1) {
        deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
      }
      if (latestCall.startTime > this.startTime) {
        deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);
      }
      deadlineInfo.push(...latestCall.call.getDeadlineInfo());
      return deadlineInfo;
    }
    getCallNumber() {
      return this.callNumber;
    }
    trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
    }
    reportStatus(statusObject) {
      this.trace("ended with status: code=" + statusObject.code + ' details="' + statusObject.details + '" start time=' + this.startTime.toISOString());
      this.bufferTracker.freeAll(this.callNumber);
      this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
      this.writeBuffer = [];
      process.nextTick(() => {
        var _a;
        (_a = this.listener) === null || _a === undefined || _a.onReceiveStatus({
          code: statusObject.code,
          details: statusObject.details,
          metadata: statusObject.metadata
        });
      });
    }
    cancelWithStatus(status, details) {
      this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
      this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata });
      for (const { call } of this.underlyingCalls) {
        call.cancelWithStatus(status, details);
      }
    }
    getPeer() {
      if (this.committedCallIndex !== null) {
        return this.underlyingCalls[this.committedCallIndex].call.getPeer();
      } else {
        return "unknown";
      }
    }
    getBufferEntry(messageIndex) {
      var _a;
      return (_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== undefined ? _a : {
        entryType: "FREED",
        allocated: false
      };
    }
    getNextBufferIndex() {
      return this.writeBufferOffset + this.writeBuffer.length;
    }
    clearSentMessages() {
      if (this.state !== "COMMITTED") {
        return;
      }
      let earliestNeededMessageIndex;
      if (this.underlyingCalls[this.committedCallIndex].state === "COMPLETED") {
        earliestNeededMessageIndex = this.getNextBufferIndex();
      } else {
        earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;
      }
      for (let messageIndex = this.writeBufferOffset;messageIndex < earliestNeededMessageIndex; messageIndex++) {
        const bufferEntry = this.getBufferEntry(messageIndex);
        if (bufferEntry.allocated) {
          this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
        }
      }
      this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);
      this.writeBufferOffset = earliestNeededMessageIndex;
    }
    commitCall(index) {
      var _a, _b;
      if (this.state === "COMMITTED") {
        return;
      }
      this.trace("Committing call [" + this.underlyingCalls[index].call.getCallNumber() + "] at index " + index);
      this.state = "COMMITTED";
      (_b = (_a = this.callConfig).onCommitted) === null || _b === undefined || _b.call(_a);
      this.committedCallIndex = index;
      for (let i = 0;i < this.underlyingCalls.length; i++) {
        if (i === index) {
          continue;
        }
        if (this.underlyingCalls[i].state === "COMPLETED") {
          continue;
        }
        this.underlyingCalls[i].state = "COMPLETED";
        this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, "Discarded in favor of other hedged attempt");
      }
      this.clearSentMessages();
    }
    commitCallWithMostMessages() {
      if (this.state === "COMMITTED") {
        return;
      }
      let mostMessages = -1;
      let callWithMostMessages = -1;
      for (const [index, childCall] of this.underlyingCalls.entries()) {
        if (childCall.state === "ACTIVE" && childCall.nextMessageToSend > mostMessages) {
          mostMessages = childCall.nextMessageToSend;
          callWithMostMessages = index;
        }
      }
      if (callWithMostMessages === -1) {
        this.state = "TRANSPARENT_ONLY";
      } else {
        this.commitCall(callWithMostMessages);
      }
    }
    isStatusCodeInList(list, code) {
      return list.some((value) => {
        var _a;
        return value === code || value.toString().toLowerCase() === ((_a = constants_1.Status[code]) === null || _a === undefined ? undefined : _a.toLowerCase());
      });
    }
    getNextRetryBackoffMs() {
      var _a;
      const retryPolicy = (_a = this.callConfig) === null || _a === undefined ? undefined : _a.methodConfig.retryPolicy;
      if (!retryPolicy) {
        return 0;
      }
      const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;
      const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
      this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
      return nextBackoffMs;
    }
    maybeRetryCall(pushback, callback) {
      if (this.state !== "RETRY") {
        callback(false);
        return;
      }
      if (this.attempts >= this.maxAttempts) {
        callback(false);
        return;
      }
      let retryDelayMs;
      if (pushback === null) {
        retryDelayMs = this.getNextRetryBackoffMs();
      } else if (pushback < 0) {
        this.state = "TRANSPARENT_ONLY";
        callback(false);
        return;
      } else {
        retryDelayMs = pushback;
        this.nextRetryBackoffSec = this.initialRetryBackoffSec;
      }
      setTimeout(() => {
        var _a, _b;
        if (this.state !== "RETRY") {
          callback(false);
          return;
        }
        if ((_b = (_a = this.retryThrottler) === null || _a === undefined ? undefined : _a.canRetryCall()) !== null && _b !== undefined ? _b : true) {
          callback(true);
          this.attempts += 1;
          this.startNewAttempt();
        } else {
          this.trace("Retry attempt denied by throttling policy");
          callback(false);
        }
      }, retryDelayMs);
    }
    countActiveCalls() {
      let count = 0;
      for (const call of this.underlyingCalls) {
        if ((call === null || call === undefined ? undefined : call.state) === "ACTIVE") {
          count += 1;
        }
      }
      return count;
    }
    handleProcessedStatus(status, callIndex, pushback) {
      var _a, _b, _c;
      switch (this.state) {
        case "COMMITTED":
        case "NO_RETRY":
        case "TRANSPARENT_ONLY":
          this.commitCall(callIndex);
          this.reportStatus(status);
          break;
        case "HEDGING":
          if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== undefined ? _a : [], status.code)) {
            (_b = this.retryThrottler) === null || _b === undefined || _b.addCallFailed();
            let delayMs;
            if (pushback === null) {
              delayMs = 0;
            } else if (pushback < 0) {
              this.state = "TRANSPARENT_ONLY";
              this.commitCall(callIndex);
              this.reportStatus(status);
              return;
            } else {
              delayMs = pushback;
            }
            setTimeout(() => {
              this.maybeStartHedgingAttempt();
              if (this.countActiveCalls() === 0) {
                this.commitCall(callIndex);
                this.reportStatus(status);
              }
            }, delayMs);
          } else {
            this.commitCall(callIndex);
            this.reportStatus(status);
          }
          break;
        case "RETRY":
          if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
            (_c = this.retryThrottler) === null || _c === undefined || _c.addCallFailed();
            this.maybeRetryCall(pushback, (retried) => {
              if (!retried) {
                this.commitCall(callIndex);
                this.reportStatus(status);
              }
            });
          } else {
            this.commitCall(callIndex);
            this.reportStatus(status);
          }
          break;
      }
    }
    getPushback(metadata) {
      const mdValue = metadata.get("grpc-retry-pushback-ms");
      if (mdValue.length === 0) {
        return null;
      }
      try {
        return parseInt(mdValue[0]);
      } catch (e) {
        return -1;
      }
    }
    handleChildStatus(status, callIndex) {
      var _a;
      if (this.underlyingCalls[callIndex].state === "COMPLETED") {
        return;
      }
      this.trace("state=" + this.state + " handling status with progress " + status.progress + " from child [" + this.underlyingCalls[callIndex].call.getCallNumber() + "] in state " + this.underlyingCalls[callIndex].state);
      this.underlyingCalls[callIndex].state = "COMPLETED";
      if (status.code === constants_1.Status.OK) {
        (_a = this.retryThrottler) === null || _a === undefined || _a.addCallSucceeded();
        this.commitCall(callIndex);
        this.reportStatus(status);
        return;
      }
      if (this.state === "NO_RETRY") {
        this.commitCall(callIndex);
        this.reportStatus(status);
        return;
      }
      if (this.state === "COMMITTED") {
        this.reportStatus(status);
        return;
      }
      const pushback = this.getPushback(status.metadata);
      switch (status.progress) {
        case "NOT_STARTED":
          this.startNewAttempt();
          break;
        case "REFUSED":
          if (this.transparentRetryUsed) {
            this.handleProcessedStatus(status, callIndex, pushback);
          } else {
            this.transparentRetryUsed = true;
            this.startNewAttempt();
          }
          break;
        case "DROP":
          this.commitCall(callIndex);
          this.reportStatus(status);
          break;
        case "PROCESSED":
          this.handleProcessedStatus(status, callIndex, pushback);
          break;
      }
    }
    maybeStartHedgingAttempt() {
      if (this.state !== "HEDGING") {
        return;
      }
      if (!this.callConfig.methodConfig.hedgingPolicy) {
        return;
      }
      if (this.attempts >= this.maxAttempts) {
        return;
      }
      this.attempts += 1;
      this.startNewAttempt();
      this.maybeStartHedgingTimer();
    }
    maybeStartHedgingTimer() {
      var _a, _b, _c;
      if (this.hedgingTimer) {
        clearTimeout(this.hedgingTimer);
      }
      if (this.state !== "HEDGING") {
        return;
      }
      if (!this.callConfig.methodConfig.hedgingPolicy) {
        return;
      }
      const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
      if (this.attempts >= this.maxAttempts) {
        return;
      }
      const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== undefined ? _a : "0s";
      const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
      this.hedgingTimer = setTimeout(() => {
        this.maybeStartHedgingAttempt();
      }, hedgingDelaySec * 1000);
      (_c = (_b = this.hedgingTimer).unref) === null || _c === undefined || _c.call(_b);
    }
    startNewAttempt() {
      const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
      this.trace("Created child call [" + child.getCallNumber() + "] for attempt " + this.attempts);
      const index = this.underlyingCalls.length;
      this.underlyingCalls.push({
        state: "ACTIVE",
        call: child,
        nextMessageToSend: 0,
        startTime: new Date
      });
      const previousAttempts = this.attempts - 1;
      const initialMetadata = this.initialMetadata.clone();
      if (previousAttempts > 0) {
        initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
      }
      let receivedMetadata = false;
      child.start(initialMetadata, {
        onReceiveMetadata: (metadata) => {
          this.trace("Received metadata from child [" + child.getCallNumber() + "]");
          this.commitCall(index);
          receivedMetadata = true;
          if (previousAttempts > 0) {
            metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
          }
          if (this.underlyingCalls[index].state === "ACTIVE") {
            this.listener.onReceiveMetadata(metadata);
          }
        },
        onReceiveMessage: (message) => {
          this.trace("Received message from child [" + child.getCallNumber() + "]");
          this.commitCall(index);
          if (this.underlyingCalls[index].state === "ACTIVE") {
            this.listener.onReceiveMessage(message);
          }
        },
        onReceiveStatus: (status) => {
          this.trace("Received status from child [" + child.getCallNumber() + "]");
          if (!receivedMetadata && previousAttempts > 0) {
            status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
          }
          this.handleChildStatus(status, index);
        }
      });
      this.sendNextChildMessage(index);
      if (this.readStarted) {
        child.startRead();
      }
    }
    start(metadata, listener) {
      this.trace("start called");
      this.listener = listener;
      this.initialMetadata = metadata;
      this.attempts += 1;
      this.startNewAttempt();
      this.maybeStartHedgingTimer();
    }
    handleChildWriteCompleted(childIndex) {
      var _a, _b;
      const childCall = this.underlyingCalls[childIndex];
      const messageIndex = childCall.nextMessageToSend;
      (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === undefined || _b.call(_a);
      this.clearSentMessages();
      childCall.nextMessageToSend += 1;
      this.sendNextChildMessage(childIndex);
    }
    sendNextChildMessage(childIndex) {
      const childCall = this.underlyingCalls[childIndex];
      if (childCall.state === "COMPLETED") {
        return;
      }
      if (this.getBufferEntry(childCall.nextMessageToSend)) {
        const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
        switch (bufferEntry.entryType) {
          case "MESSAGE":
            childCall.call.sendMessageWithContext({
              callback: (error) => {
                this.handleChildWriteCompleted(childIndex);
              }
            }, bufferEntry.message.message);
            break;
          case "HALF_CLOSE":
            childCall.nextMessageToSend += 1;
            childCall.call.halfClose();
            break;
          case "FREED":
            break;
        }
      }
    }
    sendMessageWithContext(context, message) {
      var _a;
      this.trace("write() called with message of length " + message.length);
      const writeObj = {
        message,
        flags: context.flags
      };
      const messageIndex = this.getNextBufferIndex();
      const bufferEntry = {
        entryType: "MESSAGE",
        message: writeObj,
        allocated: this.bufferTracker.allocate(message.length, this.callNumber)
      };
      this.writeBuffer.push(bufferEntry);
      if (bufferEntry.allocated) {
        (_a = context.callback) === null || _a === undefined || _a.call(context);
        for (const [callIndex, call] of this.underlyingCalls.entries()) {
          if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
            call.call.sendMessageWithContext({
              callback: (error) => {
                this.handleChildWriteCompleted(callIndex);
              }
            }, message);
          }
        }
      } else {
        this.commitCallWithMostMessages();
        if (this.committedCallIndex === null) {
          return;
        }
        const call = this.underlyingCalls[this.committedCallIndex];
        bufferEntry.callback = context.callback;
        if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
          call.call.sendMessageWithContext({
            callback: (error) => {
              this.handleChildWriteCompleted(this.committedCallIndex);
            }
          }, message);
        }
      }
    }
    startRead() {
      this.trace("startRead called");
      this.readStarted = true;
      for (const underlyingCall of this.underlyingCalls) {
        if ((underlyingCall === null || underlyingCall === undefined ? undefined : underlyingCall.state) === "ACTIVE") {
          underlyingCall.call.startRead();
        }
      }
    }
    halfClose() {
      this.trace("halfClose called");
      const halfCloseIndex = this.getNextBufferIndex();
      this.writeBuffer.push({
        entryType: "HALF_CLOSE",
        allocated: false
      });
      for (const call of this.underlyingCalls) {
        if ((call === null || call === undefined ? undefined : call.state) === "ACTIVE" && call.nextMessageToSend === halfCloseIndex) {
          call.nextMessageToSend += 1;
          call.call.halfClose();
        }
      }
    }
    setCredentials(newCredentials) {
      throw new Error("Method not implemented.");
    }
    getMethod() {
      return this.methodName;
    }
    getHost() {
      return this.host;
    }
  }
  exports.RetryingCall = RetryingCall;
});

// node_modules/@grpc/grpc-js/build/src/subchannel-interface.js
var require_subchannel_interface = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseSubchannelWrapper = undefined;

  class BaseSubchannelWrapper {
    constructor(child) {
      this.child = child;
      this.healthy = true;
      this.healthListeners = new Set;
      child.addHealthStateWatcher((childHealthy) => {
        if (this.healthy) {
          this.updateHealthListeners();
        }
      });
    }
    updateHealthListeners() {
      for (const listener of this.healthListeners) {
        listener(this.isHealthy());
      }
    }
    getConnectivityState() {
      return this.child.getConnectivityState();
    }
    addConnectivityStateListener(listener) {
      this.child.addConnectivityStateListener(listener);
    }
    removeConnectivityStateListener(listener) {
      this.child.removeConnectivityStateListener(listener);
    }
    startConnecting() {
      this.child.startConnecting();
    }
    getAddress() {
      return this.child.getAddress();
    }
    throttleKeepalive(newKeepaliveTime) {
      this.child.throttleKeepalive(newKeepaliveTime);
    }
    ref() {
      this.child.ref();
    }
    unref() {
      this.child.unref();
    }
    getChannelzRef() {
      return this.child.getChannelzRef();
    }
    isHealthy() {
      return this.healthy && this.child.isHealthy();
    }
    addHealthStateWatcher(listener) {
      this.healthListeners.add(listener);
    }
    removeHealthStateWatcher(listener) {
      this.healthListeners.delete(listener);
    }
    setHealthy(healthy) {
      if (healthy !== this.healthy) {
        this.healthy = healthy;
        if (this.child.isHealthy()) {
          this.updateHealthListeners();
        }
      }
    }
    getRealSubchannel() {
      return this.child.getRealSubchannel();
    }
    realSubchannelEquals(other) {
      return this.getRealSubchannel() === other.getRealSubchannel();
    }
    getCallCredentials() {
      return this.child.getCallCredentials();
    }
  }
  exports.BaseSubchannelWrapper = BaseSubchannelWrapper;
});

// node_modules/@grpc/grpc-js/build/src/internal-channel.js
var require_internal_channel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InternalChannel = exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = undefined;
  var channel_credentials_1 = require_channel_credentials();
  var resolving_load_balancer_1 = require_resolving_load_balancer();
  var subchannel_pool_1 = require_subchannel_pool();
  var picker_1 = require_picker();
  var metadata_1 = require_metadata();
  var constants_1 = require_constants2();
  var filter_stack_1 = require_filter_stack();
  var compression_filter_1 = require_compression_filter();
  var resolver_1 = require_resolver();
  var logging_1 = require_logging();
  var http_proxy_1 = require_http_proxy();
  var uri_parser_1 = require_uri_parser();
  var connectivity_state_1 = require_connectivity_state();
  var channelz_1 = require_channelz();
  var load_balancing_call_1 = require_load_balancing_call();
  var deadline_1 = require_deadline();
  var resolving_call_1 = require_resolving_call();
  var call_number_1 = require_call_number();
  var control_plane_status_1 = require_control_plane_status();
  var retrying_call_1 = require_retrying_call();
  var subchannel_interface_1 = require_subchannel_interface();
  var MAX_TIMEOUT_TIME = 2147483647;
  var MIN_IDLE_TIMEOUT_MS = 1000;
  var DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;
  var RETRY_THROTTLER_MAP = new Map;
  var DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24;
  var DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20;

  class ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
    constructor(childSubchannel, channel) {
      super(childSubchannel);
      this.channel = channel;
      this.refCount = 0;
      this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {
        channel.throttleKeepalive(keepaliveTime);
      };
    }
    ref() {
      if (this.refCount === 0) {
        this.child.addConnectivityStateListener(this.subchannelStateListener);
        this.channel.addWrappedSubchannel(this);
      }
      this.child.ref();
      this.refCount += 1;
    }
    unref() {
      this.child.unref();
      this.refCount -= 1;
      if (this.refCount <= 0) {
        this.child.removeConnectivityStateListener(this.subchannelStateListener);
        this.channel.removeWrappedSubchannel(this);
      }
    }
  }

  class ShutdownPicker {
    pick(pickArgs) {
      return {
        pickResultType: picker_1.PickResultType.DROP,
        status: {
          code: constants_1.Status.UNAVAILABLE,
          details: "Channel closed before call started",
          metadata: new metadata_1.Metadata
        },
        subchannel: null,
        onCallStarted: null,
        onCallEnded: null
      };
    }
  }
  exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = "grpc.internal.no_subchannel";

  class ChannelzInfoTracker {
    constructor(target) {
      this.target = target;
      this.trace = new channelz_1.ChannelzTrace;
      this.callTracker = new channelz_1.ChannelzCallTracker;
      this.childrenTracker = new channelz_1.ChannelzChildrenTracker;
      this.state = connectivity_state_1.ConnectivityState.IDLE;
    }
    getChannelzInfoCallback() {
      return () => {
        return {
          target: this.target,
          state: this.state,
          trace: this.trace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists()
        };
      };
    }
  }

  class InternalChannel {
    constructor(target, credentials, options) {
      var _a, _b, _c, _d, _e, _f;
      this.credentials = credentials;
      this.options = options;
      this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
      this.currentPicker = new picker_1.UnavailablePicker;
      this.configSelectionQueue = [];
      this.pickQueue = [];
      this.connectivityStateWatchers = [];
      this.callRefTimer = null;
      this.configSelector = null;
      this.currentResolutionError = null;
      this.wrappedSubchannels = new Set;
      this.callCount = 0;
      this.idleTimer = null;
      this.channelzEnabled = true;
      this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
      if (typeof target !== "string") {
        throw new TypeError("Channel target must be a string");
      }
      if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
        throw new TypeError("Channel credentials must be a ChannelCredentials object");
      }
      if (options) {
        if (typeof options !== "object") {
          throw new TypeError("Channel options must be an object");
        }
      }
      this.channelzInfoTracker = new ChannelzInfoTracker(target);
      const originalTargetUri = (0, uri_parser_1.parseUri)(target);
      if (originalTargetUri === null) {
        throw new Error(`Could not parse target name "${target}"`);
      }
      const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
      if (defaultSchemeMapResult === null) {
        throw new Error(`Could not find a default scheme for target name "${target}"`);
      }
      if (this.options["grpc.enable_channelz"] === 0) {
        this.channelzEnabled = false;
      }
      this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, this.channelzInfoTracker.getChannelzInfoCallback(), this.channelzEnabled);
      if (this.channelzEnabled) {
        this.channelzInfoTracker.trace.addTrace("CT_INFO", "Channel created");
      }
      if (this.options["grpc.default_authority"]) {
        this.defaultAuthority = this.options["grpc.default_authority"];
      } else {
        this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
      }
      const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
      this.target = proxyMapResult.target;
      this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
      this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_a = this.options["grpc.use_local_subchannel_pool"]) !== null && _a !== undefined ? _a : 0) === 0);
      this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_b = this.options["grpc.retry_buffer_size"]) !== null && _b !== undefined ? _b : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_c = this.options["grpc.per_rpc_retry_buffer_size"]) !== null && _c !== undefined ? _c : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
      this.keepaliveTime = (_d = this.options["grpc.keepalive_time_ms"]) !== null && _d !== undefined ? _d : -1;
      this.idleTimeoutMs = Math.max((_e = this.options["grpc.client_idle_timeout_ms"]) !== null && _e !== undefined ? _e : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);
      const channelControlHelper = {
        createSubchannel: (subchannelAddress, subchannelArgs) => {
          const finalSubchannelArgs = {};
          for (const [key, value] of Object.entries(subchannelArgs)) {
            if (!key.startsWith(exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX)) {
              finalSubchannelArgs[key] = value;
            }
          }
          const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, finalSubchannelArgs, this.credentials);
          subchannel.throttleKeepalive(this.keepaliveTime);
          if (this.channelzEnabled) {
            this.channelzInfoTracker.trace.addTrace("CT_INFO", "Created subchannel or used existing subchannel", subchannel.getChannelzRef());
          }
          const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);
          return wrappedSubchannel;
        },
        updateState: (connectivityState, picker) => {
          this.currentPicker = picker;
          const queueCopy = this.pickQueue.slice();
          this.pickQueue = [];
          if (queueCopy.length > 0) {
            this.callRefTimerUnref();
          }
          for (const call of queueCopy) {
            call.doPick();
          }
          this.updateState(connectivityState);
        },
        requestReresolution: () => {
          throw new Error("Resolving load balancer should never call requestReresolution");
        },
        addChannelzChild: (child) => {
          if (this.channelzEnabled) {
            this.channelzInfoTracker.childrenTracker.refChild(child);
          }
        },
        removeChannelzChild: (child) => {
          if (this.channelzEnabled) {
            this.channelzInfoTracker.childrenTracker.unrefChild(child);
          }
        }
      };
      this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, this.options, (serviceConfig, configSelector) => {
        var _a2;
        if (serviceConfig.retryThrottling) {
          RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
        } else {
          RETRY_THROTTLER_MAP.delete(this.getTarget());
        }
        if (this.channelzEnabled) {
          this.channelzInfoTracker.trace.addTrace("CT_INFO", "Address resolution succeeded");
        }
        (_a2 = this.configSelector) === null || _a2 === undefined || _a2.unref();
        this.configSelector = configSelector;
        this.currentResolutionError = null;
        process.nextTick(() => {
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          if (localQueue.length > 0) {
            this.callRefTimerUnref();
          }
          for (const call of localQueue) {
            call.getConfig();
          }
        });
      }, (status) => {
        if (this.channelzEnabled) {
          this.channelzInfoTracker.trace.addTrace("CT_WARNING", "Address resolution failed with code " + status.code + ' and details "' + status.details + '"');
        }
        if (this.configSelectionQueue.length > 0) {
          this.trace("Name resolution failed with calls queued for config selection");
        }
        if (this.configSelector === null) {
          this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });
        }
        const localQueue = this.configSelectionQueue;
        this.configSelectionQueue = [];
        if (localQueue.length > 0) {
          this.callRefTimerUnref();
        }
        for (const call of localQueue) {
          call.reportResolverError(status);
        }
      });
      this.filterStackFactory = new filter_stack_1.FilterStackFactory([
        new compression_filter_1.CompressionFilterFactory(this, this.options)
      ]);
      this.trace("Channel constructed with options " + JSON.stringify(options, undefined, 2));
      const error = new Error;
      if ((0, logging_1.isTracerEnabled)("channel_stacktrace")) {
        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "channel_stacktrace", "(" + this.channelzRef.id + ") " + `Channel constructed 
` + ((_f = error.stack) === null || _f === undefined ? undefined : _f.substring(error.stack.indexOf(`
`) + 1)));
      }
      this.lastActivityTimestamp = new Date;
    }
    trace(text, verbosityOverride) {
      (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== undefined ? verbosityOverride : constants_1.LogVerbosity.DEBUG, "channel", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + text);
    }
    callRefTimerRef() {
      var _a, _b, _c, _d;
      if (!this.callRefTimer) {
        this.callRefTimer = setInterval(() => {
        }, MAX_TIMEOUT_TIME);
      }
      if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === undefined ? undefined : _b.call(_a))) {
        this.trace("callRefTimer.ref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
        (_d = (_c = this.callRefTimer).ref) === null || _d === undefined || _d.call(_c);
      }
    }
    callRefTimerUnref() {
      var _a, _b, _c;
      if (!((_a = this.callRefTimer) === null || _a === undefined ? undefined : _a.hasRef) || this.callRefTimer.hasRef()) {
        this.trace("callRefTimer.unref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
        (_c = (_b = this.callRefTimer) === null || _b === undefined ? undefined : _b.unref) === null || _c === undefined || _c.call(_b);
      }
    }
    removeConnectivityStateWatcher(watcherObject) {
      const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
      if (watcherIndex >= 0) {
        this.connectivityStateWatchers.splice(watcherIndex, 1);
      }
    }
    updateState(newState) {
      (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "connectivity_state", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
      if (this.channelzEnabled) {
        this.channelzInfoTracker.trace.addTrace("CT_INFO", "Connectivity state change to " + connectivity_state_1.ConnectivityState[newState]);
      }
      this.connectivityState = newState;
      this.channelzInfoTracker.state = newState;
      const watchersCopy = this.connectivityStateWatchers.slice();
      for (const watcherObject of watchersCopy) {
        if (newState !== watcherObject.currentState) {
          if (watcherObject.timer) {
            clearTimeout(watcherObject.timer);
          }
          this.removeConnectivityStateWatcher(watcherObject);
          watcherObject.callback();
        }
      }
      if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
        this.currentResolutionError = null;
      }
    }
    throttleKeepalive(newKeepaliveTime) {
      if (newKeepaliveTime > this.keepaliveTime) {
        this.keepaliveTime = newKeepaliveTime;
        for (const wrappedSubchannel of this.wrappedSubchannels) {
          wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
        }
      }
    }
    addWrappedSubchannel(wrappedSubchannel) {
      this.wrappedSubchannels.add(wrappedSubchannel);
    }
    removeWrappedSubchannel(wrappedSubchannel) {
      this.wrappedSubchannels.delete(wrappedSubchannel);
    }
    doPick(metadata, extraPickInfo) {
      return this.currentPicker.pick({
        metadata,
        extraPickInfo
      });
    }
    queueCallForPick(call) {
      this.pickQueue.push(call);
      this.callRefTimerRef();
    }
    getConfig(method, metadata) {
      if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {
        this.resolvingLoadBalancer.exitIdle();
      }
      if (this.configSelector) {
        return {
          type: "SUCCESS",
          config: this.configSelector.invoke(method, metadata, this.randomChannelId)
        };
      } else {
        if (this.currentResolutionError) {
          return {
            type: "ERROR",
            error: this.currentResolutionError
          };
        } else {
          return {
            type: "NONE"
          };
        }
      }
    }
    queueCallForConfig(call) {
      this.configSelectionQueue.push(call);
      this.callRefTimerRef();
    }
    enterIdle() {
      this.resolvingLoadBalancer.destroy();
      this.updateState(connectivity_state_1.ConnectivityState.IDLE);
      this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);
      if (this.idleTimer) {
        clearTimeout(this.idleTimer);
        this.idleTimer = null;
      }
      if (this.callRefTimer) {
        clearInterval(this.callRefTimer);
        this.callRefTimer = null;
      }
    }
    startIdleTimeout(timeoutMs) {
      var _a, _b;
      this.idleTimer = setTimeout(() => {
        if (this.callCount > 0) {
          this.startIdleTimeout(this.idleTimeoutMs);
          return;
        }
        const now = new Date;
        const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();
        if (timeSinceLastActivity >= this.idleTimeoutMs) {
          this.trace("Idle timer triggered after " + this.idleTimeoutMs + "ms of inactivity");
          this.enterIdle();
        } else {
          this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
        }
      }, timeoutMs);
      (_b = (_a = this.idleTimer).unref) === null || _b === undefined || _b.call(_a);
    }
    maybeStartIdleTimer() {
      if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {
        this.startIdleTimeout(this.idleTimeoutMs);
      }
    }
    onCallStart() {
      if (this.channelzEnabled) {
        this.channelzInfoTracker.callTracker.addCallStarted();
      }
      this.callCount += 1;
    }
    onCallEnd(status) {
      if (this.channelzEnabled) {
        if (status.code === constants_1.Status.OK) {
          this.channelzInfoTracker.callTracker.addCallSucceeded();
        } else {
          this.channelzInfoTracker.callTracker.addCallFailed();
        }
      }
      this.callCount -= 1;
      this.lastActivityTimestamp = new Date;
      this.maybeStartIdleTimer();
    }
    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {
      const callNumber = (0, call_number_1.getNextCallNumber)();
      this.trace("createLoadBalancingCall [" + callNumber + '] method="' + method + '"');
      return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
    }
    createRetryingCall(callConfig, method, host, credentials, deadline) {
      const callNumber = (0, call_number_1.getNextCallNumber)();
      this.trace("createRetryingCall [" + callNumber + '] method="' + method + '"');
      return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
    }
    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
      const callNumber = (0, call_number_1.getNextCallNumber)();
      this.trace("createResolvingCall [" + callNumber + '] method="' + method + '", deadline=' + (0, deadline_1.deadlineToString)(deadline));
      const finalOptions = {
        deadline,
        flags: propagateFlags !== null && propagateFlags !== undefined ? propagateFlags : constants_1.Propagate.DEFAULTS,
        host: host !== null && host !== undefined ? host : this.defaultAuthority,
        parentCall
      };
      const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), callNumber);
      this.onCallStart();
      call.addStatusWatcher((status) => {
        this.onCallEnd(status);
      });
      return call;
    }
    close() {
      var _a;
      this.resolvingLoadBalancer.destroy();
      this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
      this.currentPicker = new ShutdownPicker;
      for (const call of this.configSelectionQueue) {
        call.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Channel closed before call started");
      }
      this.configSelectionQueue = [];
      for (const call of this.pickQueue) {
        call.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Channel closed before call started");
      }
      this.pickQueue = [];
      if (this.callRefTimer) {
        clearInterval(this.callRefTimer);
      }
      if (this.idleTimer) {
        clearTimeout(this.idleTimer);
      }
      if (this.channelzEnabled) {
        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
      }
      this.subchannelPool.unrefUnusedSubchannels();
      (_a = this.configSelector) === null || _a === undefined || _a.unref();
      this.configSelector = null;
    }
    getTarget() {
      return (0, uri_parser_1.uriToString)(this.target);
    }
    getConnectivityState(tryToConnect) {
      const connectivityState = this.connectivityState;
      if (tryToConnect) {
        this.resolvingLoadBalancer.exitIdle();
        this.lastActivityTimestamp = new Date;
        this.maybeStartIdleTimer();
      }
      return connectivityState;
    }
    watchConnectivityState(currentState, deadline, callback) {
      if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
        throw new Error("Channel has been shut down");
      }
      let timer = null;
      if (deadline !== Infinity) {
        const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
        const now = new Date;
        if (deadline === -Infinity || deadlineDate <= now) {
          process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
          return;
        }
        timer = setTimeout(() => {
          this.removeConnectivityStateWatcher(watcherObject);
          callback(new Error("Deadline passed without connectivity state change"));
        }, deadlineDate.getTime() - now.getTime());
      }
      const watcherObject = {
        currentState,
        callback,
        timer
      };
      this.connectivityStateWatchers.push(watcherObject);
    }
    getChannelzRef() {
      return this.channelzRef;
    }
    createCall(method, deadline, host, parentCall, propagateFlags) {
      if (typeof method !== "string") {
        throw new TypeError("Channel#createCall: method must be a string");
      }
      if (!(typeof deadline === "number" || deadline instanceof Date)) {
        throw new TypeError("Channel#createCall: deadline must be a number or Date");
      }
      if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
        throw new Error("Channel has been shut down");
      }
      return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
    }
    getOptions() {
      return this.options;
    }
  }
  exports.InternalChannel = InternalChannel;
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChannelImplementation = undefined;
  var channel_credentials_1 = require_channel_credentials();
  var internal_channel_1 = require_internal_channel();

  class ChannelImplementation {
    constructor(target, credentials, options) {
      if (typeof target !== "string") {
        throw new TypeError("Channel target must be a string");
      }
      if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
        throw new TypeError("Channel credentials must be a ChannelCredentials object");
      }
      if (options) {
        if (typeof options !== "object") {
          throw new TypeError("Channel options must be an object");
        }
      }
      this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);
    }
    close() {
      this.internalChannel.close();
    }
    getTarget() {
      return this.internalChannel.getTarget();
    }
    getConnectivityState(tryToConnect) {
      return this.internalChannel.getConnectivityState(tryToConnect);
    }
    watchConnectivityState(currentState, deadline, callback) {
      this.internalChannel.watchConnectivityState(currentState, deadline, callback);
    }
    getChannelzRef() {
      return this.internalChannel.getChannelzRef();
    }
    createCall(method, deadline, host, parentCall, propagateFlags) {
      if (typeof method !== "string") {
        throw new TypeError("Channel#createCall: method must be a string");
      }
      if (!(typeof deadline === "number" || deadline instanceof Date)) {
        throw new TypeError("Channel#createCall: deadline must be a number or Date");
      }
      return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
    }
  }
  exports.ChannelImplementation = ChannelImplementation;
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = undefined;
  exports.serverErrorToStatus = serverErrorToStatus;
  var events_1 = __require("events");
  var stream_1 = __require("stream");
  var constants_1 = require_constants2();
  var metadata_1 = require_metadata();
  function serverErrorToStatus(error, overrideTrailers) {
    var _a;
    const status = {
      code: constants_1.Status.UNKNOWN,
      details: "message" in error ? error.message : "Unknown Error",
      metadata: (_a = overrideTrailers !== null && overrideTrailers !== undefined ? overrideTrailers : error.metadata) !== null && _a !== undefined ? _a : null
    };
    if ("code" in error && typeof error.code === "number" && Number.isInteger(error.code)) {
      status.code = error.code;
      if ("details" in error && typeof error.details === "string") {
        status.details = error.details;
      }
    }
    return status;
  }

  class ServerUnaryCallImpl extends events_1.EventEmitter {
    constructor(path, call, metadata, request2) {
      super();
      this.path = path;
      this.call = call;
      this.metadata = metadata;
      this.request = request2;
      this.cancelled = false;
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
    getPath() {
      return this.path;
    }
    getHost() {
      return this.call.getHost();
    }
  }
  exports.ServerUnaryCallImpl = ServerUnaryCallImpl;

  class ServerReadableStreamImpl extends stream_1.Readable {
    constructor(path, call, metadata) {
      super({ objectMode: true });
      this.path = path;
      this.call = call;
      this.metadata = metadata;
      this.cancelled = false;
    }
    _read(size) {
      this.call.startRead();
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
    getPath() {
      return this.path;
    }
    getHost() {
      return this.call.getHost();
    }
  }
  exports.ServerReadableStreamImpl = ServerReadableStreamImpl;

  class ServerWritableStreamImpl extends stream_1.Writable {
    constructor(path, call, metadata, request2) {
      super({ objectMode: true });
      this.path = path;
      this.call = call;
      this.metadata = metadata;
      this.request = request2;
      this.pendingStatus = {
        code: constants_1.Status.OK,
        details: "OK"
      };
      this.cancelled = false;
      this.trailingMetadata = new metadata_1.Metadata;
      this.on("error", (err) => {
        this.pendingStatus = serverErrorToStatus(err);
        this.end();
      });
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
    getPath() {
      return this.path;
    }
    getHost() {
      return this.call.getHost();
    }
    _write(chunk, encoding, callback) {
      this.call.sendMessage(chunk, callback);
    }
    _final(callback) {
      var _a;
      callback(null);
      this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== undefined ? _a : this.trailingMetadata }));
    }
    end(metadata) {
      if (metadata) {
        this.trailingMetadata = metadata;
      }
      return super.end();
    }
  }
  exports.ServerWritableStreamImpl = ServerWritableStreamImpl;

  class ServerDuplexStreamImpl extends stream_1.Duplex {
    constructor(path, call, metadata) {
      super({ objectMode: true });
      this.path = path;
      this.call = call;
      this.metadata = metadata;
      this.pendingStatus = {
        code: constants_1.Status.OK,
        details: "OK"
      };
      this.cancelled = false;
      this.trailingMetadata = new metadata_1.Metadata;
      this.on("error", (err) => {
        this.pendingStatus = serverErrorToStatus(err);
        this.end();
      });
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
    getPath() {
      return this.path;
    }
    getHost() {
      return this.call.getHost();
    }
    _read(size) {
      this.call.startRead();
    }
    _write(chunk, encoding, callback) {
      this.call.sendMessage(chunk, callback);
    }
    _final(callback) {
      var _a;
      callback(null);
      this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== undefined ? _a : this.trailingMetadata }));
    }
    end(metadata) {
      if (metadata) {
        this.trailingMetadata = metadata;
      }
      return super.end();
    }
  }
  exports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCredentials = undefined;
  exports.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;
  exports.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;
  var tls_helpers_1 = require_tls_helpers();

  class ServerCredentials {
    constructor(serverConstructorOptions, contextOptions) {
      this.serverConstructorOptions = serverConstructorOptions;
      this.watchers = new Set;
      this.latestContextOptions = null;
      this.latestContextOptions = contextOptions !== null && contextOptions !== undefined ? contextOptions : null;
    }
    _addWatcher(watcher) {
      this.watchers.add(watcher);
    }
    _removeWatcher(watcher) {
      this.watchers.delete(watcher);
    }
    getWatcherCount() {
      return this.watchers.size;
    }
    updateSecureContextOptions(options) {
      this.latestContextOptions = options;
      for (const watcher of this.watchers) {
        watcher(this.latestContextOptions);
      }
    }
    _isSecure() {
      return this.serverConstructorOptions !== null;
    }
    _getSecureContextOptions() {
      return this.latestContextOptions;
    }
    _getConstructorOptions() {
      return this.serverConstructorOptions;
    }
    _getInterceptors() {
      return [];
    }
    static createInsecure() {
      return new InsecureServerCredentials;
    }
    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
      var _a;
      if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
        throw new TypeError("rootCerts must be null or a Buffer");
      }
      if (!Array.isArray(keyCertPairs)) {
        throw new TypeError("keyCertPairs must be an array");
      }
      if (typeof checkClientCertificate !== "boolean") {
        throw new TypeError("checkClientCertificate must be a boolean");
      }
      const cert = [];
      const key = [];
      for (let i = 0;i < keyCertPairs.length; i++) {
        const pair = keyCertPairs[i];
        if (pair === null || typeof pair !== "object") {
          throw new TypeError(`keyCertPair[${i}] must be an object`);
        }
        if (!Buffer.isBuffer(pair.private_key)) {
          throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
        }
        if (!Buffer.isBuffer(pair.cert_chain)) {
          throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
        }
        cert.push(pair.cert_chain);
        key.push(pair.private_key);
      }
      return new SecureServerCredentials({
        requestCert: checkClientCertificate,
        ciphers: tls_helpers_1.CIPHER_SUITES
      }, {
        ca: (_a = rootCerts !== null && rootCerts !== undefined ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== undefined ? _a : undefined,
        cert,
        key
      });
    }
  }
  exports.ServerCredentials = ServerCredentials;

  class InsecureServerCredentials extends ServerCredentials {
    constructor() {
      super(null);
    }
    _getSettings() {
      return null;
    }
    _equals(other) {
      return other instanceof InsecureServerCredentials;
    }
  }

  class SecureServerCredentials extends ServerCredentials {
    constructor(constructorOptions, contextOptions) {
      super(constructorOptions, contextOptions);
      this.options = Object.assign(Object.assign({}, constructorOptions), contextOptions);
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof SecureServerCredentials)) {
        return false;
      }
      if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
        if (!this.options.ca.equals(other.options.ca)) {
          return false;
        }
      } else {
        if (this.options.ca !== other.options.ca) {
          return false;
        }
      }
      if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
        if (this.options.cert.length !== other.options.cert.length) {
          return false;
        }
        for (let i = 0;i < this.options.cert.length; i++) {
          const thisCert = this.options.cert[i];
          const otherCert = other.options.cert[i];
          if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
            if (!thisCert.equals(otherCert)) {
              return false;
            }
          } else {
            if (thisCert !== otherCert) {
              return false;
            }
          }
        }
      } else {
        if (this.options.cert !== other.options.cert) {
          return false;
        }
      }
      if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
        if (this.options.key.length !== other.options.key.length) {
          return false;
        }
        for (let i = 0;i < this.options.key.length; i++) {
          const thisKey = this.options.key[i];
          const otherKey = other.options.key[i];
          if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
            if (!thisKey.equals(otherKey)) {
              return false;
            }
          } else {
            if (thisKey !== otherKey) {
              return false;
            }
          }
        }
      } else {
        if (this.options.key !== other.options.key) {
          return false;
        }
      }
      if (this.options.requestCert !== other.options.requestCert) {
        return false;
      }
      return true;
    }
  }

  class CertificateProviderServerCredentials extends ServerCredentials {
    constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate) {
      super({
        requestCert: caCertificateProvider !== null,
        rejectUnauthorized: requireClientCertificate,
        ciphers: tls_helpers_1.CIPHER_SUITES
      });
      this.identityCertificateProvider = identityCertificateProvider;
      this.caCertificateProvider = caCertificateProvider;
      this.requireClientCertificate = requireClientCertificate;
      this.latestCaUpdate = null;
      this.latestIdentityUpdate = null;
      this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
      this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
    }
    _addWatcher(watcher) {
      var _a;
      if (this.getWatcherCount() === 0) {
        (_a = this.caCertificateProvider) === null || _a === undefined || _a.addCaCertificateListener(this.caCertificateUpdateListener);
        this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);
      }
      super._addWatcher(watcher);
    }
    _removeWatcher(watcher) {
      var _a;
      super._removeWatcher(watcher);
      if (this.getWatcherCount() === 0) {
        (_a = this.caCertificateProvider) === null || _a === undefined || _a.removeCaCertificateListener(this.caCertificateUpdateListener);
        this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
      }
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof CertificateProviderServerCredentials)) {
        return false;
      }
      return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && this.requireClientCertificate === other.requireClientCertificate;
    }
    calculateSecureContextOptions() {
      var _a;
      if (this.latestIdentityUpdate === null) {
        return null;
      }
      if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {
        return null;
      }
      return {
        ca: (_a = this.latestCaUpdate) === null || _a === undefined ? undefined : _a.caCertificate,
        cert: [this.latestIdentityUpdate.certificate],
        key: [this.latestIdentityUpdate.privateKey]
      };
    }
    finalizeUpdate() {
      const secureContextOptions = this.calculateSecureContextOptions();
      this.updateSecureContextOptions(secureContextOptions);
    }
    handleCaCertificateUpdate(update) {
      this.latestCaUpdate = update;
      this.finalizeUpdate();
    }
    handleIdentityCertitificateUpdate(update) {
      this.latestIdentityUpdate = update;
      this.finalizeUpdate();
    }
  }
  function createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {
    return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);
  }

  class InterceptorServerCredentials extends ServerCredentials {
    constructor(childCredentials, interceptors) {
      super({});
      this.childCredentials = childCredentials;
      this.interceptors = interceptors;
    }
    _isSecure() {
      return this.childCredentials._isSecure();
    }
    _equals(other) {
      if (!(other instanceof InterceptorServerCredentials)) {
        return false;
      }
      if (!this.childCredentials._equals(other.childCredentials)) {
        return false;
      }
      if (this.interceptors.length !== other.interceptors.length) {
        return false;
      }
      for (let i = 0;i < this.interceptors.length; i++) {
        if (this.interceptors[i] !== other.interceptors[i]) {
          return false;
        }
      }
      return true;
    }
    _getInterceptors() {
      return this.interceptors;
    }
    _addWatcher(watcher) {
      this.childCredentials._addWatcher(watcher);
    }
    _removeWatcher(watcher) {
      this.childCredentials._removeWatcher(watcher);
    }
    _getConstructorOptions() {
      return this.childCredentials._getConstructorOptions();
    }
    _getSecureContextOptions() {
      return this.childCredentials._getSecureContextOptions();
    }
  }
  function createServerCredentialsWithInterceptors(credentials, interceptors) {
    return new InterceptorServerCredentials(credentials, interceptors);
  }
});

// node_modules/@grpc/grpc-js/build/src/server-interceptors.js
var require_server_interceptors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseServerInterceptingCall = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = undefined;
  exports.isInterceptingServerListener = isInterceptingServerListener;
  exports.getServerInterceptingCall = getServerInterceptingCall;
  var metadata_1 = require_metadata();
  var constants_1 = require_constants2();
  var http2 = __require("http2");
  var error_1 = require_error2();
  var zlib = __require("zlib");
  var stream_decoder_1 = require_stream_decoder();
  var logging = require_logging();
  var TRACER_NAME = "server_call";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }

  class ServerListenerBuilder {
    constructor() {
      this.metadata = undefined;
      this.message = undefined;
      this.halfClose = undefined;
      this.cancel = undefined;
    }
    withOnReceiveMetadata(onReceiveMetadata) {
      this.metadata = onReceiveMetadata;
      return this;
    }
    withOnReceiveMessage(onReceiveMessage) {
      this.message = onReceiveMessage;
      return this;
    }
    withOnReceiveHalfClose(onReceiveHalfClose) {
      this.halfClose = onReceiveHalfClose;
      return this;
    }
    withOnCancel(onCancel) {
      this.cancel = onCancel;
      return this;
    }
    build() {
      return {
        onReceiveMetadata: this.metadata,
        onReceiveMessage: this.message,
        onReceiveHalfClose: this.halfClose,
        onCancel: this.cancel
      };
    }
  }
  exports.ServerListenerBuilder = ServerListenerBuilder;
  function isInterceptingServerListener(listener) {
    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;
  }

  class InterceptingServerListenerImpl {
    constructor(listener, nextListener) {
      this.listener = listener;
      this.nextListener = nextListener;
      this.cancelled = false;
      this.processingMetadata = false;
      this.hasPendingMessage = false;
      this.pendingMessage = null;
      this.processingMessage = false;
      this.hasPendingHalfClose = false;
    }
    processPendingMessage() {
      if (this.hasPendingMessage) {
        this.nextListener.onReceiveMessage(this.pendingMessage);
        this.pendingMessage = null;
        this.hasPendingMessage = false;
      }
    }
    processPendingHalfClose() {
      if (this.hasPendingHalfClose) {
        this.nextListener.onReceiveHalfClose();
        this.hasPendingHalfClose = false;
      }
    }
    onReceiveMetadata(metadata) {
      if (this.cancelled) {
        return;
      }
      this.processingMetadata = true;
      this.listener.onReceiveMetadata(metadata, (interceptedMetadata) => {
        this.processingMetadata = false;
        if (this.cancelled) {
          return;
        }
        this.nextListener.onReceiveMetadata(interceptedMetadata);
        this.processPendingMessage();
        this.processPendingHalfClose();
      });
    }
    onReceiveMessage(message) {
      if (this.cancelled) {
        return;
      }
      this.processingMessage = true;
      this.listener.onReceiveMessage(message, (msg) => {
        this.processingMessage = false;
        if (this.cancelled) {
          return;
        }
        if (this.processingMetadata) {
          this.pendingMessage = msg;
          this.hasPendingMessage = true;
        } else {
          this.nextListener.onReceiveMessage(msg);
          this.processPendingHalfClose();
        }
      });
    }
    onReceiveHalfClose() {
      if (this.cancelled) {
        return;
      }
      this.listener.onReceiveHalfClose(() => {
        if (this.cancelled) {
          return;
        }
        if (this.processingMetadata || this.processingMessage) {
          this.hasPendingHalfClose = true;
        } else {
          this.nextListener.onReceiveHalfClose();
        }
      });
    }
    onCancel() {
      this.cancelled = true;
      this.listener.onCancel();
      this.nextListener.onCancel();
    }
  }

  class ResponderBuilder {
    constructor() {
      this.start = undefined;
      this.metadata = undefined;
      this.message = undefined;
      this.status = undefined;
    }
    withStart(start) {
      this.start = start;
      return this;
    }
    withSendMetadata(sendMetadata) {
      this.metadata = sendMetadata;
      return this;
    }
    withSendMessage(sendMessage) {
      this.message = sendMessage;
      return this;
    }
    withSendStatus(sendStatus) {
      this.status = sendStatus;
      return this;
    }
    build() {
      return {
        start: this.start,
        sendMetadata: this.metadata,
        sendMessage: this.message,
        sendStatus: this.status
      };
    }
  }
  exports.ResponderBuilder = ResponderBuilder;
  var defaultServerListener = {
    onReceiveMetadata: (metadata, next) => {
      next(metadata);
    },
    onReceiveMessage: (message, next) => {
      next(message);
    },
    onReceiveHalfClose: (next) => {
      next();
    },
    onCancel: () => {
    }
  };
  var defaultResponder = {
    start: (next) => {
      next();
    },
    sendMetadata: (metadata, next) => {
      next(metadata);
    },
    sendMessage: (message, next) => {
      next(message);
    },
    sendStatus: (status, next) => {
      next(status);
    }
  };

  class ServerInterceptingCall {
    constructor(nextCall, responder) {
      var _a, _b, _c, _d;
      this.nextCall = nextCall;
      this.processingMetadata = false;
      this.sentMetadata = false;
      this.processingMessage = false;
      this.pendingMessage = null;
      this.pendingMessageCallback = null;
      this.pendingStatus = null;
      this.responder = {
        start: (_a = responder === null || responder === undefined ? undefined : responder.start) !== null && _a !== undefined ? _a : defaultResponder.start,
        sendMetadata: (_b = responder === null || responder === undefined ? undefined : responder.sendMetadata) !== null && _b !== undefined ? _b : defaultResponder.sendMetadata,
        sendMessage: (_c = responder === null || responder === undefined ? undefined : responder.sendMessage) !== null && _c !== undefined ? _c : defaultResponder.sendMessage,
        sendStatus: (_d = responder === null || responder === undefined ? undefined : responder.sendStatus) !== null && _d !== undefined ? _d : defaultResponder.sendStatus
      };
    }
    processPendingMessage() {
      if (this.pendingMessageCallback) {
        this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);
        this.pendingMessage = null;
        this.pendingMessageCallback = null;
      }
    }
    processPendingStatus() {
      if (this.pendingStatus) {
        this.nextCall.sendStatus(this.pendingStatus);
        this.pendingStatus = null;
      }
    }
    start(listener) {
      this.responder.start((interceptedListener) => {
        var _a, _b, _c, _d;
        const fullInterceptedListener = {
          onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveMetadata) !== null && _a !== undefined ? _a : defaultServerListener.onReceiveMetadata,
          onReceiveMessage: (_b = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveMessage) !== null && _b !== undefined ? _b : defaultServerListener.onReceiveMessage,
          onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveHalfClose) !== null && _c !== undefined ? _c : defaultServerListener.onReceiveHalfClose,
          onCancel: (_d = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onCancel) !== null && _d !== undefined ? _d : defaultServerListener.onCancel
        };
        const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);
        this.nextCall.start(finalInterceptingListener);
      });
    }
    sendMetadata(metadata) {
      this.processingMetadata = true;
      this.sentMetadata = true;
      this.responder.sendMetadata(metadata, (interceptedMetadata) => {
        this.processingMetadata = false;
        this.nextCall.sendMetadata(interceptedMetadata);
        this.processPendingMessage();
        this.processPendingStatus();
      });
    }
    sendMessage(message, callback) {
      this.processingMessage = true;
      if (!this.sentMetadata) {
        this.sendMetadata(new metadata_1.Metadata);
      }
      this.responder.sendMessage(message, (interceptedMessage) => {
        this.processingMessage = false;
        if (this.processingMetadata) {
          this.pendingMessage = interceptedMessage;
          this.pendingMessageCallback = callback;
        } else {
          this.nextCall.sendMessage(interceptedMessage, callback);
        }
      });
    }
    sendStatus(status) {
      this.responder.sendStatus(status, (interceptedStatus) => {
        if (this.processingMetadata || this.processingMessage) {
          this.pendingStatus = interceptedStatus;
        } else {
          this.nextCall.sendStatus(interceptedStatus);
        }
      });
    }
    startRead() {
      this.nextCall.startRead();
    }
    getPeer() {
      return this.nextCall.getPeer();
    }
    getDeadline() {
      return this.nextCall.getDeadline();
    }
    getHost() {
      return this.nextCall.getHost();
    }
  }
  exports.ServerInterceptingCall = ServerInterceptingCall;
  var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
  var GRPC_ENCODING_HEADER = "grpc-encoding";
  var GRPC_MESSAGE_HEADER = "grpc-message";
  var GRPC_STATUS_HEADER = "grpc-status";
  var GRPC_TIMEOUT_HEADER = "grpc-timeout";
  var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
  var deadlineUnitsToMs = {
    H: 3600000,
    M: 60000,
    S: 1000,
    m: 1,
    u: 0.001,
    n: 0.000001
  };
  var defaultCompressionHeaders = {
    [GRPC_ACCEPT_ENCODING_HEADER]: "identity,deflate,gzip",
    [GRPC_ENCODING_HEADER]: "identity"
  };
  var defaultResponseHeaders = {
    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
  };
  var defaultResponseOptions = {
    waitForTrailers: true
  };

  class BaseServerInterceptingCall {
    constructor(stream, headers, callEventTracker, handler, options) {
      var _a;
      this.stream = stream;
      this.callEventTracker = callEventTracker;
      this.handler = handler;
      this.listener = null;
      this.deadlineTimer = null;
      this.deadline = Infinity;
      this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
      this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
      this.cancelled = false;
      this.metadataSent = false;
      this.wantTrailers = false;
      this.cancelNotified = false;
      this.incomingEncoding = "identity";
      this.readQueue = [];
      this.isReadPending = false;
      this.receivedHalfClose = false;
      this.streamEnded = false;
      this.stream.once("error", (err) => {
      });
      this.stream.once("close", () => {
        var _a2;
        trace("Request to method " + ((_a2 = this.handler) === null || _a2 === undefined ? undefined : _a2.path) + " stream closed with rstCode " + this.stream.rstCode);
        if (this.callEventTracker && !this.streamEnded) {
          this.streamEnded = true;
          this.callEventTracker.onStreamEnd(false);
          this.callEventTracker.onCallEnd({
            code: constants_1.Status.CANCELLED,
            details: "Stream closed before sending status",
            metadata: null
          });
        }
        this.notifyOnCancel();
      });
      this.stream.on("data", (data) => {
        this.handleDataFrame(data);
      });
      this.stream.pause();
      this.stream.on("end", () => {
        this.handleEndEvent();
      });
      if ("grpc.max_send_message_length" in options) {
        this.maxSendMessageSize = options["grpc.max_send_message_length"];
      }
      if ("grpc.max_receive_message_length" in options) {
        this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
      }
      this.host = (_a = headers[":authority"]) !== null && _a !== undefined ? _a : headers.host;
      this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);
      const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
      if (logging.isTracerEnabled(TRACER_NAME)) {
        trace("Request to " + this.handler.path + " received headers " + JSON.stringify(metadata.toJSON()));
      }
      const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
      if (timeoutHeader.length > 0) {
        this.handleTimeoutHeader(timeoutHeader[0]);
      }
      const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);
      if (encodingHeader.length > 0) {
        this.incomingEncoding = encodingHeader[0];
      }
      metadata.remove(GRPC_TIMEOUT_HEADER);
      metadata.remove(GRPC_ENCODING_HEADER);
      metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
      metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
      metadata.remove(http2.constants.HTTP2_HEADER_TE);
      metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
      this.metadata = metadata;
    }
    handleTimeoutHeader(timeoutHeader) {
      const match = timeoutHeader.toString().match(DEADLINE_REGEX);
      if (match === null) {
        const status = {
          code: constants_1.Status.INTERNAL,
          details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
          metadata: null
        };
        process.nextTick(() => {
          this.sendStatus(status);
        });
        return;
      }
      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;
      const now = new Date;
      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
      this.deadlineTimer = setTimeout(() => {
        const status = {
          code: constants_1.Status.DEADLINE_EXCEEDED,
          details: "Deadline exceeded",
          metadata: null
        };
        this.sendStatus(status);
      }, timeout);
    }
    checkCancelled() {
      if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
        this.notifyOnCancel();
        this.cancelled = true;
      }
      return this.cancelled;
    }
    notifyOnCancel() {
      if (this.cancelNotified) {
        return;
      }
      this.cancelNotified = true;
      this.cancelled = true;
      process.nextTick(() => {
        var _a;
        (_a = this.listener) === null || _a === undefined || _a.onCancel();
      });
      if (this.deadlineTimer) {
        clearTimeout(this.deadlineTimer);
      }
      this.stream.resume();
    }
    maybeSendMetadata() {
      if (!this.metadataSent) {
        this.sendMetadata(new metadata_1.Metadata);
      }
    }
    serializeMessage(value) {
      const messageBuffer = this.handler.serialize(value);
      const byteLength = messageBuffer.byteLength;
      const output = Buffer.allocUnsafe(byteLength + 5);
      output.writeUInt8(0, 0);
      output.writeUInt32BE(byteLength, 1);
      messageBuffer.copy(output, 5);
      return output;
    }
    decompressMessage(message, encoding) {
      const messageContents = message.subarray(5);
      if (encoding === "identity") {
        return messageContents;
      } else if (encoding === "deflate" || encoding === "gzip") {
        let decompresser;
        if (encoding === "deflate") {
          decompresser = zlib.createInflate();
        } else {
          decompresser = zlib.createGunzip();
        }
        return new Promise((resolve, reject) => {
          let totalLength = 0;
          const messageParts = [];
          decompresser.on("data", (chunk) => {
            messageParts.push(chunk);
            totalLength += chunk.byteLength;
            if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {
              decompresser.destroy();
              reject({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`
              });
            }
          });
          decompresser.on("end", () => {
            resolve(Buffer.concat(messageParts));
          });
          decompresser.write(messageContents);
          decompresser.end();
        });
      } else {
        return Promise.reject({
          code: constants_1.Status.UNIMPLEMENTED,
          details: `Received message compressed with unsupported encoding "${encoding}"`
        });
      }
    }
    async decompressAndMaybePush(queueEntry) {
      if (queueEntry.type !== "COMPRESSED") {
        throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
      }
      const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;
      const compressedMessageEncoding = compressed ? this.incomingEncoding : "identity";
      let decompressedMessage;
      try {
        decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);
      } catch (err) {
        this.sendStatus(err);
        return;
      }
      try {
        queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
      } catch (err) {
        this.sendStatus({
          code: constants_1.Status.INTERNAL,
          details: `Error deserializing request: ${err.message}`
        });
        return;
      }
      queueEntry.type = "READABLE";
      this.maybePushNextMessage();
    }
    maybePushNextMessage() {
      if (this.listener && this.isReadPending && this.readQueue.length > 0 && this.readQueue[0].type !== "COMPRESSED") {
        this.isReadPending = false;
        const nextQueueEntry = this.readQueue.shift();
        if (nextQueueEntry.type === "READABLE") {
          this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
        } else {
          this.listener.onReceiveHalfClose();
        }
      }
    }
    handleDataFrame(data) {
      var _a;
      if (this.checkCancelled()) {
        return;
      }
      trace("Request to " + this.handler.path + " received data frame of size " + data.length);
      let rawMessages;
      try {
        rawMessages = this.decoder.write(data);
      } catch (e) {
        this.sendStatus({ code: constants_1.Status.RESOURCE_EXHAUSTED, details: e.message });
        return;
      }
      for (const messageBytes of rawMessages) {
        this.stream.pause();
        const queueEntry = {
          type: "COMPRESSED",
          compressedMessage: messageBytes,
          parsedMessage: null
        };
        this.readQueue.push(queueEntry);
        this.decompressAndMaybePush(queueEntry);
        (_a = this.callEventTracker) === null || _a === undefined || _a.addMessageReceived();
      }
    }
    handleEndEvent() {
      this.readQueue.push({
        type: "HALF_CLOSE",
        compressedMessage: null,
        parsedMessage: null
      });
      this.receivedHalfClose = true;
      this.maybePushNextMessage();
    }
    start(listener) {
      trace("Request to " + this.handler.path + " start called");
      if (this.checkCancelled()) {
        return;
      }
      this.listener = listener;
      listener.onReceiveMetadata(this.metadata);
    }
    sendMetadata(metadata) {
      if (this.checkCancelled()) {
        return;
      }
      if (this.metadataSent) {
        return;
      }
      this.metadataSent = true;
      const custom = metadata ? metadata.toHttp2Headers() : null;
      const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);
      this.stream.respond(headers, defaultResponseOptions);
    }
    sendMessage(message, callback) {
      if (this.checkCancelled()) {
        return;
      }
      let response;
      try {
        response = this.serializeMessage(message);
      } catch (e) {
        this.sendStatus({
          code: constants_1.Status.INTERNAL,
          details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,
          metadata: null
        });
        return;
      }
      if (this.maxSendMessageSize !== -1 && response.length - 5 > this.maxSendMessageSize) {
        this.sendStatus({
          code: constants_1.Status.RESOURCE_EXHAUSTED,
          details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
          metadata: null
        });
        return;
      }
      this.maybeSendMetadata();
      trace("Request to " + this.handler.path + " sent data frame of size " + response.length);
      this.stream.write(response, (error) => {
        var _a;
        if (error) {
          this.sendStatus({
            code: constants_1.Status.INTERNAL,
            details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,
            metadata: null
          });
          return;
        }
        (_a = this.callEventTracker) === null || _a === undefined || _a.addMessageSent();
        callback();
      });
    }
    sendStatus(status) {
      var _a, _b;
      if (this.checkCancelled()) {
        return;
      }
      trace("Request to method " + ((_a = this.handler) === null || _a === undefined ? undefined : _a.path) + " ended with status code: " + constants_1.Status[status.code] + " details: " + status.details);
      if (this.metadataSent) {
        if (!this.wantTrailers) {
          this.wantTrailers = true;
          this.stream.once("wantTrailers", () => {
            var _a2;
            if (this.callEventTracker && !this.streamEnded) {
              this.streamEnded = true;
              this.callEventTracker.onStreamEnd(true);
              this.callEventTracker.onCallEnd(status);
            }
            const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, (_a2 = status.metadata) === null || _a2 === undefined ? undefined : _a2.toHttp2Headers());
            this.stream.sendTrailers(trailersToSend);
            this.notifyOnCancel();
          });
          this.stream.end();
        } else {
          this.notifyOnCancel();
        }
      } else {
        if (this.callEventTracker && !this.streamEnded) {
          this.streamEnded = true;
          this.callEventTracker.onStreamEnd(true);
          this.callEventTracker.onCallEnd(status);
        }
        const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), (_b = status.metadata) === null || _b === undefined ? undefined : _b.toHttp2Headers());
        this.stream.respond(trailersToSend, { endStream: true });
        this.notifyOnCancel();
      }
    }
    startRead() {
      trace("Request to " + this.handler.path + " startRead called");
      if (this.checkCancelled()) {
        return;
      }
      this.isReadPending = true;
      if (this.readQueue.length === 0) {
        if (!this.receivedHalfClose) {
          this.stream.resume();
        }
      } else {
        this.maybePushNextMessage();
      }
    }
    getPeer() {
      var _a;
      const socket = (_a = this.stream.session) === null || _a === undefined ? undefined : _a.socket;
      if (socket === null || socket === undefined ? undefined : socket.remoteAddress) {
        if (socket.remotePort) {
          return `${socket.remoteAddress}:${socket.remotePort}`;
        } else {
          return socket.remoteAddress;
        }
      } else {
        return "unknown";
      }
    }
    getDeadline() {
      return this.deadline;
    }
    getHost() {
      return this.host;
    }
  }
  exports.BaseServerInterceptingCall = BaseServerInterceptingCall;
  function getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {
    const methodDefinition = {
      path: handler.path,
      requestStream: handler.type === "clientStream" || handler.type === "bidi",
      responseStream: handler.type === "serverStream" || handler.type === "bidi",
      requestDeserialize: handler.deserialize,
      responseSerialize: handler.serialize
    };
    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);
    return interceptors.reduce((call, interceptor) => {
      return interceptor(methodDefinition, call);
    }, baseCall);
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server = __commonJS((exports) => {
  var __runInitializers = exports && exports.__runInitializers || function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0;i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : undefined;
  };
  var __esDecorate = exports && exports.__esDecorate || function(ctor, descriptorIn, decorators2, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== undefined && typeof f !== "function")
        throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators2.length - 1;i >= 0; i--) {
      var context = {};
      for (var p in contextIn)
        context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access)
        context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators2[i])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === undefined)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_ = accept(result.get))
          descriptor.get = _;
        if (_ = accept(result.set))
          descriptor.set = _;
        if (_ = accept(result.init))
          initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field")
          initializers.unshift(_);
        else
          descriptor[key] = _;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Server = undefined;
  var http2 = __require("http2");
  var util = __require("util");
  var constants_1 = require_constants2();
  var server_call_1 = require_server_call();
  var server_credentials_1 = require_server_credentials();
  var resolver_1 = require_resolver();
  var logging = require_logging();
  var subchannel_address_1 = require_subchannel_address();
  var uri_parser_1 = require_uri_parser();
  var channelz_1 = require_channelz();
  var server_interceptors_1 = require_server_interceptors();
  var UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);
  var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
  var KEEPALIVE_TIMEOUT_MS = 20000;
  var MAX_CONNECTION_IDLE_MS = ~(1 << 31);
  var { HTTP2_HEADER_PATH } = http2.constants;
  var TRACER_NAME = "server";
  var kMaxAge = Buffer.from("max_age");
  function serverCallTrace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, "server_call", text);
  }
  function noop() {
  }
  function deprecate(message) {
    return function(target, context) {
      return util.deprecate(target, message);
    };
  }
  function getUnimplementedStatusResponse(methodName) {
    return {
      code: constants_1.Status.UNIMPLEMENTED,
      details: `The server does not implement the method ${methodName}`
    };
  }
  function getDefaultHandler(handlerType, methodName) {
    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
    switch (handlerType) {
      case "unary":
        return (call, callback) => {
          callback(unimplementedStatusResponse, null);
        };
      case "clientStream":
        return (call, callback) => {
          callback(unimplementedStatusResponse, null);
        };
      case "serverStream":
        return (call) => {
          call.emit("error", unimplementedStatusResponse);
        };
      case "bidi":
        return (call) => {
          call.emit("error", unimplementedStatusResponse);
        };
      default:
        throw new Error(`Invalid handlerType ${handlerType}`);
    }
  }
  var Server = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _start_decorators;
    return _a = class Server2 {
      constructor(options) {
        var _b, _c, _d, _e, _f, _g;
        this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map);
        this.http2Servers = new Map;
        this.sessionIdleTimeouts = new Map;
        this.handlers = new Map;
        this.sessions = new Map;
        this.started = false;
        this.shutdown = false;
        this.serverAddressString = "null";
        this.channelzEnabled = true;
        this.options = options !== null && options !== undefined ? options : {};
        if (this.options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
          this.channelzTrace = new channelz_1.ChannelzTraceStub;
          this.callTracker = new channelz_1.ChannelzCallTrackerStub;
          this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub;
          this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub;
        } else {
          this.channelzTrace = new channelz_1.ChannelzTrace;
          this.callTracker = new channelz_1.ChannelzCallTracker;
          this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker;
          this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker;
        }
        this.channelzRef = (0, channelz_1.registerChannelzServer)("server", () => this.getChannelzInfo(), this.channelzEnabled);
        this.channelzTrace.addTrace("CT_INFO", "Server created");
        this.maxConnectionAgeMs = (_b = this.options["grpc.max_connection_age_ms"]) !== null && _b !== undefined ? _b : UNLIMITED_CONNECTION_AGE_MS;
        this.maxConnectionAgeGraceMs = (_c = this.options["grpc.max_connection_age_grace_ms"]) !== null && _c !== undefined ? _c : UNLIMITED_CONNECTION_AGE_MS;
        this.keepaliveTimeMs = (_d = this.options["grpc.keepalive_time_ms"]) !== null && _d !== undefined ? _d : KEEPALIVE_MAX_TIME_MS;
        this.keepaliveTimeoutMs = (_e = this.options["grpc.keepalive_timeout_ms"]) !== null && _e !== undefined ? _e : KEEPALIVE_TIMEOUT_MS;
        this.sessionIdleTimeout = (_f = this.options["grpc.max_connection_idle_ms"]) !== null && _f !== undefined ? _f : MAX_CONNECTION_IDLE_MS;
        this.commonServerOptions = {
          maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
        };
        if ("grpc-node.max_session_memory" in this.options) {
          this.commonServerOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        } else {
          this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
        }
        if ("grpc.max_concurrent_streams" in this.options) {
          this.commonServerOptions.settings = {
            maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
          };
        }
        this.interceptors = (_g = this.options.interceptors) !== null && _g !== undefined ? _g : [];
        this.trace("Server constructed");
      }
      getChannelzInfo() {
        return {
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          listenerChildren: this.listenerChildrenTracker.getChildLists(),
          sessionChildren: this.sessionChildrenTracker.getChildLists()
        };
      }
      getChannelzSessionInfo(session) {
        var _b, _c, _d;
        const sessionInfo = this.sessions.get(session);
        const sessionSocket = session.socket;
        const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
        const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
        let tlsInfo;
        if (session.encrypted) {
          const tlsSocket = sessionSocket;
          const cipherInfo = tlsSocket.getCipher();
          const certificate = tlsSocket.getCertificate();
          const peerCertificate = tlsSocket.getPeerCertificate();
          tlsInfo = {
            cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== undefined ? _b : null,
            cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
            localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
            remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
          };
        } else {
          tlsInfo = null;
        }
        const socketInfo = {
          remoteAddress,
          localAddress,
          security: tlsInfo,
          remoteName: null,
          streamsStarted: sessionInfo.streamTracker.callsStarted,
          streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
          streamsFailed: sessionInfo.streamTracker.callsFailed,
          messagesSent: sessionInfo.messagesSent,
          messagesReceived: sessionInfo.messagesReceived,
          keepAlivesSent: sessionInfo.keepAlivesSent,
          lastLocalStreamCreatedTimestamp: null,
          lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
          lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
          lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
          localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== undefined ? _c : null,
          remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== undefined ? _d : null
        };
        return socketInfo;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + text);
      }
      keepaliveTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + text);
      }
      addProtoService() {
        throw new Error("Not implemented. Use addService() instead");
      }
      addService(service, implementation) {
        if (service === null || typeof service !== "object" || implementation === null || typeof implementation !== "object") {
          throw new Error("addService() requires two objects as arguments");
        }
        const serviceKeys = Object.keys(service);
        if (serviceKeys.length === 0) {
          throw new Error("Cannot add an empty service to a server");
        }
        serviceKeys.forEach((name) => {
          const attrs = service[name];
          let methodType;
          if (attrs.requestStream) {
            if (attrs.responseStream) {
              methodType = "bidi";
            } else {
              methodType = "clientStream";
            }
          } else {
            if (attrs.responseStream) {
              methodType = "serverStream";
            } else {
              methodType = "unary";
            }
          }
          let implFn = implementation[name];
          let impl;
          if (implFn === undefined && typeof attrs.originalName === "string") {
            implFn = implementation[attrs.originalName];
          }
          if (implFn !== undefined) {
            impl = implFn.bind(implementation);
          } else {
            impl = getDefaultHandler(methodType, name);
          }
          const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
          if (success === false) {
            throw new Error(`Method handler for ${attrs.path} already provided.`);
          }
        });
      }
      removeService(service) {
        if (service === null || typeof service !== "object") {
          throw new Error("removeService() requires object as argument");
        }
        const serviceKeys = Object.keys(service);
        serviceKeys.forEach((name) => {
          const attrs = service[name];
          this.unregister(attrs.path);
        });
      }
      bind(port, creds) {
        throw new Error("Not implemented. Use bindAsync() instead");
      }
      experimentalRegisterListenerToChannelz(boundAddress) {
        return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {
          return {
            localAddress: boundAddress,
            remoteAddress: null,
            security: null,
            remoteName: null,
            streamsStarted: 0,
            streamsSucceeded: 0,
            streamsFailed: 0,
            messagesSent: 0,
            messagesReceived: 0,
            keepAlivesSent: 0,
            lastLocalStreamCreatedTimestamp: null,
            lastRemoteStreamCreatedTimestamp: null,
            lastMessageSentTimestamp: null,
            lastMessageReceivedTimestamp: null,
            localFlowControlWindow: null,
            remoteFlowControlWindow: null
          };
        }, this.channelzEnabled);
      }
      experimentalUnregisterListenerFromChannelz(channelzRef) {
        (0, channelz_1.unregisterChannelzRef)(channelzRef);
      }
      createHttp2Server(credentials) {
        let http2Server;
        if (credentials._isSecure()) {
          const constructorOptions = credentials._getConstructorOptions();
          const contextOptions = credentials._getSecureContextOptions();
          const secureServerOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), constructorOptions), contextOptions), { enableTrace: this.options["grpc-node.tls_enable_trace"] === 1 });
          let areCredentialsValid = contextOptions !== null;
          this.trace("Initial credentials valid: " + areCredentialsValid);
          http2Server = http2.createSecureServer(secureServerOptions);
          http2Server.prependListener("connection", (socket) => {
            if (!areCredentialsValid) {
              this.trace("Dropped connection from " + JSON.stringify(socket.address()) + " due to unloaded credentials");
              socket.destroy();
            }
          });
          http2Server.on("secureConnection", (socket) => {
            socket.on("error", (e) => {
              this.trace("An incoming TLS connection closed with error: " + e.message);
            });
          });
          const credsWatcher = (options) => {
            if (options) {
              const secureServer = http2Server;
              try {
                secureServer.setSecureContext(options);
              } catch (e) {
                logging.log(constants_1.LogVerbosity.ERROR, "Failed to set secure context with error " + e.message);
                options = null;
              }
            }
            areCredentialsValid = options !== null;
            this.trace("Post-update credentials valid: " + areCredentialsValid);
          };
          credentials._addWatcher(credsWatcher);
          http2Server.on("close", () => {
            credentials._removeWatcher(credsWatcher);
          });
        } else {
          http2Server = http2.createServer(this.commonServerOptions);
        }
        http2Server.setTimeout(0, noop);
        this._setupHandlers(http2Server, credentials._getInterceptors());
        return http2Server;
      }
      bindOneAddress(address, boundPortObject) {
        this.trace("Attempting to bind " + (0, subchannel_address_1.subchannelAddressToString)(address));
        const http2Server = this.createHttp2Server(boundPortObject.credentials);
        return new Promise((resolve, reject) => {
          const onError = (err) => {
            this.trace("Failed to bind " + (0, subchannel_address_1.subchannelAddressToString)(address) + " with error " + err.message);
            resolve({
              port: "port" in address ? address.port : 1,
              error: err.message
            });
          };
          http2Server.once("error", onError);
          http2Server.listen(address, () => {
            const boundAddress = http2Server.address();
            let boundSubchannelAddress;
            if (typeof boundAddress === "string") {
              boundSubchannelAddress = {
                path: boundAddress
              };
            } else {
              boundSubchannelAddress = {
                host: boundAddress.address,
                port: boundAddress.port
              };
            }
            const channelzRef = this.experimentalRegisterListenerToChannelz(boundSubchannelAddress);
            this.listenerChildrenTracker.refChild(channelzRef);
            this.http2Servers.set(http2Server, {
              channelzRef,
              sessions: new Set,
              ownsChannelzRef: true
            });
            boundPortObject.listeningServers.add(http2Server);
            this.trace("Successfully bound " + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
            resolve({
              port: "port" in boundSubchannelAddress ? boundSubchannelAddress.port : 1
            });
            http2Server.removeListener("error", onError);
          });
        });
      }
      async bindManyPorts(addressList, boundPortObject) {
        if (addressList.length === 0) {
          return {
            count: 0,
            port: 0,
            errors: []
          };
        }
        if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {
          const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);
          if (firstAddressResult.error) {
            const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);
            return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });
          } else {
            const restAddresses = addressList.slice(1).map((address) => (0, subchannel_address_1.isTcpSubchannelAddress)(address) ? { host: address.host, port: firstAddressResult.port } : address);
            const restAddressResult = await Promise.all(restAddresses.map((address) => this.bindOneAddress(address, boundPortObject)));
            const allResults = [firstAddressResult, ...restAddressResult];
            return {
              count: allResults.filter((result) => result.error === undefined).length,
              port: firstAddressResult.port,
              errors: allResults.filter((result) => result.error).map((result) => result.error)
            };
          }
        } else {
          const allResults = await Promise.all(addressList.map((address) => this.bindOneAddress(address, boundPortObject)));
          return {
            count: allResults.filter((result) => result.error === undefined).length,
            port: allResults[0].port,
            errors: allResults.filter((result) => result.error).map((result) => result.error)
          };
        }
      }
      async bindAddressList(addressList, boundPortObject) {
        const bindResult = await this.bindManyPorts(addressList, boundPortObject);
        if (bindResult.count > 0) {
          if (bindResult.count < addressList.length) {
            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
          }
          return bindResult.port;
        } else {
          const errorString = `No address added out of total ${addressList.length} resolved`;
          logging.log(constants_1.LogVerbosity.ERROR, errorString);
          throw new Error(`${errorString} errors: [${bindResult.errors.join(",")}]`);
        }
      }
      resolvePort(port) {
        return new Promise((resolve, reject) => {
          const resolverListener = {
            onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {
              resolverListener.onSuccessfulResolution = () => {
              };
              const addressList = [].concat(...endpointList.map((endpoint) => endpoint.addresses));
              if (addressList.length === 0) {
                reject(new Error(`No addresses resolved for port ${port}`));
                return;
              }
              resolve(addressList);
            },
            onError: (error) => {
              reject(new Error(error.details));
            }
          };
          const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);
          resolver.updateResolution();
        });
      }
      async bindPort(port, boundPortObject) {
        const addressList = await this.resolvePort(port);
        if (boundPortObject.cancelled) {
          this.completeUnbind(boundPortObject);
          throw new Error("bindAsync operation cancelled by unbind call");
        }
        const portNumber = await this.bindAddressList(addressList, boundPortObject);
        if (boundPortObject.cancelled) {
          this.completeUnbind(boundPortObject);
          throw new Error("bindAsync operation cancelled by unbind call");
        }
        return portNumber;
      }
      normalizePort(port) {
        const initialPortUri = (0, uri_parser_1.parseUri)(port);
        if (initialPortUri === null) {
          throw new Error(`Could not parse port "${port}"`);
        }
        const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
        if (portUri === null) {
          throw new Error(`Could not get a default scheme for port "${port}"`);
        }
        return portUri;
      }
      bindAsync(port, creds, callback) {
        if (this.shutdown) {
          throw new Error("bindAsync called after shutdown");
        }
        if (typeof port !== "string") {
          throw new TypeError("port must be a string");
        }
        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
          throw new TypeError("creds must be a ServerCredentials object");
        }
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        this.trace("bindAsync port=" + port);
        const portUri = this.normalizePort(port);
        const deferredCallback = (error, port2) => {
          process.nextTick(() => callback(error, port2));
        };
        let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
        if (boundPortObject) {
          if (!creds._equals(boundPortObject.credentials)) {
            deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);
            return;
          }
          boundPortObject.cancelled = false;
          if (boundPortObject.completionPromise) {
            boundPortObject.completionPromise.then((portNum) => callback(null, portNum), (error) => callback(error, 0));
          } else {
            deferredCallback(null, boundPortObject.portNumber);
          }
          return;
        }
        boundPortObject = {
          mapKey: (0, uri_parser_1.uriToString)(portUri),
          originalUri: portUri,
          completionPromise: null,
          cancelled: false,
          portNumber: 0,
          credentials: creds,
          listeningServers: new Set
        };
        const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
        const completionPromise = this.bindPort(portUri, boundPortObject);
        boundPortObject.completionPromise = completionPromise;
        if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
          completionPromise.then((portNum) => {
            const finalUri = {
              scheme: portUri.scheme,
              authority: portUri.authority,
              path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum })
            };
            boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);
            boundPortObject.completionPromise = null;
            boundPortObject.portNumber = portNum;
            this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
            callback(null, portNum);
          }, (error) => {
            callback(error, 0);
          });
        } else {
          this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
          completionPromise.then((portNum) => {
            boundPortObject.completionPromise = null;
            boundPortObject.portNumber = portNum;
            callback(null, portNum);
          }, (error) => {
            callback(error, 0);
          });
        }
      }
      registerInjectorToChannelz() {
        return (0, channelz_1.registerChannelzSocket)("injector", () => {
          return {
            localAddress: null,
            remoteAddress: null,
            security: null,
            remoteName: null,
            streamsStarted: 0,
            streamsSucceeded: 0,
            streamsFailed: 0,
            messagesSent: 0,
            messagesReceived: 0,
            keepAlivesSent: 0,
            lastLocalStreamCreatedTimestamp: null,
            lastRemoteStreamCreatedTimestamp: null,
            lastMessageSentTimestamp: null,
            lastMessageReceivedTimestamp: null,
            localFlowControlWindow: null,
            remoteFlowControlWindow: null
          };
        }, this.channelzEnabled);
      }
      experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, ownsChannelzRef = false) {
        if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {
          throw new TypeError("creds must be a ServerCredentials object");
        }
        if (this.channelzEnabled) {
          this.listenerChildrenTracker.refChild(channelzRef);
        }
        const server = this.createHttp2Server(credentials);
        const sessionsSet = new Set;
        this.http2Servers.set(server, {
          channelzRef,
          sessions: sessionsSet,
          ownsChannelzRef
        });
        return {
          injectConnection: (connection) => {
            server.emit("connection", connection);
          },
          drain: (graceTimeMs) => {
            var _b, _c;
            for (const session of sessionsSet) {
              this.closeSession(session);
            }
            (_c = (_b = setTimeout(() => {
              for (const session of sessionsSet) {
                session.destroy(http2.constants.NGHTTP2_CANCEL);
              }
            }, graceTimeMs)).unref) === null || _c === undefined || _c.call(_b);
          },
          destroy: () => {
            this.closeServer(server);
            for (const session of sessionsSet) {
              this.closeSession(session);
            }
          }
        };
      }
      createConnectionInjector(credentials) {
        if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {
          throw new TypeError("creds must be a ServerCredentials object");
        }
        const channelzRef = this.registerInjectorToChannelz();
        return this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, true);
      }
      closeServer(server, callback) {
        this.trace("Closing server with address " + JSON.stringify(server.address()));
        const serverInfo = this.http2Servers.get(server);
        server.close(() => {
          if (serverInfo && serverInfo.ownsChannelzRef) {
            this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
            (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);
          }
          this.http2Servers.delete(server);
          callback === null || callback === undefined || callback();
        });
      }
      closeSession(session, callback) {
        var _b;
        this.trace("Closing session initiated by " + ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress));
        const sessionInfo = this.sessions.get(session);
        const closeCallback = () => {
          if (sessionInfo) {
            this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
            (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);
          }
          callback === null || callback === undefined || callback();
        };
        if (session.closed) {
          queueMicrotask(closeCallback);
        } else {
          session.close(closeCallback);
        }
      }
      completeUnbind(boundPortObject) {
        for (const server of boundPortObject.listeningServers) {
          const serverInfo = this.http2Servers.get(server);
          this.closeServer(server, () => {
            boundPortObject.listeningServers.delete(server);
          });
          if (serverInfo) {
            for (const session of serverInfo.sessions) {
              this.closeSession(session);
            }
          }
        }
        this.boundPorts.delete(boundPortObject.mapKey);
      }
      unbind(port) {
        this.trace("unbind port=" + port);
        const portUri = this.normalizePort(port);
        const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
        if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
          throw new Error("Cannot unbind port 0");
        }
        const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
        if (boundPortObject) {
          this.trace("unbinding " + boundPortObject.mapKey + " originally bound as " + (0, uri_parser_1.uriToString)(boundPortObject.originalUri));
          if (boundPortObject.completionPromise) {
            boundPortObject.cancelled = true;
          } else {
            this.completeUnbind(boundPortObject);
          }
        }
      }
      drain(port, graceTimeMs) {
        var _b, _c;
        this.trace("drain port=" + port + " graceTimeMs=" + graceTimeMs);
        const portUri = this.normalizePort(port);
        const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
        if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
          throw new Error("Cannot drain port 0");
        }
        const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
        if (!boundPortObject) {
          return;
        }
        const allSessions = new Set;
        for (const http2Server of boundPortObject.listeningServers) {
          const serverEntry = this.http2Servers.get(http2Server);
          if (serverEntry) {
            for (const session of serverEntry.sessions) {
              allSessions.add(session);
              this.closeSession(session, () => {
                allSessions.delete(session);
              });
            }
          }
        }
        (_c = (_b = setTimeout(() => {
          for (const session of allSessions) {
            session.destroy(http2.constants.NGHTTP2_CANCEL);
          }
        }, graceTimeMs)).unref) === null || _c === undefined || _c.call(_b);
      }
      forceShutdown() {
        for (const boundPortObject of this.boundPorts.values()) {
          boundPortObject.cancelled = true;
        }
        this.boundPorts.clear();
        for (const server of this.http2Servers.keys()) {
          this.closeServer(server);
        }
        this.sessions.forEach((channelzInfo, session) => {
          this.closeSession(session);
          session.destroy(http2.constants.NGHTTP2_CANCEL);
        });
        this.sessions.clear();
        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
        this.shutdown = true;
      }
      register(name, handler, serialize, deserialize, type2) {
        if (this.handlers.has(name)) {
          return false;
        }
        this.handlers.set(name, {
          func: handler,
          serialize,
          deserialize,
          type: type2,
          path: name
        });
        return true;
      }
      unregister(name) {
        return this.handlers.delete(name);
      }
      start() {
        if (this.http2Servers.size === 0 || [...this.http2Servers.keys()].every((server) => !server.listening)) {
          throw new Error("server must be bound in order to start");
        }
        if (this.started === true) {
          throw new Error("server is already started");
        }
        this.started = true;
      }
      tryShutdown(callback) {
        var _b;
        const wrappedCallback = (error) => {
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
          callback(error);
        };
        let pendingChecks = 0;
        function maybeCallback() {
          pendingChecks--;
          if (pendingChecks === 0) {
            wrappedCallback();
          }
        }
        this.shutdown = true;
        for (const [serverKey, server] of this.http2Servers.entries()) {
          pendingChecks++;
          const serverString = server.channelzRef.name;
          this.trace("Waiting for server " + serverString + " to close");
          this.closeServer(serverKey, () => {
            this.trace("Server " + serverString + " finished closing");
            maybeCallback();
          });
          for (const session of server.sessions.keys()) {
            pendingChecks++;
            const sessionString = (_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress;
            this.trace("Waiting for session " + sessionString + " to close");
            this.closeSession(session, () => {
              this.trace("Session " + sessionString + " finished closing");
              maybeCallback();
            });
          }
        }
        if (pendingChecks === 0) {
          wrappedCallback();
        }
      }
      addHttp2Port() {
        throw new Error("Not yet implemented");
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      _verifyContentType(stream, headers) {
        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
        if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
          stream.respond({
            [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
          }, { endStream: true });
          return false;
        }
        return true;
      }
      _retrieveHandler(path) {
        serverCallTrace("Received call to method " + path + " at address " + this.serverAddressString);
        const handler = this.handlers.get(path);
        if (handler === undefined) {
          serverCallTrace("No handler registered for method " + path + ". Sending UNIMPLEMENTED status.");
          return null;
        }
        return handler;
      }
      _respondWithError(err, stream, channelzSessionInfo = null) {
        var _b, _c;
        const trailersToSend = Object.assign({ "grpc-status": (_b = err.code) !== null && _b !== undefined ? _b : constants_1.Status.INTERNAL, "grpc-message": err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto" }, (_c = err.metadata) === null || _c === undefined ? undefined : _c.toHttp2Headers());
        stream.respond(trailersToSend, { endStream: true });
        this.callTracker.addCallFailed();
        channelzSessionInfo === null || channelzSessionInfo === undefined || channelzSessionInfo.streamTracker.addCallFailed();
      }
      _channelzHandler(extraInterceptors, stream, headers) {
        this.onStreamOpened(stream);
        const channelzSessionInfo = this.sessions.get(stream.session);
        this.callTracker.addCallStarted();
        channelzSessionInfo === null || channelzSessionInfo === undefined || channelzSessionInfo.streamTracker.addCallStarted();
        if (!this._verifyContentType(stream, headers)) {
          this.callTracker.addCallFailed();
          channelzSessionInfo === null || channelzSessionInfo === undefined || channelzSessionInfo.streamTracker.addCallFailed();
          return;
        }
        const path = headers[HTTP2_HEADER_PATH];
        const handler = this._retrieveHandler(path);
        if (!handler) {
          this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);
          return;
        }
        const callEventTracker = {
          addMessageSent: () => {
            if (channelzSessionInfo) {
              channelzSessionInfo.messagesSent += 1;
              channelzSessionInfo.lastMessageSentTimestamp = new Date;
            }
          },
          addMessageReceived: () => {
            if (channelzSessionInfo) {
              channelzSessionInfo.messagesReceived += 1;
              channelzSessionInfo.lastMessageReceivedTimestamp = new Date;
            }
          },
          onCallEnd: (status) => {
            if (status.code === constants_1.Status.OK) {
              this.callTracker.addCallSucceeded();
            } else {
              this.callTracker.addCallFailed();
            }
          },
          onStreamEnd: (success) => {
            if (channelzSessionInfo) {
              if (success) {
                channelzSessionInfo.streamTracker.addCallSucceeded();
              } else {
                channelzSessionInfo.streamTracker.addCallFailed();
              }
            }
          }
        };
        const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);
        if (!this._runHandlerForCall(call, handler)) {
          this.callTracker.addCallFailed();
          channelzSessionInfo === null || channelzSessionInfo === undefined || channelzSessionInfo.streamTracker.addCallFailed();
          call.sendStatus({
            code: constants_1.Status.INTERNAL,
            details: `Unknown handler type: ${handler.type}`
          });
        }
      }
      _streamHandler(extraInterceptors, stream, headers) {
        this.onStreamOpened(stream);
        if (this._verifyContentType(stream, headers) !== true) {
          return;
        }
        const path = headers[HTTP2_HEADER_PATH];
        const handler = this._retrieveHandler(path);
        if (!handler) {
          this._respondWithError(getUnimplementedStatusResponse(path), stream, null);
          return;
        }
        const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);
        if (!this._runHandlerForCall(call, handler)) {
          call.sendStatus({
            code: constants_1.Status.INTERNAL,
            details: `Unknown handler type: ${handler.type}`
          });
        }
      }
      _runHandlerForCall(call, handler) {
        const { type: type2 } = handler;
        if (type2 === "unary") {
          handleUnary(call, handler);
        } else if (type2 === "clientStream") {
          handleClientStreaming(call, handler);
        } else if (type2 === "serverStream") {
          handleServerStreaming(call, handler);
        } else if (type2 === "bidi") {
          handleBidiStreaming(call, handler);
        } else {
          return false;
        }
        return true;
      }
      _setupHandlers(http2Server, extraInterceptors) {
        if (http2Server === null) {
          return;
        }
        const serverAddress = http2Server.address();
        let serverAddressString = "null";
        if (serverAddress) {
          if (typeof serverAddress === "string") {
            serverAddressString = serverAddress;
          } else {
            serverAddressString = serverAddress.address + ":" + serverAddress.port;
          }
        }
        this.serverAddressString = serverAddressString;
        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;
        const sessionHandler = this.channelzEnabled ? this._channelzSessionHandler(http2Server) : this._sessionHandler(http2Server);
        http2Server.on("stream", handler.bind(this, extraInterceptors));
        http2Server.on("session", sessionHandler);
      }
      _sessionHandler(http2Server) {
        return (session) => {
          var _b, _c;
          (_b = this.http2Servers.get(http2Server)) === null || _b === undefined || _b.sessions.add(session);
          let connectionAgeTimer = null;
          let connectionAgeGraceTimer = null;
          let keepaliveTimer = null;
          let sessionClosedByServer = false;
          const idleTimeoutObj = this.enableIdleTimeout(session);
          if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
            const jitterMagnitude = this.maxConnectionAgeMs / 10;
            const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
            connectionAgeTimer = setTimeout(() => {
              var _b2, _c2;
              sessionClosedByServer = true;
              this.trace("Connection dropped by max connection age: " + ((_b2 = session.socket) === null || _b2 === undefined ? undefined : _b2.remoteAddress));
              try {
                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
              } catch (e) {
                session.destroy();
                return;
              }
              session.close();
              if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                connectionAgeGraceTimer = setTimeout(() => {
                  session.destroy();
                }, this.maxConnectionAgeGraceMs);
                (_c2 = connectionAgeGraceTimer.unref) === null || _c2 === undefined || _c2.call(connectionAgeGraceTimer);
              }
            }, this.maxConnectionAgeMs + jitter);
            (_c = connectionAgeTimer.unref) === null || _c === undefined || _c.call(connectionAgeTimer);
          }
          const clearKeepaliveTimeout = () => {
            if (keepaliveTimer) {
              clearTimeout(keepaliveTimer);
              keepaliveTimer = null;
            }
          };
          const canSendPing = () => {
            return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;
          };
          let sendPing;
          const maybeStartKeepalivePingTimer = () => {
            var _b2;
            if (!canSendPing()) {
              return;
            }
            this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
            keepaliveTimer = setTimeout(() => {
              clearKeepaliveTimeout();
              sendPing();
            }, this.keepaliveTimeMs);
            (_b2 = keepaliveTimer.unref) === null || _b2 === undefined || _b2.call(keepaliveTimer);
          };
          sendPing = () => {
            var _b2;
            if (!canSendPing()) {
              return;
            }
            this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
            let pingSendError = "";
            try {
              const pingSentSuccessfully = session.ping((err, duration, payload) => {
                clearKeepaliveTimeout();
                if (err) {
                  this.keepaliveTrace("Ping failed with error: " + err.message);
                  sessionClosedByServer = true;
                  session.close();
                } else {
                  this.keepaliveTrace("Received ping response");
                  maybeStartKeepalivePingTimer();
                }
              });
              if (!pingSentSuccessfully) {
                pingSendError = "Ping returned false";
              }
            } catch (e) {
              pingSendError = (e instanceof Error ? e.message : "") || "Unknown error";
            }
            if (pingSendError) {
              this.keepaliveTrace("Ping send failed: " + pingSendError);
              this.trace("Connection dropped due to ping send error: " + pingSendError);
              sessionClosedByServer = true;
              session.close();
              return;
            }
            keepaliveTimer = setTimeout(() => {
              clearKeepaliveTimeout();
              this.keepaliveTrace("Ping timeout passed without response");
              this.trace("Connection dropped by keepalive timeout");
              sessionClosedByServer = true;
              session.close();
            }, this.keepaliveTimeoutMs);
            (_b2 = keepaliveTimer.unref) === null || _b2 === undefined || _b2.call(keepaliveTimer);
          };
          maybeStartKeepalivePingTimer();
          session.on("close", () => {
            var _b2, _c2;
            if (!sessionClosedByServer) {
              this.trace(`Connection dropped by client ${(_b2 = session.socket) === null || _b2 === undefined ? undefined : _b2.remoteAddress}`);
            }
            if (connectionAgeTimer) {
              clearTimeout(connectionAgeTimer);
            }
            if (connectionAgeGraceTimer) {
              clearTimeout(connectionAgeGraceTimer);
            }
            clearKeepaliveTimeout();
            if (idleTimeoutObj !== null) {
              clearTimeout(idleTimeoutObj.timeout);
              this.sessionIdleTimeouts.delete(session);
            }
            (_c2 = this.http2Servers.get(http2Server)) === null || _c2 === undefined || _c2.sessions.delete(session);
          });
        };
      }
      _channelzSessionHandler(http2Server) {
        return (session) => {
          var _b, _c, _d, _e;
          const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress) !== null && _c !== undefined ? _c : "unknown", this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);
          const channelzSessionInfo = {
            ref: channelzRef,
            streamTracker: new channelz_1.ChannelzCallTracker,
            messagesSent: 0,
            messagesReceived: 0,
            keepAlivesSent: 0,
            lastMessageSentTimestamp: null,
            lastMessageReceivedTimestamp: null
          };
          (_d = this.http2Servers.get(http2Server)) === null || _d === undefined || _d.sessions.add(session);
          this.sessions.set(session, channelzSessionInfo);
          const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;
          this.channelzTrace.addTrace("CT_INFO", "Connection established by client " + clientAddress);
          this.trace("Connection established by client " + clientAddress);
          this.sessionChildrenTracker.refChild(channelzRef);
          let connectionAgeTimer = null;
          let connectionAgeGraceTimer = null;
          let keepaliveTimeout = null;
          let sessionClosedByServer = false;
          const idleTimeoutObj = this.enableIdleTimeout(session);
          if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
            const jitterMagnitude = this.maxConnectionAgeMs / 10;
            const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
            connectionAgeTimer = setTimeout(() => {
              var _b2;
              sessionClosedByServer = true;
              this.channelzTrace.addTrace("CT_INFO", "Connection dropped by max connection age from " + clientAddress);
              try {
                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
              } catch (e) {
                session.destroy();
                return;
              }
              session.close();
              if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                connectionAgeGraceTimer = setTimeout(() => {
                  session.destroy();
                }, this.maxConnectionAgeGraceMs);
                (_b2 = connectionAgeGraceTimer.unref) === null || _b2 === undefined || _b2.call(connectionAgeGraceTimer);
              }
            }, this.maxConnectionAgeMs + jitter);
            (_e = connectionAgeTimer.unref) === null || _e === undefined || _e.call(connectionAgeTimer);
          }
          const clearKeepaliveTimeout = () => {
            if (keepaliveTimeout) {
              clearTimeout(keepaliveTimeout);
              keepaliveTimeout = null;
            }
          };
          const canSendPing = () => {
            return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;
          };
          let sendPing;
          const maybeStartKeepalivePingTimer = () => {
            var _b2;
            if (!canSendPing()) {
              return;
            }
            this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
            keepaliveTimeout = setTimeout(() => {
              clearKeepaliveTimeout();
              sendPing();
            }, this.keepaliveTimeMs);
            (_b2 = keepaliveTimeout.unref) === null || _b2 === undefined || _b2.call(keepaliveTimeout);
          };
          sendPing = () => {
            var _b2;
            if (!canSendPing()) {
              return;
            }
            this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
            let pingSendError = "";
            try {
              const pingSentSuccessfully = session.ping((err, duration, payload) => {
                clearKeepaliveTimeout();
                if (err) {
                  this.keepaliveTrace("Ping failed with error: " + err.message);
                  this.channelzTrace.addTrace("CT_INFO", "Connection dropped due to error of a ping frame " + err.message + " return in " + duration);
                  sessionClosedByServer = true;
                  session.close();
                } else {
                  this.keepaliveTrace("Received ping response");
                  maybeStartKeepalivePingTimer();
                }
              });
              if (!pingSentSuccessfully) {
                pingSendError = "Ping returned false";
              }
            } catch (e) {
              pingSendError = (e instanceof Error ? e.message : "") || "Unknown error";
            }
            if (pingSendError) {
              this.keepaliveTrace("Ping send failed: " + pingSendError);
              this.channelzTrace.addTrace("CT_INFO", "Connection dropped due to ping send error: " + pingSendError);
              sessionClosedByServer = true;
              session.close();
              return;
            }
            channelzSessionInfo.keepAlivesSent += 1;
            keepaliveTimeout = setTimeout(() => {
              clearKeepaliveTimeout();
              this.keepaliveTrace("Ping timeout passed without response");
              this.channelzTrace.addTrace("CT_INFO", "Connection dropped by keepalive timeout from " + clientAddress);
              sessionClosedByServer = true;
              session.close();
            }, this.keepaliveTimeoutMs);
            (_b2 = keepaliveTimeout.unref) === null || _b2 === undefined || _b2.call(keepaliveTimeout);
          };
          maybeStartKeepalivePingTimer();
          session.on("close", () => {
            var _b2;
            if (!sessionClosedByServer) {
              this.channelzTrace.addTrace("CT_INFO", "Connection dropped by client " + clientAddress);
            }
            this.sessionChildrenTracker.unrefChild(channelzRef);
            (0, channelz_1.unregisterChannelzRef)(channelzRef);
            if (connectionAgeTimer) {
              clearTimeout(connectionAgeTimer);
            }
            if (connectionAgeGraceTimer) {
              clearTimeout(connectionAgeGraceTimer);
            }
            clearKeepaliveTimeout();
            if (idleTimeoutObj !== null) {
              clearTimeout(idleTimeoutObj.timeout);
              this.sessionIdleTimeouts.delete(session);
            }
            (_b2 = this.http2Servers.get(http2Server)) === null || _b2 === undefined || _b2.sessions.delete(session);
            this.sessions.delete(session);
          });
        };
      }
      enableIdleTimeout(session) {
        var _b, _c;
        if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
          return null;
        }
        const idleTimeoutObj = {
          activeStreams: 0,
          lastIdle: Date.now(),
          onClose: this.onStreamClose.bind(this, session),
          timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session)
        };
        (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === undefined || _c.call(_b);
        this.sessionIdleTimeouts.set(session, idleTimeoutObj);
        const { socket } = session;
        this.trace("Enable idle timeout for " + socket.remoteAddress + ":" + socket.remotePort);
        return idleTimeoutObj;
      }
      onIdleTimeout(ctx, session) {
        const { socket } = session;
        const sessionInfo = ctx.sessionIdleTimeouts.get(session);
        if (sessionInfo !== undefined && sessionInfo.activeStreams === 0) {
          if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
            ctx.trace("Session idle timeout triggered for " + (socket === null || socket === undefined ? undefined : socket.remoteAddress) + ":" + (socket === null || socket === undefined ? undefined : socket.remotePort) + " last idle at " + sessionInfo.lastIdle);
            ctx.closeSession(session);
          } else {
            sessionInfo.timeout.refresh();
          }
        }
      }
      onStreamOpened(stream) {
        const session = stream.session;
        const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
        if (idleTimeoutObj) {
          idleTimeoutObj.activeStreams += 1;
          stream.once("close", idleTimeoutObj.onClose);
        }
      }
      onStreamClose(session) {
        var _b, _c;
        const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
        if (idleTimeoutObj) {
          idleTimeoutObj.activeStreams -= 1;
          if (idleTimeoutObj.activeStreams === 0) {
            idleTimeoutObj.lastIdle = Date.now();
            idleTimeoutObj.timeout.refresh();
            this.trace("Session onStreamClose" + ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress) + ":" + ((_c = session.socket) === null || _c === undefined ? undefined : _c.remotePort) + " at " + idleTimeoutObj.lastIdle);
          }
        }
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : undefined;
      _start_decorators = [deprecate("Calling start() is no longer necessary. It can be safely omitted.")];
      __esDecorate(_a, null, _start_decorators, { kind: "method", name: "start", static: false, private: false, access: { has: (obj) => ("start" in obj), get: (obj) => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata)
        Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a;
  })();
  exports.Server = Server;
  async function handleUnary(call, handler) {
    let stream;
    function respond(err, value, trailer, flags) {
      if (err) {
        call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
        return;
      }
      call.sendMessage(value, () => {
        call.sendStatus({
          code: constants_1.Status.OK,
          details: "OK",
          metadata: trailer !== null && trailer !== undefined ? trailer : null
        });
      });
    }
    let requestMetadata;
    let requestMessage = null;
    call.start({
      onReceiveMetadata(metadata) {
        requestMetadata = metadata;
        call.startRead();
      },
      onReceiveMessage(message) {
        if (requestMessage) {
          call.sendStatus({
            code: constants_1.Status.UNIMPLEMENTED,
            details: `Received a second request message for server streaming method ${handler.path}`,
            metadata: null
          });
          return;
        }
        requestMessage = message;
        call.startRead();
      },
      onReceiveHalfClose() {
        if (!requestMessage) {
          call.sendStatus({
            code: constants_1.Status.UNIMPLEMENTED,
            details: `Received no request message for server streaming method ${handler.path}`,
            metadata: null
          });
          return;
        }
        stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
        try {
          handler.func(stream, respond);
        } catch (err) {
          call.sendStatus({
            code: constants_1.Status.UNKNOWN,
            details: `Server method handler threw error ${err.message}`,
            metadata: null
          });
        }
      },
      onCancel() {
        if (stream) {
          stream.cancelled = true;
          stream.emit("cancelled", "cancelled");
        }
      }
    });
  }
  function handleClientStreaming(call, handler) {
    let stream;
    function respond(err, value, trailer, flags) {
      if (err) {
        call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
        return;
      }
      call.sendMessage(value, () => {
        call.sendStatus({
          code: constants_1.Status.OK,
          details: "OK",
          metadata: trailer !== null && trailer !== undefined ? trailer : null
        });
      });
    }
    call.start({
      onReceiveMetadata(metadata) {
        stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
        try {
          handler.func(stream, respond);
        } catch (err) {
          call.sendStatus({
            code: constants_1.Status.UNKNOWN,
            details: `Server method handler threw error ${err.message}`,
            metadata: null
          });
        }
      },
      onReceiveMessage(message) {
        stream.push(message);
      },
      onReceiveHalfClose() {
        stream.push(null);
      },
      onCancel() {
        if (stream) {
          stream.cancelled = true;
          stream.emit("cancelled", "cancelled");
          stream.destroy();
        }
      }
    });
  }
  function handleServerStreaming(call, handler) {
    let stream;
    let requestMetadata;
    let requestMessage = null;
    call.start({
      onReceiveMetadata(metadata) {
        requestMetadata = metadata;
        call.startRead();
      },
      onReceiveMessage(message) {
        if (requestMessage) {
          call.sendStatus({
            code: constants_1.Status.UNIMPLEMENTED,
            details: `Received a second request message for server streaming method ${handler.path}`,
            metadata: null
          });
          return;
        }
        requestMessage = message;
        call.startRead();
      },
      onReceiveHalfClose() {
        if (!requestMessage) {
          call.sendStatus({
            code: constants_1.Status.UNIMPLEMENTED,
            details: `Received no request message for server streaming method ${handler.path}`,
            metadata: null
          });
          return;
        }
        stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
        try {
          handler.func(stream);
        } catch (err) {
          call.sendStatus({
            code: constants_1.Status.UNKNOWN,
            details: `Server method handler threw error ${err.message}`,
            metadata: null
          });
        }
      },
      onCancel() {
        if (stream) {
          stream.cancelled = true;
          stream.emit("cancelled", "cancelled");
          stream.destroy();
        }
      }
    });
  }
  function handleBidiStreaming(call, handler) {
    let stream;
    call.start({
      onReceiveMetadata(metadata) {
        stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
        try {
          handler.func(stream);
        } catch (err) {
          call.sendStatus({
            code: constants_1.Status.UNKNOWN,
            details: `Server method handler threw error ${err.message}`,
            metadata: null
          });
        }
      },
      onReceiveMessage(message) {
        stream.push(message);
      },
      onReceiveHalfClose() {
        stream.push(null);
      },
      onCancel() {
        if (stream) {
          stream.cancelled = true;
          stream.emit("cancelled", "cancelled");
          stream.destroy();
        }
      }
    });
  }
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StatusBuilder = undefined;

  class StatusBuilder {
    constructor() {
      this.code = null;
      this.details = null;
      this.metadata = null;
    }
    withCode(code) {
      this.code = code;
      return this;
    }
    withDetails(details) {
      this.details = details;
      return this;
    }
    withMetadata(metadata) {
      this.metadata = metadata;
      return this;
    }
    build() {
      const status = {};
      if (this.code !== null) {
        status.code = this.code;
      }
      if (this.details !== null) {
        status.details = this.details;
      }
      if (this.metadata !== null) {
        status.metadata = this.metadata;
      }
      return status;
    }
  }
  exports.StatusBuilder = StatusBuilder;
});

// node_modules/@grpc/grpc-js/build/src/duration.js
var require_duration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.msToDuration = msToDuration;
  exports.durationToMs = durationToMs;
  exports.isDuration = isDuration;
  exports.parseDuration = parseDuration;
  function msToDuration(millis) {
    return {
      seconds: millis / 1000 | 0,
      nanos: millis % 1000 * 1e6 | 0
    };
  }
  function durationToMs(duration) {
    return duration.seconds * 1000 + duration.nanos / 1e6 | 0;
  }
  function isDuration(value) {
    return typeof value.seconds === "number" && typeof value.nanos === "number";
  }
  var durationRegex = /^(\d+)(?:\.(\d+))?s$/;
  function parseDuration(value) {
    const match = value.match(durationRegex);
    if (!match) {
      return null;
    }
    return {
      seconds: Number.parseInt(match[1], 10),
      nanos: match[2] ? Number.parseInt(match[2].padEnd(9, "0"), 10) : 0
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = undefined;
  exports.shuffled = shuffled;
  exports.setup = setup;
  var load_balancer_1 = require_load_balancer();
  var connectivity_state_1 = require_connectivity_state();
  var picker_1 = require_picker();
  var subchannel_address_1 = require_subchannel_address();
  var logging = require_logging();
  var constants_1 = require_constants2();
  var subchannel_address_2 = require_subchannel_address();
  var net_1 = __require("net");
  var TRACER_NAME = "pick_first";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var TYPE_NAME = "pick_first";
  var CONNECTION_DELAY_INTERVAL_MS = 250;

  class PickFirstLoadBalancingConfig {
    constructor(shuffleAddressList) {
      this.shuffleAddressList = shuffleAddressList;
    }
    getLoadBalancerName() {
      return TYPE_NAME;
    }
    toJsonObject() {
      return {
        [TYPE_NAME]: {
          shuffleAddressList: this.shuffleAddressList
        }
      };
    }
    getShuffleAddressList() {
      return this.shuffleAddressList;
    }
    static createFromJson(obj) {
      if ("shuffleAddressList" in obj && !(typeof obj.shuffleAddressList === "boolean")) {
        throw new Error("pick_first config field shuffleAddressList must be a boolean if provided");
      }
      return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);
    }
  }
  exports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;

  class PickFirstPicker {
    constructor(subchannel) {
      this.subchannel = subchannel;
    }
    pick(pickArgs) {
      return {
        pickResultType: picker_1.PickResultType.COMPLETE,
        subchannel: this.subchannel,
        status: null,
        onCallStarted: null,
        onCallEnded: null
      };
    }
  }
  function shuffled(list) {
    const result = list.slice();
    for (let i = result.length - 1;i > 1; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const temp = result[i];
      result[i] = result[j];
      result[j] = temp;
    }
    return result;
  }
  function interleaveAddressFamilies(addressList) {
    if (addressList.length === 0) {
      return [];
    }
    const result = [];
    const ipv6Addresses = [];
    const ipv4Addresses = [];
    const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);
    for (const address of addressList) {
      if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {
        ipv6Addresses.push(address);
      } else {
        ipv4Addresses.push(address);
      }
    }
    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
    for (let i = 0;i < Math.max(firstList.length, secondList.length); i++) {
      if (i < firstList.length) {
        result.push(firstList[i]);
      }
      if (i < secondList.length) {
        result.push(secondList[i]);
      }
    }
    return result;
  }
  var REPORT_HEALTH_STATUS_OPTION_NAME = "grpc-node.internal.pick-first.report_health_status";

  class PickFirstLoadBalancer {
    constructor(channelControlHelper) {
      this.channelControlHelper = channelControlHelper;
      this.children = [];
      this.currentState = connectivity_state_1.ConnectivityState.IDLE;
      this.currentSubchannelIndex = 0;
      this.currentPick = null;
      this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {
        this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);
      };
      this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();
      this.stickyTransientFailureMode = false;
      this.reportHealthStatus = false;
      this.lastError = null;
      this.latestAddressList = null;
      this.latestOptions = {};
      this.connectionDelayTimeout = setTimeout(() => {
      }, 0);
      clearTimeout(this.connectionDelayTimeout);
    }
    allChildrenHaveReportedTF() {
      return this.children.every((child) => child.hasReportedTransientFailure);
    }
    resetChildrenReportedTF() {
      this.children.every((child) => child.hasReportedTransientFailure = false);
    }
    calculateAndReportNewState() {
      var _a;
      if (this.currentPick) {
        if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
          const errorMessage = `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`;
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
            details: errorMessage
          }), errorMessage);
        } else {
          this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick), null);
        }
      } else if (((_a = this.latestAddressList) === null || _a === undefined ? undefined : _a.length) === 0) {
        const errorMessage = `No connection established. Last error: ${this.lastError}`;
        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
          details: errorMessage
        }), errorMessage);
      } else if (this.children.length === 0) {
        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);
      } else {
        if (this.stickyTransientFailureMode) {
          const errorMessage = `No connection established. Last error: ${this.lastError}`;
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
            details: errorMessage
          }), errorMessage);
        } else {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);
        }
      }
    }
    requestReresolution() {
      this.channelControlHelper.requestReresolution();
    }
    maybeEnterStickyTransientFailureMode() {
      if (!this.allChildrenHaveReportedTF()) {
        return;
      }
      this.requestReresolution();
      this.resetChildrenReportedTF();
      if (this.stickyTransientFailureMode) {
        this.calculateAndReportNewState();
        return;
      }
      this.stickyTransientFailureMode = true;
      for (const { subchannel } of this.children) {
        subchannel.startConnecting();
      }
      this.calculateAndReportNewState();
    }
    removeCurrentPick() {
      if (this.currentPick !== null) {
        this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);
        this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());
        this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);
        this.currentPick.unref();
        this.currentPick = null;
      }
    }
    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {
      var _a;
      if ((_a = this.currentPick) === null || _a === undefined ? undefined : _a.realSubchannelEquals(subchannel)) {
        if (newState !== connectivity_state_1.ConnectivityState.READY) {
          this.removeCurrentPick();
          this.calculateAndReportNewState();
        }
        return;
      }
      for (const [index, child] of this.children.entries()) {
        if (subchannel.realSubchannelEquals(child.subchannel)) {
          if (newState === connectivity_state_1.ConnectivityState.READY) {
            this.pickSubchannel(child.subchannel);
          }
          if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            child.hasReportedTransientFailure = true;
            if (errorMessage) {
              this.lastError = errorMessage;
            }
            this.maybeEnterStickyTransientFailureMode();
            if (index === this.currentSubchannelIndex) {
              this.startNextSubchannelConnecting(index + 1);
            }
          }
          child.subchannel.startConnecting();
          return;
        }
      }
    }
    startNextSubchannelConnecting(startIndex) {
      clearTimeout(this.connectionDelayTimeout);
      for (const [index, child] of this.children.entries()) {
        if (index >= startIndex) {
          const subchannelState = child.subchannel.getConnectivityState();
          if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
            this.startConnecting(index);
            return;
          }
        }
      }
      this.maybeEnterStickyTransientFailureMode();
    }
    startConnecting(subchannelIndex) {
      var _a, _b;
      clearTimeout(this.connectionDelayTimeout);
      this.currentSubchannelIndex = subchannelIndex;
      if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
        trace("Start connecting to subchannel with address " + this.children[subchannelIndex].subchannel.getAddress());
        process.nextTick(() => {
          var _a2;
          (_a2 = this.children[subchannelIndex]) === null || _a2 === undefined || _a2.subchannel.startConnecting();
        });
      }
      this.connectionDelayTimeout = setTimeout(() => {
        this.startNextSubchannelConnecting(subchannelIndex + 1);
      }, CONNECTION_DELAY_INTERVAL_MS);
      (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === undefined || _b.call(_a);
    }
    pickSubchannel(subchannel) {
      trace("Pick subchannel with address " + subchannel.getAddress());
      this.stickyTransientFailureMode = false;
      subchannel.ref();
      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
      this.removeCurrentPick();
      this.resetSubchannelList();
      subchannel.addConnectivityStateListener(this.subchannelStateListener);
      subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
      this.currentPick = subchannel;
      clearTimeout(this.connectionDelayTimeout);
      this.calculateAndReportNewState();
    }
    updateState(newState, picker, errorMessage) {
      trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
      this.currentState = newState;
      this.channelControlHelper.updateState(newState, picker, errorMessage);
    }
    resetSubchannelList() {
      for (const child of this.children) {
        child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);
        child.subchannel.unref();
        this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());
      }
      this.currentSubchannelIndex = 0;
      this.children = [];
    }
    connectToAddressList(addressList, options) {
      trace("connectToAddressList([" + addressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)) + "])");
      const newChildrenList = addressList.map((address) => ({
        subchannel: this.channelControlHelper.createSubchannel(address, options),
        hasReportedTransientFailure: false
      }));
      for (const { subchannel } of newChildrenList) {
        if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
          this.pickSubchannel(subchannel);
          return;
        }
      }
      for (const { subchannel } of newChildrenList) {
        subchannel.ref();
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
      }
      this.resetSubchannelList();
      this.children = newChildrenList;
      for (const { subchannel } of this.children) {
        subchannel.addConnectivityStateListener(this.subchannelStateListener);
      }
      for (const child of this.children) {
        if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
          child.hasReportedTransientFailure = true;
        }
      }
      this.startNextSubchannelConnecting(0);
      this.calculateAndReportNewState();
    }
    updateAddressList(endpointList, lbConfig, options) {
      if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
        return;
      }
      this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
      if (lbConfig.getShuffleAddressList()) {
        endpointList = shuffled(endpointList);
      }
      const rawAddressList = [].concat(...endpointList.map((endpoint) => endpoint.addresses));
      trace("updateAddressList([" + rawAddressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)) + "])");
      if (rawAddressList.length === 0) {
        this.lastError = "No addresses resolved";
      }
      const addressList = interleaveAddressFamilies(rawAddressList);
      this.latestAddressList = addressList;
      this.latestOptions = options;
      this.connectToAddressList(addressList, options);
    }
    exitIdle() {
      if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {
        this.connectToAddressList(this.latestAddressList, this.latestOptions);
      }
    }
    resetBackoff() {
    }
    destroy() {
      this.resetSubchannelList();
      this.removeCurrentPick();
    }
    getTypeName() {
      return TYPE_NAME;
    }
  }
  exports.PickFirstLoadBalancer = PickFirstLoadBalancer;
  var LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);

  class LeafLoadBalancer {
    constructor(endpoint, channelControlHelper, options) {
      this.endpoint = endpoint;
      this.options = options;
      this.latestState = connectivity_state_1.ConnectivityState.IDLE;
      const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
        updateState: (connectivityState, picker, errorMessage) => {
          this.latestState = connectivityState;
          this.latestPicker = picker;
          channelControlHelper.updateState(connectivityState, picker, errorMessage);
        }
      });
      this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper);
      this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);
    }
    startConnecting() {
      this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG, Object.assign(Object.assign({}, this.options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }));
    }
    updateEndpoint(newEndpoint, newOptions) {
      this.options = newOptions;
      this.endpoint = newEndpoint;
      if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {
        this.startConnecting();
      }
    }
    getConnectivityState() {
      return this.latestState;
    }
    getPicker() {
      return this.latestPicker;
    }
    getEndpoint() {
      return this.endpoint;
    }
    exitIdle() {
      this.pickFirstBalancer.exitIdle();
    }
    destroy() {
      this.pickFirstBalancer.destroy();
    }
  }
  exports.LeafLoadBalancer = LeafLoadBalancer;
  function setup() {
    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
  }
});

// node_modules/@grpc/grpc-js/build/src/certificate-provider.js
var require_certificate_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FileWatcherCertificateProvider = undefined;
  var fs = __require("fs");
  var logging = require_logging();
  var constants_1 = require_constants2();
  var util_1 = __require("util");
  var TRACER_NAME = "certificate_provider";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var readFilePromise = (0, util_1.promisify)(fs.readFile);

  class FileWatcherCertificateProvider {
    constructor(config) {
      this.config = config;
      this.refreshTimer = null;
      this.fileResultPromise = null;
      this.latestCaUpdate = undefined;
      this.caListeners = new Set;
      this.latestIdentityUpdate = undefined;
      this.identityListeners = new Set;
      this.lastUpdateTime = null;
      if (config.certificateFile === undefined !== (config.privateKeyFile === undefined)) {
        throw new Error("certificateFile and privateKeyFile must be set or unset together");
      }
      if (config.certificateFile === undefined && config.caCertificateFile === undefined) {
        throw new Error("At least one of certificateFile and caCertificateFile must be set");
      }
      trace("File watcher constructed with config " + JSON.stringify(config));
    }
    updateCertificates() {
      if (this.fileResultPromise) {
        return;
      }
      this.fileResultPromise = Promise.allSettled([
        this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),
        this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),
        this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()
      ]);
      this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {
        if (!this.refreshTimer) {
          return;
        }
        trace("File watcher read certificates certificate " + certificateResult.status + ", privateKey " + privateKeyResult.status + ", CA certificate " + caCertificateResult.status);
        this.lastUpdateTime = new Date;
        this.fileResultPromise = null;
        if (certificateResult.status === "fulfilled" && privateKeyResult.status === "fulfilled") {
          this.latestIdentityUpdate = {
            certificate: certificateResult.value,
            privateKey: privateKeyResult.value
          };
        } else {
          this.latestIdentityUpdate = null;
        }
        if (caCertificateResult.status === "fulfilled") {
          this.latestCaUpdate = {
            caCertificate: caCertificateResult.value
          };
        } else {
          this.latestCaUpdate = null;
        }
        for (const listener of this.identityListeners) {
          listener(this.latestIdentityUpdate);
        }
        for (const listener of this.caListeners) {
          listener(this.latestCaUpdate);
        }
      });
      trace("File watcher initiated certificate update");
    }
    maybeStartWatchingFiles() {
      if (!this.refreshTimer) {
        const timeSinceLastUpdate = this.lastUpdateTime ? new Date().getTime() - this.lastUpdateTime.getTime() : Infinity;
        if (timeSinceLastUpdate > this.config.refreshIntervalMs) {
          this.updateCertificates();
        }
        if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {
          this.latestCaUpdate = undefined;
          this.latestIdentityUpdate = undefined;
        }
        this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);
        trace("File watcher started watching");
      }
    }
    maybeStopWatchingFiles() {
      if (this.caListeners.size === 0 && this.identityListeners.size === 0) {
        this.fileResultPromise = null;
        if (this.refreshTimer) {
          clearInterval(this.refreshTimer);
          this.refreshTimer = null;
        }
      }
    }
    addCaCertificateListener(listener) {
      this.caListeners.add(listener);
      this.maybeStartWatchingFiles();
      if (this.latestCaUpdate !== undefined) {
        process.nextTick(listener, this.latestCaUpdate);
      }
    }
    removeCaCertificateListener(listener) {
      this.caListeners.delete(listener);
      this.maybeStopWatchingFiles();
    }
    addIdentityCertificateListener(listener) {
      this.identityListeners.add(listener);
      this.maybeStartWatchingFiles();
      if (this.latestIdentityUpdate !== undefined) {
        process.nextTick(listener, this.latestIdentityUpdate);
      }
    }
    removeIdentityCertificateListener(listener) {
      this.identityListeners.delete(listener);
      this.maybeStopWatchingFiles();
    }
  }
  exports.FileWatcherCertificateProvider = FileWatcherCertificateProvider;
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = exports.createCertificateProviderChannelCredentials = exports.FileWatcherCertificateProvider = exports.createCertificateProviderServerCredentials = exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.parseDuration = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = undefined;
  var logging_1 = require_logging();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return logging_1.trace;
  } });
  Object.defineProperty(exports, "log", { enumerable: true, get: function() {
    return logging_1.log;
  } });
  var resolver_1 = require_resolver();
  Object.defineProperty(exports, "registerResolver", { enumerable: true, get: function() {
    return resolver_1.registerResolver;
  } });
  Object.defineProperty(exports, "createResolver", { enumerable: true, get: function() {
    return resolver_1.createResolver;
  } });
  var uri_parser_1 = require_uri_parser();
  Object.defineProperty(exports, "uriToString", { enumerable: true, get: function() {
    return uri_parser_1.uriToString;
  } });
  Object.defineProperty(exports, "splitHostPort", { enumerable: true, get: function() {
    return uri_parser_1.splitHostPort;
  } });
  var duration_1 = require_duration();
  Object.defineProperty(exports, "durationToMs", { enumerable: true, get: function() {
    return duration_1.durationToMs;
  } });
  Object.defineProperty(exports, "parseDuration", { enumerable: true, get: function() {
    return duration_1.parseDuration;
  } });
  var backoff_timeout_1 = require_backoff_timeout();
  Object.defineProperty(exports, "BackoffTimeout", { enumerable: true, get: function() {
    return backoff_timeout_1.BackoffTimeout;
  } });
  var load_balancer_1 = require_load_balancer();
  Object.defineProperty(exports, "createChildChannelControlHelper", { enumerable: true, get: function() {
    return load_balancer_1.createChildChannelControlHelper;
  } });
  Object.defineProperty(exports, "registerLoadBalancerType", { enumerable: true, get: function() {
    return load_balancer_1.registerLoadBalancerType;
  } });
  Object.defineProperty(exports, "selectLbConfigFromList", { enumerable: true, get: function() {
    return load_balancer_1.selectLbConfigFromList;
  } });
  Object.defineProperty(exports, "parseLoadBalancingConfig", { enumerable: true, get: function() {
    return load_balancer_1.parseLoadBalancingConfig;
  } });
  Object.defineProperty(exports, "isLoadBalancerNameRegistered", { enumerable: true, get: function() {
    return load_balancer_1.isLoadBalancerNameRegistered;
  } });
  var load_balancer_pick_first_1 = require_load_balancer_pick_first();
  Object.defineProperty(exports, "LeafLoadBalancer", { enumerable: true, get: function() {
    return load_balancer_pick_first_1.LeafLoadBalancer;
  } });
  var subchannel_address_1 = require_subchannel_address();
  Object.defineProperty(exports, "subchannelAddressToString", { enumerable: true, get: function() {
    return subchannel_address_1.subchannelAddressToString;
  } });
  Object.defineProperty(exports, "endpointToString", { enumerable: true, get: function() {
    return subchannel_address_1.endpointToString;
  } });
  Object.defineProperty(exports, "endpointHasAddress", { enumerable: true, get: function() {
    return subchannel_address_1.endpointHasAddress;
  } });
  Object.defineProperty(exports, "EndpointMap", { enumerable: true, get: function() {
    return subchannel_address_1.EndpointMap;
  } });
  var load_balancer_child_handler_1 = require_load_balancer_child_handler();
  Object.defineProperty(exports, "ChildLoadBalancerHandler", { enumerable: true, get: function() {
    return load_balancer_child_handler_1.ChildLoadBalancerHandler;
  } });
  var picker_1 = require_picker();
  Object.defineProperty(exports, "UnavailablePicker", { enumerable: true, get: function() {
    return picker_1.UnavailablePicker;
  } });
  Object.defineProperty(exports, "QueuePicker", { enumerable: true, get: function() {
    return picker_1.QueuePicker;
  } });
  Object.defineProperty(exports, "PickResultType", { enumerable: true, get: function() {
    return picker_1.PickResultType;
  } });
  var filter_1 = require_filter();
  Object.defineProperty(exports, "BaseFilter", { enumerable: true, get: function() {
    return filter_1.BaseFilter;
  } });
  var filter_stack_1 = require_filter_stack();
  Object.defineProperty(exports, "FilterStackFactory", { enumerable: true, get: function() {
    return filter_stack_1.FilterStackFactory;
  } });
  var admin_1 = require_admin();
  Object.defineProperty(exports, "registerAdminService", { enumerable: true, get: function() {
    return admin_1.registerAdminService;
  } });
  var subchannel_interface_1 = require_subchannel_interface();
  Object.defineProperty(exports, "BaseSubchannelWrapper", { enumerable: true, get: function() {
    return subchannel_interface_1.BaseSubchannelWrapper;
  } });
  var server_credentials_1 = require_server_credentials();
  Object.defineProperty(exports, "createServerCredentialsWithInterceptors", { enumerable: true, get: function() {
    return server_credentials_1.createServerCredentialsWithInterceptors;
  } });
  Object.defineProperty(exports, "createCertificateProviderServerCredentials", { enumerable: true, get: function() {
    return server_credentials_1.createCertificateProviderServerCredentials;
  } });
  var certificate_provider_1 = require_certificate_provider();
  Object.defineProperty(exports, "FileWatcherCertificateProvider", { enumerable: true, get: function() {
    return certificate_provider_1.FileWatcherCertificateProvider;
  } });
  var channel_credentials_1 = require_channel_credentials();
  Object.defineProperty(exports, "createCertificateProviderChannelCredentials", { enumerable: true, get: function() {
    return channel_credentials_1.createCertificateProviderChannelCredentials;
  } });
  var internal_channel_1 = require_internal_channel();
  Object.defineProperty(exports, "SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX", { enumerable: true, get: function() {
    return internal_channel_1.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX;
  } });
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setup = setup;
  var resolver_1 = require_resolver();

  class UdsResolver {
    constructor(target, listener, channelOptions) {
      this.listener = listener;
      this.hasReturnedResult = false;
      this.endpoints = [];
      let path;
      if (target.authority === "") {
        path = "/" + target.path;
      } else {
        path = target.path;
      }
      this.endpoints = [{ addresses: [{ path }] }];
    }
    updateResolution() {
      if (!this.hasReturnedResult) {
        this.hasReturnedResult = true;
        process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});
      }
    }
    destroy() {
      this.hasReturnedResult = false;
    }
    static getDefaultAuthority(target) {
      return "localhost";
    }
  }
  function setup() {
    (0, resolver_1.registerResolver)("unix", UdsResolver);
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-ip.js
var require_resolver_ip = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setup = setup;
  var net_1 = __require("net");
  var constants_1 = require_constants2();
  var metadata_1 = require_metadata();
  var resolver_1 = require_resolver();
  var uri_parser_1 = require_uri_parser();
  var logging = require_logging();
  var TRACER_NAME = "ip_resolver";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var IPV4_SCHEME = "ipv4";
  var IPV6_SCHEME = "ipv6";
  var DEFAULT_PORT = 443;

  class IpResolver {
    constructor(target, listener, channelOptions) {
      var _a;
      this.listener = listener;
      this.endpoints = [];
      this.error = null;
      this.hasReturnedResult = false;
      trace("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
      const addresses = [];
      if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
        this.error = {
          code: constants_1.Status.UNAVAILABLE,
          details: `Unrecognized scheme ${target.scheme} in IP resolver`,
          metadata: new metadata_1.Metadata
        };
        return;
      }
      const pathList = target.path.split(",");
      for (const path of pathList) {
        const hostPort = (0, uri_parser_1.splitHostPort)(path);
        if (hostPort === null) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Failed to parse ${target.scheme} address ${path}`,
            metadata: new metadata_1.Metadata
          };
          return;
        }
        if (target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host) || target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host)) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Failed to parse ${target.scheme} address ${path}`,
            metadata: new metadata_1.Metadata
          };
          return;
        }
        addresses.push({
          host: hostPort.host,
          port: (_a = hostPort.port) !== null && _a !== undefined ? _a : DEFAULT_PORT
        });
      }
      this.endpoints = addresses.map((address) => ({ addresses: [address] }));
      trace("Parsed " + target.scheme + " address list " + addresses);
    }
    updateResolution() {
      if (!this.hasReturnedResult) {
        this.hasReturnedResult = true;
        process.nextTick(() => {
          if (this.error) {
            this.listener.onError(this.error);
          } else {
            this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});
          }
        });
      }
    }
    destroy() {
      this.hasReturnedResult = false;
    }
    static getDefaultAuthority(target) {
      return target.path.split(",")[0];
    }
  }
  function setup() {
    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RoundRobinLoadBalancer = undefined;
  exports.setup = setup;
  var load_balancer_1 = require_load_balancer();
  var connectivity_state_1 = require_connectivity_state();
  var picker_1 = require_picker();
  var logging = require_logging();
  var constants_1 = require_constants2();
  var subchannel_address_1 = require_subchannel_address();
  var load_balancer_pick_first_1 = require_load_balancer_pick_first();
  var TRACER_NAME = "round_robin";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var TYPE_NAME = "round_robin";

  class RoundRobinLoadBalancingConfig {
    getLoadBalancerName() {
      return TYPE_NAME;
    }
    constructor() {
    }
    toJsonObject() {
      return {
        [TYPE_NAME]: {}
      };
    }
    static createFromJson(obj) {
      return new RoundRobinLoadBalancingConfig;
    }
  }

  class RoundRobinPicker {
    constructor(children, nextIndex = 0) {
      this.children = children;
      this.nextIndex = nextIndex;
    }
    pick(pickArgs) {
      const childPicker = this.children[this.nextIndex].picker;
      this.nextIndex = (this.nextIndex + 1) % this.children.length;
      return childPicker.pick(pickArgs);
    }
    peekNextEndpoint() {
      return this.children[this.nextIndex].endpoint;
    }
  }

  class RoundRobinLoadBalancer {
    constructor(channelControlHelper) {
      this.channelControlHelper = channelControlHelper;
      this.children = [];
      this.currentState = connectivity_state_1.ConnectivityState.IDLE;
      this.currentReadyPicker = null;
      this.updatesPaused = false;
      this.lastError = null;
      this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
        updateState: (connectivityState, picker, errorMessage) => {
          if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {
            this.channelControlHelper.requestReresolution();
          }
          if (errorMessage) {
            this.lastError = errorMessage;
          }
          this.calculateAndUpdateState();
        }
      });
    }
    countChildrenWithState(state) {
      return this.children.filter((child) => child.getConnectivityState() === state).length;
    }
    calculateAndUpdateState() {
      if (this.updatesPaused) {
        return;
      }
      if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {
        const readyChildren = this.children.filter((child) => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
        let index = 0;
        if (this.currentReadyPicker !== null) {
          const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
          index = readyChildren.findIndex((child) => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));
          if (index < 0) {
            index = 0;
          }
        }
        this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map((child) => ({
          endpoint: child.getEndpoint(),
          picker: child.getPicker()
        })), index), null);
      } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {
        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);
      } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {
        const errorMessage = `round_robin: No connection established. Last error: ${this.lastError}`;
        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
          details: errorMessage
        }), errorMessage);
      } else {
        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);
      }
      for (const child of this.children) {
        if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
          child.exitIdle();
        }
      }
    }
    updateState(newState, picker, errorMessage) {
      trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
      if (newState === connectivity_state_1.ConnectivityState.READY) {
        this.currentReadyPicker = picker;
      } else {
        this.currentReadyPicker = null;
      }
      this.currentState = newState;
      this.channelControlHelper.updateState(newState, picker, errorMessage);
    }
    resetSubchannelList() {
      for (const child of this.children) {
        child.destroy();
      }
    }
    updateAddressList(endpointList, lbConfig, options) {
      this.resetSubchannelList();
      trace("Connect to endpoint list " + endpointList.map(subchannel_address_1.endpointToString));
      this.updatesPaused = true;
      this.children = endpointList.map((endpoint) => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, options));
      for (const child of this.children) {
        child.startConnecting();
      }
      this.updatesPaused = false;
      this.calculateAndUpdateState();
    }
    exitIdle() {
    }
    resetBackoff() {
    }
    destroy() {
      this.resetSubchannelList();
    }
    getTypeName() {
      return TYPE_NAME;
    }
  }
  exports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
  function setup() {
    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js
var require_load_balancer_outlier_detection = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = undefined;
  exports.setup = setup;
  var connectivity_state_1 = require_connectivity_state();
  var constants_1 = require_constants2();
  var duration_1 = require_duration();
  var experimental_1 = require_experimental();
  var load_balancer_1 = require_load_balancer();
  var load_balancer_child_handler_1 = require_load_balancer_child_handler();
  var picker_1 = require_picker();
  var subchannel_address_1 = require_subchannel_address();
  var subchannel_interface_1 = require_subchannel_interface();
  var logging = require_logging();
  var TRACER_NAME = "outlier_detection";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var TYPE_NAME = "outlier_detection";
  var OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== undefined ? _a : "true") === "true";
  var defaultSuccessRateEjectionConfig = {
    stdev_factor: 1900,
    enforcement_percentage: 100,
    minimum_hosts: 5,
    request_volume: 100
  };
  var defaultFailurePercentageEjectionConfig = {
    threshold: 85,
    enforcement_percentage: 100,
    minimum_hosts: 5,
    request_volume: 50
  };
  function validateFieldType(obj, fieldName, expectedType, objectName) {
    if (fieldName in obj && obj[fieldName] !== undefined && typeof obj[fieldName] !== expectedType) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
    }
  }
  function validatePositiveDuration(obj, fieldName, objectName) {
    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
    if (fieldName in obj && obj[fieldName] !== undefined) {
      if (!(0, duration_1.isDuration)(obj[fieldName])) {
        throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
      }
      if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {
        throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
      }
    }
  }
  function validatePercentage(obj, fieldName, objectName) {
    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
    validateFieldType(obj, fieldName, "number", objectName);
    if (fieldName in obj && obj[fieldName] !== undefined && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
      throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
    }
  }

  class OutlierDetectionLoadBalancingConfig {
    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
      this.childPolicy = childPolicy;
      if (childPolicy.getLoadBalancerName() === "pick_first") {
        throw new Error("outlier_detection LB policy cannot have a pick_first child policy");
      }
      this.intervalMs = intervalMs !== null && intervalMs !== undefined ? intervalMs : 1e4;
      this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== undefined ? baseEjectionTimeMs : 30000;
      this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== undefined ? maxEjectionTimeMs : 300000;
      this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== undefined ? maxEjectionPercent : 10;
      this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
      this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
    }
    getLoadBalancerName() {
      return TYPE_NAME;
    }
    toJsonObject() {
      var _a2, _b;
      return {
        outlier_detection: {
          interval: (0, duration_1.msToDuration)(this.intervalMs),
          base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
          max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
          max_ejection_percent: this.maxEjectionPercent,
          success_rate_ejection: (_a2 = this.successRateEjection) !== null && _a2 !== undefined ? _a2 : undefined,
          failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== undefined ? _b : undefined,
          child_policy: [this.childPolicy.toJsonObject()]
        }
      };
    }
    getIntervalMs() {
      return this.intervalMs;
    }
    getBaseEjectionTimeMs() {
      return this.baseEjectionTimeMs;
    }
    getMaxEjectionTimeMs() {
      return this.maxEjectionTimeMs;
    }
    getMaxEjectionPercent() {
      return this.maxEjectionPercent;
    }
    getSuccessRateEjectionConfig() {
      return this.successRateEjection;
    }
    getFailurePercentageEjectionConfig() {
      return this.failurePercentageEjection;
    }
    getChildPolicy() {
      return this.childPolicy;
    }
    static createFromJson(obj) {
      var _a2;
      validatePositiveDuration(obj, "interval");
      validatePositiveDuration(obj, "base_ejection_time");
      validatePositiveDuration(obj, "max_ejection_time");
      validatePercentage(obj, "max_ejection_percent");
      if ("success_rate_ejection" in obj && obj.success_rate_ejection !== undefined) {
        if (typeof obj.success_rate_ejection !== "object") {
          throw new Error("outlier detection config success_rate_ejection must be an object");
        }
        validateFieldType(obj.success_rate_ejection, "stdev_factor", "number", "success_rate_ejection");
        validatePercentage(obj.success_rate_ejection, "enforcement_percentage", "success_rate_ejection");
        validateFieldType(obj.success_rate_ejection, "minimum_hosts", "number", "success_rate_ejection");
        validateFieldType(obj.success_rate_ejection, "request_volume", "number", "success_rate_ejection");
      }
      if ("failure_percentage_ejection" in obj && obj.failure_percentage_ejection !== undefined) {
        if (typeof obj.failure_percentage_ejection !== "object") {
          throw new Error("outlier detection config failure_percentage_ejection must be an object");
        }
        validatePercentage(obj.failure_percentage_ejection, "threshold", "failure_percentage_ejection");
        validatePercentage(obj.failure_percentage_ejection, "enforcement_percentage", "failure_percentage_ejection");
        validateFieldType(obj.failure_percentage_ejection, "minimum_hosts", "number", "failure_percentage_ejection");
        validateFieldType(obj.failure_percentage_ejection, "request_volume", "number", "failure_percentage_ejection");
      }
      if (!("child_policy" in obj) || !Array.isArray(obj.child_policy)) {
        throw new Error("outlier detection config child_policy must be an array");
      }
      const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);
      if (!childPolicy) {
        throw new Error("outlier detection config child_policy: no valid recognized policy found");
      }
      return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a2 = obj.max_ejection_percent) !== null && _a2 !== undefined ? _a2 : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);
    }
  }
  exports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;

  class OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
    constructor(childSubchannel, mapEntry) {
      super(childSubchannel);
      this.mapEntry = mapEntry;
      this.refCount = 0;
    }
    ref() {
      this.child.ref();
      this.refCount += 1;
    }
    unref() {
      this.child.unref();
      this.refCount -= 1;
      if (this.refCount <= 0) {
        if (this.mapEntry) {
          const index = this.mapEntry.subchannelWrappers.indexOf(this);
          if (index >= 0) {
            this.mapEntry.subchannelWrappers.splice(index, 1);
          }
        }
      }
    }
    eject() {
      this.setHealthy(false);
    }
    uneject() {
      this.setHealthy(true);
    }
    getMapEntry() {
      return this.mapEntry;
    }
    getWrappedSubchannel() {
      return this.child;
    }
  }
  function createEmptyBucket() {
    return {
      success: 0,
      failure: 0
    };
  }

  class CallCounter {
    constructor() {
      this.activeBucket = createEmptyBucket();
      this.inactiveBucket = createEmptyBucket();
    }
    addSuccess() {
      this.activeBucket.success += 1;
    }
    addFailure() {
      this.activeBucket.failure += 1;
    }
    switchBuckets() {
      this.inactiveBucket = this.activeBucket;
      this.activeBucket = createEmptyBucket();
    }
    getLastSuccesses() {
      return this.inactiveBucket.success;
    }
    getLastFailures() {
      return this.inactiveBucket.failure;
    }
  }

  class OutlierDetectionPicker {
    constructor(wrappedPicker, countCalls) {
      this.wrappedPicker = wrappedPicker;
      this.countCalls = countCalls;
    }
    pick(pickArgs) {
      const wrappedPick = this.wrappedPicker.pick(pickArgs);
      if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
        const subchannelWrapper = wrappedPick.subchannel;
        const mapEntry = subchannelWrapper.getMapEntry();
        if (mapEntry) {
          let onCallEnded = wrappedPick.onCallEnded;
          if (this.countCalls) {
            onCallEnded = (statusCode) => {
              var _a2;
              if (statusCode === constants_1.Status.OK) {
                mapEntry.counter.addSuccess();
              } else {
                mapEntry.counter.addFailure();
              }
              (_a2 = wrappedPick.onCallEnded) === null || _a2 === undefined || _a2.call(wrappedPick, statusCode);
            };
          }
          return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded });
        } else {
          return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });
        }
      } else {
        return wrappedPick;
      }
    }
  }

  class OutlierDetectionLoadBalancer {
    constructor(channelControlHelper) {
      this.entryMap = new subchannel_address_1.EndpointMap;
      this.latestConfig = null;
      this.timerStartTime = null;
      this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
        createSubchannel: (subchannelAddress, subchannelArgs) => {
          const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
          const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);
          const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
          if ((mapEntry === null || mapEntry === undefined ? undefined : mapEntry.currentEjectionTimestamp) !== null) {
            subchannelWrapper.eject();
          }
          mapEntry === null || mapEntry === undefined || mapEntry.subchannelWrappers.push(subchannelWrapper);
          return subchannelWrapper;
        },
        updateState: (connectivityState, picker, errorMessage) => {
          if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
            channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()), errorMessage);
          } else {
            channelControlHelper.updateState(connectivityState, picker, errorMessage);
          }
        }
      }));
      this.ejectionTimer = setInterval(() => {
      }, 0);
      clearInterval(this.ejectionTimer);
    }
    isCountingEnabled() {
      return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);
    }
    getCurrentEjectionPercent() {
      let ejectionCount = 0;
      for (const mapEntry of this.entryMap.values()) {
        if (mapEntry.currentEjectionTimestamp !== null) {
          ejectionCount += 1;
        }
      }
      return ejectionCount * 100 / this.entryMap.size;
    }
    runSuccessRateCheck(ejectionTimestamp) {
      if (!this.latestConfig) {
        return;
      }
      const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
      if (!successRateConfig) {
        return;
      }
      trace("Running success rate check");
      const targetRequestVolume = successRateConfig.request_volume;
      let addresesWithTargetVolume = 0;
      const successRates = [];
      for (const [endpoint, mapEntry] of this.entryMap.entries()) {
        const successes = mapEntry.counter.getLastSuccesses();
        const failures = mapEntry.counter.getLastFailures();
        trace("Stats for " + (0, subchannel_address_1.endpointToString)(endpoint) + ": successes=" + successes + " failures=" + failures + " targetRequestVolume=" + targetRequestVolume);
        if (successes + failures >= targetRequestVolume) {
          addresesWithTargetVolume += 1;
          successRates.push(successes / (successes + failures));
        }
      }
      trace("Found " + addresesWithTargetVolume + " success rate candidates; currentEjectionPercent=" + this.getCurrentEjectionPercent() + " successRates=[" + successRates + "]");
      if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
        return;
      }
      const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
      let successRateDeviationSum = 0;
      for (const rate of successRates) {
        const deviation = rate - successRateMean;
        successRateDeviationSum += deviation * deviation;
      }
      const successRateVariance = successRateDeviationSum / successRates.length;
      const successRateStdev = Math.sqrt(successRateVariance);
      const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);
      trace("stdev=" + successRateStdev + " ejectionThreshold=" + ejectionThreshold);
      for (const [address, mapEntry] of this.entryMap.entries()) {
        if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
          break;
        }
        const successes = mapEntry.counter.getLastSuccesses();
        const failures = mapEntry.counter.getLastFailures();
        if (successes + failures < targetRequestVolume) {
          continue;
        }
        const successRate = successes / (successes + failures);
        trace("Checking candidate " + address + " successRate=" + successRate);
        if (successRate < ejectionThreshold) {
          const randomNumber = Math.random() * 100;
          trace("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + successRateConfig.enforcement_percentage);
          if (randomNumber < successRateConfig.enforcement_percentage) {
            trace("Ejecting candidate " + address);
            this.eject(mapEntry, ejectionTimestamp);
          }
        }
      }
    }
    runFailurePercentageCheck(ejectionTimestamp) {
      if (!this.latestConfig) {
        return;
      }
      const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
      if (!failurePercentageConfig) {
        return;
      }
      trace("Running failure percentage check. threshold=" + failurePercentageConfig.threshold + " request volume threshold=" + failurePercentageConfig.request_volume);
      let addressesWithTargetVolume = 0;
      for (const mapEntry of this.entryMap.values()) {
        const successes = mapEntry.counter.getLastSuccesses();
        const failures = mapEntry.counter.getLastFailures();
        if (successes + failures >= failurePercentageConfig.request_volume) {
          addressesWithTargetVolume += 1;
        }
      }
      if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
        return;
      }
      for (const [address, mapEntry] of this.entryMap.entries()) {
        if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
          break;
        }
        const successes = mapEntry.counter.getLastSuccesses();
        const failures = mapEntry.counter.getLastFailures();
        trace("Candidate successes=" + successes + " failures=" + failures);
        if (successes + failures < failurePercentageConfig.request_volume) {
          continue;
        }
        const failurePercentage = failures * 100 / (failures + successes);
        if (failurePercentage > failurePercentageConfig.threshold) {
          const randomNumber = Math.random() * 100;
          trace("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + failurePercentageConfig.enforcement_percentage);
          if (randomNumber < failurePercentageConfig.enforcement_percentage) {
            trace("Ejecting candidate " + address);
            this.eject(mapEntry, ejectionTimestamp);
          }
        }
      }
    }
    eject(mapEntry, ejectionTimestamp) {
      mapEntry.currentEjectionTimestamp = new Date;
      mapEntry.ejectionTimeMultiplier += 1;
      for (const subchannelWrapper of mapEntry.subchannelWrappers) {
        subchannelWrapper.eject();
      }
    }
    uneject(mapEntry) {
      mapEntry.currentEjectionTimestamp = null;
      for (const subchannelWrapper of mapEntry.subchannelWrappers) {
        subchannelWrapper.uneject();
      }
    }
    switchAllBuckets() {
      for (const mapEntry of this.entryMap.values()) {
        mapEntry.counter.switchBuckets();
      }
    }
    startTimer(delayMs) {
      var _a2, _b;
      this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
      (_b = (_a2 = this.ejectionTimer).unref) === null || _b === undefined || _b.call(_a2);
    }
    runChecks() {
      const ejectionTimestamp = new Date;
      trace("Ejection timer running");
      this.switchAllBuckets();
      if (!this.latestConfig) {
        return;
      }
      this.timerStartTime = ejectionTimestamp;
      this.startTimer(this.latestConfig.getIntervalMs());
      this.runSuccessRateCheck(ejectionTimestamp);
      this.runFailurePercentageCheck(ejectionTimestamp);
      for (const [address, mapEntry] of this.entryMap.entries()) {
        if (mapEntry.currentEjectionTimestamp === null) {
          if (mapEntry.ejectionTimeMultiplier > 0) {
            mapEntry.ejectionTimeMultiplier -= 1;
          }
        } else {
          const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
          const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
          const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
          returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
          if (returnTime < new Date) {
            trace("Unejecting " + address);
            this.uneject(mapEntry);
          }
        }
      }
    }
    updateAddressList(endpointList, lbConfig, options) {
      if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
        return;
      }
      trace("Received update with config: " + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));
      for (const endpoint of endpointList) {
        if (!this.entryMap.has(endpoint)) {
          trace("Adding map entry for " + (0, subchannel_address_1.endpointToString)(endpoint));
          this.entryMap.set(endpoint, {
            counter: new CallCounter,
            currentEjectionTimestamp: null,
            ejectionTimeMultiplier: 0,
            subchannelWrappers: []
          });
        }
      }
      this.entryMap.deleteMissing(endpointList);
      const childPolicy = lbConfig.getChildPolicy();
      this.childBalancer.updateAddressList(endpointList, childPolicy, options);
      if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {
        if (this.timerStartTime) {
          trace("Previous timer existed. Replacing timer");
          clearTimeout(this.ejectionTimer);
          const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());
          this.startTimer(remainingDelay);
        } else {
          trace("Starting new timer");
          this.timerStartTime = new Date;
          this.startTimer(lbConfig.getIntervalMs());
          this.switchAllBuckets();
        }
      } else {
        trace("Counting disabled. Cancelling timer.");
        this.timerStartTime = null;
        clearTimeout(this.ejectionTimer);
        for (const mapEntry of this.entryMap.values()) {
          this.uneject(mapEntry);
          mapEntry.ejectionTimeMultiplier = 0;
        }
      }
      this.latestConfig = lbConfig;
    }
    exitIdle() {
      this.childBalancer.exitIdle();
    }
    resetBackoff() {
      this.childBalancer.resetBackoff();
    }
    destroy() {
      clearTimeout(this.ejectionTimer);
      this.childBalancer.destroy();
    }
    getTypeName() {
      return TYPE_NAME;
    }
  }
  exports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
  function setup() {
    if (OUTLIER_DETECTION_ENABLED) {
      (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = undefined;
  var call_credentials_1 = require_call_credentials();
  Object.defineProperty(exports, "CallCredentials", { enumerable: true, get: function() {
    return call_credentials_1.CallCredentials;
  } });
  var channel_1 = require_channel();
  Object.defineProperty(exports, "Channel", { enumerable: true, get: function() {
    return channel_1.ChannelImplementation;
  } });
  var compression_algorithms_1 = require_compression_algorithms();
  Object.defineProperty(exports, "compressionAlgorithms", { enumerable: true, get: function() {
    return compression_algorithms_1.CompressionAlgorithms;
  } });
  var connectivity_state_1 = require_connectivity_state();
  Object.defineProperty(exports, "connectivityState", { enumerable: true, get: function() {
    return connectivity_state_1.ConnectivityState;
  } });
  var channel_credentials_1 = require_channel_credentials();
  Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function() {
    return channel_credentials_1.ChannelCredentials;
  } });
  var client_1 = require_client();
  Object.defineProperty(exports, "Client", { enumerable: true, get: function() {
    return client_1.Client;
  } });
  var constants_1 = require_constants2();
  Object.defineProperty(exports, "logVerbosity", { enumerable: true, get: function() {
    return constants_1.LogVerbosity;
  } });
  Object.defineProperty(exports, "status", { enumerable: true, get: function() {
    return constants_1.Status;
  } });
  Object.defineProperty(exports, "propagate", { enumerable: true, get: function() {
    return constants_1.Propagate;
  } });
  var logging = require_logging();
  var make_client_1 = require_make_client();
  Object.defineProperty(exports, "loadPackageDefinition", { enumerable: true, get: function() {
    return make_client_1.loadPackageDefinition;
  } });
  Object.defineProperty(exports, "makeClientConstructor", { enumerable: true, get: function() {
    return make_client_1.makeClientConstructor;
  } });
  Object.defineProperty(exports, "makeGenericClientConstructor", { enumerable: true, get: function() {
    return make_client_1.makeClientConstructor;
  } });
  var metadata_1 = require_metadata();
  Object.defineProperty(exports, "Metadata", { enumerable: true, get: function() {
    return metadata_1.Metadata;
  } });
  var server_1 = require_server();
  Object.defineProperty(exports, "Server", { enumerable: true, get: function() {
    return server_1.Server;
  } });
  var server_credentials_1 = require_server_credentials();
  Object.defineProperty(exports, "ServerCredentials", { enumerable: true, get: function() {
    return server_credentials_1.ServerCredentials;
  } });
  var status_builder_1 = require_status_builder();
  Object.defineProperty(exports, "StatusBuilder", { enumerable: true, get: function() {
    return status_builder_1.StatusBuilder;
  } });
  exports.credentials = {
    combineChannelCredentials: (channelCredentials, ...callCredentials) => {
      return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
    },
    combineCallCredentials: (first, ...additional) => {
      return additional.reduce((acc, other) => acc.compose(other), first);
    },
    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
    createSsl: channel_credentials_1.ChannelCredentials.createSsl,
    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
    createEmpty: call_credentials_1.CallCredentials.createEmpty
  };
  var closeClient = (client) => client.close();
  exports.closeClient = closeClient;
  var waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
  exports.waitForClientReady = waitForClientReady;
  var loadObject = (value, options) => {
    throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
  };
  exports.loadObject = loadObject;
  var load = (filename, format, options) => {
    throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
  };
  exports.load = load;
  var setLogger = (logger) => {
    logging.setLogger(logger);
  };
  exports.setLogger = setLogger;
  var setLogVerbosity = (verbosity) => {
    logging.setLoggerVerbosity(verbosity);
  };
  exports.setLogVerbosity = setLogVerbosity;
  var getClientChannel = (client) => {
    return client_1.Client.prototype.getChannel.call(client);
  };
  exports.getClientChannel = getClientChannel;
  var client_interceptors_1 = require_client_interceptors();
  Object.defineProperty(exports, "ListenerBuilder", { enumerable: true, get: function() {
    return client_interceptors_1.ListenerBuilder;
  } });
  Object.defineProperty(exports, "RequesterBuilder", { enumerable: true, get: function() {
    return client_interceptors_1.RequesterBuilder;
  } });
  Object.defineProperty(exports, "InterceptingCall", { enumerable: true, get: function() {
    return client_interceptors_1.InterceptingCall;
  } });
  Object.defineProperty(exports, "InterceptorConfigurationError", { enumerable: true, get: function() {
    return client_interceptors_1.InterceptorConfigurationError;
  } });
  var channelz_1 = require_channelz();
  Object.defineProperty(exports, "getChannelzServiceDefinition", { enumerable: true, get: function() {
    return channelz_1.getChannelzServiceDefinition;
  } });
  Object.defineProperty(exports, "getChannelzHandlers", { enumerable: true, get: function() {
    return channelz_1.getChannelzHandlers;
  } });
  var admin_1 = require_admin();
  Object.defineProperty(exports, "addAdminServicesToServer", { enumerable: true, get: function() {
    return admin_1.addAdminServicesToServer;
  } });
  var server_interceptors_1 = require_server_interceptors();
  Object.defineProperty(exports, "ServerListenerBuilder", { enumerable: true, get: function() {
    return server_interceptors_1.ServerListenerBuilder;
  } });
  Object.defineProperty(exports, "ResponderBuilder", { enumerable: true, get: function() {
    return server_interceptors_1.ResponderBuilder;
  } });
  Object.defineProperty(exports, "ServerInterceptingCall", { enumerable: true, get: function() {
    return server_interceptors_1.ServerInterceptingCall;
  } });
  var experimental = require_experimental();
  exports.experimental = experimental;
  var resolver_dns = require_resolver_dns();
  var resolver_uds = require_resolver_uds();
  var resolver_ip = require_resolver_ip();
  var load_balancer_pick_first = require_load_balancer_pick_first();
  var load_balancer_round_robin = require_load_balancer_round_robin();
  var load_balancer_outlier_detection = require_load_balancer_outlier_detection();
  var channelz = require_channelz();
  (() => {
    resolver_dns.setup();
    resolver_uds.setup();
    resolver_ip.setup();
    load_balancer_pick_first.setup();
    load_balancer_round_robin.setup();
    load_balancer_outlier_detection.setup();
    channelz.setup();
  })();
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/create-service-client-constructor.js
var require_create_service_client_constructor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createServiceClientConstructor = undefined;
  var grpc = require_src18();
  function createServiceClientConstructor(path, name) {
    const serviceDefinition = {
      export: {
        path,
        requestStream: false,
        responseStream: false,
        requestSerialize: (arg) => {
          return arg;
        },
        requestDeserialize: (arg) => {
          return arg;
        },
        responseSerialize: (arg) => {
          return arg;
        },
        responseDeserialize: (arg) => {
          return arg;
        }
      }
    };
    return grpc.makeGenericClientConstructor(serviceDefinition, name);
  }
  exports.createServiceClientConstructor = createServiceClientConstructor;
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/grpc-exporter-transport.js
var require_grpc_exporter_transport = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createOtlpGrpcExporterTransport = exports.GrpcExporterTransport = exports.createEmptyMetadata = exports.createSslCredentials = exports.createInsecureCredentials = undefined;
  var GRPC_COMPRESSION_NONE = 0;
  var GRPC_COMPRESSION_GZIP = 2;
  function toGrpcCompression(compression) {
    return compression === "gzip" ? GRPC_COMPRESSION_GZIP : GRPC_COMPRESSION_NONE;
  }
  function createInsecureCredentials() {
    const {
      credentials
    } = require_src18();
    return credentials.createInsecure();
  }
  exports.createInsecureCredentials = createInsecureCredentials;
  function createSslCredentials(rootCert, privateKey, certChain) {
    const {
      credentials
    } = require_src18();
    return credentials.createSsl(rootCert, privateKey, certChain);
  }
  exports.createSslCredentials = createSslCredentials;
  function createEmptyMetadata() {
    const {
      Metadata
    } = require_src18();
    return new Metadata;
  }
  exports.createEmptyMetadata = createEmptyMetadata;

  class GrpcExporterTransport {
    _parameters;
    _client;
    _metadata;
    constructor(_parameters) {
      this._parameters = _parameters;
    }
    shutdown() {
      this._client?.close();
    }
    send(data, timeoutMillis) {
      const buffer = Buffer.from(data);
      if (this._client == null) {
        const {
          createServiceClientConstructor
        } = require_create_service_client_constructor();
        try {
          this._metadata = this._parameters.metadata();
        } catch (error) {
          return Promise.resolve({
            status: "failure",
            error
          });
        }
        const clientConstructor = createServiceClientConstructor(this._parameters.grpcPath, this._parameters.grpcName);
        try {
          this._client = new clientConstructor(this._parameters.address, this._parameters.credentials(), {
            "grpc.default_compression_algorithm": toGrpcCompression(this._parameters.compression)
          });
        } catch (error) {
          return Promise.resolve({
            status: "failure",
            error
          });
        }
      }
      return new Promise((resolve) => {
        const deadline = Date.now() + timeoutMillis;
        if (this._metadata == null) {
          return resolve({
            error: new Error("metadata was null"),
            status: "failure"
          });
        }
        this._client.export(buffer, this._metadata, { deadline }, (err, response) => {
          if (err) {
            resolve({
              status: "failure",
              error: err
            });
          } else {
            resolve({
              data: response,
              status: "success"
            });
          }
        });
      });
    }
  }
  exports.GrpcExporterTransport = GrpcExporterTransport;
  function createOtlpGrpcExporterTransport(options) {
    return new GrpcExporterTransport(options);
  }
  exports.createOtlpGrpcExporterTransport = createOtlpGrpcExporterTransport;
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/version.js
var require_version5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.202.0";
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/configuration/otlp-grpc-configuration.js
var require_otlp_grpc_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOtlpGrpcDefaultConfiguration = exports.mergeOtlpGrpcConfigurationWithDefaults = exports.validateAndNormalizeUrl = undefined;
  var otlp_exporter_base_1 = require_src13();
  var grpc_exporter_transport_1 = require_grpc_exporter_transport();
  var version_1 = require_version5();
  var url_1 = __require("url");
  var api_1 = require_src();
  function validateAndNormalizeUrl(url) {
    url = url.trim();
    const hasProtocol = url.match(/^([\w]{1,8}):\/\//);
    if (!hasProtocol) {
      url = `https://${url}`;
    }
    const target = new url_1.URL(url);
    if (target.protocol === "unix:") {
      return url;
    }
    if (target.pathname && target.pathname !== "/") {
      api_1.diag.warn("URL path should not be set when using grpc, the path part of the URL will be ignored.");
    }
    if (target.protocol !== "" && !target.protocol?.match(/^(http)s?:$/)) {
      api_1.diag.warn("URL protocol should be http(s)://. Using http://.");
    }
    return target.host;
  }
  exports.validateAndNormalizeUrl = validateAndNormalizeUrl;
  function overrideMetadataEntriesIfNotPresent(metadata, additionalMetadata) {
    for (const [key, value] of Object.entries(additionalMetadata.getMap())) {
      if (metadata.get(key).length < 1) {
        metadata.set(key, value);
      }
    }
  }
  function mergeOtlpGrpcConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
    const rawUrl = userProvidedConfiguration.url ?? fallbackConfiguration.url ?? defaultConfiguration.url;
    return {
      ...(0, otlp_exporter_base_1.mergeOtlpSharedConfigurationWithDefaults)(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration),
      metadata: () => {
        const metadata = defaultConfiguration.metadata();
        overrideMetadataEntriesIfNotPresent(metadata, userProvidedConfiguration.metadata?.().clone() ?? (0, grpc_exporter_transport_1.createEmptyMetadata)());
        overrideMetadataEntriesIfNotPresent(metadata, fallbackConfiguration.metadata?.() ?? (0, grpc_exporter_transport_1.createEmptyMetadata)());
        return metadata;
      },
      url: validateAndNormalizeUrl(rawUrl),
      credentials: userProvidedConfiguration.credentials ?? fallbackConfiguration.credentials?.(rawUrl) ?? defaultConfiguration.credentials(rawUrl)
    };
  }
  exports.mergeOtlpGrpcConfigurationWithDefaults = mergeOtlpGrpcConfigurationWithDefaults;
  function getOtlpGrpcDefaultConfiguration() {
    return {
      ...(0, otlp_exporter_base_1.getSharedConfigurationDefaults)(),
      metadata: () => {
        const metadata = (0, grpc_exporter_transport_1.createEmptyMetadata)();
        metadata.set("User-Agent", `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`);
        return metadata;
      },
      url: "http://localhost:4317",
      credentials: (url) => {
        if (url.startsWith("http://")) {
          return () => (0, grpc_exporter_transport_1.createInsecureCredentials)();
        } else {
          return () => (0, grpc_exporter_transport_1.createSslCredentials)();
        }
      }
    };
  }
  exports.getOtlpGrpcDefaultConfiguration = getOtlpGrpcDefaultConfiguration;
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/configuration/otlp-grpc-env-configuration.js
var require_otlp_grpc_env_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOtlpGrpcConfigurationFromEnv = undefined;
  var core_1 = require_src3();
  var grpc_exporter_transport_1 = require_grpc_exporter_transport();
  var node_http_1 = require_index_node_http();
  var fs = __require("fs");
  var path = __require("path");
  var api_1 = require_src();
  function fallbackIfNullishOrBlank(signalSpecific, nonSignalSpecific) {
    if (signalSpecific != null && signalSpecific !== "") {
      return signalSpecific;
    }
    if (nonSignalSpecific != null && nonSignalSpecific !== "") {
      return nonSignalSpecific;
    }
    return;
  }
  function getMetadataFromEnv(signalIdentifier) {
    const signalSpecificRawHeaders = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_HEADERS`]?.trim();
    const nonSignalSpecificRawHeaders = process.env["OTEL_EXPORTER_OTLP_HEADERS"]?.trim();
    const signalSpecificHeaders = (0, core_1.parseKeyPairsIntoRecord)(signalSpecificRawHeaders);
    const nonSignalSpecificHeaders = (0, core_1.parseKeyPairsIntoRecord)(nonSignalSpecificRawHeaders);
    if (Object.keys(signalSpecificHeaders).length === 0 && Object.keys(nonSignalSpecificHeaders).length === 0) {
      return;
    }
    const mergeHeaders = Object.assign({}, nonSignalSpecificHeaders, signalSpecificHeaders);
    const metadata = (0, grpc_exporter_transport_1.createEmptyMetadata)();
    for (const [key, value] of Object.entries(mergeHeaders)) {
      metadata.set(key, value);
    }
    return metadata;
  }
  function getMetadataProviderFromEnv(signalIdentifier) {
    const metadata = getMetadataFromEnv(signalIdentifier);
    if (metadata == null) {
      return;
    }
    return () => metadata;
  }
  function getUrlFromEnv(signalIdentifier) {
    const specificEndpoint = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_ENDPOINT`]?.trim();
    const nonSpecificEndpoint = process.env[`OTEL_EXPORTER_OTLP_ENDPOINT`]?.trim();
    return fallbackIfNullishOrBlank(specificEndpoint, nonSpecificEndpoint);
  }
  function getInsecureSettingFromEnv(signalIdentifier) {
    const signalSpecificInsecureValue = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_INSECURE`]?.toLowerCase().trim();
    const nonSignalSpecificInsecureValue = process.env[`OTEL_EXPORTER_OTLP_INSECURE`]?.toLowerCase().trim();
    return fallbackIfNullishOrBlank(signalSpecificInsecureValue, nonSignalSpecificInsecureValue) === "true";
  }
  function readFileFromEnv(signalSpecificEnvVar, nonSignalSpecificEnvVar, warningMessage) {
    const signalSpecificPath = process.env[signalSpecificEnvVar]?.trim();
    const nonSignalSpecificPath = process.env[nonSignalSpecificEnvVar]?.trim();
    const filePath = fallbackIfNullishOrBlank(signalSpecificPath, nonSignalSpecificPath);
    if (filePath != null) {
      try {
        return fs.readFileSync(path.resolve(process.cwd(), filePath));
      } catch {
        api_1.diag.warn(warningMessage);
        return;
      }
    } else {
      return;
    }
  }
  function getClientCertificateFromEnv(signalIdentifier) {
    return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_CERTIFICATE`, "OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE", "Failed to read client certificate chain file");
  }
  function getClientKeyFromEnv(signalIdentifier) {
    return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_KEY`, "OTEL_EXPORTER_OTLP_CLIENT_KEY", "Failed to read client certificate private key file");
  }
  function getRootCertificateFromEnv(signalIdentifier) {
    return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CERTIFICATE`, "OTEL_EXPORTER_OTLP_CERTIFICATE", "Failed to read root certificate file");
  }
  function getCredentialsFromEnvIgnoreInsecure(signalIdentifier) {
    const clientKey = getClientKeyFromEnv(signalIdentifier);
    const clientCertificate = getClientCertificateFromEnv(signalIdentifier);
    const rootCertificate = getRootCertificateFromEnv(signalIdentifier);
    const clientChainIntact = clientKey != null && clientCertificate != null;
    if (rootCertificate != null && !clientChainIntact) {
      api_1.diag.warn("Client key and certificate must both be provided, but one was missing - attempting to create credentials from just the root certificate");
      return (0, grpc_exporter_transport_1.createSslCredentials)(getRootCertificateFromEnv(signalIdentifier));
    }
    return (0, grpc_exporter_transport_1.createSslCredentials)(rootCertificate, clientKey, clientCertificate);
  }
  function getCredentialsFromEnv(signalIdentifier) {
    if (getInsecureSettingFromEnv(signalIdentifier)) {
      return (0, grpc_exporter_transport_1.createInsecureCredentials)();
    }
    return getCredentialsFromEnvIgnoreInsecure(signalIdentifier);
  }
  function getOtlpGrpcConfigurationFromEnv(signalIdentifier) {
    return {
      ...(0, node_http_1.getSharedConfigurationFromEnvironment)(signalIdentifier),
      metadata: getMetadataProviderFromEnv(signalIdentifier),
      url: getUrlFromEnv(signalIdentifier),
      credentials: (finalResolvedUrl) => {
        if (finalResolvedUrl.startsWith("http://")) {
          return () => {
            return (0, grpc_exporter_transport_1.createInsecureCredentials)();
          };
        } else if (finalResolvedUrl.startsWith("https://")) {
          return () => {
            return getCredentialsFromEnvIgnoreInsecure(signalIdentifier);
          };
        }
        return () => {
          return getCredentialsFromEnv(signalIdentifier);
        };
      }
    };
  }
  exports.getOtlpGrpcConfigurationFromEnv = getOtlpGrpcConfigurationFromEnv;
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/configuration/convert-legacy-otlp-grpc-options.js
var require_convert_legacy_otlp_grpc_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertLegacyOtlpGrpcOptions = undefined;
  var api_1 = require_src();
  var otlp_grpc_configuration_1 = require_otlp_grpc_configuration();
  var grpc_exporter_transport_1 = require_grpc_exporter_transport();
  var otlp_grpc_env_configuration_1 = require_otlp_grpc_env_configuration();
  function convertLegacyOtlpGrpcOptions(config, signalIdentifier) {
    if (config.headers) {
      api_1.diag.warn("Headers cannot be set when using grpc");
    }
    const userProvidedCredentials = config.credentials;
    return (0, otlp_grpc_configuration_1.mergeOtlpGrpcConfigurationWithDefaults)({
      url: config.url,
      metadata: () => {
        return config.metadata ?? (0, grpc_exporter_transport_1.createEmptyMetadata)();
      },
      compression: config.compression,
      timeoutMillis: config.timeoutMillis,
      concurrencyLimit: config.concurrencyLimit,
      credentials: userProvidedCredentials != null ? () => userProvidedCredentials : undefined
    }, (0, otlp_grpc_env_configuration_1.getOtlpGrpcConfigurationFromEnv)(signalIdentifier), (0, otlp_grpc_configuration_1.getOtlpGrpcDefaultConfiguration)());
  }
  exports.convertLegacyOtlpGrpcOptions = convertLegacyOtlpGrpcOptions;
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/otlp-grpc-export-delegate.js
var require_otlp_grpc_export_delegate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createOtlpGrpcExportDelegate = undefined;
  var otlp_exporter_base_1 = require_src13();
  var grpc_exporter_transport_1 = require_grpc_exporter_transport();
  function createOtlpGrpcExportDelegate(options, serializer, grpcName, grpcPath) {
    return (0, otlp_exporter_base_1.createOtlpNetworkExportDelegate)(options, serializer, (0, grpc_exporter_transport_1.createOtlpGrpcExporterTransport)({
      address: options.url,
      compression: options.compression,
      credentials: options.credentials,
      metadata: options.metadata,
      grpcName,
      grpcPath
    }));
  }
  exports.createOtlpGrpcExportDelegate = createOtlpGrpcExportDelegate;
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/index.js
var require_src19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createOtlpGrpcExportDelegate = exports.convertLegacyOtlpGrpcOptions = undefined;
  var convert_legacy_otlp_grpc_options_1 = require_convert_legacy_otlp_grpc_options();
  Object.defineProperty(exports, "convertLegacyOtlpGrpcOptions", { enumerable: true, get: function() {
    return convert_legacy_otlp_grpc_options_1.convertLegacyOtlpGrpcOptions;
  } });
  var otlp_grpc_export_delegate_1 = require_otlp_grpc_export_delegate();
  Object.defineProperty(exports, "createOtlpGrpcExportDelegate", { enumerable: true, get: function() {
    return otlp_grpc_export_delegate_1.createOtlpGrpcExportDelegate;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-grpc/build/src/OTLPLogExporter.js
var require_OTLPLogExporter2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var otlp_grpc_exporter_base_1 = require_src19();
  var otlp_transformer_1 = require_src14();
  var otlp_exporter_base_1 = require_src13();

  class OTLPLogExporter extends otlp_exporter_base_1.OTLPExporterBase {
    constructor(config = {}) {
      super((0, otlp_grpc_exporter_base_1.createOtlpGrpcExportDelegate)((0, otlp_grpc_exporter_base_1.convertLegacyOtlpGrpcOptions)(config, "LOGS"), otlp_transformer_1.ProtobufLogsSerializer, "LogsExportService", "/opentelemetry.proto.collector.logs.v1.LogsService/Export"));
    }
  }
  exports.OTLPLogExporter = OTLPLogExporter;
});

// node_modules/@opentelemetry/exporter-logs-otlp-grpc/build/src/index.js
var require_src20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var OTLPLogExporter_1 = require_OTLPLogExporter2();
  Object.defineProperty(exports, "OTLPLogExporter", { enumerable: true, get: function() {
    return OTLPLogExporter_1.OTLPLogExporter;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-proto/build/src/version.js
var require_version6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.202.0";
});

// node_modules/@opentelemetry/exporter-logs-otlp-proto/build/src/platform/node/OTLPLogExporter.js
var require_OTLPLogExporter3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var otlp_exporter_base_1 = require_src13();
  var otlp_transformer_1 = require_src14();
  var node_http_1 = require_index_node_http();
  var version_1 = require_version6();

  class OTLPLogExporter extends otlp_exporter_base_1.OTLPExporterBase {
    constructor(config = {}) {
      super((0, node_http_1.createOtlpHttpExportDelegate)((0, node_http_1.convertLegacyHttpOptions)(config, "LOGS", "v1/logs", {
        "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`,
        "Content-Type": "application/x-protobuf"
      }), otlp_transformer_1.ProtobufLogsSerializer));
    }
  }
  exports.OTLPLogExporter = OTLPLogExporter;
});

// node_modules/@opentelemetry/exporter-logs-otlp-proto/build/src/platform/node/index.js
var require_node11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var OTLPLogExporter_1 = require_OTLPLogExporter3();
  Object.defineProperty(exports, "OTLPLogExporter", { enumerable: true, get: function() {
    return OTLPLogExporter_1.OTLPLogExporter;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-proto/build/src/platform/index.js
var require_platform10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var node_1 = require_node11();
  Object.defineProperty(exports, "OTLPLogExporter", { enumerable: true, get: function() {
    return node_1.OTLPLogExporter;
  } });
});

// node_modules/@opentelemetry/exporter-logs-otlp-proto/build/src/index.js
var require_src21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPLogExporter = undefined;
  var platform_1 = require_platform10();
  Object.defineProperty(exports, "OTLPLogExporter", { enumerable: true, get: function() {
    return platform_1.OTLPLogExporter;
  } });
});

// node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterOptions.js
var require_OTLPMetricExporterOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregationTemporalityPreference = undefined;
  var AggregationTemporalityPreference;
  (function(AggregationTemporalityPreference2) {
    AggregationTemporalityPreference2[AggregationTemporalityPreference2["DELTA"] = 0] = "DELTA";
    AggregationTemporalityPreference2[AggregationTemporalityPreference2["CUMULATIVE"] = 1] = "CUMULATIVE";
    AggregationTemporalityPreference2[AggregationTemporalityPreference2["LOWMEMORY"] = 2] = "LOWMEMORY";
  })(AggregationTemporalityPreference = exports.AggregationTemporalityPreference || (exports.AggregationTemporalityPreference = {}));
});

// node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterBase.js
var require_OTLPMetricExporterBase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporterBase = exports.LowMemoryTemporalitySelector = exports.DeltaTemporalitySelector = exports.CumulativeTemporalitySelector = undefined;
  var core_1 = require_src3();
  var sdk_metrics_1 = require_src7();
  var OTLPMetricExporterOptions_1 = require_OTLPMetricExporterOptions();
  var otlp_exporter_base_1 = require_src13();
  var api_1 = require_src();
  var CumulativeTemporalitySelector = () => sdk_metrics_1.AggregationTemporality.CUMULATIVE;
  exports.CumulativeTemporalitySelector = CumulativeTemporalitySelector;
  var DeltaTemporalitySelector = (instrumentType) => {
    switch (instrumentType) {
      case sdk_metrics_1.InstrumentType.COUNTER:
      case sdk_metrics_1.InstrumentType.OBSERVABLE_COUNTER:
      case sdk_metrics_1.InstrumentType.GAUGE:
      case sdk_metrics_1.InstrumentType.HISTOGRAM:
      case sdk_metrics_1.InstrumentType.OBSERVABLE_GAUGE:
        return sdk_metrics_1.AggregationTemporality.DELTA;
      case sdk_metrics_1.InstrumentType.UP_DOWN_COUNTER:
      case sdk_metrics_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
        return sdk_metrics_1.AggregationTemporality.CUMULATIVE;
    }
  };
  exports.DeltaTemporalitySelector = DeltaTemporalitySelector;
  var LowMemoryTemporalitySelector = (instrumentType) => {
    switch (instrumentType) {
      case sdk_metrics_1.InstrumentType.COUNTER:
      case sdk_metrics_1.InstrumentType.HISTOGRAM:
        return sdk_metrics_1.AggregationTemporality.DELTA;
      case sdk_metrics_1.InstrumentType.GAUGE:
      case sdk_metrics_1.InstrumentType.UP_DOWN_COUNTER:
      case sdk_metrics_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
      case sdk_metrics_1.InstrumentType.OBSERVABLE_COUNTER:
      case sdk_metrics_1.InstrumentType.OBSERVABLE_GAUGE:
        return sdk_metrics_1.AggregationTemporality.CUMULATIVE;
    }
  };
  exports.LowMemoryTemporalitySelector = LowMemoryTemporalitySelector;
  function chooseTemporalitySelectorFromEnvironment() {
    const configuredTemporality = ((0, core_1.getStringFromEnv)("OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE") ?? "cumulative").toLowerCase();
    if (configuredTemporality === "cumulative") {
      return exports.CumulativeTemporalitySelector;
    }
    if (configuredTemporality === "delta") {
      return exports.DeltaTemporalitySelector;
    }
    if (configuredTemporality === "lowmemory") {
      return exports.LowMemoryTemporalitySelector;
    }
    api_1.diag.warn(`OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE is set to '${configuredTemporality}', but only 'cumulative' and 'delta' are allowed. Using default ('cumulative') instead.`);
    return exports.CumulativeTemporalitySelector;
  }
  function chooseTemporalitySelector(temporalityPreference) {
    if (temporalityPreference != null) {
      if (temporalityPreference === OTLPMetricExporterOptions_1.AggregationTemporalityPreference.DELTA) {
        return exports.DeltaTemporalitySelector;
      } else if (temporalityPreference === OTLPMetricExporterOptions_1.AggregationTemporalityPreference.LOWMEMORY) {
        return exports.LowMemoryTemporalitySelector;
      }
      return exports.CumulativeTemporalitySelector;
    }
    return chooseTemporalitySelectorFromEnvironment();
  }
  var DEFAULT_AGGREGATION = Object.freeze({
    type: sdk_metrics_1.AggregationType.DEFAULT
  });
  function chooseAggregationSelector(config) {
    return config?.aggregationPreference ?? (() => DEFAULT_AGGREGATION);
  }

  class OTLPMetricExporterBase extends otlp_exporter_base_1.OTLPExporterBase {
    _aggregationTemporalitySelector;
    _aggregationSelector;
    constructor(delegate, config) {
      super(delegate);
      this._aggregationSelector = chooseAggregationSelector(config);
      this._aggregationTemporalitySelector = chooseTemporalitySelector(config?.temporalityPreference);
    }
    selectAggregation(instrumentType) {
      return this._aggregationSelector(instrumentType);
    }
    selectAggregationTemporality(instrumentType) {
      return this._aggregationTemporalitySelector(instrumentType);
    }
  }
  exports.OTLPMetricExporterBase = OTLPMetricExporterBase;
});

// node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/version.js
var require_version7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.202.0";
});

// node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/OTLPMetricExporter.js
var require_OTLPMetricExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var OTLPMetricExporterBase_1 = require_OTLPMetricExporterBase();
  var otlp_transformer_1 = require_src14();
  var version_1 = require_version7();
  var node_http_1 = require_index_node_http();
  var USER_AGENT = {
    "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`
  };

  class OTLPMetricExporter extends OTLPMetricExporterBase_1.OTLPMetricExporterBase {
    constructor(config) {
      super((0, node_http_1.createOtlpHttpExportDelegate)((0, node_http_1.convertLegacyHttpOptions)(config ?? {}, "METRICS", "v1/metrics", {
        ...USER_AGENT,
        "Content-Type": "application/json"
      }), otlp_transformer_1.JsonMetricsSerializer), config);
    }
  }
  exports.OTLPMetricExporter = OTLPMetricExporter;
});

// node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/index.js
var require_node12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var OTLPMetricExporter_1 = require_OTLPMetricExporter();
  Object.defineProperty(exports, "OTLPMetricExporter", { enumerable: true, get: function() {
    return OTLPMetricExporter_1.OTLPMetricExporter;
  } });
});

// node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/index.js
var require_platform11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var node_1 = require_node12();
  Object.defineProperty(exports, "OTLPMetricExporter", { enumerable: true, get: function() {
    return node_1.OTLPMetricExporter;
  } });
});

// node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/index.js
var require_src22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporterBase = exports.LowMemoryTemporalitySelector = exports.DeltaTemporalitySelector = exports.CumulativeTemporalitySelector = exports.AggregationTemporalityPreference = exports.OTLPMetricExporter = undefined;
  var platform_1 = require_platform11();
  Object.defineProperty(exports, "OTLPMetricExporter", { enumerable: true, get: function() {
    return platform_1.OTLPMetricExporter;
  } });
  var OTLPMetricExporterOptions_1 = require_OTLPMetricExporterOptions();
  Object.defineProperty(exports, "AggregationTemporalityPreference", { enumerable: true, get: function() {
    return OTLPMetricExporterOptions_1.AggregationTemporalityPreference;
  } });
  var OTLPMetricExporterBase_1 = require_OTLPMetricExporterBase();
  Object.defineProperty(exports, "CumulativeTemporalitySelector", { enumerable: true, get: function() {
    return OTLPMetricExporterBase_1.CumulativeTemporalitySelector;
  } });
  Object.defineProperty(exports, "DeltaTemporalitySelector", { enumerable: true, get: function() {
    return OTLPMetricExporterBase_1.DeltaTemporalitySelector;
  } });
  Object.defineProperty(exports, "LowMemoryTemporalitySelector", { enumerable: true, get: function() {
    return OTLPMetricExporterBase_1.LowMemoryTemporalitySelector;
  } });
  Object.defineProperty(exports, "OTLPMetricExporterBase", { enumerable: true, get: function() {
    return OTLPMetricExporterBase_1.OTLPMetricExporterBase;
  } });
});

// node_modules/@opentelemetry/exporter-metrics-otlp-grpc/build/src/OTLPMetricExporter.js
var require_OTLPMetricExporter2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var exporter_metrics_otlp_http_1 = require_src22();
  var otlp_grpc_exporter_base_1 = require_src19();
  var otlp_transformer_1 = require_src14();

  class OTLPMetricExporter extends exporter_metrics_otlp_http_1.OTLPMetricExporterBase {
    constructor(config) {
      super((0, otlp_grpc_exporter_base_1.createOtlpGrpcExportDelegate)((0, otlp_grpc_exporter_base_1.convertLegacyOtlpGrpcOptions)(config ?? {}, "METRICS"), otlp_transformer_1.ProtobufMetricsSerializer, "MetricsExportService", "/opentelemetry.proto.collector.metrics.v1.MetricsService/Export"), config);
    }
  }
  exports.OTLPMetricExporter = OTLPMetricExporter;
});

// node_modules/@opentelemetry/exporter-metrics-otlp-grpc/build/src/index.js
var require_src23 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var OTLPMetricExporter_1 = require_OTLPMetricExporter2();
  Object.defineProperty(exports, "OTLPMetricExporter", { enumerable: true, get: function() {
    return OTLPMetricExporter_1.OTLPMetricExporter;
  } });
});

// node_modules/@opentelemetry/exporter-metrics-otlp-proto/build/src/version.js
var require_version8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.202.0";
});

// node_modules/@opentelemetry/exporter-metrics-otlp-proto/build/src/platform/node/OTLPMetricExporter.js
var require_OTLPMetricExporter3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var exporter_metrics_otlp_http_1 = require_src22();
  var otlp_transformer_1 = require_src14();
  var version_1 = require_version8();
  var node_http_1 = require_index_node_http();

  class OTLPMetricExporter extends exporter_metrics_otlp_http_1.OTLPMetricExporterBase {
    constructor(config) {
      super((0, node_http_1.createOtlpHttpExportDelegate)((0, node_http_1.convertLegacyHttpOptions)(config ?? {}, "METRICS", "v1/metrics", {
        "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`,
        "Content-Type": "application/x-protobuf"
      }), otlp_transformer_1.ProtobufMetricsSerializer), config);
    }
  }
  exports.OTLPMetricExporter = OTLPMetricExporter;
});

// node_modules/@opentelemetry/exporter-metrics-otlp-proto/build/src/platform/node/index.js
var require_node13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var OTLPMetricExporter_1 = require_OTLPMetricExporter3();
  Object.defineProperty(exports, "OTLPMetricExporter", { enumerable: true, get: function() {
    return OTLPMetricExporter_1.OTLPMetricExporter;
  } });
});

// node_modules/@opentelemetry/exporter-metrics-otlp-proto/build/src/platform/index.js
var require_platform12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var node_1 = require_node13();
  Object.defineProperty(exports, "OTLPMetricExporter", { enumerable: true, get: function() {
    return node_1.OTLPMetricExporter;
  } });
});

// node_modules/@opentelemetry/exporter-metrics-otlp-proto/build/src/index.js
var require_src24 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPMetricExporter = undefined;
  var platform_1 = require_platform12();
  Object.defineProperty(exports, "OTLPMetricExporter", { enumerable: true, get: function() {
    return platform_1.OTLPMetricExporter;
  } });
});

// node_modules/@opentelemetry/exporter-prometheus/build/src/PrometheusSerializer.js
var require_PrometheusSerializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PrometheusSerializer = undefined;
  var api_1 = require_src();
  var sdk_metrics_1 = require_src7();
  var core_1 = require_src3();
  function escapeString(str) {
    return str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n");
  }
  function escapeAttributeValue(str = "") {
    if (typeof str !== "string") {
      str = JSON.stringify(str);
    }
    return escapeString(str).replace(/"/g, "\\\"");
  }
  var invalidCharacterRegex = /[^a-z0-9_]/gi;
  var multipleUnderscoreRegex = /_{2,}/g;
  function sanitizePrometheusMetricName(name) {
    return name.replace(invalidCharacterRegex, "_").replace(multipleUnderscoreRegex, "_");
  }
  function enforcePrometheusNamingConvention(name, data) {
    if (!name.endsWith("_total") && data.dataPointType === sdk_metrics_1.DataPointType.SUM && data.isMonotonic) {
      name = name + "_total";
    }
    return name;
  }
  function valueString(value) {
    if (value === Infinity) {
      return "+Inf";
    } else if (value === -Infinity) {
      return "-Inf";
    } else {
      return `${value}`;
    }
  }
  function toPrometheusType(metricData) {
    switch (metricData.dataPointType) {
      case sdk_metrics_1.DataPointType.SUM:
        if (metricData.isMonotonic) {
          return "counter";
        }
        return "gauge";
      case sdk_metrics_1.DataPointType.GAUGE:
        return "gauge";
      case sdk_metrics_1.DataPointType.HISTOGRAM:
        return "histogram";
      default:
        return "untyped";
    }
  }
  function stringify(metricName, attributes, value, timestamp, additionalAttributes) {
    let hasAttribute = false;
    let attributesStr = "";
    for (const [key, val] of Object.entries(attributes)) {
      const sanitizedAttributeName = sanitizePrometheusMetricName(key);
      hasAttribute = true;
      attributesStr += `${attributesStr.length > 0 ? "," : ""}${sanitizedAttributeName}="${escapeAttributeValue(val)}"`;
    }
    if (additionalAttributes) {
      for (const [key, val] of Object.entries(additionalAttributes)) {
        const sanitizedAttributeName = sanitizePrometheusMetricName(key);
        hasAttribute = true;
        attributesStr += `${attributesStr.length > 0 ? "," : ""}${sanitizedAttributeName}="${escapeAttributeValue(val)}"`;
      }
    }
    if (hasAttribute) {
      metricName += `{${attributesStr}}`;
    }
    return `${metricName} ${valueString(value)}${timestamp !== undefined ? " " + String(timestamp) : ""}
`;
  }
  var NO_REGISTERED_METRICS = "# no registered metrics";

  class PrometheusSerializer {
    _prefix;
    _appendTimestamp;
    _additionalAttributes;
    _withResourceConstantLabels;
    constructor(prefix, appendTimestamp = false, withResourceConstantLabels) {
      if (prefix) {
        this._prefix = prefix + "_";
      }
      this._appendTimestamp = appendTimestamp;
      this._withResourceConstantLabels = withResourceConstantLabels;
    }
    serialize(resourceMetrics) {
      let str = "";
      this._additionalAttributes = this._filterResourceConstantLabels(resourceMetrics.resource.attributes, this._withResourceConstantLabels);
      for (const scopeMetrics of resourceMetrics.scopeMetrics) {
        str += this._serializeScopeMetrics(scopeMetrics);
      }
      if (str === "") {
        str += NO_REGISTERED_METRICS;
      }
      return this._serializeResource(resourceMetrics.resource) + str;
    }
    _filterResourceConstantLabels(attributes, pattern) {
      if (pattern) {
        const filteredAttributes = {};
        for (const [key, value] of Object.entries(attributes)) {
          if (key.match(pattern)) {
            filteredAttributes[key] = value;
          }
        }
        return filteredAttributes;
      }
      return;
    }
    _serializeScopeMetrics(scopeMetrics) {
      let str = "";
      for (const metric of scopeMetrics.metrics) {
        str += this._serializeMetricData(metric) + `
`;
      }
      return str;
    }
    _serializeMetricData(metricData) {
      let name = sanitizePrometheusMetricName(escapeString(metricData.descriptor.name));
      if (this._prefix) {
        name = `${this._prefix}${name}`;
      }
      const dataPointType = metricData.dataPointType;
      name = enforcePrometheusNamingConvention(name, metricData);
      const help = `# HELP ${name} ${escapeString(metricData.descriptor.description || "description missing")}`;
      const unit = metricData.descriptor.unit ? `
# UNIT ${name} ${escapeString(metricData.descriptor.unit)}` : "";
      const type2 = `# TYPE ${name} ${toPrometheusType(metricData)}`;
      let results = "";
      switch (dataPointType) {
        case sdk_metrics_1.DataPointType.SUM:
        case sdk_metrics_1.DataPointType.GAUGE: {
          results = metricData.dataPoints.map((it) => this._serializeSingularDataPoint(name, metricData, it)).join("");
          break;
        }
        case sdk_metrics_1.DataPointType.HISTOGRAM: {
          results = metricData.dataPoints.map((it) => this._serializeHistogramDataPoint(name, metricData, it)).join("");
          break;
        }
        default: {
          api_1.diag.error(`Unrecognizable DataPointType: ${dataPointType} for metric "${name}"`);
        }
      }
      return `${help}${unit}
${type2}
${results}`.trim();
    }
    _serializeSingularDataPoint(name, data, dataPoint) {
      let results = "";
      name = enforcePrometheusNamingConvention(name, data);
      const { value, attributes } = dataPoint;
      const timestamp = (0, core_1.hrTimeToMilliseconds)(dataPoint.endTime);
      results += stringify(name, attributes, value, this._appendTimestamp ? timestamp : undefined, this._additionalAttributes);
      return results;
    }
    _serializeHistogramDataPoint(name, data, dataPoint) {
      let results = "";
      name = enforcePrometheusNamingConvention(name, data);
      const attributes = dataPoint.attributes;
      const histogram = dataPoint.value;
      const timestamp = (0, core_1.hrTimeToMilliseconds)(dataPoint.endTime);
      for (const key of ["count", "sum"]) {
        const value = histogram[key];
        if (value != null)
          results += stringify(name + "_" + key, attributes, value, this._appendTimestamp ? timestamp : undefined, this._additionalAttributes);
      }
      let cumulativeSum = 0;
      const countEntries = histogram.buckets.counts.entries();
      let infiniteBoundaryDefined = false;
      for (const [idx, val] of countEntries) {
        cumulativeSum += val;
        const upperBound = histogram.buckets.boundaries[idx];
        if (upperBound === undefined && infiniteBoundaryDefined) {
          break;
        }
        if (upperBound === Infinity) {
          infiniteBoundaryDefined = true;
        }
        results += stringify(name + "_bucket", attributes, cumulativeSum, this._appendTimestamp ? timestamp : undefined, Object.assign({}, this._additionalAttributes ?? {}, {
          le: upperBound === undefined || upperBound === Infinity ? "+Inf" : String(upperBound)
        }));
      }
      return results;
    }
    _serializeResource(resource) {
      const name = "target_info";
      const help = `# HELP ${name} Target metadata`;
      const type2 = `# TYPE ${name} gauge`;
      const results = stringify(name, resource.attributes, 1).trim();
      return `${help}
${type2}
${results}
`;
    }
  }
  exports.PrometheusSerializer = PrometheusSerializer;
});

// node_modules/@opentelemetry/exporter-prometheus/build/src/PrometheusExporter.js
var require_PrometheusExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PrometheusExporter = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var sdk_metrics_1 = require_src7();
  var http_1 = __require("http");
  var PrometheusSerializer_1 = require_PrometheusSerializer();
  var url_1 = __require("url");

  class PrometheusExporter extends sdk_metrics_1.MetricReader {
    static DEFAULT_OPTIONS = {
      host: undefined,
      port: 9464,
      endpoint: "/metrics",
      prefix: "",
      appendTimestamp: false,
      withResourceConstantLabels: undefined
    };
    _host;
    _port;
    _baseUrl;
    _endpoint;
    _server;
    _prefix;
    _appendTimestamp;
    _serializer;
    _startServerPromise;
    constructor(config = {}, callback = () => {
    }) {
      super({
        aggregationSelector: (_instrumentType) => {
          return {
            type: sdk_metrics_1.AggregationType.DEFAULT
          };
        },
        aggregationTemporalitySelector: (_instrumentType) => sdk_metrics_1.AggregationTemporality.CUMULATIVE,
        metricProducers: config.metricProducers
      });
      this._host = config.host || process.env.OTEL_EXPORTER_PROMETHEUS_HOST || PrometheusExporter.DEFAULT_OPTIONS.host;
      this._port = config.port || Number(process.env.OTEL_EXPORTER_PROMETHEUS_PORT) || PrometheusExporter.DEFAULT_OPTIONS.port;
      this._prefix = config.prefix || PrometheusExporter.DEFAULT_OPTIONS.prefix;
      this._appendTimestamp = typeof config.appendTimestamp === "boolean" ? config.appendTimestamp : PrometheusExporter.DEFAULT_OPTIONS.appendTimestamp;
      const _withResourceConstantLabels = config.withResourceConstantLabels || PrometheusExporter.DEFAULT_OPTIONS.withResourceConstantLabels;
      this._server = (0, http_1.createServer)(this._requestHandler).unref();
      this._serializer = new PrometheusSerializer_1.PrometheusSerializer(this._prefix, this._appendTimestamp, _withResourceConstantLabels);
      this._baseUrl = `http://${this._host}:${this._port}/`;
      this._endpoint = (config.endpoint || PrometheusExporter.DEFAULT_OPTIONS.endpoint).replace(/^([^/])/, "/$1");
      if (config.preventServerStart !== true) {
        this.startServer().then(callback, (err) => {
          api_1.diag.error(err);
          callback(err);
        });
      } else if (callback) {
        queueMicrotask(callback);
      }
    }
    async onForceFlush() {
    }
    onShutdown() {
      return this.stopServer();
    }
    stopServer() {
      if (!this._server) {
        api_1.diag.debug("Prometheus stopServer() was called but server was never started.");
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          this._server.close((err) => {
            if (!err) {
              api_1.diag.debug("Prometheus exporter was stopped");
            } else {
              if (err.code !== "ERR_SERVER_NOT_RUNNING") {
                (0, core_1.globalErrorHandler)(err);
              }
            }
            resolve();
          });
        });
      }
    }
    startServer() {
      this._startServerPromise ??= new Promise((resolve, reject) => {
        this._server.once("error", reject);
        this._server.listen({
          port: this._port,
          host: this._host
        }, () => {
          api_1.diag.debug(`Prometheus exporter server started: ${this._host}:${this._port}/${this._endpoint}`);
          resolve();
        });
      });
      return this._startServerPromise;
    }
    getMetricsRequestHandler(_request, response) {
      this._exportMetrics(response);
    }
    _requestHandler = (request2, response) => {
      if (request2.url != null && new url_1.URL(request2.url, this._baseUrl).pathname === this._endpoint) {
        this._exportMetrics(response);
      } else {
        this._notFound(response);
      }
    };
    _exportMetrics = (response) => {
      response.statusCode = 200;
      response.setHeader("content-type", "text/plain");
      this.collect().then((collectionResult) => {
        const { resourceMetrics, errors } = collectionResult;
        if (errors.length) {
          api_1.diag.error("PrometheusExporter: metrics collection errors", ...errors);
        }
        response.end(this._serializer.serialize(resourceMetrics));
      }, (err) => {
        response.end(`# failed to export metrics: ${err}`);
      });
    };
    _notFound = (response) => {
      response.statusCode = 404;
      response.end();
    };
  }
  exports.PrometheusExporter = PrometheusExporter;
});

// node_modules/@opentelemetry/exporter-prometheus/build/src/index.js
var require_src25 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PrometheusSerializer = exports.PrometheusExporter = undefined;
  var PrometheusExporter_1 = require_PrometheusExporter();
  Object.defineProperty(exports, "PrometheusExporter", { enumerable: true, get: function() {
    return PrometheusExporter_1.PrometheusExporter;
  } });
  var PrometheusSerializer_1 = require_PrometheusSerializer();
  Object.defineProperty(exports, "PrometheusSerializer", { enumerable: true, get: function() {
    return PrometheusSerializer_1.PrometheusSerializer;
  } });
});

// node_modules/@opentelemetry/exporter-trace-otlp-proto/build/src/version.js
var require_version9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.202.0";
});

// node_modules/@opentelemetry/exporter-trace-otlp-proto/build/src/platform/node/OTLPTraceExporter.js
var require_OTLPTraceExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var otlp_exporter_base_1 = require_src13();
  var otlp_transformer_1 = require_src14();
  var version_1 = require_version9();
  var node_http_1 = require_index_node_http();

  class OTLPTraceExporter extends otlp_exporter_base_1.OTLPExporterBase {
    constructor(config = {}) {
      super((0, node_http_1.createOtlpHttpExportDelegate)((0, node_http_1.convertLegacyHttpOptions)(config, "TRACES", "v1/traces", {
        "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`,
        "Content-Type": "application/x-protobuf"
      }), otlp_transformer_1.ProtobufTraceSerializer));
    }
  }
  exports.OTLPTraceExporter = OTLPTraceExporter;
});

// node_modules/@opentelemetry/exporter-trace-otlp-proto/build/src/platform/node/index.js
var require_node14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var OTLPTraceExporter_1 = require_OTLPTraceExporter();
  Object.defineProperty(exports, "OTLPTraceExporter", { enumerable: true, get: function() {
    return OTLPTraceExporter_1.OTLPTraceExporter;
  } });
});

// node_modules/@opentelemetry/exporter-trace-otlp-proto/build/src/platform/index.js
var require_platform13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var node_1 = require_node14();
  Object.defineProperty(exports, "OTLPTraceExporter", { enumerable: true, get: function() {
    return node_1.OTLPTraceExporter;
  } });
});

// node_modules/@opentelemetry/exporter-trace-otlp-proto/build/src/index.js
var require_src26 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var platform_1 = require_platform13();
  Object.defineProperty(exports, "OTLPTraceExporter", { enumerable: true, get: function() {
    return platform_1.OTLPTraceExporter;
  } });
});

// node_modules/@opentelemetry/exporter-trace-otlp-http/build/src/version.js
var require_version10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "0.202.0";
});

// node_modules/@opentelemetry/exporter-trace-otlp-http/build/src/platform/node/OTLPTraceExporter.js
var require_OTLPTraceExporter2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var otlp_exporter_base_1 = require_src13();
  var version_1 = require_version10();
  var otlp_transformer_1 = require_src14();
  var node_http_1 = require_index_node_http();

  class OTLPTraceExporter extends otlp_exporter_base_1.OTLPExporterBase {
    constructor(config = {}) {
      super((0, node_http_1.createOtlpHttpExportDelegate)((0, node_http_1.convertLegacyHttpOptions)(config, "TRACES", "v1/traces", {
        "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`,
        "Content-Type": "application/json"
      }), otlp_transformer_1.JsonTraceSerializer));
    }
  }
  exports.OTLPTraceExporter = OTLPTraceExporter;
});

// node_modules/@opentelemetry/exporter-trace-otlp-http/build/src/platform/node/index.js
var require_node15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var OTLPTraceExporter_1 = require_OTLPTraceExporter2();
  Object.defineProperty(exports, "OTLPTraceExporter", { enumerable: true, get: function() {
    return OTLPTraceExporter_1.OTLPTraceExporter;
  } });
});

// node_modules/@opentelemetry/exporter-trace-otlp-http/build/src/platform/index.js
var require_platform14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var node_1 = require_node15();
  Object.defineProperty(exports, "OTLPTraceExporter", { enumerable: true, get: function() {
    return node_1.OTLPTraceExporter;
  } });
});

// node_modules/@opentelemetry/exporter-trace-otlp-http/build/src/index.js
var require_src27 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var platform_1 = require_platform14();
  Object.defineProperty(exports, "OTLPTraceExporter", { enumerable: true, get: function() {
    return platform_1.OTLPTraceExporter;
  } });
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/OTLPTraceExporter.js
var require_OTLPTraceExporter3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var otlp_grpc_exporter_base_1 = require_src19();
  var otlp_transformer_1 = require_src14();
  var otlp_exporter_base_1 = require_src13();

  class OTLPTraceExporter extends otlp_exporter_base_1.OTLPExporterBase {
    constructor(config = {}) {
      super((0, otlp_grpc_exporter_base_1.createOtlpGrpcExportDelegate)((0, otlp_grpc_exporter_base_1.convertLegacyOtlpGrpcOptions)(config, "TRACES"), otlp_transformer_1.ProtobufTraceSerializer, "TraceExportService", "/opentelemetry.proto.collector.trace.v1.TraceService/Export"));
    }
  }
  exports.OTLPTraceExporter = OTLPTraceExporter;
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/index.js
var require_src28 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OTLPTraceExporter = undefined;
  var OTLPTraceExporter_1 = require_OTLPTraceExporter3();
  Object.defineProperty(exports, "OTLPTraceExporter", { enumerable: true, get: function() {
    return OTLPTraceExporter_1.OTLPTraceExporter;
  } });
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/platform/node/util.js
var require_util5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareSend = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var http = __require("http");
  var https = __require("https");
  function prepareSend(urlStr, headers) {
    const url = new URL(urlStr);
    const reqOpts = Object.assign({
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...headers
      }
    });
    return function send(zipkinSpans, done) {
      if (zipkinSpans.length === 0) {
        api_1.diag.debug("Zipkin send with empty spans");
        return done({ code: core_1.ExportResultCode.SUCCESS });
      }
      const { request: request2 } = url.protocol === "http:" ? http : https;
      const req = request2(url, reqOpts, (res) => {
        let rawData = "";
        res.on("data", (chunk) => {
          rawData += chunk;
        });
        res.on("end", () => {
          const statusCode = res.statusCode || 0;
          api_1.diag.debug(`Zipkin response status code: ${statusCode}, body: ${rawData}`);
          if (statusCode < 400) {
            return done({ code: core_1.ExportResultCode.SUCCESS });
          } else {
            return done({
              code: core_1.ExportResultCode.FAILED,
              error: new Error(`Got unexpected status code from zipkin: ${statusCode}`)
            });
          }
        });
      });
      req.on("error", (error) => {
        return done({
          code: core_1.ExportResultCode.FAILED,
          error
        });
      });
      const payload = JSON.stringify(zipkinSpans);
      api_1.diag.debug(`Zipkin request payload: ${payload}`);
      req.write(payload, "utf8");
      req.end();
    };
  }
  exports.prepareSend = prepareSend;
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/platform/node/index.js
var require_node16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareSend = undefined;
  var util_1 = require_util5();
  Object.defineProperty(exports, "prepareSend", { enumerable: true, get: function() {
    return util_1.prepareSend;
  } });
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/platform/index.js
var require_platform15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareSend = undefined;
  var node_1 = require_node16();
  Object.defineProperty(exports, "prepareSend", { enumerable: true, get: function() {
    return node_1.prepareSend;
  } });
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/types.js
var require_types6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2["CLIENT"] = "CLIENT";
    SpanKind2["SERVER"] = "SERVER";
    SpanKind2["CONSUMER"] = "CONSUMER";
    SpanKind2["PRODUCER"] = "PRODUCER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/transform.js
var require_transform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._toZipkinAnnotations = exports._toZipkinTags = exports.toZipkinSpan = exports.defaultStatusErrorTagName = exports.defaultStatusCodeTagName = undefined;
  var api = require_src();
  var core_1 = require_src3();
  var zipkinTypes = require_types6();
  var ZIPKIN_SPAN_KIND_MAPPING = {
    [api.SpanKind.CLIENT]: zipkinTypes.SpanKind.CLIENT,
    [api.SpanKind.SERVER]: zipkinTypes.SpanKind.SERVER,
    [api.SpanKind.CONSUMER]: zipkinTypes.SpanKind.CONSUMER,
    [api.SpanKind.PRODUCER]: zipkinTypes.SpanKind.PRODUCER,
    [api.SpanKind.INTERNAL]: undefined
  };
  exports.defaultStatusCodeTagName = "otel.status_code";
  exports.defaultStatusErrorTagName = "error";
  function toZipkinSpan(span, serviceName, statusCodeTagName, statusErrorTagName) {
    const zipkinSpan = {
      traceId: span.spanContext().traceId,
      parentId: span.parentSpanContext?.spanId,
      name: span.name,
      id: span.spanContext().spanId,
      kind: ZIPKIN_SPAN_KIND_MAPPING[span.kind],
      timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
      duration: Math.round((0, core_1.hrTimeToMicroseconds)(span.duration)),
      localEndpoint: { serviceName },
      tags: _toZipkinTags(span, statusCodeTagName, statusErrorTagName),
      annotations: span.events.length ? _toZipkinAnnotations(span.events) : undefined
    };
    return zipkinSpan;
  }
  exports.toZipkinSpan = toZipkinSpan;
  function _toZipkinTags({ attributes, resource, status, droppedAttributesCount, droppedEventsCount, droppedLinksCount }, statusCodeTagName, statusErrorTagName) {
    const tags = {};
    for (const key of Object.keys(attributes)) {
      tags[key] = String(attributes[key]);
    }
    if (status.code !== api.SpanStatusCode.UNSET) {
      tags[statusCodeTagName] = String(api.SpanStatusCode[status.code]);
    }
    if (status.code === api.SpanStatusCode.ERROR && status.message) {
      tags[statusErrorTagName] = status.message;
    }
    if (droppedAttributesCount) {
      tags["otel.dropped_attributes_count"] = String(droppedAttributesCount);
    }
    if (droppedEventsCount) {
      tags["otel.dropped_events_count"] = String(droppedEventsCount);
    }
    if (droppedLinksCount) {
      tags["otel.dropped_links_count"] = String(droppedLinksCount);
    }
    Object.keys(resource.attributes).forEach((name) => tags[name] = String(resource.attributes[name]));
    return tags;
  }
  exports._toZipkinTags = _toZipkinTags;
  function _toZipkinAnnotations(events) {
    return events.map((event) => ({
      timestamp: Math.round((0, core_1.hrTimeToMicroseconds)(event.time)),
      value: event.name
    }));
  }
  exports._toZipkinAnnotations = _toZipkinAnnotations;
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/utils.js
var require_utils10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareGetHeaders = undefined;
  function prepareGetHeaders(getExportRequestHeaders) {
    return function() {
      return getExportRequestHeaders();
    };
  }
  exports.prepareGetHeaders = prepareGetHeaders;
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/zipkin.js
var require_zipkin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZipkinExporter = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var index_1 = require_platform15();
  var transform_1 = require_transform();
  var semantic_conventions_1 = require_src2();
  var utils_1 = require_utils10();

  class ZipkinExporter {
    DEFAULT_SERVICE_NAME = "OpenTelemetry Service";
    _statusCodeTagName;
    _statusDescriptionTagName;
    _urlStr;
    _send;
    _getHeaders;
    _serviceName;
    _isShutdown;
    _sendingPromises = [];
    constructor(config = {}) {
      this._urlStr = config.url || ((0, core_1.getStringFromEnv)("OTEL_EXPORTER_ZIPKIN_ENDPOINT") ?? "http://localhost:9411/api/v2/spans");
      this._send = (0, index_1.prepareSend)(this._urlStr, config.headers);
      this._serviceName = config.serviceName;
      this._statusCodeTagName = config.statusCodeTagName || transform_1.defaultStatusCodeTagName;
      this._statusDescriptionTagName = config.statusDescriptionTagName || transform_1.defaultStatusErrorTagName;
      this._isShutdown = false;
      if (typeof config.getExportRequestHeaders === "function") {
        this._getHeaders = (0, utils_1.prepareGetHeaders)(config.getExportRequestHeaders);
      } else {
        this._beforeSend = function() {
        };
      }
    }
    export(spans, resultCallback) {
      const serviceName = String(this._serviceName || spans[0].resource.attributes[semantic_conventions_1.ATTR_SERVICE_NAME] || this.DEFAULT_SERVICE_NAME);
      api_1.diag.debug("Zipkin exporter export");
      if (this._isShutdown) {
        setTimeout(() => resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Exporter has been shutdown")
        }));
        return;
      }
      const promise = new Promise((resolve) => {
        this._sendSpans(spans, serviceName, (result) => {
          resolve();
          resultCallback(result);
        });
      });
      this._sendingPromises.push(promise);
      const popPromise = () => {
        const index = this._sendingPromises.indexOf(promise);
        this._sendingPromises.splice(index, 1);
      };
      promise.then(popPromise, popPromise);
    }
    shutdown() {
      api_1.diag.debug("Zipkin exporter shutdown");
      this._isShutdown = true;
      return this.forceFlush();
    }
    forceFlush() {
      return new Promise((resolve, reject) => {
        Promise.all(this._sendingPromises).then(() => {
          resolve();
        }, reject);
      });
    }
    _beforeSend() {
      if (this._getHeaders) {
        this._send = (0, index_1.prepareSend)(this._urlStr, this._getHeaders());
      }
    }
    _sendSpans(spans, serviceName, done) {
      const zipkinSpans = spans.map((span) => (0, transform_1.toZipkinSpan)(span, String(span.attributes[semantic_conventions_1.ATTR_SERVICE_NAME] || span.resource.attributes[semantic_conventions_1.ATTR_SERVICE_NAME] || serviceName), this._statusCodeTagName, this._statusDescriptionTagName));
      this._beforeSend();
      return this._send(zipkinSpans, (result) => {
        if (done) {
          return done(result);
        }
      });
    }
  }
  exports.ZipkinExporter = ZipkinExporter;
});

// node_modules/@opentelemetry/exporter-zipkin/build/src/index.js
var require_src29 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZipkinExporter = exports.prepareSend = undefined;
  var platform_1 = require_platform15();
  Object.defineProperty(exports, "prepareSend", { enumerable: true, get: function() {
    return platform_1.prepareSend;
  } });
  var zipkin_1 = require_zipkin();
  Object.defineProperty(exports, "ZipkinExporter", { enumerable: true, get: function() {
    return zipkin_1.ZipkinExporter;
  } });
});

// node_modules/@opentelemetry/propagator-b3/build/src/common.js
var require_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.B3_DEBUG_FLAG_KEY = undefined;
  var api_1 = require_src();
  exports.B3_DEBUG_FLAG_KEY = (0, api_1.createContextKey)("OpenTelemetry Context Key B3 Debug Flag");
});

// node_modules/@opentelemetry/propagator-b3/build/src/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X_B3_FLAGS = exports.X_B3_PARENT_SPAN_ID = exports.X_B3_SAMPLED = exports.X_B3_SPAN_ID = exports.X_B3_TRACE_ID = exports.B3_CONTEXT_HEADER = undefined;
  exports.B3_CONTEXT_HEADER = "b3";
  exports.X_B3_TRACE_ID = "x-b3-traceid";
  exports.X_B3_SPAN_ID = "x-b3-spanid";
  exports.X_B3_SAMPLED = "x-b3-sampled";
  exports.X_B3_PARENT_SPAN_ID = "x-b3-parentspanid";
  exports.X_B3_FLAGS = "x-b3-flags";
});

// node_modules/@opentelemetry/propagator-b3/build/src/B3MultiPropagator.js
var require_B3MultiPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.B3MultiPropagator = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var common_1 = require_common3();
  var constants_1 = require_constants3();
  var VALID_SAMPLED_VALUES = new Set([true, "true", "True", "1", 1]);
  var VALID_UNSAMPLED_VALUES = new Set([false, "false", "False", "0", 0]);
  function isValidSampledValue(sampled) {
    return sampled === api_1.TraceFlags.SAMPLED || sampled === api_1.TraceFlags.NONE;
  }
  function parseHeader(header) {
    return Array.isArray(header) ? header[0] : header;
  }
  function getHeaderValue(carrier, getter, key) {
    const header = getter.get(carrier, key);
    return parseHeader(header);
  }
  function getTraceId(carrier, getter) {
    const traceId = getHeaderValue(carrier, getter, constants_1.X_B3_TRACE_ID);
    if (typeof traceId === "string") {
      return traceId.padStart(32, "0");
    }
    return "";
  }
  function getSpanId(carrier, getter) {
    const spanId = getHeaderValue(carrier, getter, constants_1.X_B3_SPAN_ID);
    if (typeof spanId === "string") {
      return spanId;
    }
    return "";
  }
  function getDebug(carrier, getter) {
    const debug = getHeaderValue(carrier, getter, constants_1.X_B3_FLAGS);
    return debug === "1" ? "1" : undefined;
  }
  function getTraceFlags(carrier, getter) {
    const traceFlags = getHeaderValue(carrier, getter, constants_1.X_B3_SAMPLED);
    const debug = getDebug(carrier, getter);
    if (debug === "1" || VALID_SAMPLED_VALUES.has(traceFlags)) {
      return api_1.TraceFlags.SAMPLED;
    }
    if (traceFlags === undefined || VALID_UNSAMPLED_VALUES.has(traceFlags)) {
      return api_1.TraceFlags.NONE;
    }
    return;
  }

  class B3MultiPropagator {
    inject(context, carrier, setter) {
      const spanContext = api_1.trace.getSpanContext(context);
      if (!spanContext || !(0, api_1.isSpanContextValid)(spanContext) || (0, core_1.isTracingSuppressed)(context))
        return;
      const debug = context.getValue(common_1.B3_DEBUG_FLAG_KEY);
      setter.set(carrier, constants_1.X_B3_TRACE_ID, spanContext.traceId);
      setter.set(carrier, constants_1.X_B3_SPAN_ID, spanContext.spanId);
      if (debug === "1") {
        setter.set(carrier, constants_1.X_B3_FLAGS, debug);
      } else if (spanContext.traceFlags !== undefined) {
        setter.set(carrier, constants_1.X_B3_SAMPLED, (api_1.TraceFlags.SAMPLED & spanContext.traceFlags) === api_1.TraceFlags.SAMPLED ? "1" : "0");
      }
    }
    extract(context, carrier, getter) {
      const traceId = getTraceId(carrier, getter);
      const spanId = getSpanId(carrier, getter);
      const traceFlags = getTraceFlags(carrier, getter);
      const debug = getDebug(carrier, getter);
      if ((0, api_1.isValidTraceId)(traceId) && (0, api_1.isValidSpanId)(spanId) && isValidSampledValue(traceFlags)) {
        context = context.setValue(common_1.B3_DEBUG_FLAG_KEY, debug);
        return api_1.trace.setSpanContext(context, {
          traceId,
          spanId,
          isRemote: true,
          traceFlags
        });
      }
      return context;
    }
    fields() {
      return [
        constants_1.X_B3_TRACE_ID,
        constants_1.X_B3_SPAN_ID,
        constants_1.X_B3_FLAGS,
        constants_1.X_B3_SAMPLED,
        constants_1.X_B3_PARENT_SPAN_ID
      ];
    }
  }
  exports.B3MultiPropagator = B3MultiPropagator;
});

// node_modules/@opentelemetry/propagator-b3/build/src/B3SinglePropagator.js
var require_B3SinglePropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.B3SinglePropagator = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var common_1 = require_common3();
  var constants_1 = require_constants3();
  var B3_CONTEXT_REGEX = /((?:[0-9a-f]{16}){1,2})-([0-9a-f]{16})(?:-([01d](?![0-9a-f])))?(?:-([0-9a-f]{16}))?/;
  var PADDING = "0".repeat(16);
  var SAMPLED_VALUES = new Set(["d", "1"]);
  var DEBUG_STATE = "d";
  function convertToTraceId128(traceId) {
    return traceId.length === 32 ? traceId : `${PADDING}${traceId}`;
  }
  function convertToTraceFlags(samplingState) {
    if (samplingState && SAMPLED_VALUES.has(samplingState)) {
      return api_1.TraceFlags.SAMPLED;
    }
    return api_1.TraceFlags.NONE;
  }

  class B3SinglePropagator {
    inject(context, carrier, setter) {
      const spanContext = api_1.trace.getSpanContext(context);
      if (!spanContext || !(0, api_1.isSpanContextValid)(spanContext) || (0, core_1.isTracingSuppressed)(context))
        return;
      const samplingState = context.getValue(common_1.B3_DEBUG_FLAG_KEY) || spanContext.traceFlags & 1;
      const value = `${spanContext.traceId}-${spanContext.spanId}-${samplingState}`;
      setter.set(carrier, constants_1.B3_CONTEXT_HEADER, value);
    }
    extract(context, carrier, getter) {
      const header = getter.get(carrier, constants_1.B3_CONTEXT_HEADER);
      const b3Context = Array.isArray(header) ? header[0] : header;
      if (typeof b3Context !== "string")
        return context;
      const match = b3Context.match(B3_CONTEXT_REGEX);
      if (!match)
        return context;
      const [, extractedTraceId, spanId, samplingState] = match;
      const traceId = convertToTraceId128(extractedTraceId);
      if (!(0, api_1.isValidTraceId)(traceId) || !(0, api_1.isValidSpanId)(spanId))
        return context;
      const traceFlags = convertToTraceFlags(samplingState);
      if (samplingState === DEBUG_STATE) {
        context = context.setValue(common_1.B3_DEBUG_FLAG_KEY, samplingState);
      }
      return api_1.trace.setSpanContext(context, {
        traceId,
        spanId,
        isRemote: true,
        traceFlags
      });
    }
    fields() {
      return [constants_1.B3_CONTEXT_HEADER];
    }
  }
  exports.B3SinglePropagator = B3SinglePropagator;
});

// node_modules/@opentelemetry/propagator-b3/build/src/types.js
var require_types7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.B3InjectEncoding = undefined;
  var B3InjectEncoding;
  (function(B3InjectEncoding2) {
    B3InjectEncoding2[B3InjectEncoding2["SINGLE_HEADER"] = 0] = "SINGLE_HEADER";
    B3InjectEncoding2[B3InjectEncoding2["MULTI_HEADER"] = 1] = "MULTI_HEADER";
  })(B3InjectEncoding = exports.B3InjectEncoding || (exports.B3InjectEncoding = {}));
});

// node_modules/@opentelemetry/propagator-b3/build/src/B3Propagator.js
var require_B3Propagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.B3Propagator = undefined;
  var core_1 = require_src3();
  var B3MultiPropagator_1 = require_B3MultiPropagator();
  var B3SinglePropagator_1 = require_B3SinglePropagator();
  var constants_1 = require_constants3();
  var types_1 = require_types7();

  class B3Propagator {
    _b3MultiPropagator = new B3MultiPropagator_1.B3MultiPropagator;
    _b3SinglePropagator = new B3SinglePropagator_1.B3SinglePropagator;
    _inject;
    _fields;
    constructor(config = {}) {
      if (config.injectEncoding === types_1.B3InjectEncoding.MULTI_HEADER) {
        this._inject = this._b3MultiPropagator.inject;
        this._fields = this._b3MultiPropagator.fields();
      } else {
        this._inject = this._b3SinglePropagator.inject;
        this._fields = this._b3SinglePropagator.fields();
      }
    }
    inject(context, carrier, setter) {
      if ((0, core_1.isTracingSuppressed)(context)) {
        return;
      }
      this._inject(context, carrier, setter);
    }
    extract(context, carrier, getter) {
      const header = getter.get(carrier, constants_1.B3_CONTEXT_HEADER);
      const b3Context = Array.isArray(header) ? header[0] : header;
      if (b3Context) {
        return this._b3SinglePropagator.extract(context, carrier, getter);
      } else {
        return this._b3MultiPropagator.extract(context, carrier, getter);
      }
    }
    fields() {
      return this._fields;
    }
  }
  exports.B3Propagator = B3Propagator;
});

// node_modules/@opentelemetry/propagator-b3/build/src/index.js
var require_src30 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.B3InjectEncoding = exports.X_B3_TRACE_ID = exports.X_B3_SPAN_ID = exports.X_B3_SAMPLED = exports.X_B3_PARENT_SPAN_ID = exports.X_B3_FLAGS = exports.B3_CONTEXT_HEADER = exports.B3Propagator = undefined;
  var B3Propagator_1 = require_B3Propagator();
  Object.defineProperty(exports, "B3Propagator", { enumerable: true, get: function() {
    return B3Propagator_1.B3Propagator;
  } });
  var constants_1 = require_constants3();
  Object.defineProperty(exports, "B3_CONTEXT_HEADER", { enumerable: true, get: function() {
    return constants_1.B3_CONTEXT_HEADER;
  } });
  Object.defineProperty(exports, "X_B3_FLAGS", { enumerable: true, get: function() {
    return constants_1.X_B3_FLAGS;
  } });
  Object.defineProperty(exports, "X_B3_PARENT_SPAN_ID", { enumerable: true, get: function() {
    return constants_1.X_B3_PARENT_SPAN_ID;
  } });
  Object.defineProperty(exports, "X_B3_SAMPLED", { enumerable: true, get: function() {
    return constants_1.X_B3_SAMPLED;
  } });
  Object.defineProperty(exports, "X_B3_SPAN_ID", { enumerable: true, get: function() {
    return constants_1.X_B3_SPAN_ID;
  } });
  Object.defineProperty(exports, "X_B3_TRACE_ID", { enumerable: true, get: function() {
    return constants_1.X_B3_TRACE_ID;
  } });
  var types_1 = require_types7();
  Object.defineProperty(exports, "B3InjectEncoding", { enumerable: true, get: function() {
    return types_1.B3InjectEncoding;
  } });
});

// node_modules/@opentelemetry/propagator-jaeger/build/src/JaegerPropagator.js
var require_JaegerPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JaegerPropagator = exports.UBER_BAGGAGE_HEADER_PREFIX = exports.UBER_TRACE_ID_HEADER = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  exports.UBER_TRACE_ID_HEADER = "uber-trace-id";
  exports.UBER_BAGGAGE_HEADER_PREFIX = "uberctx";

  class JaegerPropagator {
    _jaegerTraceHeader;
    _jaegerBaggageHeaderPrefix;
    constructor(config) {
      if (typeof config === "string") {
        this._jaegerTraceHeader = config;
        this._jaegerBaggageHeaderPrefix = exports.UBER_BAGGAGE_HEADER_PREFIX;
      } else {
        this._jaegerTraceHeader = config?.customTraceHeader || exports.UBER_TRACE_ID_HEADER;
        this._jaegerBaggageHeaderPrefix = config?.customBaggageHeaderPrefix || exports.UBER_BAGGAGE_HEADER_PREFIX;
      }
    }
    inject(context, carrier, setter) {
      const spanContext = api_1.trace.getSpanContext(context);
      const baggage = api_1.propagation.getBaggage(context);
      if (spanContext && (0, core_1.isTracingSuppressed)(context) === false) {
        const traceFlags = `0${(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, this._jaegerTraceHeader, `${spanContext.traceId}:${spanContext.spanId}:0:${traceFlags}`);
      }
      if (baggage) {
        for (const [key, entry] of baggage.getAllEntries()) {
          setter.set(carrier, `${this._jaegerBaggageHeaderPrefix}-${key}`, encodeURIComponent(entry.value));
        }
      }
    }
    extract(context, carrier, getter) {
      const uberTraceIdHeader = getter.get(carrier, this._jaegerTraceHeader);
      const uberTraceId = Array.isArray(uberTraceIdHeader) ? uberTraceIdHeader[0] : uberTraceIdHeader;
      const baggageValues = getter.keys(carrier).filter((key) => key.startsWith(`${this._jaegerBaggageHeaderPrefix}-`)).map((key) => {
        const value = getter.get(carrier, key);
        return {
          key: key.substring(this._jaegerBaggageHeaderPrefix.length + 1),
          value: Array.isArray(value) ? value[0] : value
        };
      });
      let newContext = context;
      if (typeof uberTraceId === "string") {
        const spanContext = deserializeSpanContext(uberTraceId);
        if (spanContext) {
          newContext = api_1.trace.setSpanContext(newContext, spanContext);
        }
      }
      if (baggageValues.length === 0)
        return newContext;
      let currentBaggage = api_1.propagation.getBaggage(context) ?? api_1.propagation.createBaggage();
      for (const baggageEntry of baggageValues) {
        if (baggageEntry.value === undefined)
          continue;
        currentBaggage = currentBaggage.setEntry(baggageEntry.key, {
          value: decodeURIComponent(baggageEntry.value)
        });
      }
      newContext = api_1.propagation.setBaggage(newContext, currentBaggage);
      return newContext;
    }
    fields() {
      return [this._jaegerTraceHeader];
    }
  }
  exports.JaegerPropagator = JaegerPropagator;
  var VALID_HEX_RE = /^[0-9a-f]{1,2}$/i;
  function deserializeSpanContext(serializedString) {
    const headers = decodeURIComponent(serializedString).split(":");
    if (headers.length !== 4) {
      return null;
    }
    const [_traceId, _spanId, , flags] = headers;
    const traceId = _traceId.padStart(32, "0");
    const spanId = _spanId.padStart(16, "0");
    const traceFlags = VALID_HEX_RE.test(flags) ? parseInt(flags, 16) & 1 : 1;
    return { traceId, spanId, isRemote: true, traceFlags };
  }
});

// node_modules/@opentelemetry/propagator-jaeger/build/src/index.js
var require_src31 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UBER_TRACE_ID_HEADER = exports.UBER_BAGGAGE_HEADER_PREFIX = exports.JaegerPropagator = undefined;
  var JaegerPropagator_1 = require_JaegerPropagator();
  Object.defineProperty(exports, "JaegerPropagator", { enumerable: true, get: function() {
    return JaegerPropagator_1.JaegerPropagator;
  } });
  Object.defineProperty(exports, "UBER_BAGGAGE_HEADER_PREFIX", { enumerable: true, get: function() {
    return JaegerPropagator_1.UBER_BAGGAGE_HEADER_PREFIX;
  } });
  Object.defineProperty(exports, "UBER_TRACE_ID_HEADER", { enumerable: true, get: function() {
    return JaegerPropagator_1.UBER_TRACE_ID_HEADER;
  } });
});

// node_modules/@opentelemetry/sdk-node/build/src/utils.js
var require_utils11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPropagatorFromEnv = exports.getSpanProcessorsFromEnv = exports.getOtlpProtocolFromEnv = exports.filterBlanksAndNulls = exports.getResourceDetectorsFromEnv = undefined;
  var api_1 = require_src();
  var core_1 = require_src3();
  var exporter_trace_otlp_proto_1 = require_src26();
  var exporter_trace_otlp_http_1 = require_src27();
  var exporter_trace_otlp_grpc_1 = require_src28();
  var exporter_zipkin_1 = require_src29();
  var resources_1 = require_src5();
  var sdk_trace_base_1 = require_src9();
  var propagator_b3_1 = require_src30();
  var propagator_jaeger_1 = require_src31();
  var RESOURCE_DETECTOR_ENVIRONMENT = "env";
  var RESOURCE_DETECTOR_HOST = "host";
  var RESOURCE_DETECTOR_OS = "os";
  var RESOURCE_DETECTOR_PROCESS = "process";
  var RESOURCE_DETECTOR_SERVICE_INSTANCE_ID = "serviceinstance";
  function getResourceDetectorsFromEnv() {
    const resourceDetectors = new Map([
      [RESOURCE_DETECTOR_ENVIRONMENT, resources_1.envDetector],
      [RESOURCE_DETECTOR_HOST, resources_1.hostDetector],
      [RESOURCE_DETECTOR_OS, resources_1.osDetector],
      [RESOURCE_DETECTOR_SERVICE_INSTANCE_ID, resources_1.serviceInstanceIdDetector],
      [RESOURCE_DETECTOR_PROCESS, resources_1.processDetector]
    ]);
    const resourceDetectorsFromEnv = (0, core_1.getStringListFromEnv)("OTEL_NODE_RESOURCE_DETECTORS") ?? ["all"];
    if (resourceDetectorsFromEnv.includes("all")) {
      return [...resourceDetectors.values()].flat();
    }
    if (resourceDetectorsFromEnv.includes("none")) {
      return [];
    }
    return resourceDetectorsFromEnv.flatMap((detector) => {
      const resourceDetector = resourceDetectors.get(detector);
      if (!resourceDetector) {
        api_1.diag.warn(`Invalid resource detector "${detector}" specified in the environment variable OTEL_NODE_RESOURCE_DETECTORS`);
      }
      return resourceDetector || [];
    });
  }
  exports.getResourceDetectorsFromEnv = getResourceDetectorsFromEnv;
  function filterBlanksAndNulls(list) {
    return list.map((item) => item.trim()).filter((s) => s !== "null" && s !== "");
  }
  exports.filterBlanksAndNulls = filterBlanksAndNulls;
  function getOtlpProtocolFromEnv() {
    return (0, core_1.getStringFromEnv)("OTEL_EXPORTER_OTLP_TRACES_PROTOCOL") ?? (0, core_1.getStringFromEnv)("OTEL_EXPORTER_OTLP_PROTOCOL") ?? "http/protobuf";
  }
  exports.getOtlpProtocolFromEnv = getOtlpProtocolFromEnv;
  function getOtlpExporterFromEnv() {
    const protocol = getOtlpProtocolFromEnv();
    switch (protocol) {
      case "grpc":
        return new exporter_trace_otlp_grpc_1.OTLPTraceExporter;
      case "http/json":
        return new exporter_trace_otlp_http_1.OTLPTraceExporter;
      case "http/protobuf":
        return new exporter_trace_otlp_proto_1.OTLPTraceExporter;
      default:
        api_1.diag.warn(`Unsupported OTLP traces protocol: ${protocol}. Using http/protobuf.`);
        return new exporter_trace_otlp_proto_1.OTLPTraceExporter;
    }
  }
  function getJaegerExporter() {
    try {
      const { JaegerExporter } = (()=>{throw new Error("Cannot require module "+"@opentelemetry/exporter-jaeger");})();
      return new JaegerExporter;
    } catch (e) {
      throw new Error(`Could not instantiate JaegerExporter. This could be due to the JaegerExporter's lack of support for bundling. If possible, use @opentelemetry/exporter-trace-otlp-proto instead. Original Error: ${e}`);
    }
  }
  function getSpanProcessorsFromEnv() {
    const exportersMap = new Map([
      ["otlp", () => getOtlpExporterFromEnv()],
      ["zipkin", () => new exporter_zipkin_1.ZipkinExporter],
      ["console", () => new sdk_trace_base_1.ConsoleSpanExporter],
      ["jaeger", () => getJaegerExporter()]
    ]);
    const exporters = [];
    const processors = [];
    let traceExportersList = filterBlanksAndNulls(Array.from(new Set((0, core_1.getStringListFromEnv)("OTEL_TRACES_EXPORTER"))));
    if (traceExportersList[0] === "none") {
      api_1.diag.warn('OTEL_TRACES_EXPORTER contains "none". SDK will not be initialized.');
      return [];
    }
    if (traceExportersList.length === 0) {
      api_1.diag.debug("OTEL_TRACES_EXPORTER is empty. Using default otlp exporter.");
      traceExportersList = ["otlp"];
    } else if (traceExportersList.length > 1 && traceExportersList.includes("none")) {
      api_1.diag.warn('OTEL_TRACES_EXPORTER contains "none" along with other exporters. Using default otlp exporter.');
      traceExportersList = ["otlp"];
    }
    for (const name of traceExportersList) {
      const exporter = exportersMap.get(name)?.();
      if (exporter) {
        exporters.push(exporter);
      } else {
        api_1.diag.warn(`Unrecognized OTEL_TRACES_EXPORTER value: ${name}.`);
      }
    }
    for (const exp of exporters) {
      if (exp instanceof sdk_trace_base_1.ConsoleSpanExporter) {
        processors.push(new sdk_trace_base_1.SimpleSpanProcessor(exp));
      } else {
        processors.push(new sdk_trace_base_1.BatchSpanProcessor(exp));
      }
    }
    if (exporters.length === 0) {
      api_1.diag.warn("Unable to set up trace exporter(s) due to invalid exporter and/or protocol values.");
    }
    return processors;
  }
  exports.getSpanProcessorsFromEnv = getSpanProcessorsFromEnv;
  function getPropagatorFromEnv() {
    const propagatorsEnvVarValue = (0, core_1.getStringListFromEnv)("OTEL_PROPAGATORS");
    if (propagatorsEnvVarValue == null) {
      return;
    }
    const propagatorsFactory = new Map([
      ["tracecontext", () => new core_1.W3CTraceContextPropagator],
      ["baggage", () => new core_1.W3CBaggagePropagator],
      ["b3", () => new propagator_b3_1.B3Propagator],
      [
        "b3multi",
        () => new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.MULTI_HEADER })
      ],
      ["jaeger", () => new propagator_jaeger_1.JaegerPropagator]
    ]);
    const uniquePropagatorNames = Array.from(new Set(propagatorsEnvVarValue));
    const propagators = uniquePropagatorNames.map((name) => {
      const propagator = propagatorsFactory.get(name)?.();
      if (!propagator) {
        api_1.diag.warn(`Propagator "${name}" requested through environment variable is unavailable.`);
        return;
      }
      return propagator;
    });
    const validPropagators = propagators.reduce((list, item) => {
      if (item) {
        list.push(item);
      }
      return list;
    }, []);
    if (validPropagators.length === 0) {
      return null;
    } else if (uniquePropagatorNames.length === 1) {
      return validPropagators[0];
    } else {
      return new core_1.CompositePropagator({
        propagators: validPropagators
      });
    }
  }
  exports.getPropagatorFromEnv = getPropagatorFromEnv;
});

// node_modules/@opentelemetry/sdk-node/build/src/sdk.js
var require_sdk = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeSDK = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src4();
  var instrumentation_1 = require_src12();
  var resources_1 = require_src5();
  var sdk_logs_1 = require_src6();
  var exporter_logs_otlp_http_1 = require_src15();
  var exporter_logs_otlp_grpc_1 = require_src20();
  var exporter_logs_otlp_proto_1 = require_src21();
  var exporter_metrics_otlp_grpc_1 = require_src23();
  var exporter_metrics_otlp_proto_1 = require_src24();
  var exporter_metrics_otlp_http_1 = require_src22();
  var exporter_prometheus_1 = require_src25();
  var sdk_metrics_1 = require_src7();
  var sdk_trace_base_1 = require_src9();
  var sdk_trace_node_1 = require_src10();
  var semantic_conventions_1 = require_src2();
  var core_1 = require_src3();
  var utils_1 = require_utils11();
  function getValueInMillis(envName, defaultValue) {
    return parseInt(process.env[envName] || "") || defaultValue;
  }
  function configureMetricProviderFromEnv() {
    const metricReaders = [];
    const enabledExporters = (0, core_1.getStringListFromEnv)("OTEL_METRICS_EXPORTER");
    if (!enabledExporters) {
      return metricReaders;
    }
    if (enabledExporters.length === 0) {
      api_1.diag.debug("OTEL_METRICS_EXPORTER is empty. Using default otlp exporter.");
    }
    if (enabledExporters.includes("none")) {
      api_1.diag.info(`OTEL_METRICS_EXPORTER contains "none". Metric provider will not be initialized.`);
      return metricReaders;
    }
    enabledExporters.forEach((exporter) => {
      if (exporter === "otlp") {
        const protocol = process.env.OTEL_EXPORTER_OTLP_METRICS_PROTOCOL?.trim() || process.env.OTEL_EXPORTER_OTLP_PROTOCOL?.trim();
        const exportIntervalMillis = getValueInMillis("OTEL_METRIC_EXPORT_INTERVAL", 60000);
        const exportTimeoutMillis = getValueInMillis("OTEL_METRIC_EXPORT_TIMEOUT", 30000);
        switch (protocol) {
          case "grpc":
            metricReaders.push(new sdk_metrics_1.PeriodicExportingMetricReader({
              exporter: new exporter_metrics_otlp_grpc_1.OTLPMetricExporter,
              exportIntervalMillis,
              exportTimeoutMillis
            }));
            break;
          case "http/json":
            metricReaders.push(new sdk_metrics_1.PeriodicExportingMetricReader({
              exporter: new exporter_metrics_otlp_http_1.OTLPMetricExporter,
              exportIntervalMillis,
              exportTimeoutMillis
            }));
            break;
          case "http/protobuf":
            metricReaders.push(new sdk_metrics_1.PeriodicExportingMetricReader({
              exporter: new exporter_metrics_otlp_proto_1.OTLPMetricExporter,
              exportIntervalMillis,
              exportTimeoutMillis
            }));
            break;
          default:
            api_1.diag.warn(`Unsupported OTLP metrics protocol: "${protocol}". Using http/protobuf.`);
            metricReaders.push(new sdk_metrics_1.PeriodicExportingMetricReader({
              exporter: new exporter_metrics_otlp_proto_1.OTLPMetricExporter,
              exportIntervalMillis,
              exportTimeoutMillis
            }));
        }
      } else if (exporter === "console") {
        metricReaders.push(new sdk_metrics_1.PeriodicExportingMetricReader({
          exporter: new sdk_metrics_1.ConsoleMetricExporter
        }));
      } else if (exporter === "prometheus") {
        metricReaders.push(new exporter_prometheus_1.PrometheusExporter);
      } else {
        api_1.diag.warn(`Unsupported OTEL_METRICS_EXPORTER value: "${exporter}". Supported values are: otlp, console, prometheus, none.`);
      }
    });
    return metricReaders;
  }

  class NodeSDK {
    _tracerProviderConfig;
    _loggerProviderConfig;
    _meterProviderConfig;
    _instrumentations;
    _resource;
    _resourceDetectors;
    _autoDetectResources;
    _tracerProvider;
    _loggerProvider;
    _meterProvider;
    _serviceName;
    _configuration;
    _disabled;
    constructor(configuration = {}) {
      if ((0, core_1.getBooleanFromEnv)("OTEL_SDK_DISABLED")) {
        this._disabled = true;
      }
      const logLevel = (0, core_1.getStringFromEnv)("OTEL_LOG_LEVEL");
      if (logLevel != null) {
        api_1.diag.setLogger(new api_1.DiagConsoleLogger, {
          logLevel: (0, core_1.diagLogLevelFromString)(logLevel)
        });
      }
      this._configuration = configuration;
      this._resource = configuration.resource ?? (0, resources_1.defaultResource)();
      this._autoDetectResources = configuration.autoDetectResources ?? true;
      if (!this._autoDetectResources) {
        this._resourceDetectors = [];
      } else if (configuration.resourceDetectors != null) {
        this._resourceDetectors = configuration.resourceDetectors;
      } else if ((0, core_1.getStringFromEnv)("OTEL_NODE_RESOURCE_DETECTORS")) {
        this._resourceDetectors = (0, utils_1.getResourceDetectorsFromEnv)();
      } else {
        this._resourceDetectors = [resources_1.envDetector, resources_1.processDetector, resources_1.hostDetector];
      }
      this._serviceName = configuration.serviceName;
      if (configuration.traceExporter || configuration.spanProcessor || configuration.spanProcessors) {
        const tracerProviderConfig = {};
        if (configuration.sampler) {
          tracerProviderConfig.sampler = configuration.sampler;
        }
        if (configuration.spanLimits) {
          tracerProviderConfig.spanLimits = configuration.spanLimits;
        }
        if (configuration.idGenerator) {
          tracerProviderConfig.idGenerator = configuration.idGenerator;
        }
        if (configuration.spanProcessor) {
          api_1.diag.warn("The 'spanProcessor' option is deprecated. Please use 'spanProcessors' instead.");
        }
        const spanProcessor = configuration.spanProcessor ?? new sdk_trace_base_1.BatchSpanProcessor(configuration.traceExporter);
        const spanProcessors = configuration.spanProcessors ?? [spanProcessor];
        this._tracerProviderConfig = {
          tracerConfig: tracerProviderConfig,
          spanProcessors,
          contextManager: configuration.contextManager,
          textMapPropagator: configuration.textMapPropagator
        };
      }
      if (configuration.logRecordProcessors) {
        this._loggerProviderConfig = {
          logRecordProcessors: configuration.logRecordProcessors
        };
      } else if (configuration.logRecordProcessor) {
        this._loggerProviderConfig = {
          logRecordProcessors: [configuration.logRecordProcessor]
        };
        api_1.diag.warn("The 'logRecordProcessor' option is deprecated. Please use 'logRecordProcessors' instead.");
      } else {
        this.configureLoggerProviderFromEnv();
      }
      if (configuration.metricReader || configuration.views) {
        const meterProviderConfig = {};
        if (configuration.metricReader) {
          meterProviderConfig.reader = configuration.metricReader;
        }
        if (configuration.views) {
          meterProviderConfig.views = configuration.views;
        }
        this._meterProviderConfig = meterProviderConfig;
      }
      this._instrumentations = configuration.instrumentations?.flat() ?? [];
    }
    start() {
      if (this._disabled) {
        return;
      }
      (0, instrumentation_1.registerInstrumentations)({
        instrumentations: this._instrumentations
      });
      if (this._autoDetectResources) {
        const internalConfig = {
          detectors: this._resourceDetectors
        };
        this._resource = this._resource.merge((0, resources_1.detectResources)(internalConfig));
      }
      this._resource = this._serviceName === undefined ? this._resource : this._resource.merge((0, resources_1.resourceFromAttributes)({
        [semantic_conventions_1.ATTR_SERVICE_NAME]: this._serviceName
      }));
      const spanProcessors = this._tracerProviderConfig ? this._tracerProviderConfig.spanProcessors : (0, utils_1.getSpanProcessorsFromEnv)();
      this._tracerProvider = new sdk_trace_node_1.NodeTracerProvider({
        ...this._configuration,
        resource: this._resource,
        spanProcessors
      });
      if (spanProcessors.length > 0) {
        this._tracerProvider.register({
          contextManager: this._tracerProviderConfig?.contextManager ?? this._configuration?.contextManager,
          propagator: this._tracerProviderConfig?.textMapPropagator ?? (0, utils_1.getPropagatorFromEnv)()
        });
      }
      if (this._loggerProviderConfig) {
        const loggerProvider = new sdk_logs_1.LoggerProvider({
          resource: this._resource,
          processors: this._loggerProviderConfig.logRecordProcessors
        });
        this._loggerProvider = loggerProvider;
        api_logs_1.logs.setGlobalLoggerProvider(loggerProvider);
      }
      const metricReadersFromEnv = configureMetricProviderFromEnv();
      if (this._meterProviderConfig || metricReadersFromEnv.length > 0) {
        const readers = [];
        if (this._meterProviderConfig?.reader) {
          readers.push(this._meterProviderConfig.reader);
        }
        if (readers.length === 0) {
          metricReadersFromEnv.forEach((r) => readers.push(r));
        }
        const meterProvider = new sdk_metrics_1.MeterProvider({
          resource: this._resource,
          views: this._meterProviderConfig?.views ?? [],
          readers
        });
        this._meterProvider = meterProvider;
        api_1.metrics.setGlobalMeterProvider(meterProvider);
        for (const instrumentation of this._instrumentations) {
          instrumentation.setMeterProvider(api_1.metrics.getMeterProvider());
        }
      }
    }
    shutdown() {
      const promises = [];
      if (this._tracerProvider) {
        promises.push(this._tracerProvider.shutdown());
      }
      if (this._loggerProvider) {
        promises.push(this._loggerProvider.shutdown());
      }
      if (this._meterProvider) {
        promises.push(this._meterProvider.shutdown());
      }
      return Promise.all(promises).then(() => {
      });
    }
    configureLoggerProviderFromEnv() {
      const enabledExporters = (0, core_1.getStringListFromEnv)("OTEL_LOGS_EXPORTER") ?? [];
      if (enabledExporters.length === 0) {
        api_1.diag.debug("OTEL_LOGS_EXPORTER is empty. Using default otlp exporter.");
        enabledExporters.push("otlp");
      }
      if (enabledExporters.includes("none")) {
        api_1.diag.info(`OTEL_LOGS_EXPORTER contains "none". Logger provider will not be initialized.`);
        return;
      }
      const exporters = [];
      enabledExporters.forEach((exporter) => {
        if (exporter === "otlp") {
          const protocol = ((0, core_1.getStringFromEnv)("OTEL_EXPORTER_OTLP_LOGS_PROTOCOL") ?? (0, core_1.getStringFromEnv)("OTEL_EXPORTER_OTLP_PROTOCOL"))?.trim();
          switch (protocol) {
            case "grpc":
              exporters.push(new exporter_logs_otlp_grpc_1.OTLPLogExporter);
              break;
            case "http/json":
              exporters.push(new exporter_logs_otlp_http_1.OTLPLogExporter);
              break;
            case "http/protobuf":
              exporters.push(new exporter_logs_otlp_proto_1.OTLPLogExporter);
              break;
            case undefined:
            case "":
              exporters.push(new exporter_logs_otlp_proto_1.OTLPLogExporter);
              break;
            default:
              api_1.diag.warn(`Unsupported OTLP logs protocol: "${protocol}". Using http/protobuf.`);
              exporters.push(new exporter_logs_otlp_proto_1.OTLPLogExporter);
          }
        } else if (exporter === "console") {
          exporters.push(new sdk_logs_1.ConsoleLogRecordExporter);
        } else {
          api_1.diag.warn(`Unsupported OTEL_LOGS_EXPORTER value: "${exporter}". Supported values are: otlp, console, none.`);
        }
      });
      if (exporters.length > 0) {
        this._loggerProviderConfig = {
          logRecordProcessors: exporters.map((exporter) => {
            if (exporter instanceof sdk_logs_1.ConsoleLogRecordExporter) {
              return new sdk_logs_1.SimpleLogRecordProcessor(exporter);
            } else {
              return new sdk_logs_1.BatchLogRecordProcessor(exporter);
            }
          })
        };
      }
    }
  }
  exports.NodeSDK = NodeSDK;
});

// node_modules/@opentelemetry/sdk-node/build/src/index.js
var require_src32 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeSDK = exports.tracing = exports.resources = exports.node = exports.metrics = exports.logs = exports.core = exports.contextBase = exports.api = undefined;
  exports.api = require_src();
  exports.contextBase = require_src();
  exports.core = require_src3();
  exports.logs = require_src6();
  exports.metrics = require_src7();
  exports.node = require_src10();
  exports.resources = require_src5();
  exports.tracing = require_src9();
  var sdk_1 = require_sdk();
  Object.defineProperty(exports, "NodeSDK", { enumerable: true, get: function() {
    return sdk_1.NodeSDK;
  } });
});

// node_modules/node-color-log/index.js
var require_node_color_log = __commonJS((exports, module) => {
  var CONFIG = {
    SYSTEM: {
      reset: "\x1B[0m",
      bold: "\x1B[1m",
      dim: "\x1B[2m",
      italic: "\x1B[3m",
      underscore: "\x1B[4m",
      reverse: "\x1B[7m",
      strikethrough: "\x1B[9m",
      backoneline: "\x1B[1A",
      cleanthisline: "\x1B[K"
    },
    FONT: {
      black: "\x1B[30m",
      red: "\x1B[31m",
      green: "\x1B[32m",
      yellow: "\x1B[33m",
      blue: "\x1B[34m",
      magenta: "\x1B[35m",
      cyan: "\x1B[36m",
      white: "\x1B[37m"
    },
    BACKGROUND: {
      black: "\x1B[40m",
      red: "\x1B[41m",
      green: "\x1B[42m",
      yellow: "\x1B[43m",
      blue: "\x1B[44m",
      magenta: "\x1B[45m",
      cyan: "\x1B[46m",
      white: "\x1B[47m"
    }
  };
  var LEVELS = ["success", "debug", "info", "warn", "error", "disable"];

  class Logger {
    constructor(name) {
      this.command = "";
      this.lastCommand = "";
      this.name = name || "";
      const level = typeof process !== "undefined" ? process.env.LOGGER : undefined;
      if (this.isLevelValid(level)) {
        this.level = level;
      }
      this.noColor = false;
      this._getDate = () => new Date().toISOString();
      this._customizedConsole = console;
    }
    createNamedLogger(name) {
      return new Logger(name);
    }
    setLevel(level) {
      if (this.isLevelValid(level)) {
        this.level = level;
      } else {
        throw "Level you are trying to set is invalid";
      }
    }
    setLogStream(newStream) {
      if (newStream.writable) {
        this._customizedConsole = new console.Console(newStream);
      } else {
        throw "invalid writable stream object";
      }
    }
    setLevelNoColor() {
      this.noColor = true;
    }
    setLevelColor() {
      this.noColor = false;
    }
    isLevelValid(level) {
      return LEVELS.includes(level);
    }
    isAllowedLevel(level) {
      return this.level ? LEVELS.indexOf(this.level) <= LEVELS.indexOf(level) : true;
    }
    log(...args) {
      this.append(...args);
      if (!this.noColor) {
        this.command += CONFIG.SYSTEM.reset;
      }
      this._print(this.command);
      this.lastCommand = this.command;
      this.command = "";
      return this;
    }
    joint() {
      console.error("node-color-log warning: `joint` is deprecated, please use `append`");
      this._print(CONFIG.SYSTEM.backoneline + CONFIG.SYSTEM.cleanthisline);
      this.command = "";
      this.lastCommand = this.lastCommand.replace(CONFIG.SYSTEM.backoneline, "");
      this.command += CONFIG.SYSTEM.backoneline;
      this.command += this.lastCommand;
      return this;
    }
    setDate(callback) {
      this._getDate = callback;
    }
    getPrefix() {
      if (this.name) {
        return `${this._getDate()} [${this.name}]`;
      } else {
        return this._getDate();
      }
    }
    color(ticket) {
      if (ticket in CONFIG.FONT) {
        this.command += CONFIG.FONT[ticket];
      } else {
        console.error("node-color-log warning: Font color not found! Use the default.");
      }
      return this;
    }
    bgColor(ticket) {
      if (ticket in CONFIG.BACKGROUND) {
        this.command += CONFIG.BACKGROUND[ticket];
      } else {
        console.error("node-color-log warning: Background color not found! Use the default.");
      }
      return this;
    }
    bold() {
      this.command += CONFIG.SYSTEM.bold;
      return this;
    }
    dim() {
      this.command += CONFIG.SYSTEM.dim;
      return this;
    }
    underscore() {
      this.command += CONFIG.SYSTEM.underscore;
      return this;
    }
    strikethrough() {
      this.command += CONFIG.SYSTEM.strikethrough;
      return this;
    }
    reverse() {
      this.command += CONFIG.SYSTEM.reverse;
      return this;
    }
    italic() {
      this.command += CONFIG.SYSTEM.italic;
      return this;
    }
    fontColorLog(ticket, text, setting) {
      let command = "";
      if (setting) {
        command += this.checkSetting(setting);
      }
      if (ticket in CONFIG.FONT) {
        command += CONFIG.FONT[ticket];
      } else {
        console.error("node-color-log warning: Font color not found! Use the default.");
      }
      command += text;
      command += CONFIG.SYSTEM.reset;
      this.lastCommand = command;
      this._print(command);
    }
    bgColorLog(ticket, text, setting) {
      let command = "";
      if (setting) {
        command += this.checkSetting(setting);
      }
      if (ticket in CONFIG.BACKGROUND) {
        command += CONFIG.BACKGROUND[ticket];
      } else {
        console.error("node-color-log warning: Background color not found! Use the default.");
      }
      command += text;
      command += CONFIG.SYSTEM.reset;
      this.lastCommand = command;
      this._print(command);
    }
    colorLog(ticketObj, text, setting) {
      let command = "";
      if (setting) {
        command += this.checkSetting(setting);
      }
      if (ticketObj.font in CONFIG.FONT) {
        command += CONFIG.FONT[ticketObj.font];
      } else {
        console.error("node-color-log warning: Font color not found! Use the default.");
      }
      if (ticketObj.bg in CONFIG.BACKGROUND) {
        command += CONFIG.BACKGROUND[ticketObj.bg];
      } else {
        console.error("node-color-log warning: Background color not found! Use the default.");
      }
      command += text;
      command += CONFIG.SYSTEM.reset;
      this.lastCommand = command;
      this._print(command);
    }
    error(...args) {
      if (!this.isAllowedLevel("error"))
        return;
      if (this.noColor) {
        const d = this.getPrefix();
        this.log(d, " [ERROR] ", ...args);
      } else {
        const d = this.getPrefix();
        this.append(d + " ").bgColor("red").append("[ERROR]").reset().append(" ").color("red").log(...args);
      }
    }
    warn(...args) {
      if (!this.isAllowedLevel("warn"))
        return;
      if (this.noColor) {
        const d = this.getPrefix();
        this.log(d, " [WARN] ", ...args);
      } else {
        const d = this.getPrefix();
        this.append(d + " ").bgColor("yellow").color("black").append("[WARN]").reset().append(" ").color("yellow").log(...args);
      }
    }
    info(...args) {
      if (!this.isAllowedLevel("info"))
        return;
      if (this.noColor) {
        const d = this.getPrefix();
        this.log(d, " [INFO] ", ...args);
      } else {
        const d = this.getPrefix();
        this.append(d + " ").bgColor("green").color("black").append("[INFO]").reset().append(" ").color("green").log(...args);
      }
    }
    debug(...args) {
      if (!this.isAllowedLevel("debug"))
        return;
      if (this.noColor) {
        const d = this.getPrefix();
        this.log(d, " [DEBUG] ", ...args);
      } else {
        const d = this.getPrefix();
        this.append(d + " ").bgColor("cyan").color("black").append("[DEBUG]").reset().append(" ").color("cyan").log(...args);
      }
    }
    success(...args) {
      if (!this.isAllowedLevel("success"))
        return;
      if (this.noColor) {
        const d = this.getPrefix();
        this.log(d, " [SUCCESS] ", ...args);
      } else {
        const d = this.getPrefix();
        this.append(d + " ").bgColor("green").color("black").append("[SUCCESS]").reset().append(" ").color("green").log(...args);
      }
    }
    checkSetting(setting) {
      const validSetting = ["bold", "italic", "dim", "underscore", "reverse", "strikethrough"];
      let command = "";
      for (const item in setting) {
        if (validSetting.indexOf(item) !== -1) {
          if (setting[item] === true) {
            command += CONFIG.SYSTEM[item];
          } else if (setting[item] !== false) {
            console.error(`node-color-log warning: The value ${item} should be boolean.`);
          }
        } else {
          console.error(`node-color-log warning: ${item} is not valid in setting.`);
        }
      }
      return command;
    }
    _print(...args) {
      this._customizedConsole.error(...args);
    }
    append(...args) {
      for (const idx in args) {
        const arg = args[idx];
        if (typeof arg === "string") {
          this.command += arg;
        } else {
          try {
            this.command += JSON.stringify(arg);
          } catch {
            this.command += arg;
          }
        }
        if (args.length > 1 && idx < args.length - 1) {
          this.command += " ";
        }
      }
      return this;
    }
    reset() {
      this.command += CONFIG.SYSTEM.reset;
      return this;
    }
  }
  var logger = new Logger;
  module.exports = logger;
});

// src/common/utils.ts
var import_node_color_log, log = (stack) => import_node_color_log.default.bgColor("red").color("black").log(stack);
var init_utils = __esm(() => {
  import_node_color_log = __toESM(require_node_color_log(), 1);
});

// src/common/errors/DaggerSDKError.ts
var DaggerSDKError;
var init_DaggerSDKError = __esm(() => {
  init_utils();
  DaggerSDKError = class DaggerSDKError extends Error {
    cause;
    constructor(message, options) {
      super(message);
      this.cause = options?.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
    printStackTrace() {
      log(this.stack);
    }
  };
});

// src/common/errors/errors-codes.ts
var ERROR_CODES, ERROR_NAMES;
var init_errors_codes = __esm(() => {
  ERROR_CODES = {
    GraphQLRequestError: "D100",
    UnknownDaggerError: "D101",
    TooManyNestedObjectsError: "D102",
    EngineSessionConnectParamsParseError: "D103",
    EngineSessionConnectionTimeoutError: "D104",
    EngineSessionError: "D105",
    InitEngineSessionBinaryError: "D106",
    DockerImageRefValidationError: "D107",
    NotAwaitedRequestError: "D108",
    ExecError: "D109",
    IntrospectionError: "D110"
  };
  ERROR_NAMES = Object.keys(ERROR_CODES).reduce((obj, item) => ({ ...obj, [item]: item }), {});
});

// src/common/errors/UnknownDaggerError.ts
var UnknownDaggerError;
var init_UnknownDaggerError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  UnknownDaggerError = class UnknownDaggerError extends DaggerSDKError {
    name = ERROR_NAMES.UnknownDaggerError;
    code = ERROR_CODES.UnknownDaggerError;
    constructor(message, options) {
      super(message, options);
    }
  };
});

// src/common/errors/DockerImageRefValidationError.ts
var DockerImageRefValidationError;
var init_DockerImageRefValidationError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  DockerImageRefValidationError = class DockerImageRefValidationError extends DaggerSDKError {
    name = ERROR_NAMES.DockerImageRefValidationError;
    code = ERROR_CODES.DockerImageRefValidationError;
    ref;
    constructor(message, options) {
      super(message, options);
      this.ref = options?.ref;
    }
  };
});

// src/common/errors/EngineSessionConnectParamsParseError.ts
var EngineSessionConnectParamsParseError;
var init_EngineSessionConnectParamsParseError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  EngineSessionConnectParamsParseError = class EngineSessionConnectParamsParseError extends DaggerSDKError {
    name = ERROR_NAMES.EngineSessionConnectParamsParseError;
    code = ERROR_CODES.EngineSessionConnectParamsParseError;
    parsedLine;
    constructor(message, options) {
      super(message, options);
      this.parsedLine = options.parsedLine;
    }
  };
});

// src/common/errors/ExecError.ts
var ExecError;
var init_ExecError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  ExecError = class ExecError extends DaggerSDKError {
    name = ERROR_NAMES.ExecError;
    code = ERROR_CODES.ExecError;
    cmd;
    exitCode;
    stdout;
    stderr;
    extensions;
    constructor(message, options) {
      super(message, options);
      this.cmd = options.cmd;
      this.exitCode = options.exitCode;
      this.stdout = options.stdout;
      this.stderr = options.stderr;
      this.extensions = options.extensions;
    }
  };
});

// src/common/errors/GraphQLRequestError.ts
var GraphQLRequestError;
var init_GraphQLRequestError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  GraphQLRequestError = class GraphQLRequestError extends DaggerSDKError {
    name = ERROR_NAMES.GraphQLRequestError;
    code = ERROR_CODES.GraphQLRequestError;
    requestContext;
    response;
    extensions;
    constructor(message, options) {
      super(message, options);
      this.requestContext = options.error.request;
      this.response = options.error.response;
      this.extensions = options.error.response.errors?.[0]?.extensions;
    }
  };
});

// src/common/errors/InitEngineSessionBinaryError.ts
var InitEngineSessionBinaryError;
var init_InitEngineSessionBinaryError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  InitEngineSessionBinaryError = class InitEngineSessionBinaryError extends DaggerSDKError {
    name = ERROR_NAMES.InitEngineSessionBinaryError;
    code = ERROR_CODES.InitEngineSessionBinaryError;
    constructor(message, options) {
      super(message, options);
    }
  };
});

// src/common/errors/TooManyNestedObjectsError.ts
var TooManyNestedObjectsError;
var init_TooManyNestedObjectsError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  TooManyNestedObjectsError = class TooManyNestedObjectsError extends DaggerSDKError {
    name = ERROR_NAMES.TooManyNestedObjectsError;
    code = ERROR_CODES.TooManyNestedObjectsError;
    response;
    constructor(message, options) {
      super(message, options);
      this.response = options.response;
    }
  };
});

// src/common/errors/EngineSessionErrorOptions.ts
var EngineSessionError;
var init_EngineSessionErrorOptions = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  EngineSessionError = class EngineSessionError extends DaggerSDKError {
    name = ERROR_NAMES.EngineSessionError;
    code = ERROR_CODES.EngineSessionError;
    constructor(message, options) {
      super(message, options);
    }
  };
});

// src/common/errors/EngineSessionConnectionTimeoutError.ts
var EngineSessionConnectionTimeoutError;
var init_EngineSessionConnectionTimeoutError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  EngineSessionConnectionTimeoutError = class EngineSessionConnectionTimeoutError extends DaggerSDKError {
    name = ERROR_NAMES.EngineSessionConnectionTimeoutError;
    code = ERROR_CODES.EngineSessionConnectionTimeoutError;
    timeOutDuration;
    constructor(message, options) {
      super(message, options);
      this.timeOutDuration = options.timeOutDuration;
    }
  };
});

// src/common/errors/NotAwaitedRequestError.ts
var NotAwaitedRequestError;
var init_NotAwaitedRequestError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  NotAwaitedRequestError = class NotAwaitedRequestError extends DaggerSDKError {
    name = ERROR_NAMES.NotAwaitedRequestError;
    code = ERROR_CODES.NotAwaitedRequestError;
    constructor(message, options) {
      super(message, options);
    }
  };
});

// src/common/errors/FunctionNotFound.ts
var FunctionNotFound;
var init_FunctionNotFound = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  FunctionNotFound = class FunctionNotFound extends DaggerSDKError {
    name = ERROR_NAMES.ExecError;
    code = ERROR_CODES.ExecError;
    constructor(message, options) {
      super(message, options);
    }
  };
});

// src/common/errors/IntrospectionError.ts
var IntrospectionError;
var init_IntrospectionError = __esm(() => {
  init_DaggerSDKError();
  init_errors_codes();
  IntrospectionError = class IntrospectionError extends DaggerSDKError {
    name = ERROR_NAMES.IntrospectionError;
    code = ERROR_CODES.IntrospectionError;
    constructor(message, options) {
      super(message, options);
    }
  };
});

// src/common/errors/index.ts
var init_errors = __esm(() => {
  init_DaggerSDKError();
  init_UnknownDaggerError();
  init_DockerImageRefValidationError();
  init_EngineSessionConnectParamsParseError();
  init_ExecError();
  init_GraphQLRequestError();
  init_InitEngineSessionBinaryError();
  init_TooManyNestedObjectsError();
  init_EngineSessionErrorOptions();
  init_EngineSessionConnectionTimeoutError();
  init_NotAwaitedRequestError();
  init_FunctionNotFound();
  init_IntrospectionError();
  init_errors_codes();
});

// node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type2 = meta[0] || "text/plain";
  let typeFull = type2;
  for (let i = 1;i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else if (meta[i]) {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type2;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default;
var init_dist = __esm(() => {
  dist_default = dataUriToBuffer;
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
  })(exports, function(exports2) {
    function noop() {
      return;
    }
    function typeIsObject(x) {
      return typeof x === "object" && x !== null || typeof x === "function";
    }
    const rethrowAssertionErrorRejection = noop;
    function setFunctionName(fn, name) {
      try {
        Object.defineProperty(fn, "name", {
          value: name,
          configurable: true
        });
      } catch (_a2) {
      }
    }
    const originalPromise = Promise;
    const originalPromiseThen = Promise.prototype.then;
    const originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
      return new originalPromise(executor);
    }
    function promiseResolvedWith(value) {
      return newPromise((resolve) => resolve(value));
    }
    function promiseRejectedWith(reason) {
      return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
      return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    function uponPromise(promise, onFulfilled, onRejected) {
      PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
      uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
      uponPromise(promise, undefined, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
      return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
      PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
    }
    let _queueMicrotask = (callback) => {
      if (typeof queueMicrotask === "function") {
        _queueMicrotask = queueMicrotask;
      } else {
        const resolvedPromise = promiseResolvedWith(undefined);
        _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
      }
      return _queueMicrotask(callback);
    };
    function reflectCall(F, V, args) {
      if (typeof F !== "function") {
        throw new TypeError("Argument is not a function");
      }
      return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
      try {
        return promiseResolvedWith(reflectCall(F, V, args));
      } catch (value) {
        return promiseRejectedWith(value);
      }
    }
    const QUEUE_MAX_ARRAY_SIZE = 16384;

    class SimpleQueue {
      constructor() {
        this._cursor = 0;
        this._size = 0;
        this._front = {
          _elements: [],
          _next: undefined
        };
        this._back = this._front;
        this._cursor = 0;
        this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(element) {
        const oldBack = this._back;
        let newBack = oldBack;
        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
          newBack = {
            _elements: [],
            _next: undefined
          };
        }
        oldBack._elements.push(element);
        if (newBack !== oldBack) {
          this._back = newBack;
          oldBack._next = newBack;
        }
        ++this._size;
      }
      shift() {
        const oldFront = this._front;
        let newFront = oldFront;
        const oldCursor = this._cursor;
        let newCursor = oldCursor + 1;
        const elements = oldFront._elements;
        const element = elements[oldCursor];
        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
          newFront = oldFront._next;
          newCursor = 0;
        }
        --this._size;
        this._cursor = newCursor;
        if (oldFront !== newFront) {
          this._front = newFront;
        }
        elements[oldCursor] = undefined;
        return element;
      }
      forEach(callback) {
        let i = this._cursor;
        let node2 = this._front;
        let elements = node2._elements;
        while (i !== elements.length || node2._next !== undefined) {
          if (i === elements.length) {
            node2 = node2._next;
            elements = node2._elements;
            i = 0;
            if (elements.length === 0) {
              break;
            }
          }
          callback(elements[i]);
          ++i;
        }
      }
      peek() {
        const front = this._front;
        const cursor = this._cursor;
        return front._elements[cursor];
      }
    }
    const AbortSteps = Symbol("[[AbortSteps]]");
    const ErrorSteps = Symbol("[[ErrorSteps]]");
    const CancelSteps = Symbol("[[CancelSteps]]");
    const PullSteps = Symbol("[[PullSteps]]");
    const ReleaseSteps = Symbol("[[ReleaseSteps]]");
    function ReadableStreamReaderGenericInitialize(reader, stream) {
      reader._ownerReadableStream = stream;
      stream._reader = reader;
      if (stream._state === "readable") {
        defaultReaderClosedPromiseInitialize(reader);
      } else if (stream._state === "closed") {
        defaultReaderClosedPromiseInitializeAsResolved(reader);
      } else {
        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
      }
    }
    function ReadableStreamReaderGenericCancel(reader, reason) {
      const stream = reader._ownerReadableStream;
      return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
      const stream = reader._ownerReadableStream;
      if (stream._state === "readable") {
        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
      } else {
        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
      }
      stream._readableStreamController[ReleaseSteps]();
      stream._reader = undefined;
      reader._ownerReadableStream = undefined;
    }
    function readerLockException(name) {
      return new TypeError("Cannot " + name + " a stream using a released reader");
    }
    function defaultReaderClosedPromiseInitialize(reader) {
      reader._closedPromise = newPromise((resolve, reject) => {
        reader._closedPromise_resolve = resolve;
        reader._closedPromise_reject = reject;
      });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
      defaultReaderClosedPromiseInitialize(reader);
      defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
      defaultReaderClosedPromiseInitialize(reader);
      defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
      if (reader._closedPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(reader._closedPromise);
      reader._closedPromise_reject(reason);
      reader._closedPromise_resolve = undefined;
      reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
      defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
      if (reader._closedPromise_resolve === undefined) {
        return;
      }
      reader._closedPromise_resolve(undefined);
      reader._closedPromise_resolve = undefined;
      reader._closedPromise_reject = undefined;
    }
    const NumberIsFinite = Number.isFinite || function(x) {
      return typeof x === "number" && isFinite(x);
    };
    const MathTrunc = Math.trunc || function(v) {
      return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
    function isDictionary(x) {
      return typeof x === "object" || typeof x === "function";
    }
    function assertDictionary(obj, context2) {
      if (obj !== undefined && !isDictionary(obj)) {
        throw new TypeError(`${context2} is not an object.`);
      }
    }
    function assertFunction(x, context2) {
      if (typeof x !== "function") {
        throw new TypeError(`${context2} is not a function.`);
      }
    }
    function isObject(x) {
      return typeof x === "object" && x !== null || typeof x === "function";
    }
    function assertObject(x, context2) {
      if (!isObject(x)) {
        throw new TypeError(`${context2} is not an object.`);
      }
    }
    function assertRequiredArgument(x, position2, context2) {
      if (x === undefined) {
        throw new TypeError(`Parameter ${position2} is required in '${context2}'.`);
      }
    }
    function assertRequiredField(x, field, context2) {
      if (x === undefined) {
        throw new TypeError(`${field} is required in '${context2}'.`);
      }
    }
    function convertUnrestrictedDouble(value) {
      return Number(value);
    }
    function censorNegativeZero(x) {
      return x === 0 ? 0 : x;
    }
    function integerPart(x) {
      return censorNegativeZero(MathTrunc(x));
    }
    function convertUnsignedLongLongWithEnforceRange(value, context2) {
      const lowerBound = 0;
      const upperBound = Number.MAX_SAFE_INTEGER;
      let x = Number(value);
      x = censorNegativeZero(x);
      if (!NumberIsFinite(x)) {
        throw new TypeError(`${context2} is not a finite number`);
      }
      x = integerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw new TypeError(`${context2} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
      }
      if (!NumberIsFinite(x) || x === 0) {
        return 0;
      }
      return x;
    }
    function assertReadableStream(x, context2) {
      if (!IsReadableStream(x)) {
        throw new TypeError(`${context2} is not a ReadableStream.`);
      }
    }
    function AcquireReadableStreamDefaultReader(stream) {
      return new ReadableStreamDefaultReader(stream);
    }
    function ReadableStreamAddReadRequest(stream, readRequest) {
      stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
      const reader = stream._reader;
      const readRequest = reader._readRequests.shift();
      if (done) {
        readRequest._closeSteps();
      } else {
        readRequest._chunkSteps(chunk);
      }
    }
    function ReadableStreamGetNumReadRequests(stream) {
      return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
      const reader = stream._reader;
      if (reader === undefined) {
        return false;
      }
      if (!IsReadableStreamDefaultReader(reader)) {
        return false;
      }
      return true;
    }

    class ReadableStreamDefaultReader {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readRequests = new SimpleQueue;
      }
      get closed() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      cancel(reason = undefined) {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      }
      read() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("read"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        let resolvePromise;
        let rejectPromise;
        const promise = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readRequest = {
          _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
          _closeSteps: () => resolvePromise({ value: undefined, done: true }),
          _errorSteps: (e) => rejectPromise(e)
        };
        ReadableStreamDefaultReaderRead(this, readRequest);
        return promise;
      }
      releaseLock() {
        if (!IsReadableStreamDefaultReader(this)) {
          throw defaultReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === undefined) {
          return;
        }
        ReadableStreamDefaultReaderRelease(this);
      }
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
    setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: true
      });
    }
    function IsReadableStreamDefaultReader(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
        return false;
      }
      return x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
      const stream = reader._ownerReadableStream;
      stream._disturbed = true;
      if (stream._state === "closed") {
        readRequest._closeSteps();
      } else if (stream._state === "errored") {
        readRequest._errorSteps(stream._storedError);
      } else {
        stream._readableStreamController[PullSteps](readRequest);
      }
    }
    function ReadableStreamDefaultReaderRelease(reader) {
      ReadableStreamReaderGenericRelease(reader);
      const e = new TypeError("Reader was released");
      ReadableStreamDefaultReaderErrorReadRequests(reader, e);
    }
    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
      const readRequests = reader._readRequests;
      reader._readRequests = new SimpleQueue;
      readRequests.forEach((readRequest) => {
        readRequest._errorSteps(e);
      });
    }
    function defaultReaderBrandCheckException(name) {
      return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);

    class ReadableStreamAsyncIteratorImpl {
      constructor(reader, preventCancel) {
        this._ongoingPromise = undefined;
        this._isFinished = false;
        this._reader = reader;
        this._preventCancel = preventCancel;
      }
      next() {
        const nextSteps = () => this._nextSteps();
        this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
        return this._ongoingPromise;
      }
      return(value) {
        const returnSteps = () => this._returnSteps(value);
        return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
      }
      _nextSteps() {
        if (this._isFinished) {
          return Promise.resolve({ value: undefined, done: true });
        }
        const reader = this._reader;
        let resolvePromise;
        let rejectPromise;
        const promise = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readRequest = {
          _chunkSteps: (chunk) => {
            this._ongoingPromise = undefined;
            _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
          },
          _closeSteps: () => {
            this._ongoingPromise = undefined;
            this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            resolvePromise({ value: undefined, done: true });
          },
          _errorSteps: (reason) => {
            this._ongoingPromise = undefined;
            this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            rejectPromise(reason);
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promise;
      }
      _returnSteps(value) {
        if (this._isFinished) {
          return Promise.resolve({ value, done: true });
        }
        this._isFinished = true;
        const reader = this._reader;
        if (!this._preventCancel) {
          const result = ReadableStreamReaderGenericCancel(reader, value);
          ReadableStreamReaderGenericRelease(reader);
          return transformPromiseWith(result, () => ({ value, done: true }));
        }
        ReadableStreamReaderGenericRelease(reader);
        return promiseResolvedWith({ value, done: true });
      }
    }
    const ReadableStreamAsyncIteratorPrototype = {
      next() {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        }
        return this._asyncIteratorImpl.next();
      },
      return(value) {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
        return this._asyncIteratorImpl.return(value);
      }
    };
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
      const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
      iterator._asyncIteratorImpl = impl;
      return iterator;
    }
    function IsReadableStreamAsyncIterator(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
        return false;
      }
      try {
        return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
      } catch (_a2) {
        return false;
      }
    }
    function streamAsyncIteratorBrandCheckException(name) {
      return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }
    const NumberIsNaN = Number.isNaN || function(x) {
      return x !== x;
    };
    var _a, _b, _c;
    function CreateArrayFromList(elements) {
      return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
      new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    let TransferArrayBuffer = (O) => {
      if (typeof O.transfer === "function") {
        TransferArrayBuffer = (buffer) => buffer.transfer();
      } else if (typeof structuredClone === "function") {
        TransferArrayBuffer = (buffer) => structuredClone(buffer, { transfer: [buffer] });
      } else {
        TransferArrayBuffer = (buffer) => buffer;
      }
      return TransferArrayBuffer(O);
    };
    let IsDetachedBuffer = (O) => {
      if (typeof O.detached === "boolean") {
        IsDetachedBuffer = (buffer) => buffer.detached;
      } else {
        IsDetachedBuffer = (buffer) => buffer.byteLength === 0;
      }
      return IsDetachedBuffer(O);
    };
    function ArrayBufferSlice(buffer, begin, end) {
      if (buffer.slice) {
        return buffer.slice(begin, end);
      }
      const length = end - begin;
      const slice = new ArrayBuffer(length);
      CopyDataBlockBytes(slice, 0, buffer, begin, length);
      return slice;
    }
    function GetMethod(receiver, prop) {
      const func = receiver[prop];
      if (func === undefined || func === null) {
        return;
      }
      if (typeof func !== "function") {
        throw new TypeError(`${String(prop)} is not a function`);
      }
      return func;
    }
    function CreateAsyncFromSyncIterator(syncIteratorRecord) {
      const syncIterable = {
        [Symbol.iterator]: () => syncIteratorRecord.iterator
      };
      const asyncIterator = async function* () {
        return yield* syncIterable;
      }();
      const nextMethod = asyncIterator.next;
      return { iterator: asyncIterator, nextMethod, done: false };
    }
    const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== undefined ? _a : (_b = Symbol.for) === null || _b === undefined ? undefined : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== undefined ? _c : "@@asyncIterator";
    function GetIterator(obj, hint = "sync", method) {
      if (method === undefined) {
        if (hint === "async") {
          method = GetMethod(obj, SymbolAsyncIterator);
          if (method === undefined) {
            const syncMethod = GetMethod(obj, Symbol.iterator);
            const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
            return CreateAsyncFromSyncIterator(syncIteratorRecord);
          }
        } else {
          method = GetMethod(obj, Symbol.iterator);
        }
      }
      if (method === undefined) {
        throw new TypeError("The object is not iterable");
      }
      const iterator = reflectCall(method, obj, []);
      if (!typeIsObject(iterator)) {
        throw new TypeError("The iterator method must return an object");
      }
      const nextMethod = iterator.next;
      return { iterator, nextMethod, done: false };
    }
    function IteratorNext(iteratorRecord) {
      const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
      if (!typeIsObject(result)) {
        throw new TypeError("The iterator.next() method must return an object");
      }
      return result;
    }
    function IteratorComplete(iterResult) {
      return Boolean(iterResult.done);
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IsNonNegativeNumber(v) {
      if (typeof v !== "number") {
        return false;
      }
      if (NumberIsNaN(v)) {
        return false;
      }
      if (v < 0) {
        return false;
      }
      return true;
    }
    function CloneAsUint8Array(O) {
      const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
      return new Uint8Array(buffer);
    }
    function DequeueValue(container) {
      const pair = container._queue.shift();
      container._queueTotalSize -= pair.size;
      if (container._queueTotalSize < 0) {
        container._queueTotalSize = 0;
      }
      return pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
      if (!IsNonNegativeNumber(size) || size === Infinity) {
        throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
      }
      container._queue.push({ value, size });
      container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
      const pair = container._queue.peek();
      return pair.value;
    }
    function ResetQueue(container) {
      container._queue = new SimpleQueue;
      container._queueTotalSize = 0;
    }
    function isDataViewConstructor(ctor) {
      return ctor === DataView;
    }
    function isDataView(view) {
      return isDataViewConstructor(view.constructor);
    }
    function arrayBufferViewElementSize(ctor) {
      if (isDataViewConstructor(ctor)) {
        return 1;
      }
      return ctor.BYTES_PER_ELEMENT;
    }

    class ReadableStreamBYOBRequest {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("view");
        }
        return this._view;
      }
      respond(bytesWritten) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respond");
        }
        assertRequiredArgument(bytesWritten, 1, "respond");
        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(this._view.buffer)) {
          throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
        }
        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
      }
      respondWithNewView(view) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respondWithNewView");
        }
        assertRequiredArgument(view, 1, "respondWithNewView");
        if (!ArrayBuffer.isView(view)) {
          throw new TypeError("You can only respond with array buffer views");
        }
        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(view.buffer)) {
          throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
        }
        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
      }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
      respond: { enumerable: true },
      respondWithNewView: { enumerable: true },
      view: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
    setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: true
      });
    }

    class ReadableByteStreamController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("byobRequest");
        }
        return ReadableByteStreamControllerGetBYOBRequest(this);
      }
      get desiredSize() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("desiredSize");
        }
        return ReadableByteStreamControllerGetDesiredSize(this);
      }
      close() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("close");
        }
        if (this._closeRequested) {
          throw new TypeError("The stream has already been closed; do not close it again!");
        }
        const state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
        }
        ReadableByteStreamControllerClose(this);
      }
      enqueue(chunk) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("enqueue");
        }
        assertRequiredArgument(chunk, 1, "enqueue");
        if (!ArrayBuffer.isView(chunk)) {
          throw new TypeError("chunk must be an array buffer view");
        }
        if (chunk.byteLength === 0) {
          throw new TypeError("chunk must have non-zero byteLength");
        }
        if (chunk.buffer.byteLength === 0) {
          throw new TypeError(`chunk's buffer must have non-zero byteLength`);
        }
        if (this._closeRequested) {
          throw new TypeError("stream is closed or draining");
        }
        const state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
        }
        ReadableByteStreamControllerEnqueue(this, chunk);
      }
      error(e = undefined) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("error");
        }
        ReadableByteStreamControllerError(this, e);
      }
      [CancelSteps](reason) {
        ReadableByteStreamControllerClearPendingPullIntos(this);
        ResetQueue(this);
        const result = this._cancelAlgorithm(reason);
        ReadableByteStreamControllerClearAlgorithms(this);
        return result;
      }
      [PullSteps](readRequest) {
        const stream = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
          return;
        }
        const autoAllocateChunkSize = this._autoAllocateChunkSize;
        if (autoAllocateChunkSize !== undefined) {
          let buffer;
          try {
            buffer = new ArrayBuffer(autoAllocateChunkSize);
          } catch (bufferE) {
            readRequest._errorSteps(bufferE);
            return;
          }
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: autoAllocateChunkSize,
            byteOffset: 0,
            byteLength: autoAllocateChunkSize,
            bytesFilled: 0,
            minimumFill: 1,
            elementSize: 1,
            viewConstructor: Uint8Array,
            readerType: "default"
          };
          this._pendingPullIntos.push(pullIntoDescriptor);
        }
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableByteStreamControllerCallPullIfNeeded(this);
      }
      [ReleaseSteps]() {
        if (this._pendingPullIntos.length > 0) {
          const firstPullInto = this._pendingPullIntos.peek();
          firstPullInto.readerType = "none";
          this._pendingPullIntos = new SimpleQueue;
          this._pendingPullIntos.push(firstPullInto);
        }
      }
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      byobRequest: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableByteStreamController.prototype.close, "close");
    setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
    setFunctionName(ReadableByteStreamController.prototype.error, "error");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: true
      });
    }
    function IsReadableByteStreamController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
        return false;
      }
      return x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
        return false;
      }
      return x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
      const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
      if (!shouldPull) {
        return;
      }
      if (controller._pulling) {
        controller._pullAgain = true;
        return;
      }
      controller._pulling = true;
      const pullPromise = controller._pullAlgorithm();
      uponPromise(pullPromise, () => {
        controller._pulling = false;
        if (controller._pullAgain) {
          controller._pullAgain = false;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        return null;
      }, (e) => {
        ReadableByteStreamControllerError(controller, e);
        return null;
      });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
      ReadableByteStreamControllerInvalidateBYOBRequest(controller);
      controller._pendingPullIntos = new SimpleQueue;
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
      let done = false;
      if (stream._state === "closed") {
        done = true;
      }
      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
      if (pullIntoDescriptor.readerType === "default") {
        ReadableStreamFulfillReadRequest(stream, filledView, done);
      } else {
        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
      }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
      const bytesFilled = pullIntoDescriptor.bytesFilled;
      const elementSize = pullIntoDescriptor.elementSize;
      return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
      controller._queue.push({ buffer, byteOffset, byteLength });
      controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
      let clonedChunk;
      try {
        clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
      } catch (cloneE) {
        ReadableByteStreamControllerError(controller, cloneE);
        throw cloneE;
      }
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
    }
    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
      if (firstDescriptor.bytesFilled > 0) {
        ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
      }
      ReadableByteStreamControllerShiftPendingPullInto(controller);
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
      const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
      const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
      let totalBytesToCopyRemaining = maxBytesToCopy;
      let ready = false;
      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
      const maxAlignedBytes = maxBytesFilled - remainderBytes;
      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
        ready = true;
      }
      const queue = controller._queue;
      while (totalBytesToCopyRemaining > 0) {
        const headOfQueue = queue.peek();
        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
        if (headOfQueue.byteLength === bytesToCopy) {
          queue.shift();
        } else {
          headOfQueue.byteOffset += bytesToCopy;
          headOfQueue.byteLength -= bytesToCopy;
        }
        controller._queueTotalSize -= bytesToCopy;
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
        totalBytesToCopyRemaining -= bytesToCopy;
      }
      return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
      pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
      if (controller._queueTotalSize === 0 && controller._closeRequested) {
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(controller._controlledReadableByteStream);
      } else {
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
      if (controller._byobRequest === null) {
        return;
      }
      controller._byobRequest._associatedReadableByteStreamController = undefined;
      controller._byobRequest._view = null;
      controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
      while (controller._pendingPullIntos.length > 0) {
        if (controller._queueTotalSize === 0) {
          return;
        }
        const pullIntoDescriptor = controller._pendingPullIntos.peek();
        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        }
      }
    }
    function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
      const reader = controller._controlledReadableByteStream._reader;
      while (reader._readRequests.length > 0) {
        if (controller._queueTotalSize === 0) {
          return;
        }
        const readRequest = reader._readRequests.shift();
        ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
      }
    }
    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
      const stream = controller._controlledReadableByteStream;
      const ctor = view.constructor;
      const elementSize = arrayBufferViewElementSize(ctor);
      const { byteOffset, byteLength } = view;
      const minimumFill = min * elementSize;
      let buffer;
      try {
        buffer = TransferArrayBuffer(view.buffer);
      } catch (e) {
        readIntoRequest._errorSteps(e);
        return;
      }
      const pullIntoDescriptor = {
        buffer,
        bufferByteLength: buffer.byteLength,
        byteOffset,
        byteLength,
        bytesFilled: 0,
        minimumFill,
        elementSize,
        viewConstructor: ctor,
        readerType: "byob"
      };
      if (controller._pendingPullIntos.length > 0) {
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        return;
      }
      if (stream._state === "closed") {
        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
        readIntoRequest._closeSteps(emptyView);
        return;
      }
      if (controller._queueTotalSize > 0) {
        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          ReadableByteStreamControllerHandleQueueDrain(controller);
          readIntoRequest._chunkSteps(filledView);
          return;
        }
        if (controller._closeRequested) {
          const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
          ReadableByteStreamControllerError(controller, e);
          readIntoRequest._errorSteps(e);
          return;
        }
      }
      controller._pendingPullIntos.push(pullIntoDescriptor);
      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
      if (firstDescriptor.readerType === "none") {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      const stream = controller._controlledReadableByteStream;
      if (ReadableStreamHasBYOBReader(stream)) {
        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
          ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
        }
      }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
      if (pullIntoDescriptor.readerType === "none") {
        ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        return;
      }
      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
        return;
      }
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
      if (remainderSize > 0) {
        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
        ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
      }
      pullIntoDescriptor.bytesFilled -= remainderSize;
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      ReadableByteStreamControllerInvalidateBYOBRequest(controller);
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
      } else {
        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
      }
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
      const descriptor = controller._pendingPullIntos.shift();
      return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
      const stream = controller._controlledReadableByteStream;
      if (stream._state !== "readable") {
        return false;
      }
      if (controller._closeRequested) {
        return false;
      }
      if (!controller._started) {
        return false;
      }
      if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        return true;
      }
      if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
        return true;
      }
      const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
      if (desiredSize > 0) {
        return true;
      }
      return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
      controller._pullAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
    }
    function ReadableByteStreamControllerClose(controller) {
      const stream = controller._controlledReadableByteStream;
      if (controller._closeRequested || stream._state !== "readable") {
        return;
      }
      if (controller._queueTotalSize > 0) {
        controller._closeRequested = true;
        return;
      }
      if (controller._pendingPullIntos.length > 0) {
        const firstPendingPullInto = controller._pendingPullIntos.peek();
        if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
          const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
          ReadableByteStreamControllerError(controller, e);
          throw e;
        }
      }
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
      const stream = controller._controlledReadableByteStream;
      if (controller._closeRequested || stream._state !== "readable") {
        return;
      }
      const { buffer, byteOffset, byteLength } = chunk;
      if (IsDetachedBuffer(buffer)) {
        throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
      }
      const transferredBuffer = TransferArrayBuffer(buffer);
      if (controller._pendingPullIntos.length > 0) {
        const firstPendingPullInto = controller._pendingPullIntos.peek();
        if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
          throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        if (firstPendingPullInto.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
        }
      }
      if (ReadableStreamHasDefaultReader(stream)) {
        ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
        if (ReadableStreamGetNumReadRequests(stream) === 0) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        } else {
          if (controller._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
          }
          const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
          ReadableStreamFulfillReadRequest(stream, transferredView, false);
        }
      } else if (ReadableStreamHasBYOBReader(stream)) {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      } else {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      }
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
      const stream = controller._controlledReadableByteStream;
      if (stream._state !== "readable") {
        return;
      }
      ReadableByteStreamControllerClearPendingPullIntos(controller);
      ResetQueue(controller);
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamError(stream, e);
    }
    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
      const entry = controller._queue.shift();
      controller._queueTotalSize -= entry.byteLength;
      ReadableByteStreamControllerHandleQueueDrain(controller);
      const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
      readRequest._chunkSteps(view);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
      if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
        const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
        SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
        controller._byobRequest = byobRequest;
      }
      return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
      const state = controller._controlledReadableByteStream._state;
      if (state === "errored") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        if (bytesWritten !== 0) {
          throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        }
      } else {
        if (bytesWritten === 0) {
          throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
        }
        if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
          throw new RangeError("bytesWritten out of range");
        }
      }
      firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
      ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        if (view.byteLength !== 0) {
          throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        }
      } else {
        if (view.byteLength === 0) {
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        }
      }
      if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
        throw new RangeError("The region specified by view does not match byobRequest");
      }
      if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
        throw new RangeError("The buffer of view has different capacity than byobRequest");
      }
      if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
        throw new RangeError("The region specified by view is larger than byobRequest");
      }
      const viewByteLength = view.byteLength;
      firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
      ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
      controller._controlledReadableByteStream = stream;
      controller._pullAgain = false;
      controller._pulling = false;
      controller._byobRequest = null;
      controller._queue = controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._closeRequested = false;
      controller._started = false;
      controller._strategyHWM = highWaterMark;
      controller._pullAlgorithm = pullAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      controller._autoAllocateChunkSize = autoAllocateChunkSize;
      controller._pendingPullIntos = new SimpleQueue;
      stream._readableStreamController = controller;
      const startResult = startAlgorithm();
      uponPromise(promiseResolvedWith(startResult), () => {
        controller._started = true;
        ReadableByteStreamControllerCallPullIfNeeded(controller);
        return null;
      }, (r) => {
        ReadableByteStreamControllerError(controller, r);
        return null;
      });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
      const controller = Object.create(ReadableByteStreamController.prototype);
      let startAlgorithm;
      let pullAlgorithm;
      let cancelAlgorithm;
      if (underlyingByteSource.start !== undefined) {
        startAlgorithm = () => underlyingByteSource.start(controller);
      } else {
        startAlgorithm = () => {
          return;
        };
      }
      if (underlyingByteSource.pull !== undefined) {
        pullAlgorithm = () => underlyingByteSource.pull(controller);
      } else {
        pullAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingByteSource.cancel !== undefined) {
        cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
      } else {
        cancelAlgorithm = () => promiseResolvedWith(undefined);
      }
      const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
      if (autoAllocateChunkSize === 0) {
        throw new TypeError("autoAllocateChunkSize must be greater than 0");
      }
      SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request2, controller, view) {
      request2._associatedReadableByteStreamController = controller;
      request2._view = view;
    }
    function byobRequestBrandCheckException(name) {
      return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    function byteStreamControllerBrandCheckException(name) {
      return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }
    function convertReaderOptions(options, context2) {
      assertDictionary(options, context2);
      const mode = options === null || options === undefined ? undefined : options.mode;
      return {
        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context2} has member 'mode' that`)
      };
    }
    function convertReadableStreamReaderMode(mode, context2) {
      mode = `${mode}`;
      if (mode !== "byob") {
        throw new TypeError(`${context2} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
      }
      return mode;
    }
    function convertByobReadOptions(options, context2) {
      var _a2;
      assertDictionary(options, context2);
      const min = (_a2 = options === null || options === undefined ? undefined : options.min) !== null && _a2 !== undefined ? _a2 : 1;
      return {
        min: convertUnsignedLongLongWithEnforceRange(min, `${context2} has member 'min' that`)
      };
    }
    function AcquireReadableStreamBYOBReader(stream) {
      return new ReadableStreamBYOBReader(stream);
    }
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
      stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
      const reader = stream._reader;
      const readIntoRequest = reader._readIntoRequests.shift();
      if (done) {
        readIntoRequest._closeSteps(chunk);
      } else {
        readIntoRequest._chunkSteps(chunk);
      }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
      return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
      const reader = stream._reader;
      if (reader === undefined) {
        return false;
      }
      if (!IsReadableStreamBYOBReader(reader)) {
        return false;
      }
      return true;
    }

    class ReadableStreamBYOBReader {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        if (!IsReadableByteStreamController(stream._readableStreamController)) {
          throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte " + "source");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readIntoRequests = new SimpleQueue;
      }
      get closed() {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      cancel(reason = undefined) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      }
      read(view, rawOptions = {}) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("read"));
        }
        if (!ArrayBuffer.isView(view)) {
          return promiseRejectedWith(new TypeError("view must be an array buffer view"));
        }
        if (view.byteLength === 0) {
          return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
        }
        if (view.buffer.byteLength === 0) {
          return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
        }
        if (IsDetachedBuffer(view.buffer)) {
          return promiseRejectedWith(new TypeError("view's buffer has been detached"));
        }
        let options;
        try {
          options = convertByobReadOptions(rawOptions, "options");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        const min = options.min;
        if (min === 0) {
          return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
        }
        if (!isDataView(view)) {
          if (min > view.length) {
            return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
          }
        } else if (min > view.byteLength) {
          return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        let resolvePromise;
        let rejectPromise;
        const promise = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readIntoRequest = {
          _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
          _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
          _errorSteps: (e) => rejectPromise(e)
        };
        ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
        return promise;
      }
      releaseLock() {
        if (!IsReadableStreamBYOBReader(this)) {
          throw byobReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === undefined) {
          return;
        }
        ReadableStreamBYOBReaderRelease(this);
      }
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
    setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: true
      });
    }
    function IsReadableStreamBYOBReader(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
        return false;
      }
      return x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
      const stream = reader._ownerReadableStream;
      stream._disturbed = true;
      if (stream._state === "errored") {
        readIntoRequest._errorSteps(stream._storedError);
      } else {
        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
      }
    }
    function ReadableStreamBYOBReaderRelease(reader) {
      ReadableStreamReaderGenericRelease(reader);
      const e = new TypeError("Reader was released");
      ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
    }
    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
      const readIntoRequests = reader._readIntoRequests;
      reader._readIntoRequests = new SimpleQueue;
      readIntoRequests.forEach((readIntoRequest) => {
        readIntoRequest._errorSteps(e);
      });
    }
    function byobReaderBrandCheckException(name) {
      return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }
    function ExtractHighWaterMark(strategy, defaultHWM) {
      const { highWaterMark } = strategy;
      if (highWaterMark === undefined) {
        return defaultHWM;
      }
      if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
        throw new RangeError("Invalid highWaterMark");
      }
      return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
      const { size } = strategy;
      if (!size) {
        return () => 1;
      }
      return size;
    }
    function convertQueuingStrategy(init, context2) {
      assertDictionary(init, context2);
      const highWaterMark = init === null || init === undefined ? undefined : init.highWaterMark;
      const size = init === null || init === undefined ? undefined : init.size;
      return {
        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context2} has member 'size' that`)
      };
    }
    function convertQueuingStrategySize(fn, context2) {
      assertFunction(fn, context2);
      return (chunk) => convertUnrestrictedDouble(fn(chunk));
    }
    function convertUnderlyingSink(original, context2) {
      assertDictionary(original, context2);
      const abort = original === null || original === undefined ? undefined : original.abort;
      const close2 = original === null || original === undefined ? undefined : original.close;
      const start = original === null || original === undefined ? undefined : original.start;
      const type2 = original === null || original === undefined ? undefined : original.type;
      const write = original === null || original === undefined ? undefined : original.write;
      return {
        abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context2} has member 'abort' that`),
        close: close2 === undefined ? undefined : convertUnderlyingSinkCloseCallback(close2, original, `${context2} has member 'close' that`),
        start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context2} has member 'start' that`),
        write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context2} has member 'write' that`),
        type: type2
      };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }
    function assertWritableStream(x, context2) {
      if (!IsWritableStream(x)) {
        throw new TypeError(`${context2} is not a WritableStream.`);
      }
    }
    function isAbortSignal(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      try {
        return typeof value.aborted === "boolean";
      } catch (_a2) {
        return false;
      }
    }
    const supportsAbortController = typeof AbortController === "function";
    function createAbortController() {
      if (supportsAbortController) {
        return new AbortController;
      }
      return;
    }

    class WritableStream {
      constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
        if (rawUnderlyingSink === undefined) {
          rawUnderlyingSink = null;
        } else {
          assertObject(rawUnderlyingSink, "First parameter");
        }
        const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
        InitializeWritableStream(this);
        const type2 = underlyingSink.type;
        if (type2 !== undefined) {
          throw new RangeError("Invalid type is specified");
        }
        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        const highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
      }
      get locked() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("locked");
        }
        return IsWritableStreamLocked(this);
      }
      abort(reason = undefined) {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("abort"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
        }
        return WritableStreamAbort(this, reason);
      }
      close() {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("close"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
        }
        if (WritableStreamCloseQueuedOrInFlight(this)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamClose(this);
      }
      getWriter() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("getWriter");
        }
        return AcquireWritableStreamDefaultWriter(this);
      }
    }
    Object.defineProperties(WritableStream.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      getWriter: { enumerable: true },
      locked: { enumerable: true }
    });
    setFunctionName(WritableStream.prototype.abort, "abort");
    setFunctionName(WritableStream.prototype.close, "close");
    setFunctionName(WritableStream.prototype.getWriter, "getWriter");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
        value: "WritableStream",
        configurable: true
      });
    }
    function AcquireWritableStreamDefaultWriter(stream) {
      return new WritableStreamDefaultWriter(stream);
    }
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
      const stream = Object.create(WritableStream.prototype);
      InitializeWritableStream(stream);
      const controller = Object.create(WritableStreamDefaultController.prototype);
      SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      return stream;
    }
    function InitializeWritableStream(stream) {
      stream._state = "writable";
      stream._storedError = undefined;
      stream._writer = undefined;
      stream._writableStreamController = undefined;
      stream._writeRequests = new SimpleQueue;
      stream._inFlightWriteRequest = undefined;
      stream._closeRequest = undefined;
      stream._inFlightCloseRequest = undefined;
      stream._pendingAbortRequest = undefined;
      stream._backpressure = false;
    }
    function IsWritableStream(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
        return false;
      }
      return x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
      if (stream._writer === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamAbort(stream, reason) {
      var _a2;
      if (stream._state === "closed" || stream._state === "errored") {
        return promiseResolvedWith(undefined);
      }
      stream._writableStreamController._abortReason = reason;
      (_a2 = stream._writableStreamController._abortController) === null || _a2 === undefined || _a2.abort(reason);
      const state = stream._state;
      if (state === "closed" || state === "errored") {
        return promiseResolvedWith(undefined);
      }
      if (stream._pendingAbortRequest !== undefined) {
        return stream._pendingAbortRequest._promise;
      }
      let wasAlreadyErroring = false;
      if (state === "erroring") {
        wasAlreadyErroring = true;
        reason = undefined;
      }
      const promise = newPromise((resolve, reject) => {
        stream._pendingAbortRequest = {
          _promise: undefined,
          _resolve: resolve,
          _reject: reject,
          _reason: reason,
          _wasAlreadyErroring: wasAlreadyErroring
        };
      });
      stream._pendingAbortRequest._promise = promise;
      if (!wasAlreadyErroring) {
        WritableStreamStartErroring(stream, reason);
      }
      return promise;
    }
    function WritableStreamClose(stream) {
      const state = stream._state;
      if (state === "closed" || state === "errored") {
        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
      }
      const promise = newPromise((resolve, reject) => {
        const closeRequest = {
          _resolve: resolve,
          _reject: reject
        };
        stream._closeRequest = closeRequest;
      });
      const writer = stream._writer;
      if (writer !== undefined && stream._backpressure && state === "writable") {
        defaultWriterReadyPromiseResolve(writer);
      }
      WritableStreamDefaultControllerClose(stream._writableStreamController);
      return promise;
    }
    function WritableStreamAddWriteRequest(stream) {
      const promise = newPromise((resolve, reject) => {
        const writeRequest = {
          _resolve: resolve,
          _reject: reject
        };
        stream._writeRequests.push(writeRequest);
      });
      return promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
      const state = stream._state;
      if (state === "writable") {
        WritableStreamStartErroring(stream, error);
        return;
      }
      WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
      const controller = stream._writableStreamController;
      stream._state = "erroring";
      stream._storedError = reason;
      const writer = stream._writer;
      if (writer !== undefined) {
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
      }
      if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
        WritableStreamFinishErroring(stream);
      }
    }
    function WritableStreamFinishErroring(stream) {
      stream._state = "errored";
      stream._writableStreamController[ErrorSteps]();
      const storedError = stream._storedError;
      stream._writeRequests.forEach((writeRequest) => {
        writeRequest._reject(storedError);
      });
      stream._writeRequests = new SimpleQueue;
      if (stream._pendingAbortRequest === undefined) {
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return;
      }
      const abortRequest = stream._pendingAbortRequest;
      stream._pendingAbortRequest = undefined;
      if (abortRequest._wasAlreadyErroring) {
        abortRequest._reject(storedError);
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return;
      }
      const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
      uponPromise(promise, () => {
        abortRequest._resolve();
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return null;
      }, (reason) => {
        abortRequest._reject(reason);
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return null;
      });
    }
    function WritableStreamFinishInFlightWrite(stream) {
      stream._inFlightWriteRequest._resolve(undefined);
      stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error) {
      stream._inFlightWriteRequest._reject(error);
      stream._inFlightWriteRequest = undefined;
      WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamFinishInFlightClose(stream) {
      stream._inFlightCloseRequest._resolve(undefined);
      stream._inFlightCloseRequest = undefined;
      const state = stream._state;
      if (state === "erroring") {
        stream._storedError = undefined;
        if (stream._pendingAbortRequest !== undefined) {
          stream._pendingAbortRequest._resolve();
          stream._pendingAbortRequest = undefined;
        }
      }
      stream._state = "closed";
      const writer = stream._writer;
      if (writer !== undefined) {
        defaultWriterClosedPromiseResolve(writer);
      }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error) {
      stream._inFlightCloseRequest._reject(error);
      stream._inFlightCloseRequest = undefined;
      if (stream._pendingAbortRequest !== undefined) {
        stream._pendingAbortRequest._reject(error);
        stream._pendingAbortRequest = undefined;
      }
      WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamCloseQueuedOrInFlight(stream) {
      if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
      if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
      stream._inFlightCloseRequest = stream._closeRequest;
      stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
      stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
      if (stream._closeRequest !== undefined) {
        stream._closeRequest._reject(stream._storedError);
        stream._closeRequest = undefined;
      }
      const writer = stream._writer;
      if (writer !== undefined) {
        defaultWriterClosedPromiseReject(writer, stream._storedError);
      }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
      const writer = stream._writer;
      if (writer !== undefined && backpressure !== stream._backpressure) {
        if (backpressure) {
          defaultWriterReadyPromiseReset(writer);
        } else {
          defaultWriterReadyPromiseResolve(writer);
        }
      }
      stream._backpressure = backpressure;
    }

    class WritableStreamDefaultWriter {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
        assertWritableStream(stream, "First parameter");
        if (IsWritableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        }
        this._ownerWritableStream = stream;
        stream._writer = this;
        const state = stream._state;
        if (state === "writable") {
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
            defaultWriterReadyPromiseInitialize(this);
          } else {
            defaultWriterReadyPromiseInitializeAsResolved(this);
          }
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "erroring") {
          defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "closed") {
          defaultWriterReadyPromiseInitializeAsResolved(this);
          defaultWriterClosedPromiseInitializeAsResolved(this);
        } else {
          const storedError = stream._storedError;
          defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
          defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
        }
      }
      get closed() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      get desiredSize() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("desiredSize");
        }
        if (this._ownerWritableStream === undefined) {
          throw defaultWriterLockException("desiredSize");
        }
        return WritableStreamDefaultWriterGetDesiredSize(this);
      }
      get ready() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
        }
        return this._readyPromise;
      }
      abort(reason = undefined) {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
        }
        if (this._ownerWritableStream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("abort"));
        }
        return WritableStreamDefaultWriterAbort(this, reason);
      }
      close() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("close"));
        }
        const stream = this._ownerWritableStream;
        if (stream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("close"));
        }
        if (WritableStreamCloseQueuedOrInFlight(stream)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamDefaultWriterClose(this);
      }
      releaseLock() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("releaseLock");
        }
        const stream = this._ownerWritableStream;
        if (stream === undefined) {
          return;
        }
        WritableStreamDefaultWriterRelease(this);
      }
      write(chunk = undefined) {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("write"));
        }
        if (this._ownerWritableStream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        return WritableStreamDefaultWriterWrite(this, chunk);
      }
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      releaseLock: { enumerable: true },
      write: { enumerable: true },
      closed: { enumerable: true },
      desiredSize: { enumerable: true },
      ready: { enumerable: true }
    });
    setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
    setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
    setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: true
      });
    }
    function IsWritableStreamDefaultWriter(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
        return false;
      }
      return x instanceof WritableStreamDefaultWriter;
    }
    function WritableStreamDefaultWriterAbort(writer, reason) {
      const stream = writer._ownerWritableStream;
      return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
      const stream = writer._ownerWritableStream;
      return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
      const stream = writer._ownerWritableStream;
      const state = stream._state;
      if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
        return promiseResolvedWith(undefined);
      }
      if (state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
      if (writer._closedPromiseState === "pending") {
        defaultWriterClosedPromiseReject(writer, error);
      } else {
        defaultWriterClosedPromiseResetToRejected(writer, error);
      }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
      if (writer._readyPromiseState === "pending") {
        defaultWriterReadyPromiseReject(writer, error);
      } else {
        defaultWriterReadyPromiseResetToRejected(writer, error);
      }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
      const stream = writer._ownerWritableStream;
      const state = stream._state;
      if (state === "errored" || state === "erroring") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
      const stream = writer._ownerWritableStream;
      const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
      WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
      stream._writer = undefined;
      writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
      const stream = writer._ownerWritableStream;
      const controller = stream._writableStreamController;
      const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
      if (stream !== writer._ownerWritableStream) {
        return promiseRejectedWith(defaultWriterLockException("write to"));
      }
      const state = stream._state;
      if (state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
        return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
      }
      if (state === "erroring") {
        return promiseRejectedWith(stream._storedError);
      }
      const promise = WritableStreamAddWriteRequest(stream);
      WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
      return promise;
    }
    const closeSentinel = {};

    class WritableStreamDefaultController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get abortReason() {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("abortReason");
        }
        return this._abortReason;
      }
      get signal() {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("signal");
        }
        if (this._abortController === undefined) {
          throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
        }
        return this._abortController.signal;
      }
      error(e = undefined) {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("error");
        }
        const state = this._controlledWritableStream._state;
        if (state !== "writable") {
          return;
        }
        WritableStreamDefaultControllerError(this, e);
      }
      [AbortSteps](reason) {
        const result = this._abortAlgorithm(reason);
        WritableStreamDefaultControllerClearAlgorithms(this);
        return result;
      }
      [ErrorSteps]() {
        ResetQueue(this);
      }
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
      abortReason: { enumerable: true },
      signal: { enumerable: true },
      error: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: true
      });
    }
    function IsWritableStreamDefaultController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
        return false;
      }
      return x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
      controller._controlledWritableStream = stream;
      stream._writableStreamController = controller;
      controller._queue = undefined;
      controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._abortReason = undefined;
      controller._abortController = createAbortController();
      controller._started = false;
      controller._strategySizeAlgorithm = sizeAlgorithm;
      controller._strategyHWM = highWaterMark;
      controller._writeAlgorithm = writeAlgorithm;
      controller._closeAlgorithm = closeAlgorithm;
      controller._abortAlgorithm = abortAlgorithm;
      const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
      const startResult = startAlgorithm();
      const startPromise = promiseResolvedWith(startResult);
      uponPromise(startPromise, () => {
        controller._started = true;
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        return null;
      }, (r) => {
        controller._started = true;
        WritableStreamDealWithRejection(stream, r);
        return null;
      });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
      const controller = Object.create(WritableStreamDefaultController.prototype);
      let startAlgorithm;
      let writeAlgorithm;
      let closeAlgorithm;
      let abortAlgorithm;
      if (underlyingSink.start !== undefined) {
        startAlgorithm = () => underlyingSink.start(controller);
      } else {
        startAlgorithm = () => {
          return;
        };
      }
      if (underlyingSink.write !== undefined) {
        writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
      } else {
        writeAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingSink.close !== undefined) {
        closeAlgorithm = () => underlyingSink.close();
      } else {
        closeAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingSink.abort !== undefined) {
        abortAlgorithm = (reason) => underlyingSink.abort(reason);
      } else {
        abortAlgorithm = () => promiseResolvedWith(undefined);
      }
      SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
      controller._writeAlgorithm = undefined;
      controller._closeAlgorithm = undefined;
      controller._abortAlgorithm = undefined;
      controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
      EnqueueValueWithSize(controller, closeSentinel, 0);
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
      try {
        return controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
        return 1;
      }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
        return;
      }
      const stream = controller._controlledWritableStream;
      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
      }
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
      const stream = controller._controlledWritableStream;
      if (!controller._started) {
        return;
      }
      if (stream._inFlightWriteRequest !== undefined) {
        return;
      }
      const state = stream._state;
      if (state === "erroring") {
        WritableStreamFinishErroring(stream);
        return;
      }
      if (controller._queue.length === 0) {
        return;
      }
      const value = PeekQueueValue(controller);
      if (value === closeSentinel) {
        WritableStreamDefaultControllerProcessClose(controller);
      } else {
        WritableStreamDefaultControllerProcessWrite(controller, value);
      }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
      if (controller._controlledWritableStream._state === "writable") {
        WritableStreamDefaultControllerError(controller, error);
      }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
      const stream = controller._controlledWritableStream;
      WritableStreamMarkCloseRequestInFlight(stream);
      DequeueValue(controller);
      const sinkClosePromise = controller._closeAlgorithm();
      WritableStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(sinkClosePromise, () => {
        WritableStreamFinishInFlightClose(stream);
        return null;
      }, (reason) => {
        WritableStreamFinishInFlightCloseWithError(stream, reason);
        return null;
      });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
      const stream = controller._controlledWritableStream;
      WritableStreamMarkFirstWriteRequestInFlight(stream);
      const sinkWritePromise = controller._writeAlgorithm(chunk);
      uponPromise(sinkWritePromise, () => {
        WritableStreamFinishInFlightWrite(stream);
        const state = stream._state;
        DequeueValue(controller);
        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        return null;
      }, (reason) => {
        if (stream._state === "writable") {
          WritableStreamDefaultControllerClearAlgorithms(controller);
        }
        WritableStreamFinishInFlightWriteWithError(stream, reason);
        return null;
      });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
      const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
      return desiredSize <= 0;
    }
    function WritableStreamDefaultControllerError(controller, error) {
      const stream = controller._controlledWritableStream;
      WritableStreamDefaultControllerClearAlgorithms(controller);
      WritableStreamStartErroring(stream, error);
    }
    function streamBrandCheckException$2(name) {
      return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    function defaultControllerBrandCheckException$2(name) {
      return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    function defaultWriterBrandCheckException(name) {
      return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
      return new TypeError("Cannot " + name + " a stream using a released writer");
    }
    function defaultWriterClosedPromiseInitialize(writer) {
      writer._closedPromise = newPromise((resolve, reject) => {
        writer._closedPromise_resolve = resolve;
        writer._closedPromise_reject = reject;
        writer._closedPromiseState = "pending";
      });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
      defaultWriterClosedPromiseInitialize(writer);
      defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
      defaultWriterClosedPromiseInitialize(writer);
      defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
      if (writer._closedPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(writer._closedPromise);
      writer._closedPromise_reject(reason);
      writer._closedPromise_resolve = undefined;
      writer._closedPromise_reject = undefined;
      writer._closedPromiseState = "rejected";
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
      defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
      if (writer._closedPromise_resolve === undefined) {
        return;
      }
      writer._closedPromise_resolve(undefined);
      writer._closedPromise_resolve = undefined;
      writer._closedPromise_reject = undefined;
      writer._closedPromiseState = "resolved";
    }
    function defaultWriterReadyPromiseInitialize(writer) {
      writer._readyPromise = newPromise((resolve, reject) => {
        writer._readyPromise_resolve = resolve;
        writer._readyPromise_reject = reject;
      });
      writer._readyPromiseState = "pending";
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
      defaultWriterReadyPromiseInitialize(writer);
      defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
      defaultWriterReadyPromiseInitialize(writer);
      defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
      if (writer._readyPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(writer._readyPromise);
      writer._readyPromise_reject(reason);
      writer._readyPromise_resolve = undefined;
      writer._readyPromise_reject = undefined;
      writer._readyPromiseState = "rejected";
    }
    function defaultWriterReadyPromiseReset(writer) {
      defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
      defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
      if (writer._readyPromise_resolve === undefined) {
        return;
      }
      writer._readyPromise_resolve(undefined);
      writer._readyPromise_resolve = undefined;
      writer._readyPromise_reject = undefined;
      writer._readyPromiseState = "fulfilled";
    }
    function getGlobals() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      } else if (typeof self !== "undefined") {
        return self;
      } else if (typeof global !== "undefined") {
        return global;
      }
      return;
    }
    const globals = getGlobals();
    function isDOMExceptionConstructor(ctor) {
      if (!(typeof ctor === "function" || typeof ctor === "object")) {
        return false;
      }
      if (ctor.name !== "DOMException") {
        return false;
      }
      try {
        new ctor;
        return true;
      } catch (_a2) {
        return false;
      }
    }
    function getFromGlobal() {
      const ctor = globals === null || globals === undefined ? undefined : globals.DOMException;
      return isDOMExceptionConstructor(ctor) ? ctor : undefined;
    }
    function createPolyfill() {
      const ctor = function DOMException(message, name) {
        this.message = message || "";
        this.name = name || "Error";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      };
      setFunctionName(ctor, "DOMException");
      ctor.prototype = Object.create(Error.prototype);
      Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
      return ctor;
    }
    const DOMException2 = getFromGlobal() || createPolyfill();
    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
      const reader = AcquireReadableStreamDefaultReader(source);
      const writer = AcquireWritableStreamDefaultWriter(dest);
      source._disturbed = true;
      let shuttingDown = false;
      let currentWrite = promiseResolvedWith(undefined);
      return newPromise((resolve, reject) => {
        let abortAlgorithm;
        if (signal !== undefined) {
          abortAlgorithm = () => {
            const error = signal.reason !== undefined ? signal.reason : new DOMException2("Aborted", "AbortError");
            const actions = [];
            if (!preventAbort) {
              actions.push(() => {
                if (dest._state === "writable") {
                  return WritableStreamAbort(dest, error);
                }
                return promiseResolvedWith(undefined);
              });
            }
            if (!preventCancel) {
              actions.push(() => {
                if (source._state === "readable") {
                  return ReadableStreamCancel(source, error);
                }
                return promiseResolvedWith(undefined);
              });
            }
            shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
          };
          if (signal.aborted) {
            abortAlgorithm();
            return;
          }
          signal.addEventListener("abort", abortAlgorithm);
        }
        function pipeLoop() {
          return newPromise((resolveLoop, rejectLoop) => {
            function next(done) {
              if (done) {
                resolveLoop();
              } else {
                PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
            }
            next(false);
          });
        }
        function pipeStep() {
          if (shuttingDown) {
            return promiseResolvedWith(true);
          }
          return PerformPromiseThen(writer._readyPromise, () => {
            return newPromise((resolveRead, rejectRead) => {
              ReadableStreamDefaultReaderRead(reader, {
                _chunkSteps: (chunk) => {
                  currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                  resolveRead(false);
                },
                _closeSteps: () => resolveRead(true),
                _errorSteps: rejectRead
              });
            });
          });
        }
        isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
          if (!preventAbort) {
            shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
          } else {
            shutdown(true, storedError);
          }
          return null;
        });
        isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
          if (!preventCancel) {
            shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
          } else {
            shutdown(true, storedError);
          }
          return null;
        });
        isOrBecomesClosed(source, reader._closedPromise, () => {
          if (!preventClose) {
            shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
          } else {
            shutdown();
          }
          return null;
        });
        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
          const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
          if (!preventCancel) {
            shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
          } else {
            shutdown(true, destClosed);
          }
        }
        setPromiseIsHandledToTrue(pipeLoop());
        function waitForWritesToFinish() {
          const oldCurrentWrite = currentWrite;
          return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
        }
        function isOrBecomesErrored(stream, promise, action) {
          if (stream._state === "errored") {
            action(stream._storedError);
          } else {
            uponRejection(promise, action);
          }
        }
        function isOrBecomesClosed(stream, promise, action) {
          if (stream._state === "closed") {
            action();
          } else {
            uponFulfillment(promise, action);
          }
        }
        function shutdownWithAction(action, originalIsError, originalError) {
          if (shuttingDown) {
            return;
          }
          shuttingDown = true;
          if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
            uponFulfillment(waitForWritesToFinish(), doTheRest);
          } else {
            doTheRest();
          }
          function doTheRest() {
            uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
            return null;
          }
        }
        function shutdown(isError, error) {
          if (shuttingDown) {
            return;
          }
          shuttingDown = true;
          if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
            uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
          } else {
            finalize(isError, error);
          }
        }
        function finalize(isError, error) {
          WritableStreamDefaultWriterRelease(writer);
          ReadableStreamReaderGenericRelease(reader);
          if (signal !== undefined) {
            signal.removeEventListener("abort", abortAlgorithm);
          }
          if (isError) {
            reject(error);
          } else {
            resolve(undefined);
          }
          return null;
        }
      });
    }

    class ReadableStreamDefaultController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("desiredSize");
        }
        return ReadableStreamDefaultControllerGetDesiredSize(this);
      }
      close() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("close");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits close");
        }
        ReadableStreamDefaultControllerClose(this);
      }
      enqueue(chunk = undefined) {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("enqueue");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits enqueue");
        }
        return ReadableStreamDefaultControllerEnqueue(this, chunk);
      }
      error(e = undefined) {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("error");
        }
        ReadableStreamDefaultControllerError(this, e);
      }
      [CancelSteps](reason) {
        ResetQueue(this);
        const result = this._cancelAlgorithm(reason);
        ReadableStreamDefaultControllerClearAlgorithms(this);
        return result;
      }
      [PullSteps](readRequest) {
        const stream = this._controlledReadableStream;
        if (this._queue.length > 0) {
          const chunk = DequeueValue(this);
          if (this._closeRequested && this._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(this);
            ReadableStreamClose(stream);
          } else {
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
          readRequest._chunkSteps(chunk);
        } else {
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
      }
      [ReleaseSteps]() {
      }
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
    setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
    setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: true
      });
    }
    function IsReadableStreamDefaultController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
        return false;
      }
      return x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
      const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
      if (!shouldPull) {
        return;
      }
      if (controller._pulling) {
        controller._pullAgain = true;
        return;
      }
      controller._pulling = true;
      const pullPromise = controller._pullAlgorithm();
      uponPromise(pullPromise, () => {
        controller._pulling = false;
        if (controller._pullAgain) {
          controller._pullAgain = false;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        return null;
      }, (e) => {
        ReadableStreamDefaultControllerError(controller, e);
        return null;
      });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
      const stream = controller._controlledReadableStream;
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return false;
      }
      if (!controller._started) {
        return false;
      }
      if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        return true;
      }
      const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
      if (desiredSize > 0) {
        return true;
      }
      return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
      controller._pullAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
      controller._strategySizeAlgorithm = undefined;
    }
    function ReadableStreamDefaultControllerClose(controller) {
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return;
      }
      const stream = controller._controlledReadableStream;
      controller._closeRequested = true;
      if (controller._queue.length === 0) {
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return;
      }
      const stream = controller._controlledReadableStream;
      if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        ReadableStreamFulfillReadRequest(stream, chunk, false);
      } else {
        let chunkSize;
        try {
          chunkSize = controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          ReadableStreamDefaultControllerError(controller, chunkSizeE);
          throw chunkSizeE;
        }
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          ReadableStreamDefaultControllerError(controller, enqueueE);
          throw enqueueE;
        }
      }
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
      const stream = controller._controlledReadableStream;
      if (stream._state !== "readable") {
        return;
      }
      ResetQueue(controller);
      ReadableStreamDefaultControllerClearAlgorithms(controller);
      ReadableStreamError(stream, e);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
      const state = controller._controlledReadableStream._state;
      if (state === "errored") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
      if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
        return false;
      }
      return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
      const state = controller._controlledReadableStream._state;
      if (!controller._closeRequested && state === "readable") {
        return true;
      }
      return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
      controller._controlledReadableStream = stream;
      controller._queue = undefined;
      controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._started = false;
      controller._closeRequested = false;
      controller._pullAgain = false;
      controller._pulling = false;
      controller._strategySizeAlgorithm = sizeAlgorithm;
      controller._strategyHWM = highWaterMark;
      controller._pullAlgorithm = pullAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      stream._readableStreamController = controller;
      const startResult = startAlgorithm();
      uponPromise(promiseResolvedWith(startResult), () => {
        controller._started = true;
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        return null;
      }, (r) => {
        ReadableStreamDefaultControllerError(controller, r);
        return null;
      });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
      const controller = Object.create(ReadableStreamDefaultController.prototype);
      let startAlgorithm;
      let pullAlgorithm;
      let cancelAlgorithm;
      if (underlyingSource.start !== undefined) {
        startAlgorithm = () => underlyingSource.start(controller);
      } else {
        startAlgorithm = () => {
          return;
        };
      }
      if (underlyingSource.pull !== undefined) {
        pullAlgorithm = () => underlyingSource.pull(controller);
      } else {
        pullAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingSource.cancel !== undefined) {
        cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
      } else {
        cancelAlgorithm = () => promiseResolvedWith(undefined);
      }
      SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    function defaultControllerBrandCheckException$1(name) {
      return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }
    function ReadableStreamTee(stream, cloneForBranch2) {
      if (IsReadableByteStreamController(stream._readableStreamController)) {
        return ReadableByteStreamTee(stream);
      }
      return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      let reading = false;
      let readAgain = false;
      let canceled1 = false;
      let canceled2 = false;
      let reason1;
      let reason2;
      let branch1;
      let branch2;
      let resolveCancelPromise;
      const cancelPromise = newPromise((resolve) => {
        resolveCancelPromise = resolve;
      });
      function pullAlgorithm() {
        if (reading) {
          readAgain = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const readRequest = {
          _chunkSteps: (chunk) => {
            _queueMicrotask(() => {
              readAgain = false;
              const chunk1 = chunk;
              const chunk2 = chunk;
              if (!canceled1) {
                ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
              }
              reading = false;
              if (readAgain) {
                pullAlgorithm();
              }
            });
          },
          _closeSteps: () => {
            reading = false;
            if (!canceled1) {
              ReadableStreamDefaultControllerClose(branch1._readableStreamController);
            }
            if (!canceled2) {
              ReadableStreamDefaultControllerClose(branch2._readableStreamController);
            }
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promiseResolvedWith(undefined);
      }
      function cancel1Algorithm(reason) {
        canceled1 = true;
        reason1 = reason;
        if (canceled2) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function cancel2Algorithm(reason) {
        canceled2 = true;
        reason2 = reason;
        if (canceled1) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function startAlgorithm() {
      }
      branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
      branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
      uponRejection(reader._closedPromise, (r) => {
        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(undefined);
        }
        return null;
      });
      return [branch1, branch2];
    }
    function ReadableByteStreamTee(stream) {
      let reader = AcquireReadableStreamDefaultReader(stream);
      let reading = false;
      let readAgainForBranch1 = false;
      let readAgainForBranch2 = false;
      let canceled1 = false;
      let canceled2 = false;
      let reason1;
      let reason2;
      let branch1;
      let branch2;
      let resolveCancelPromise;
      const cancelPromise = newPromise((resolve) => {
        resolveCancelPromise = resolve;
      });
      function forwardReaderError(thisReader) {
        uponRejection(thisReader._closedPromise, (r) => {
          if (thisReader !== reader) {
            return null;
          }
          ReadableByteStreamControllerError(branch1._readableStreamController, r);
          ReadableByteStreamControllerError(branch2._readableStreamController, r);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
          return null;
        });
      }
      function pullWithDefaultReader() {
        if (IsReadableStreamBYOBReader(reader)) {
          ReadableStreamReaderGenericRelease(reader);
          reader = AcquireReadableStreamDefaultReader(stream);
          forwardReaderError(reader);
        }
        const readRequest = {
          _chunkSteps: (chunk) => {
            _queueMicrotask(() => {
              readAgainForBranch1 = false;
              readAgainForBranch2 = false;
              const chunk1 = chunk;
              let chunk2 = chunk;
              if (!canceled1 && !canceled2) {
                try {
                  chunk2 = CloneAsUint8Array(chunk);
                } catch (cloneE) {
                  ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                  ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                  resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                  return;
                }
              }
              if (!canceled1) {
                ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
              }
              if (!canceled2) {
                ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
              }
              reading = false;
              if (readAgainForBranch1) {
                pull1Algorithm();
              } else if (readAgainForBranch2) {
                pull2Algorithm();
              }
            });
          },
          _closeSteps: () => {
            reading = false;
            if (!canceled1) {
              ReadableByteStreamControllerClose(branch1._readableStreamController);
            }
            if (!canceled2) {
              ReadableByteStreamControllerClose(branch2._readableStreamController);
            }
            if (branch1._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
            }
            if (branch2._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
            }
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
      }
      function pullWithBYOBReader(view, forBranch2) {
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamReaderGenericRelease(reader);
          reader = AcquireReadableStreamBYOBReader(stream);
          forwardReaderError(reader);
        }
        const byobBranch = forBranch2 ? branch2 : branch1;
        const otherBranch = forBranch2 ? branch1 : branch2;
        const readIntoRequest = {
          _chunkSteps: (chunk) => {
            _queueMicrotask(() => {
              readAgainForBranch1 = false;
              readAgainForBranch2 = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!otherCanceled) {
                let clonedChunk;
                try {
                  clonedChunk = CloneAsUint8Array(chunk);
                } catch (cloneE) {
                  ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                  ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                  resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                  return;
                }
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
              } else if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              reading = false;
              if (readAgainForBranch1) {
                pull1Algorithm();
              } else if (readAgainForBranch2) {
                pull2Algorithm();
              }
            });
          },
          _closeSteps: (chunk) => {
            reading = false;
            const byobCanceled = forBranch2 ? canceled2 : canceled1;
            const otherCanceled = forBranch2 ? canceled1 : canceled2;
            if (!byobCanceled) {
              ReadableByteStreamControllerClose(byobBranch._readableStreamController);
            }
            if (!otherCanceled) {
              ReadableByteStreamControllerClose(otherBranch._readableStreamController);
            }
            if (chunk !== undefined) {
              if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
              }
            }
            if (!byobCanceled || !otherCanceled) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
      }
      function pull1Algorithm() {
        if (reading) {
          readAgainForBranch1 = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
        if (byobRequest === null) {
          pullWithDefaultReader();
        } else {
          pullWithBYOBReader(byobRequest._view, false);
        }
        return promiseResolvedWith(undefined);
      }
      function pull2Algorithm() {
        if (reading) {
          readAgainForBranch2 = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
        if (byobRequest === null) {
          pullWithDefaultReader();
        } else {
          pullWithBYOBReader(byobRequest._view, true);
        }
        return promiseResolvedWith(undefined);
      }
      function cancel1Algorithm(reason) {
        canceled1 = true;
        reason1 = reason;
        if (canceled2) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function cancel2Algorithm(reason) {
        canceled2 = true;
        reason2 = reason;
        if (canceled1) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function startAlgorithm() {
        return;
      }
      branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
      branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
      forwardReaderError(reader);
      return [branch1, branch2];
    }
    function isReadableStreamLike(stream) {
      return typeIsObject(stream) && typeof stream.getReader !== "undefined";
    }
    function ReadableStreamFrom(source) {
      if (isReadableStreamLike(source)) {
        return ReadableStreamFromDefaultReader(source.getReader());
      }
      return ReadableStreamFromIterable(source);
    }
    function ReadableStreamFromIterable(asyncIterable) {
      let stream;
      const iteratorRecord = GetIterator(asyncIterable, "async");
      const startAlgorithm = noop;
      function pullAlgorithm() {
        let nextResult;
        try {
          nextResult = IteratorNext(iteratorRecord);
        } catch (e) {
          return promiseRejectedWith(e);
        }
        const nextPromise = promiseResolvedWith(nextResult);
        return transformPromiseWith(nextPromise, (iterResult) => {
          if (!typeIsObject(iterResult)) {
            throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
          }
          const done = IteratorComplete(iterResult);
          if (done) {
            ReadableStreamDefaultControllerClose(stream._readableStreamController);
          } else {
            const value = IteratorValue(iterResult);
            ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
          }
        });
      }
      function cancelAlgorithm(reason) {
        const iterator = iteratorRecord.iterator;
        let returnMethod;
        try {
          returnMethod = GetMethod(iterator, "return");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        if (returnMethod === undefined) {
          return promiseResolvedWith(undefined);
        }
        let returnResult;
        try {
          returnResult = reflectCall(returnMethod, iterator, [reason]);
        } catch (e) {
          return promiseRejectedWith(e);
        }
        const returnPromise = promiseResolvedWith(returnResult);
        return transformPromiseWith(returnPromise, (iterResult) => {
          if (!typeIsObject(iterResult)) {
            throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
          }
          return;
        });
      }
      stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
      return stream;
    }
    function ReadableStreamFromDefaultReader(reader) {
      let stream;
      const startAlgorithm = noop;
      function pullAlgorithm() {
        let readPromise;
        try {
          readPromise = reader.read();
        } catch (e) {
          return promiseRejectedWith(e);
        }
        return transformPromiseWith(readPromise, (readResult) => {
          if (!typeIsObject(readResult)) {
            throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
          }
          if (readResult.done) {
            ReadableStreamDefaultControllerClose(stream._readableStreamController);
          } else {
            const value = readResult.value;
            ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
          }
        });
      }
      function cancelAlgorithm(reason) {
        try {
          return promiseResolvedWith(reader.cancel(reason));
        } catch (e) {
          return promiseRejectedWith(e);
        }
      }
      stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
      return stream;
    }
    function convertUnderlyingDefaultOrByteSource(source, context2) {
      assertDictionary(source, context2);
      const original = source;
      const autoAllocateChunkSize = original === null || original === undefined ? undefined : original.autoAllocateChunkSize;
      const cancel = original === null || original === undefined ? undefined : original.cancel;
      const pull = original === null || original === undefined ? undefined : original.pull;
      const start = original === null || original === undefined ? undefined : original.start;
      const type2 = original === null || original === undefined ? undefined : original.type;
      return {
        autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context2} has member 'autoAllocateChunkSize' that`),
        cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context2} has member 'cancel' that`),
        pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context2} has member 'pull' that`),
        start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context2} has member 'start' that`),
        type: type2 === undefined ? undefined : convertReadableStreamType(type2, `${context2} has member 'type' that`)
      };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertReadableStreamType(type2, context2) {
      type2 = `${type2}`;
      if (type2 !== "bytes") {
        throw new TypeError(`${context2} '${type2}' is not a valid enumeration value for ReadableStreamType`);
      }
      return type2;
    }
    function convertIteratorOptions(options, context2) {
      assertDictionary(options, context2);
      const preventCancel = options === null || options === undefined ? undefined : options.preventCancel;
      return { preventCancel: Boolean(preventCancel) };
    }
    function convertPipeOptions(options, context2) {
      assertDictionary(options, context2);
      const preventAbort = options === null || options === undefined ? undefined : options.preventAbort;
      const preventCancel = options === null || options === undefined ? undefined : options.preventCancel;
      const preventClose = options === null || options === undefined ? undefined : options.preventClose;
      const signal = options === null || options === undefined ? undefined : options.signal;
      if (signal !== undefined) {
        assertAbortSignal(signal, `${context2} has member 'signal' that`);
      }
      return {
        preventAbort: Boolean(preventAbort),
        preventCancel: Boolean(preventCancel),
        preventClose: Boolean(preventClose),
        signal
      };
    }
    function assertAbortSignal(signal, context2) {
      if (!isAbortSignal(signal)) {
        throw new TypeError(`${context2} is not an AbortSignal.`);
      }
    }
    function convertReadableWritablePair(pair, context2) {
      assertDictionary(pair, context2);
      const readable = pair === null || pair === undefined ? undefined : pair.readable;
      assertRequiredField(readable, "readable", "ReadableWritablePair");
      assertReadableStream(readable, `${context2} has member 'readable' that`);
      const writable = pair === null || pair === undefined ? undefined : pair.writable;
      assertRequiredField(writable, "writable", "ReadableWritablePair");
      assertWritableStream(writable, `${context2} has member 'writable' that`);
      return { readable, writable };
    }

    class ReadableStream2 {
      constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
        if (rawUnderlyingSource === undefined) {
          rawUnderlyingSource = null;
        } else {
          assertObject(rawUnderlyingSource, "First parameter");
        }
        const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
        InitializeReadableStream(this);
        if (underlyingSource.type === "bytes") {
          if (strategy.size !== undefined) {
            throw new RangeError("The strategy for a byte stream cannot have a size function");
          }
          const highWaterMark = ExtractHighWaterMark(strategy, 0);
          SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
        } else {
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
        }
      }
      get locked() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("locked");
        }
        return IsReadableStreamLocked(this);
      }
      cancel(reason = undefined) {
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("cancel"));
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
        }
        return ReadableStreamCancel(this, reason);
      }
      getReader(rawOptions = undefined) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("getReader");
        }
        const options = convertReaderOptions(rawOptions, "First parameter");
        if (options.mode === undefined) {
          return AcquireReadableStreamDefaultReader(this);
        }
        return AcquireReadableStreamBYOBReader(this);
      }
      pipeThrough(rawTransform, rawOptions = {}) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("pipeThrough");
        }
        assertRequiredArgument(rawTransform, 1, "pipeThrough");
        const transform = convertReadableWritablePair(rawTransform, "First parameter");
        const options = convertPipeOptions(rawOptions, "Second parameter");
        if (IsReadableStreamLocked(this)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        }
        if (IsWritableStreamLocked(transform.writable)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        }
        const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        setPromiseIsHandledToTrue(promise);
        return transform.readable;
      }
      pipeTo(destination, rawOptions = {}) {
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
        }
        if (destination === undefined) {
          return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
        }
        if (!IsWritableStream(destination)) {
          return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
        }
        let options;
        try {
          options = convertPipeOptions(rawOptions, "Second parameter");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
        }
        if (IsWritableStreamLocked(destination)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
        }
        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
      }
      tee() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("tee");
        }
        const branches = ReadableStreamTee(this);
        return CreateArrayFromList(branches);
      }
      values(rawOptions = undefined) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("values");
        }
        const options = convertIteratorOptions(rawOptions, "First parameter");
        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
      }
      [SymbolAsyncIterator](options) {
        return this.values(options);
      }
      static from(asyncIterable) {
        return ReadableStreamFrom(asyncIterable);
      }
    }
    Object.defineProperties(ReadableStream2, {
      from: { enumerable: true }
    });
    Object.defineProperties(ReadableStream2.prototype, {
      cancel: { enumerable: true },
      getReader: { enumerable: true },
      pipeThrough: { enumerable: true },
      pipeTo: { enumerable: true },
      tee: { enumerable: true },
      values: { enumerable: true },
      locked: { enumerable: true }
    });
    setFunctionName(ReadableStream2.from, "from");
    setFunctionName(ReadableStream2.prototype.cancel, "cancel");
    setFunctionName(ReadableStream2.prototype.getReader, "getReader");
    setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
    setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
    setFunctionName(ReadableStream2.prototype.tee, "tee");
    setFunctionName(ReadableStream2.prototype.values, "values");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, {
        value: "ReadableStream",
        configurable: true
      });
    }
    Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
      value: ReadableStream2.prototype.values,
      writable: true,
      configurable: true
    });
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
      const stream = Object.create(ReadableStream2.prototype);
      InitializeReadableStream(stream);
      const controller = Object.create(ReadableStreamDefaultController.prototype);
      SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      return stream;
    }
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
      const stream = Object.create(ReadableStream2.prototype);
      InitializeReadableStream(stream);
      const controller = Object.create(ReadableByteStreamController.prototype);
      SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
      return stream;
    }
    function InitializeReadableStream(stream) {
      stream._state = "readable";
      stream._reader = undefined;
      stream._storedError = undefined;
      stream._disturbed = false;
    }
    function IsReadableStream(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
        return false;
      }
      return x instanceof ReadableStream2;
    }
    function IsReadableStreamLocked(stream) {
      if (stream._reader === undefined) {
        return false;
      }
      return true;
    }
    function ReadableStreamCancel(stream, reason) {
      stream._disturbed = true;
      if (stream._state === "closed") {
        return promiseResolvedWith(undefined);
      }
      if (stream._state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      ReadableStreamClose(stream);
      const reader = stream._reader;
      if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue;
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._closeSteps(undefined);
        });
      }
      const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
      return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
      stream._state = "closed";
      const reader = stream._reader;
      if (reader === undefined) {
        return;
      }
      defaultReaderClosedPromiseResolve(reader);
      if (IsReadableStreamDefaultReader(reader)) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue;
        readRequests.forEach((readRequest) => {
          readRequest._closeSteps();
        });
      }
    }
    function ReadableStreamError(stream, e) {
      stream._state = "errored";
      stream._storedError = e;
      const reader = stream._reader;
      if (reader === undefined) {
        return;
      }
      defaultReaderClosedPromiseReject(reader, e);
      if (IsReadableStreamDefaultReader(reader)) {
        ReadableStreamDefaultReaderErrorReadRequests(reader, e);
      } else {
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
      }
    }
    function streamBrandCheckException$1(name) {
      return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }
    function convertQueuingStrategyInit(init, context2) {
      assertDictionary(init, context2);
      const highWaterMark = init === null || init === undefined ? undefined : init.highWaterMark;
      assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
      return {
        highWaterMark: convertUnrestrictedDouble(highWaterMark)
      };
    }
    const byteLengthSizeFunction = (chunk) => {
      return chunk.byteLength;
    };
    setFunctionName(byteLengthSizeFunction, "size");

    class ByteLengthQueuingStrategy {
      constructor(options) {
        assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      get highWaterMark() {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException("highWaterMark");
        }
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException("size");
        }
        return byteLengthSizeFunction;
      }
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: true
      });
    }
    function byteLengthBrandCheckException(name) {
      return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
        return false;
      }
      return x instanceof ByteLengthQueuingStrategy;
    }
    const countSizeFunction = () => {
      return 1;
    };
    setFunctionName(countSizeFunction, "size");

    class CountQueuingStrategy2 {
      constructor(options) {
        assertRequiredArgument(options, 1, "CountQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._countQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      get highWaterMark() {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException("highWaterMark");
        }
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException("size");
        }
        return countSizeFunction;
      }
    }
    Object.defineProperties(CountQueuingStrategy2.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(CountQueuingStrategy2.prototype, Symbol.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: true
      });
    }
    function countBrandCheckException(name) {
      return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
        return false;
      }
      return x instanceof CountQueuingStrategy2;
    }
    function convertTransformer(original, context2) {
      assertDictionary(original, context2);
      const cancel = original === null || original === undefined ? undefined : original.cancel;
      const flush = original === null || original === undefined ? undefined : original.flush;
      const readableType = original === null || original === undefined ? undefined : original.readableType;
      const start = original === null || original === undefined ? undefined : original.start;
      const transform = original === null || original === undefined ? undefined : original.transform;
      const writableType = original === null || original === undefined ? undefined : original.writableType;
      return {
        cancel: cancel === undefined ? undefined : convertTransformerCancelCallback(cancel, original, `${context2} has member 'cancel' that`),
        flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context2} has member 'flush' that`),
        readableType,
        start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context2} has member 'start' that`),
        transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context2} has member 'transform' that`),
        writableType
      };
    }
    function convertTransformerFlushCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertTransformerStartCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertTransformerTransformCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }
    function convertTransformerCancelCallback(fn, original, context2) {
      assertFunction(fn, context2);
      return (reason) => promiseCall(fn, original, [reason]);
    }

    class TransformStream {
      constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
        if (rawTransformer === undefined) {
          rawTransformer = null;
        }
        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
        const transformer = convertTransformer(rawTransformer, "First parameter");
        if (transformer.readableType !== undefined) {
          throw new RangeError("Invalid readableType specified");
        }
        if (transformer.writableType !== undefined) {
          throw new RangeError("Invalid writableType specified");
        }
        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
        let startPromise_resolve;
        const startPromise = newPromise((resolve) => {
          startPromise_resolve = resolve;
        });
        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
        if (transformer.start !== undefined) {
          startPromise_resolve(transformer.start(this._transformStreamController));
        } else {
          startPromise_resolve(undefined);
        }
      }
      get readable() {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException("readable");
        }
        return this._readable;
      }
      get writable() {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException("writable");
        }
        return this._writable;
      }
    }
    Object.defineProperties(TransformStream.prototype, {
      readable: { enumerable: true },
      writable: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
        value: "TransformStream",
        configurable: true
      });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
      function startAlgorithm() {
        return startPromise;
      }
      function writeAlgorithm(chunk) {
        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
      }
      function abortAlgorithm(reason) {
        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
      }
      function closeAlgorithm() {
        return TransformStreamDefaultSinkCloseAlgorithm(stream);
      }
      stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
      function pullAlgorithm() {
        return TransformStreamDefaultSourcePullAlgorithm(stream);
      }
      function cancelAlgorithm(reason) {
        return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
      }
      stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
      stream._backpressure = undefined;
      stream._backpressureChangePromise = undefined;
      stream._backpressureChangePromise_resolve = undefined;
      TransformStreamSetBackpressure(stream, true);
      stream._transformStreamController = undefined;
    }
    function IsTransformStream(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
        return false;
      }
      return x instanceof TransformStream;
    }
    function TransformStreamError(stream, e) {
      ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
      TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
      TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
      WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
      TransformStreamUnblockWrite(stream);
    }
    function TransformStreamUnblockWrite(stream) {
      if (stream._backpressure) {
        TransformStreamSetBackpressure(stream, false);
      }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
      if (stream._backpressureChangePromise !== undefined) {
        stream._backpressureChangePromise_resolve();
      }
      stream._backpressureChangePromise = newPromise((resolve) => {
        stream._backpressureChangePromise_resolve = resolve;
      });
      stream._backpressure = backpressure;
    }

    class TransformStreamDefaultController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("desiredSize");
        }
        const readableController = this._controlledTransformStream._readable._readableStreamController;
        return ReadableStreamDefaultControllerGetDesiredSize(readableController);
      }
      enqueue(chunk = undefined) {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("enqueue");
        }
        TransformStreamDefaultControllerEnqueue(this, chunk);
      }
      error(reason = undefined) {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("error");
        }
        TransformStreamDefaultControllerError(this, reason);
      }
      terminate() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("terminate");
        }
        TransformStreamDefaultControllerTerminate(this);
      }
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
      enqueue: { enumerable: true },
      error: { enumerable: true },
      terminate: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
    setFunctionName(TransformStreamDefaultController.prototype.error, "error");
    setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: true
      });
    }
    function IsTransformStreamDefaultController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
        return false;
      }
      return x instanceof TransformStreamDefaultController;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
      controller._controlledTransformStream = stream;
      stream._transformStreamController = controller;
      controller._transformAlgorithm = transformAlgorithm;
      controller._flushAlgorithm = flushAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      controller._finishPromise = undefined;
      controller._finishPromise_resolve = undefined;
      controller._finishPromise_reject = undefined;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
      const controller = Object.create(TransformStreamDefaultController.prototype);
      let transformAlgorithm;
      let flushAlgorithm;
      let cancelAlgorithm;
      if (transformer.transform !== undefined) {
        transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
      } else {
        transformAlgorithm = (chunk) => {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(undefined);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
      }
      if (transformer.flush !== undefined) {
        flushAlgorithm = () => transformer.flush(controller);
      } else {
        flushAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (transformer.cancel !== undefined) {
        cancelAlgorithm = (reason) => transformer.cancel(reason);
      } else {
        cancelAlgorithm = () => promiseResolvedWith(undefined);
      }
      SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
      controller._transformAlgorithm = undefined;
      controller._flushAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
      const stream = controller._controlledTransformStream;
      const readableController = stream._readable._readableStreamController;
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
        throw new TypeError("Readable side is not in a state that permits enqueue");
      }
      try {
        ReadableStreamDefaultControllerEnqueue(readableController, chunk);
      } catch (e) {
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
        throw stream._readable._storedError;
      }
      const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
      if (backpressure !== stream._backpressure) {
        TransformStreamSetBackpressure(stream, true);
      }
    }
    function TransformStreamDefaultControllerError(controller, e) {
      TransformStreamError(controller._controlledTransformStream, e);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
      const transformPromise = controller._transformAlgorithm(chunk);
      return transformPromiseWith(transformPromise, undefined, (r) => {
        TransformStreamError(controller._controlledTransformStream, r);
        throw r;
      });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
      const stream = controller._controlledTransformStream;
      const readableController = stream._readable._readableStreamController;
      ReadableStreamDefaultControllerClose(readableController);
      const error = new TypeError("TransformStream terminated");
      TransformStreamErrorWritableAndUnblockWrite(stream, error);
    }
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
      const controller = stream._transformStreamController;
      if (stream._backpressure) {
        const backpressureChangePromise = stream._backpressureChangePromise;
        return transformPromiseWith(backpressureChangePromise, () => {
          const writable = stream._writable;
          const state = writable._state;
          if (state === "erroring") {
            throw writable._storedError;
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        });
      }
      return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
      const controller = stream._transformStreamController;
      if (controller._finishPromise !== undefined) {
        return controller._finishPromise;
      }
      const readable = stream._readable;
      controller._finishPromise = newPromise((resolve, reject) => {
        controller._finishPromise_resolve = resolve;
        controller._finishPromise_reject = reject;
      });
      const cancelPromise = controller._cancelAlgorithm(reason);
      TransformStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(cancelPromise, () => {
        if (readable._state === "errored") {
          defaultControllerFinishPromiseReject(controller, readable._storedError);
        } else {
          ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
          defaultControllerFinishPromiseResolve(controller);
        }
        return null;
      }, (r) => {
        ReadableStreamDefaultControllerError(readable._readableStreamController, r);
        defaultControllerFinishPromiseReject(controller, r);
        return null;
      });
      return controller._finishPromise;
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
      const controller = stream._transformStreamController;
      if (controller._finishPromise !== undefined) {
        return controller._finishPromise;
      }
      const readable = stream._readable;
      controller._finishPromise = newPromise((resolve, reject) => {
        controller._finishPromise_resolve = resolve;
        controller._finishPromise_reject = reject;
      });
      const flushPromise = controller._flushAlgorithm();
      TransformStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(flushPromise, () => {
        if (readable._state === "errored") {
          defaultControllerFinishPromiseReject(controller, readable._storedError);
        } else {
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
          defaultControllerFinishPromiseResolve(controller);
        }
        return null;
      }, (r) => {
        ReadableStreamDefaultControllerError(readable._readableStreamController, r);
        defaultControllerFinishPromiseReject(controller, r);
        return null;
      });
      return controller._finishPromise;
    }
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
      TransformStreamSetBackpressure(stream, false);
      return stream._backpressureChangePromise;
    }
    function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
      const controller = stream._transformStreamController;
      if (controller._finishPromise !== undefined) {
        return controller._finishPromise;
      }
      const writable = stream._writable;
      controller._finishPromise = newPromise((resolve, reject) => {
        controller._finishPromise_resolve = resolve;
        controller._finishPromise_reject = reject;
      });
      const cancelPromise = controller._cancelAlgorithm(reason);
      TransformStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(cancelPromise, () => {
        if (writable._state === "errored") {
          defaultControllerFinishPromiseReject(controller, writable._storedError);
        } else {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseResolve(controller);
        }
        return null;
      }, (r) => {
        WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);
        TransformStreamUnblockWrite(stream);
        defaultControllerFinishPromiseReject(controller, r);
        return null;
      });
      return controller._finishPromise;
    }
    function defaultControllerBrandCheckException(name) {
      return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    function defaultControllerFinishPromiseResolve(controller) {
      if (controller._finishPromise_resolve === undefined) {
        return;
      }
      controller._finishPromise_resolve();
      controller._finishPromise_resolve = undefined;
      controller._finishPromise_reject = undefined;
    }
    function defaultControllerFinishPromiseReject(controller, reason) {
      if (controller._finishPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(controller._finishPromise);
      controller._finishPromise_reject(reason);
      controller._finishPromise_resolve = undefined;
      controller._finishPromise_reject = undefined;
    }
    function streamBrandCheckException(name) {
      return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }
    exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
    exports2.CountQueuingStrategy = CountQueuingStrategy2;
    exports2.ReadableByteStreamController = ReadableByteStreamController;
    exports2.ReadableStream = ReadableStream2;
    exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
    exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
    exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
    exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    exports2.TransformStream = TransformStream;
    exports2.TransformStreamDefaultController = TransformStreamDefaultController;
    exports2.WritableStream = WritableStream;
    exports2.WritableStreamDefaultController = WritableStreamDefaultController;
    exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
  });
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS(() => {
  var POOL_SIZE = 65536;
  if (!globalThis.ReadableStream) {
    try {
      const process2 = __require("node:process");
      const { emitWarning } = process2;
      try {
        process2.emitWarning = () => {
        };
        Object.assign(globalThis, __require("node:stream/web"));
        process2.emitWarning = emitWarning;
      } catch (error) {
        process2.emitWarning = emitWarning;
        throw error;
      }
    } catch (error) {
      Object.assign(globalThis, require_ponyfill_es2018());
    }
  }
  try {
    const { Blob } = __require("buffer");
    if (Blob && !Blob.prototype.stream) {
      Blob.prototype.stream = function name(params) {
        let position2 = 0;
        const blob = this;
        return new ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = blob.slice(position2, Math.min(blob.size, position2 + POOL_SIZE));
            const buffer = await chunk.arrayBuffer();
            position2 += buffer.byteLength;
            ctrl.enqueue(new Uint8Array(buffer));
            if (position2 === blob.size) {
              ctrl.close();
            }
          }
        });
      };
    }
  } catch (error) {
  }
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone) {
        let position2 = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position2 !== end) {
          const size = Math.min(end - position2, POOL_SIZE);
          const chunk = part.buffer.slice(position2, position2 + size);
          position2 += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position2 = 0, b = part;
      while (position2 !== b.size) {
        const chunk = b.slice(position2, Math.min(b.size, position2 + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position2 += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE = 65536, _Blob, Blob2, fetch_blob_default;
var init_fetch_blob = __esm(() => {
  import_streams = __toESM(require_streams(), 1);
  /*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
  _Blob = class Blob {
    #parts = [];
    #type = "";
    #size = 0;
    #endings = "transparent";
    constructor(blobParts = [], options = {}) {
      if (typeof blobParts !== "object" || blobParts === null) {
        throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
      }
      if (typeof blobParts[Symbol.iterator] !== "function") {
        throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
      }
      if (typeof options !== "object" && typeof options !== "function") {
        throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
      }
      if (options === null)
        options = {};
      const encoder = new TextEncoder;
      for (const element of blobParts) {
        let part;
        if (ArrayBuffer.isView(element)) {
          part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
        } else if (element instanceof ArrayBuffer) {
          part = new Uint8Array(element.slice(0));
        } else if (element instanceof Blob) {
          part = element;
        } else {
          part = encoder.encode(`${element}`);
        }
        this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
        this.#parts.push(part);
      }
      this.#endings = `${options.endings === undefined ? "transparent" : options.endings}`;
      const type2 = options.type === undefined ? "" : String(options.type);
      this.#type = /^[\x20-\x7E]*$/.test(type2) ? type2 : "";
    }
    get size() {
      return this.#size;
    }
    get type() {
      return this.#type;
    }
    async text() {
      const decoder = new TextDecoder;
      let str = "";
      for await (const part of toIterator(this.#parts, false)) {
        str += decoder.decode(part, { stream: true });
      }
      str += decoder.decode();
      return str;
    }
    async arrayBuffer() {
      const data = new Uint8Array(this.size);
      let offset = 0;
      for await (const chunk of toIterator(this.#parts, false)) {
        data.set(chunk, offset);
        offset += chunk.length;
      }
      return data.buffer;
    }
    stream() {
      const it = toIterator(this.#parts, true);
      return new globalThis.ReadableStream({
        type: "bytes",
        async pull(ctrl) {
          const chunk = await it.next();
          chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
        },
        async cancel() {
          await it.return();
        }
      });
    }
    slice(start = 0, end = this.size, type2 = "") {
      const { size } = this;
      let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
      let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
      const span = Math.max(relativeEnd - relativeStart, 0);
      const parts = this.#parts;
      const blobParts = [];
      let added = 0;
      for (const part of parts) {
        if (added >= span) {
          break;
        }
        const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
        if (relativeStart && size2 <= relativeStart) {
          relativeStart -= size2;
          relativeEnd -= size2;
        } else {
          let chunk;
          if (ArrayBuffer.isView(part)) {
            chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
            added += chunk.byteLength;
          } else {
            chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            added += chunk.size;
          }
          relativeEnd -= size2;
          blobParts.push(chunk);
          relativeStart = 0;
        }
      }
      const blob = new Blob([], { type: String(type2).toLowerCase() });
      blob.#size = span;
      blob.#parts = blobParts;
      return blob;
    }
    get [Symbol.toStringTag]() {
      return "Blob";
    }
    static [Symbol.hasInstance](object) {
      return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
  };
  Object.defineProperties(_Blob.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Blob2 = _Blob;
  fetch_blob_default = Blob2;
});

// node_modules/fetch-blob/file.js
var _File, File3, file_default;
var init_file = __esm(() => {
  init_fetch_blob();
  _File = class File2 extends fetch_blob_default {
    #lastModified = 0;
    #name = "";
    constructor(fileBits, fileName, options = {}) {
      if (arguments.length < 2) {
        throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
      }
      super(fileBits, options);
      if (options === null)
        options = {};
      const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);
      if (!Number.isNaN(lastModified)) {
        this.#lastModified = lastModified;
      }
      this.#name = String(fileName);
    }
    get name() {
      return this.#name;
    }
    get lastModified() {
      return this.#lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
    static [Symbol.hasInstance](object) {
      return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
    }
  };
  File3 = _File;
  file_default = File3;
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, `\r
`)}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, `\r
`));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== undefined ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]), e = (c, f2) => (f2 ? c : c.replace(/\r?\n|\r/g, `\r
`)).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), x = (n, a, e2) => {
  if (a.length < e2) {
    throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
  }
}, FormData;
var init_esm_min = __esm(() => {
  init_fetch_blob();
  init_file();
  /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
  ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
  r = Math.random;
  m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
  FormData = class FormData2 {
    #d = [];
    constructor(...a) {
      if (a.length)
        throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
    }
    get [t]() {
      return "FormData";
    }
    [i]() {
      return this.entries();
    }
    static [h](o) {
      return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
    }
    append(...a) {
      x("append", arguments, 2);
      this.#d.push(f(...a));
    }
    delete(a) {
      x("delete", arguments, 1);
      a += "";
      this.#d = this.#d.filter(([b]) => b !== a);
    }
    get(a) {
      x("get", arguments, 1);
      a += "";
      for (var b = this.#d, l = b.length, c = 0;c < l; c++)
        if (b[c][0] === a)
          return b[c][1];
      return null;
    }
    getAll(a, b) {
      x("getAll", arguments, 1);
      b = [];
      a += "";
      this.#d.forEach((c) => c[0] === a && b.push(c[1]));
      return b;
    }
    has(a) {
      x("has", arguments, 1);
      a += "";
      return this.#d.some((b) => b[0] === a);
    }
    forEach(a, b) {
      x("forEach", arguments, 1);
      for (var [c, d] of this)
        a.call(b, d, c, this);
    }
    set(...a) {
      x("set", arguments, 2);
      var b = [], c = true;
      a = f(...a);
      this.#d.forEach((d) => {
        d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
      });
      c && b.push(a);
      this.#d = b;
    }
    *entries() {
      yield* this.#d;
    }
    *keys() {
      for (var [a] of this)
        yield a;
    }
    *values() {
      for (var [, a] of this)
        yield a;
    }
  };
});

// node_modules/node-fetch/src/errors/base.js
var FetchBaseError;
var init_base = __esm(() => {
  FetchBaseError = class FetchBaseError extends Error {
    constructor(message, type2) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.type = type2;
    }
    get name() {
      return this.constructor.name;
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  };
});

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError;
var init_fetch_error = __esm(() => {
  init_base();
  FetchError = class FetchError extends FetchBaseError {
    constructor(message, type2, systemError) {
      super(message, type2);
      if (systemError) {
        this.code = this.errno = systemError.code;
        this.erroredSysCall = systemError.syscall;
      }
    }
  };
});

// node_modules/node-fetch/src/utils/is.js
var NAME, isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
}, isBlob = (object) => {
  return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
}, isAbortSignal = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
}, isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
}, isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};
var init_is = __esm(() => {
  NAME = Symbol.toStringTag;
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS((exports, module) => {
  /*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
  if (!globalThis.DOMException) {
    try {
      const { MessageChannel } = __require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer;
      port.postMessage(ab, [ab, ab]);
    } catch (err) {
      err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
    }
  }
  module.exports = globalThis.DOMException;
});

// node_modules/fetch-blob/from.js
import { statSync, createReadStream, promises as fs } from "node:fs";
var import_node_domexception, stat, BlobDataItem;
var init_from = __esm(() => {
  import_node_domexception = __toESM(require_node_domexception(), 1);
  init_file();
  init_fetch_blob();
  ({ stat } = fs);
  BlobDataItem = class BlobDataItem {
    #path;
    #start;
    constructor(options) {
      this.#path = options.path;
      this.#start = options.start;
      this.size = options.size;
      this.lastModified = options.lastModified;
    }
    slice(start, end) {
      return new BlobDataItem({
        path: this.#path,
        lastModified: this.lastModified,
        size: end - start,
        start: this.#start + start
      });
    }
    async* stream() {
      const { mtimeMs } = await stat(this.#path);
      if (mtimeMs > this.lastModified) {
        throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
      }
      yield* createReadStream(this.#path, {
        start: this.#start,
        end: this.#start + this.size - 1
      });
    }
    get [Symbol.toStringTag]() {
      return "Blob";
    }
  };
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var exports_multipart_parser = {};
__export(exports_multipart_parser, {
  toFormData: () => toFormData
});

class MultipartParser {
  constructor(boundary) {
    this.index = 0;
    this.flags = 0;
    this.onHeaderEnd = noop;
    this.onHeaderField = noop;
    this.onHeadersEnd = noop;
    this.onHeaderValue = noop;
    this.onPartBegin = noop;
    this.onPartData = noop;
    this.onPartEnd = noop;
    this.boundaryChars = {};
    boundary = `\r
--` + boundary;
    const ui8a = new Uint8Array(boundary.length);
    for (let i2 = 0;i2 < boundary.length; i2++) {
      ui8a[i2] = boundary.charCodeAt(i2);
      this.boundaryChars[ui8a[i2]] = true;
    }
    this.boundary = ui8a;
    this.lookbehind = new Uint8Array(this.boundary.length + 8);
    this.state = S.START_BOUNDARY;
  }
  write(data) {
    let i2 = 0;
    const length_ = data.length;
    let previousIndex = this.index;
    let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
    const boundaryLength = this.boundary.length;
    const boundaryEnd = boundaryLength - 1;
    const bufferLength = data.length;
    let c;
    let cl;
    const mark = (name) => {
      this[name + "Mark"] = i2;
    };
    const clear = (name) => {
      delete this[name + "Mark"];
    };
    const callback = (callbackSymbol, start, end, ui8a) => {
      if (start === undefined || start !== end) {
        this[callbackSymbol](ui8a && ui8a.subarray(start, end));
      }
    };
    const dataCallback = (name, clear2) => {
      const markSymbol = name + "Mark";
      if (!(markSymbol in this)) {
        return;
      }
      if (clear2) {
        callback(name, this[markSymbol], i2, data);
        delete this[markSymbol];
      } else {
        callback(name, this[markSymbol], data.length, data);
        this[markSymbol] = 0;
      }
    };
    for (i2 = 0;i2 < length_; i2++) {
      c = data[i2];
      switch (state) {
        case S.START_BOUNDARY:
          if (index === boundary.length - 2) {
            if (c === HYPHEN) {
              flags |= F.LAST_BOUNDARY;
            } else if (c !== CR) {
              return;
            }
            index++;
            break;
          } else if (index - 1 === boundary.length - 2) {
            if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
              state = S.END;
              flags = 0;
            } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
              index = 0;
              callback("onPartBegin");
              state = S.HEADER_FIELD_START;
            } else {
              return;
            }
            break;
          }
          if (c !== boundary[index + 2]) {
            index = -2;
          }
          if (c === boundary[index + 2]) {
            index++;
          }
          break;
        case S.HEADER_FIELD_START:
          state = S.HEADER_FIELD;
          mark("onHeaderField");
          index = 0;
        case S.HEADER_FIELD:
          if (c === CR) {
            clear("onHeaderField");
            state = S.HEADERS_ALMOST_DONE;
            break;
          }
          index++;
          if (c === HYPHEN) {
            break;
          }
          if (c === COLON) {
            if (index === 1) {
              return;
            }
            dataCallback("onHeaderField", true);
            state = S.HEADER_VALUE_START;
            break;
          }
          cl = lower(c);
          if (cl < A || cl > Z) {
            return;
          }
          break;
        case S.HEADER_VALUE_START:
          if (c === SPACE) {
            break;
          }
          mark("onHeaderValue");
          state = S.HEADER_VALUE;
        case S.HEADER_VALUE:
          if (c === CR) {
            dataCallback("onHeaderValue", true);
            callback("onHeaderEnd");
            state = S.HEADER_VALUE_ALMOST_DONE;
          }
          break;
        case S.HEADER_VALUE_ALMOST_DONE:
          if (c !== LF) {
            return;
          }
          state = S.HEADER_FIELD_START;
          break;
        case S.HEADERS_ALMOST_DONE:
          if (c !== LF) {
            return;
          }
          callback("onHeadersEnd");
          state = S.PART_DATA_START;
          break;
        case S.PART_DATA_START:
          state = S.PART_DATA;
          mark("onPartData");
        case S.PART_DATA:
          previousIndex = index;
          if (index === 0) {
            i2 += boundaryEnd;
            while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
              i2 += boundaryLength;
            }
            i2 -= boundaryEnd;
            c = data[i2];
          }
          if (index < boundary.length) {
            if (boundary[index] === c) {
              if (index === 0) {
                dataCallback("onPartData", true);
              }
              index++;
            } else {
              index = 0;
            }
          } else if (index === boundary.length) {
            index++;
            if (c === CR) {
              flags |= F.PART_BOUNDARY;
            } else if (c === HYPHEN) {
              flags |= F.LAST_BOUNDARY;
            } else {
              index = 0;
            }
          } else if (index - 1 === boundary.length) {
            if (flags & F.PART_BOUNDARY) {
              index = 0;
              if (c === LF) {
                flags &= ~F.PART_BOUNDARY;
                callback("onPartEnd");
                callback("onPartBegin");
                state = S.HEADER_FIELD_START;
                break;
              }
            } else if (flags & F.LAST_BOUNDARY) {
              if (c === HYPHEN) {
                callback("onPartEnd");
                state = S.END;
                flags = 0;
              } else {
                index = 0;
              }
            } else {
              index = 0;
            }
          }
          if (index > 0) {
            lookbehind[index - 1] = c;
          } else if (previousIndex > 0) {
            const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
            callback("onPartData", 0, previousIndex, _lookbehind);
            previousIndex = 0;
            mark("onPartData");
            i2--;
          }
          break;
        case S.END:
          break;
        default:
          throw new Error(`Unexpected state entered: ${state}`);
      }
    }
    dataCallback("onHeaderField");
    dataCallback("onHeaderValue");
    dataCallback("onPartData");
    this.index = index;
    this.state = state;
    this.flags = flags;
  }
  end() {
    if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
      this.onPartEnd();
    } else if (this.state !== S.END) {
      throw new Error("MultipartParser.end(): stream ended unexpectedly");
    }
  }
}
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData;
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s = 0, S, f2 = 1, F, LF = 10, CR = 13, SPACE = 32, HYPHEN = 45, COLON = 58, A = 97, Z = 122, lower = (c) => c | 32, noop = () => {
};
var init_multipart_parser = __esm(() => {
  init_from();
  init_esm_min();
  S = {
    START_BOUNDARY: s++,
    HEADER_FIELD_START: s++,
    HEADER_FIELD: s++,
    HEADER_VALUE_START: s++,
    HEADER_VALUE: s++,
    HEADER_VALUE_ALMOST_DONE: s++,
    HEADERS_ALMOST_DONE: s++,
    PART_DATA_START: s++,
    PART_DATA: s++,
    END: s++
  };
  F = {
    PART_BOUNDARY: f2,
    LAST_BOUNDARY: f2 *= 2
  };
});

// node_modules/node-fetch/src/body.js
import Stream, { PassThrough } from "node:stream";
import { types, deprecate, promisify } from "node:util";
import { Buffer as Buffer2 } from "node:buffer";

class Body {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer2.from(body.toString());
    } else if (isBlob(body)) {
    } else if (Buffer2.isBuffer(body)) {
    } else if (types.isAnyArrayBuffer(body)) {
      body = Buffer2.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer2.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream) {
    } else if (body instanceof FormData) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = Buffer2.from(String(body));
    }
    let stream = body;
    if (Buffer2.isBuffer(body)) {
      stream = Stream.Readable.from(body);
    } else if (isBlob(body)) {
      stream = Stream.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof Stream) {
      body.on("error", (error_) => {
        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData;
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), exports_multipart_parser));
    return toFormData2(this.body, ct);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  buffer() {
    return consumeBody(this);
  }
}
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer2.alloc(0);
  }
  if (!(body instanceof Stream)) {
    return Buffer2.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer2.from(accum.join(""));
      }
      return Buffer2.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var pipeline, INTERNALS, clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough({ highWaterMark });
    p2 = new PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
}, getNonSpecFormDataBoundary, extractContentType = (body, request2) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer2.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData) {
    return `multipart/form-data; boundary=${request2[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof Stream) {
    return null;
  }
  return "text/plain;charset=UTF-8";
}, getTotalBytes = (request2) => {
  const { body } = request2[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer2.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
}, writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};
var init_body = __esm(() => {
  init_fetch_blob();
  init_esm_min();
  init_fetch_error();
  init_base();
  init_is();
  pipeline = promisify(Stream.pipeline);
  INTERNALS = Symbol("Body internals");
  Body.prototype.buffer = deprecate(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true },
    data: { get: deprecate(() => {
    }, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") }
  });
  getNonSpecFormDataBoundary = deprecate((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
});

// node_modules/node-fetch/src/headers.js
import { types as types2 } from "node:util";
import http from "node:http";
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
var validateHeaderName, validateHeaderValue, Headers2;
var init_headers = __esm(() => {
  validateHeaderName = typeof http.validateHeaderName === "function" ? http.validateHeaderName : (name) => {
    if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
      const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
      Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
      throw error;
    }
  };
  validateHeaderValue = typeof http.validateHeaderValue === "function" ? http.validateHeaderValue : (name, value) => {
    if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
      const error = new TypeError(`Invalid character in header content ["${name}"]`);
      Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
      throw error;
    }
  };
  Headers2 = class Headers2 extends URLSearchParams {
    constructor(init) {
      let result = [];
      if (init instanceof Headers2) {
        const raw = init.raw();
        for (const [name, values] of Object.entries(raw)) {
          result.push(...values.map((value) => [name, value]));
        }
      } else if (init == null) {
      } else if (typeof init === "object" && !types2.isBoxedPrimitive(init)) {
        const method = init[Symbol.iterator];
        if (method == null) {
          result.push(...Object.entries(init));
        } else {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          result = [...init].map((pair) => {
            if (typeof pair !== "object" || types2.isBoxedPrimitive(pair)) {
              throw new TypeError("Each header pair must be an iterable object");
            }
            return [...pair];
          }).map((pair) => {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            return [...pair];
          });
        }
      } else {
        throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
      }
      result = result.length > 0 ? result.map(([name, value]) => {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return [String(name).toLowerCase(), String(value)];
      }) : undefined;
      super(result);
      return new Proxy(this, {
        get(target, p, receiver) {
          switch (p) {
            case "append":
            case "set":
              return (name, value) => {
                validateHeaderName(name);
                validateHeaderValue(name, String(value));
                return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
              };
            case "delete":
            case "has":
            case "getAll":
              return (name) => {
                validateHeaderName(name);
                return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
              };
            case "keys":
              return () => {
                target.sort();
                return new Set(URLSearchParams.prototype.keys.call(target)).keys();
              };
            default:
              return Reflect.get(target, p, receiver);
          }
        }
      });
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
    toString() {
      return Object.prototype.toString.call(this);
    }
    get(name) {
      const values = this.getAll(name);
      if (values.length === 0) {
        return null;
      }
      let value = values.join(", ");
      if (/^content-encoding$/i.test(name)) {
        value = value.toLowerCase();
      }
      return value;
    }
    forEach(callback, thisArg = undefined) {
      for (const name of this.keys()) {
        Reflect.apply(callback, thisArg, [this.get(name), name, this]);
      }
    }
    *values() {
      for (const name of this.keys()) {
        yield this.get(name);
      }
    }
    *entries() {
      for (const name of this.keys()) {
        yield [name, this.get(name)];
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    raw() {
      return [...this.keys()].reduce((result, key) => {
        result[key] = this.getAll(key);
        return result;
      }, {});
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return [...this.keys()].reduce((result, key) => {
        const values = this.getAll(key);
        if (key === "host") {
          result[key] = values[0];
        } else {
          result[key] = values.length > 1 ? values : values[0];
        }
        return result;
      }, {});
    }
  };
  Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
    result[property] = { enumerable: true };
    return result;
  }, {}));
});

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus, isRedirect = (code) => {
  return redirectStatus.has(code);
};
var init_is_redirect = __esm(() => {
  redirectStatus = new Set([301, 302, 303, 307, 308]);
});

// node_modules/node-fetch/src/response.js
var INTERNALS2, Response;
var init_response = __esm(() => {
  init_headers();
  init_body();
  init_is_redirect();
  INTERNALS2 = Symbol("Response internals");
  Response = class Response extends Body {
    constructor(body = null, options = {}) {
      super(body, options);
      const status = options.status != null ? options.status : 200;
      const headers = new Headers2(options.headers);
      if (body !== null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body, this);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS2] = {
        type: "default",
        url: options.url,
        status,
        statusText: options.statusText || "",
        headers,
        counter: options.counter,
        highWaterMark: options.highWaterMark
      };
    }
    get type() {
      return this[INTERNALS2].type;
    }
    get url() {
      return this[INTERNALS2].url || "";
    }
    get status() {
      return this[INTERNALS2].status;
    }
    get ok() {
      return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
    }
    get redirected() {
      return this[INTERNALS2].counter > 0;
    }
    get statusText() {
      return this[INTERNALS2].statusText;
    }
    get headers() {
      return this[INTERNALS2].headers;
    }
    get highWaterMark() {
      return this[INTERNALS2].highWaterMark;
    }
    clone() {
      return new Response(clone(this, this.highWaterMark), {
        type: this.type,
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected,
        size: this.size,
        highWaterMark: this.highWaterMark
      });
    }
    static redirect(url, status = 302) {
      if (!isRedirect(status)) {
        throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
      }
      return new Response(null, {
        headers: {
          location: new URL(url).toString()
        },
        status
      });
    }
    static error() {
      const response = new Response(null, { status: 0, statusText: "" });
      response[INTERNALS2].type = "error";
      return response;
    }
    static json(data = undefined, init = {}) {
      const body = JSON.stringify(data);
      if (body === undefined) {
        throw new TypeError("data is not JSON serializable");
      }
      const headers = new Headers2(init && init.headers);
      if (!headers.has("content-type")) {
        headers.set("content-type", "application/json");
      }
      return new Response(body, {
        ...init,
        headers
      });
    }
    get [Symbol.toStringTag]() {
      return "Response";
    }
  };
  Object.defineProperties(Response.prototype, {
    type: { enumerable: true },
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
});

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
import { isIP } from "node:net";
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = isIP(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request2, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request2.referrer === "no-referrer" || request2.referrerPolicy === "") {
    return null;
  }
  const policy = request2.referrerPolicy;
  if (request2.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request2.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request2.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
var ReferrerPolicy, DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
var init_referrer = __esm(() => {
  ReferrerPolicy = new Set([
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ]);
});

// node_modules/node-fetch/src/request.js
import { format as formatUrl } from "node:url";
import { deprecate as deprecate2 } from "node:util";
var INTERNALS3, isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
}, doBadDataWarn, Request, getNodeRequestOptions = (request2) => {
  const { parsedURL } = request2[INTERNALS3];
  const headers = new Headers2(request2[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request2.body === null && /^(post|put)$/i.test(request2.method)) {
    contentLengthValue = "0";
  }
  if (request2.body !== null) {
    const totalBytes = getTotalBytes(request2);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (request2.referrerPolicy === "") {
    request2.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request2.referrer && request2.referrer !== "no-referrer") {
    request2[INTERNALS3].referrer = determineRequestsReferrer(request2);
  } else {
    request2[INTERNALS3].referrer = "no-referrer";
  }
  if (request2[INTERNALS3].referrer instanceof URL) {
    headers.set("Referer", request2.referrer);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request2.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip, deflate, br");
  }
  let { agent } = request2;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  const search = getSearch(parsedURL);
  const options = {
    path: parsedURL.pathname + search,
    method: request2.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request2.insecureHTTPParser,
    agent
  };
  return {
    parsedURL,
    options
  };
};
var init_request2 = __esm(() => {
  init_headers();
  init_body();
  init_is();
  init_referrer();
  INTERNALS3 = Symbol("Request internals");
  doBadDataWarn = deprecate2(() => {
  }, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
  Request = class Request extends Body {
    constructor(input, init = {}) {
      let parsedURL;
      if (isRequest(input)) {
        parsedURL = new URL(input.url);
      } else {
        parsedURL = new URL(input);
        input = {};
      }
      if (parsedURL.username !== "" || parsedURL.password !== "") {
        throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
      }
      let method = init.method || input.method || "GET";
      if (/^(delete|get|head|options|post|put)$/i.test(method)) {
        method = method.toUpperCase();
      }
      if (!isRequest(init) && "data" in init) {
        doBadDataWarn();
      }
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      super(inputBody, {
        size: init.size || input.size || 0
      });
      const headers = new Headers2(init.headers || input.headers || {});
      if (inputBody !== null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody, this);
        if (contentType) {
          headers.set("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init) {
        signal = init.signal;
      }
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
      }
      let referrer = init.referrer == null ? input.referrer : init.referrer;
      if (referrer === "") {
        referrer = "no-referrer";
      } else if (referrer) {
        const parsedReferrer = new URL(referrer);
        referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
      } else {
        referrer = undefined;
      }
      this[INTERNALS3] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal,
        referrer
      };
      this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;
      this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
      this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
      this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
      this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
    }
    get method() {
      return this[INTERNALS3].method;
    }
    get url() {
      return formatUrl(this[INTERNALS3].parsedURL);
    }
    get headers() {
      return this[INTERNALS3].headers;
    }
    get redirect() {
      return this[INTERNALS3].redirect;
    }
    get signal() {
      return this[INTERNALS3].signal;
    }
    get referrer() {
      if (this[INTERNALS3].referrer === "no-referrer") {
        return "";
      }
      if (this[INTERNALS3].referrer === "client") {
        return "about:client";
      }
      if (this[INTERNALS3].referrer) {
        return this[INTERNALS3].referrer.toString();
      }
      return;
    }
    get referrerPolicy() {
      return this[INTERNALS3].referrerPolicy;
    }
    set referrerPolicy(referrerPolicy) {
      this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
    }
    clone() {
      return new Request(this);
    }
    get [Symbol.toStringTag]() {
      return "Request";
    }
  };
  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true },
    referrer: { enumerable: true },
    referrerPolicy: { enumerable: true }
  });
});

// node_modules/node-fetch/src/errors/abort-error.js
var AbortError;
var init_abort_error = __esm(() => {
  init_base();
  AbortError = class AbortError extends FetchBaseError {
    constructor(message, type2 = "aborted") {
      super(message, type2);
    }
  };
});

// node_modules/node-fetch/src/index.js
import http2 from "node:http";
import https from "node:https";
import zlib from "node:zlib";
import Stream2, { PassThrough as PassThrough2, pipeline as pump } from "node:stream";
import { Buffer as Buffer3 } from "node:buffer";
async function fetch2(url, options_) {
  return new Promise((resolve, reject) => {
    const request2 = new Request(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request2);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request2.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? https : http2).request;
    const { signal } = request2;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request2.body && request2.body instanceof Stream2.Readable) {
        request2.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request2.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request2.url);
        } catch {
          if (request2.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request2.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request2.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request2.counter >= request2.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request2.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request2.headers),
              follow: request2.follow,
              counter: request2.counter + 1,
              agent: request2.agent,
              compress: request2.compress,
              method: request2.method,
              body: clone(request2),
              signal: request2.signal,
              size: request2.size,
              referrer: request2.referrer,
              referrerPolicy: request2.referrerPolicy
            };
            if (!isDomainOrSubdomain(request2.url, locationURL) || !isSameProtocol(request2.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request2.body && options_.body instanceof Stream2.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request2.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = undefined;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve(fetch2(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request2.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = pump(response_, new PassThrough2, (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request2.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request2.size,
        counter: request2.counter,
        highWaterMark: request2.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request2.compress || request2.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = pump(body, zlib.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = pump(response_, new PassThrough2, (error) => {
          if (error) {
            reject(error);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = pump(body, zlib.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = pump(body, zlib.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new Response(body, responseOptions);
          resolve(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response(body, responseOptions);
            resolve(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = pump(body, zlib.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve(response);
    });
    writeToStream(request_, request2).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request2, errorCallback) {
  const LAST_CHUNK = Buffer3.from(`0\r
\r
`);
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request2.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request2.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = Buffer3.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer3.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer3.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request2.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}
var supportedSchemas;
var init_src = __esm(() => {
  init_dist();
  init_body();
  init_response();
  init_headers();
  init_request2();
  init_fetch_error();
  init_abort_error();
  init_is_redirect();
  init_esm_min();
  init_is();
  init_referrer();
  init_from();
  supportedSchemas = new Set(["data:", "http:", "https:"]);
});

// src/common/graphql/client.ts
class CustomSetter {
  set(carrier, key, value) {
    carrier.set(key, value);
  }
}
function createGQLClient(port, token) {
  const client = new GraphQLClient(`http://127.0.0.1:${port}/query`, {
    fetch: createFetchWithTimeout(1000 * 60 * 60 * 24 * 7),
    headers: {
      Authorization: "Basic " + Buffer.from(token + ":").toString("base64")
    },
    requestMiddleware: async (req) => {
      opentelemetry3.propagation.inject(opentelemetry3.context.active(), req.headers, new CustomSetter);
      return req;
    }
  });
  return client;
}
var opentelemetry3, createFetchWithTimeout = (timeout) => async (input, init) => {
  if (init?.signal) {
    throw new Error("Internal error: could not create fetch client with timeout");
  }
  const controller = new AbortController;
  const timerId = setTimeout(() => {
    controller.abort();
  }, timeout);
  try {
    return await fetch2(input, {
      ...init,
      signal: controller.signal
    });
  } finally {
    clearTimeout(timerId);
  }
};
var init_client = __esm(() => {
  opentelemetry3 = __toESM(require_src(), 1);
  init_main();
  init_src();
});

// node_modules/adm-zip/util/constants.js
var require_constants4 = __commonJS((exports, module) => {
  module.exports = {
    LOCHDR: 30,
    LOCSIG: 67324752,
    LOCVER: 4,
    LOCFLG: 6,
    LOCHOW: 8,
    LOCTIM: 10,
    LOCCRC: 14,
    LOCSIZ: 18,
    LOCLEN: 22,
    LOCNAM: 26,
    LOCEXT: 28,
    EXTSIG: 134695760,
    EXTHDR: 16,
    EXTCRC: 4,
    EXTSIZ: 8,
    EXTLEN: 12,
    CENHDR: 46,
    CENSIG: 33639248,
    CENVEM: 4,
    CENVER: 6,
    CENFLG: 8,
    CENHOW: 10,
    CENTIM: 12,
    CENCRC: 16,
    CENSIZ: 20,
    CENLEN: 24,
    CENNAM: 28,
    CENEXT: 30,
    CENCOM: 32,
    CENDSK: 34,
    CENATT: 36,
    CENATX: 38,
    CENOFF: 42,
    ENDHDR: 22,
    ENDSIG: 101010256,
    ENDSUB: 8,
    ENDTOT: 10,
    ENDSIZ: 12,
    ENDOFF: 16,
    ENDCOM: 20,
    END64HDR: 20,
    END64SIG: 117853008,
    END64START: 4,
    END64OFF: 8,
    END64NUMDISKS: 16,
    ZIP64SIG: 101075792,
    ZIP64HDR: 56,
    ZIP64LEAD: 12,
    ZIP64SIZE: 4,
    ZIP64VEM: 12,
    ZIP64VER: 14,
    ZIP64DSK: 16,
    ZIP64DSKDIR: 20,
    ZIP64SUB: 24,
    ZIP64TOT: 32,
    ZIP64SIZB: 40,
    ZIP64OFF: 48,
    ZIP64EXTRA: 56,
    STORED: 0,
    SHRUNK: 1,
    REDUCED1: 2,
    REDUCED2: 3,
    REDUCED3: 4,
    REDUCED4: 5,
    IMPLODED: 6,
    DEFLATED: 8,
    ENHANCED_DEFLATED: 9,
    PKWARE: 10,
    BZIP2: 12,
    LZMA: 14,
    IBM_TERSE: 18,
    IBM_LZ77: 19,
    AES_ENCRYPT: 99,
    FLG_ENC: 1,
    FLG_COMP1: 2,
    FLG_COMP2: 4,
    FLG_DESC: 8,
    FLG_ENH: 16,
    FLG_PATCH: 32,
    FLG_STR: 64,
    FLG_EFS: 2048,
    FLG_MSK: 4096,
    FILE: 2,
    BUFFER: 1,
    NONE: 0,
    EF_ID: 0,
    EF_SIZE: 2,
    ID_ZIP64: 1,
    ID_AVINFO: 7,
    ID_PFS: 8,
    ID_OS2: 9,
    ID_NTFS: 10,
    ID_OPENVMS: 12,
    ID_UNIX: 13,
    ID_FORK: 14,
    ID_PATCH: 15,
    ID_X509_PKCS7: 20,
    ID_X509_CERTID_F: 21,
    ID_X509_CERTID_C: 22,
    ID_STRONGENC: 23,
    ID_RECORD_MGT: 24,
    ID_X509_PKCS7_RL: 25,
    ID_IBM1: 101,
    ID_IBM2: 102,
    ID_POSZIP: 18064,
    EF_ZIP64_OR_32: 4294967295,
    EF_ZIP64_OR_16: 65535,
    EF_ZIP64_SUNCOMP: 0,
    EF_ZIP64_SCOMP: 8,
    EF_ZIP64_RHO: 16,
    EF_ZIP64_DSN: 24
  };
});

// node_modules/adm-zip/util/errors.js
var require_errors = __commonJS((exports) => {
  var errors = {
    INVALID_LOC: "Invalid LOC header (bad signature)",
    INVALID_CEN: "Invalid CEN header (bad signature)",
    INVALID_END: "Invalid END header (bad signature)",
    DESCRIPTOR_NOT_EXIST: "No descriptor present",
    DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
    DESCRIPTOR_FAULTY: "Descriptor data is malformed",
    NO_DATA: "Nothing to decompress",
    BAD_CRC: "CRC32 checksum failed {0}",
    FILE_IN_THE_WAY: "There is a file in the way: {0}",
    UNKNOWN_METHOD: "Invalid/unsupported compression method",
    AVAIL_DATA: "inflate::Available inflate data did not terminate",
    INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
    INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
    INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
    INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
    INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
    INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
    INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
    INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
    CANT_EXTRACT_FILE: "Could not extract the file",
    CANT_OVERRIDE: "Target file already exists",
    DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
    NO_ZIP: "No zip file was loaded",
    NO_ENTRY: "Entry doesn't exist",
    DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
    FILE_NOT_FOUND: 'File not found: "{0}"',
    NOT_IMPLEMENTED: "Not implemented",
    INVALID_FILENAME: "Invalid filename",
    INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
    INVALID_PASS_PARAM: "Incompatible password parameter",
    WRONG_PASSWORD: "Wrong Password",
    COMMENT_TOO_LONG: "Comment is too long",
    EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
  };
  function E(message) {
    return function(...args) {
      if (args.length) {
        message = message.replace(/\{(\d)\}/g, (_, n) => args[n] || "");
      }
      return new Error("ADM-ZIP: " + message);
    };
  }
  for (const msg of Object.keys(errors)) {
    exports[msg] = E(errors[msg]);
  }
});

// node_modules/adm-zip/util/utils.js
var require_utils12 = __commonJS((exports, module) => {
  var fsystem = __require("fs");
  var pth = __require("path");
  var Constants = require_constants4();
  var Errors = require_errors();
  var isWin = typeof process === "object" && process.platform === "win32";
  var is_Obj = (obj) => typeof obj === "object" && obj !== null;
  var crcTable = new Uint32Array(256).map((t2, c) => {
    for (let k = 0;k < 8; k++) {
      if ((c & 1) !== 0) {
        c = 3988292384 ^ c >>> 1;
      } else {
        c >>>= 1;
      }
    }
    return c >>> 0;
  });
  function Utils(opts) {
    this.sep = pth.sep;
    this.fs = fsystem;
    if (is_Obj(opts)) {
      if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
        this.fs = opts.fs;
      }
    }
  }
  module.exports = Utils;
  Utils.prototype.makeDir = function(folder) {
    const self2 = this;
    function mkdirSync(fpath) {
      let resolvedPath = fpath.split(self2.sep)[0];
      fpath.split(self2.sep).forEach(function(name) {
        if (!name || name.substr(-1, 1) === ":")
          return;
        resolvedPath += self2.sep + name;
        var stat2;
        try {
          stat2 = self2.fs.statSync(resolvedPath);
        } catch (e2) {
          self2.fs.mkdirSync(resolvedPath);
        }
        if (stat2 && stat2.isFile())
          throw Errors.FILE_IN_THE_WAY(`"${resolvedPath}"`);
      });
    }
    mkdirSync(folder);
  };
  Utils.prototype.writeFileTo = function(path, content, overwrite, attr) {
    const self2 = this;
    if (self2.fs.existsSync(path)) {
      if (!overwrite)
        return false;
      var stat2 = self2.fs.statSync(path);
      if (stat2.isDirectory()) {
        return false;
      }
    }
    var folder = pth.dirname(path);
    if (!self2.fs.existsSync(folder)) {
      self2.makeDir(folder);
    }
    var fd;
    try {
      fd = self2.fs.openSync(path, "w", 438);
    } catch (e2) {
      self2.fs.chmodSync(path, 438);
      fd = self2.fs.openSync(path, "w", 438);
    }
    if (fd) {
      try {
        self2.fs.writeSync(fd, content, 0, content.length, 0);
      } finally {
        self2.fs.closeSync(fd);
      }
    }
    self2.fs.chmodSync(path, attr || 438);
    return true;
  };
  Utils.prototype.writeFileToAsync = function(path, content, overwrite, attr, callback) {
    if (typeof attr === "function") {
      callback = attr;
      attr = undefined;
    }
    const self2 = this;
    self2.fs.exists(path, function(exist) {
      if (exist && !overwrite)
        return callback(false);
      self2.fs.stat(path, function(err, stat2) {
        if (exist && stat2.isDirectory()) {
          return callback(false);
        }
        var folder = pth.dirname(path);
        self2.fs.exists(folder, function(exists) {
          if (!exists)
            self2.makeDir(folder);
          self2.fs.open(path, "w", 438, function(err2, fd) {
            if (err2) {
              self2.fs.chmod(path, 438, function() {
                self2.fs.open(path, "w", 438, function(err3, fd2) {
                  self2.fs.write(fd2, content, 0, content.length, 0, function() {
                    self2.fs.close(fd2, function() {
                      self2.fs.chmod(path, attr || 438, function() {
                        callback(true);
                      });
                    });
                  });
                });
              });
            } else if (fd) {
              self2.fs.write(fd, content, 0, content.length, 0, function() {
                self2.fs.close(fd, function() {
                  self2.fs.chmod(path, attr || 438, function() {
                    callback(true);
                  });
                });
              });
            } else {
              self2.fs.chmod(path, attr || 438, function() {
                callback(true);
              });
            }
          });
        });
      });
    });
  };
  Utils.prototype.findFiles = function(path) {
    const self2 = this;
    function findSync(dir, pattern, recursive) {
      if (typeof pattern === "boolean") {
        recursive = pattern;
        pattern = undefined;
      }
      let files2 = [];
      self2.fs.readdirSync(dir).forEach(function(file) {
        const path2 = pth.join(dir, file);
        const stat2 = self2.fs.statSync(path2);
        if (!pattern || pattern.test(path2)) {
          files2.push(pth.normalize(path2) + (stat2.isDirectory() ? self2.sep : ""));
        }
        if (stat2.isDirectory() && recursive)
          files2 = files2.concat(findSync(path2, pattern, recursive));
      });
      return files2;
    }
    return findSync(path, undefined, true);
  };
  Utils.prototype.findFilesAsync = function(dir, cb) {
    const self2 = this;
    let results = [];
    self2.fs.readdir(dir, function(err, list) {
      if (err)
        return cb(err);
      let list_length = list.length;
      if (!list_length)
        return cb(null, results);
      list.forEach(function(file) {
        file = pth.join(dir, file);
        self2.fs.stat(file, function(err2, stat2) {
          if (err2)
            return cb(err2);
          if (stat2) {
            results.push(pth.normalize(file) + (stat2.isDirectory() ? self2.sep : ""));
            if (stat2.isDirectory()) {
              self2.findFilesAsync(file, function(err3, res) {
                if (err3)
                  return cb(err3);
                results = results.concat(res);
                if (!--list_length)
                  cb(null, results);
              });
            } else {
              if (!--list_length)
                cb(null, results);
            }
          }
        });
      });
    });
  };
  Utils.prototype.getAttributes = function() {
  };
  Utils.prototype.setAttributes = function() {
  };
  Utils.crc32update = function(crc, byte) {
    return crcTable[(crc ^ byte) & 255] ^ crc >>> 8;
  };
  Utils.crc32 = function(buf) {
    if (typeof buf === "string") {
      buf = Buffer.from(buf, "utf8");
    }
    let len = buf.length;
    let crc = ~0;
    for (let off = 0;off < len; )
      crc = Utils.crc32update(crc, buf[off++]);
    return ~crc >>> 0;
  };
  Utils.methodToString = function(method) {
    switch (method) {
      case Constants.STORED:
        return "STORED (" + method + ")";
      case Constants.DEFLATED:
        return "DEFLATED (" + method + ")";
      default:
        return "UNSUPPORTED (" + method + ")";
    }
  };
  Utils.canonical = function(path) {
    if (!path)
      return "";
    const safeSuffix = pth.posix.normalize("/" + path.split("\\").join("/"));
    return pth.join(".", safeSuffix);
  };
  Utils.zipnamefix = function(path) {
    if (!path)
      return "";
    const safeSuffix = pth.posix.normalize("/" + path.split("\\").join("/"));
    return pth.posix.join(".", safeSuffix);
  };
  Utils.findLast = function(arr, callback) {
    if (!Array.isArray(arr))
      throw new TypeError("arr is not array");
    const len = arr.length >>> 0;
    for (let i2 = len - 1;i2 >= 0; i2--) {
      if (callback(arr[i2], i2, arr)) {
        return arr[i2];
      }
    }
    return;
  };
  Utils.sanitize = function(prefix, name) {
    prefix = pth.resolve(pth.normalize(prefix));
    var parts = name.split("/");
    for (var i2 = 0, l = parts.length;i2 < l; i2++) {
      var path = pth.normalize(pth.join(prefix, parts.slice(i2, l).join(pth.sep)));
      if (path.indexOf(prefix) === 0) {
        return path;
      }
    }
    return pth.normalize(pth.join(prefix, pth.basename(name)));
  };
  Utils.toBuffer = function toBuffer(input, encoder) {
    if (Buffer.isBuffer(input)) {
      return input;
    } else if (input instanceof Uint8Array) {
      return Buffer.from(input);
    } else {
      return typeof input === "string" ? encoder(input) : Buffer.alloc(0);
    }
  };
  Utils.readBigUInt64LE = function(buffer, index) {
    var slice = Buffer.from(buffer.slice(index, index + 8));
    slice.swap64();
    return parseInt(`0x${slice.toString("hex")}`);
  };
  Utils.fromDOS2Date = function(val) {
    return new Date((val >> 25 & 127) + 1980, Math.max((val >> 21 & 15) - 1, 0), Math.max(val >> 16 & 31, 1), val >> 11 & 31, val >> 5 & 63, (val & 31) << 1);
  };
  Utils.fromDate2DOS = function(val) {
    let date = 0;
    let time = 0;
    if (val.getFullYear() > 1979) {
      date = (val.getFullYear() - 1980 & 127) << 9 | val.getMonth() + 1 << 5 | val.getDate();
      time = val.getHours() << 11 | val.getMinutes() << 5 | val.getSeconds() >> 1;
    }
    return date << 16 | time;
  };
  Utils.isWin = isWin;
  Utils.crcTable = crcTable;
});

// node_modules/adm-zip/util/fattr.js
var require_fattr = __commonJS((exports, module) => {
  var pth = __require("path");
  module.exports = function(path, { fs: fs2 }) {
    var _path = path || "", _obj = newAttr(), _stat = null;
    function newAttr() {
      return {
        directory: false,
        readonly: false,
        hidden: false,
        executable: false,
        mtime: 0,
        atime: 0
      };
    }
    if (_path && fs2.existsSync(_path)) {
      _stat = fs2.statSync(_path);
      _obj.directory = _stat.isDirectory();
      _obj.mtime = _stat.mtime;
      _obj.atime = _stat.atime;
      _obj.executable = (73 & _stat.mode) !== 0;
      _obj.readonly = (128 & _stat.mode) === 0;
      _obj.hidden = pth.basename(_path)[0] === ".";
    } else {
      console.warn("Invalid path: " + _path);
    }
    return {
      get directory() {
        return _obj.directory;
      },
      get readOnly() {
        return _obj.readonly;
      },
      get hidden() {
        return _obj.hidden;
      },
      get mtime() {
        return _obj.mtime;
      },
      get atime() {
        return _obj.atime;
      },
      get executable() {
        return _obj.executable;
      },
      decodeAttributes: function() {
      },
      encodeAttributes: function() {
      },
      toJSON: function() {
        return {
          path: _path,
          isDirectory: _obj.directory,
          isReadOnly: _obj.readonly,
          isHidden: _obj.hidden,
          isExecutable: _obj.executable,
          mTime: _obj.mtime,
          aTime: _obj.atime
        };
      },
      toString: function() {
        return JSON.stringify(this.toJSON(), null, "\t");
      }
    };
  };
});

// node_modules/adm-zip/util/decoder.js
var require_decoder2 = __commonJS((exports, module) => {
  module.exports = {
    efs: true,
    encode: (data) => Buffer.from(data, "utf8"),
    decode: (data) => data.toString("utf8")
  };
});

// node_modules/adm-zip/util/index.js
var require_util6 = __commonJS((exports, module) => {
  module.exports = require_utils12();
  module.exports.Constants = require_constants4();
  module.exports.Errors = require_errors();
  module.exports.FileAttr = require_fattr();
  module.exports.decoder = require_decoder2();
});

// node_modules/adm-zip/headers/entryHeader.js
var require_entryHeader = __commonJS((exports, module) => {
  var Utils = require_util6();
  var Constants = Utils.Constants;
  module.exports = function() {
    var _verMade = 20, _version = 10, _flags = 0, _method = 0, _time = 0, _crc = 0, _compressedSize = 0, _size = 0, _fnameLen = 0, _extraLen = 0, _comLen = 0, _diskStart = 0, _inattr = 0, _attr = 0, _offset = 0;
    _verMade |= Utils.isWin ? 2560 : 768;
    _flags |= Constants.FLG_EFS;
    const _localHeader = {
      extraLen: 0
    };
    const uint32 = (val) => Math.max(0, val) >>> 0;
    const uint16 = (val) => Math.max(0, val) & 65535;
    const uint8 = (val) => Math.max(0, val) & 255;
    _time = Utils.fromDate2DOS(new Date);
    return {
      get made() {
        return _verMade;
      },
      set made(val) {
        _verMade = val;
      },
      get version() {
        return _version;
      },
      set version(val) {
        _version = val;
      },
      get flags() {
        return _flags;
      },
      set flags(val) {
        _flags = val;
      },
      get flags_efs() {
        return (_flags & Constants.FLG_EFS) > 0;
      },
      set flags_efs(val) {
        if (val) {
          _flags |= Constants.FLG_EFS;
        } else {
          _flags &= ~Constants.FLG_EFS;
        }
      },
      get flags_desc() {
        return (_flags & Constants.FLG_DESC) > 0;
      },
      set flags_desc(val) {
        if (val) {
          _flags |= Constants.FLG_DESC;
        } else {
          _flags &= ~Constants.FLG_DESC;
        }
      },
      get method() {
        return _method;
      },
      set method(val) {
        switch (val) {
          case Constants.STORED:
            this.version = 10;
          case Constants.DEFLATED:
          default:
            this.version = 20;
        }
        _method = val;
      },
      get time() {
        return Utils.fromDOS2Date(this.timeval);
      },
      set time(val) {
        this.timeval = Utils.fromDate2DOS(val);
      },
      get timeval() {
        return _time;
      },
      set timeval(val) {
        _time = uint32(val);
      },
      get timeHighByte() {
        return uint8(_time >>> 8);
      },
      get crc() {
        return _crc;
      },
      set crc(val) {
        _crc = uint32(val);
      },
      get compressedSize() {
        return _compressedSize;
      },
      set compressedSize(val) {
        _compressedSize = uint32(val);
      },
      get size() {
        return _size;
      },
      set size(val) {
        _size = uint32(val);
      },
      get fileNameLength() {
        return _fnameLen;
      },
      set fileNameLength(val) {
        _fnameLen = val;
      },
      get extraLength() {
        return _extraLen;
      },
      set extraLength(val) {
        _extraLen = val;
      },
      get extraLocalLength() {
        return _localHeader.extraLen;
      },
      set extraLocalLength(val) {
        _localHeader.extraLen = val;
      },
      get commentLength() {
        return _comLen;
      },
      set commentLength(val) {
        _comLen = val;
      },
      get diskNumStart() {
        return _diskStart;
      },
      set diskNumStart(val) {
        _diskStart = uint32(val);
      },
      get inAttr() {
        return _inattr;
      },
      set inAttr(val) {
        _inattr = uint32(val);
      },
      get attr() {
        return _attr;
      },
      set attr(val) {
        _attr = uint32(val);
      },
      get fileAttr() {
        return (_attr || 0) >> 16 & 4095;
      },
      get offset() {
        return _offset;
      },
      set offset(val) {
        _offset = uint32(val);
      },
      get encrypted() {
        return (_flags & Constants.FLG_ENC) === Constants.FLG_ENC;
      },
      get centralHeaderSize() {
        return Constants.CENHDR + _fnameLen + _extraLen + _comLen;
      },
      get realDataOffset() {
        return _offset + Constants.LOCHDR + _localHeader.fnameLen + _localHeader.extraLen;
      },
      get localHeader() {
        return _localHeader;
      },
      loadLocalHeaderFromBinary: function(input) {
        var data = input.slice(_offset, _offset + Constants.LOCHDR);
        if (data.readUInt32LE(0) !== Constants.LOCSIG) {
          throw Utils.Errors.INVALID_LOC();
        }
        _localHeader.version = data.readUInt16LE(Constants.LOCVER);
        _localHeader.flags = data.readUInt16LE(Constants.LOCFLG);
        _localHeader.method = data.readUInt16LE(Constants.LOCHOW);
        _localHeader.time = data.readUInt32LE(Constants.LOCTIM);
        _localHeader.crc = data.readUInt32LE(Constants.LOCCRC);
        _localHeader.compressedSize = data.readUInt32LE(Constants.LOCSIZ);
        _localHeader.size = data.readUInt32LE(Constants.LOCLEN);
        _localHeader.fnameLen = data.readUInt16LE(Constants.LOCNAM);
        _localHeader.extraLen = data.readUInt16LE(Constants.LOCEXT);
        const extraStart = _offset + Constants.LOCHDR + _localHeader.fnameLen;
        const extraEnd = extraStart + _localHeader.extraLen;
        return input.slice(extraStart, extraEnd);
      },
      loadFromBinary: function(data) {
        if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {
          throw Utils.Errors.INVALID_CEN();
        }
        _verMade = data.readUInt16LE(Constants.CENVEM);
        _version = data.readUInt16LE(Constants.CENVER);
        _flags = data.readUInt16LE(Constants.CENFLG);
        _method = data.readUInt16LE(Constants.CENHOW);
        _time = data.readUInt32LE(Constants.CENTIM);
        _crc = data.readUInt32LE(Constants.CENCRC);
        _compressedSize = data.readUInt32LE(Constants.CENSIZ);
        _size = data.readUInt32LE(Constants.CENLEN);
        _fnameLen = data.readUInt16LE(Constants.CENNAM);
        _extraLen = data.readUInt16LE(Constants.CENEXT);
        _comLen = data.readUInt16LE(Constants.CENCOM);
        _diskStart = data.readUInt16LE(Constants.CENDSK);
        _inattr = data.readUInt16LE(Constants.CENATT);
        _attr = data.readUInt32LE(Constants.CENATX);
        _offset = data.readUInt32LE(Constants.CENOFF);
      },
      localHeaderToBinary: function() {
        var data = Buffer.alloc(Constants.LOCHDR);
        data.writeUInt32LE(Constants.LOCSIG, 0);
        data.writeUInt16LE(_version, Constants.LOCVER);
        data.writeUInt16LE(_flags, Constants.LOCFLG);
        data.writeUInt16LE(_method, Constants.LOCHOW);
        data.writeUInt32LE(_time, Constants.LOCTIM);
        data.writeUInt32LE(_crc, Constants.LOCCRC);
        data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);
        data.writeUInt32LE(_size, Constants.LOCLEN);
        data.writeUInt16LE(_fnameLen, Constants.LOCNAM);
        data.writeUInt16LE(_localHeader.extraLen, Constants.LOCEXT);
        return data;
      },
      centralHeaderToBinary: function() {
        var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);
        data.writeUInt32LE(Constants.CENSIG, 0);
        data.writeUInt16LE(_verMade, Constants.CENVEM);
        data.writeUInt16LE(_version, Constants.CENVER);
        data.writeUInt16LE(_flags, Constants.CENFLG);
        data.writeUInt16LE(_method, Constants.CENHOW);
        data.writeUInt32LE(_time, Constants.CENTIM);
        data.writeUInt32LE(_crc, Constants.CENCRC);
        data.writeUInt32LE(_compressedSize, Constants.CENSIZ);
        data.writeUInt32LE(_size, Constants.CENLEN);
        data.writeUInt16LE(_fnameLen, Constants.CENNAM);
        data.writeUInt16LE(_extraLen, Constants.CENEXT);
        data.writeUInt16LE(_comLen, Constants.CENCOM);
        data.writeUInt16LE(_diskStart, Constants.CENDSK);
        data.writeUInt16LE(_inattr, Constants.CENATT);
        data.writeUInt32LE(_attr, Constants.CENATX);
        data.writeUInt32LE(_offset, Constants.CENOFF);
        return data;
      },
      toJSON: function() {
        const bytes = function(nr) {
          return nr + " bytes";
        };
        return {
          made: _verMade,
          version: _version,
          flags: _flags,
          method: Utils.methodToString(_method),
          time: this.time,
          crc: "0x" + _crc.toString(16).toUpperCase(),
          compressedSize: bytes(_compressedSize),
          size: bytes(_size),
          fileNameLength: bytes(_fnameLen),
          extraLength: bytes(_extraLen),
          commentLength: bytes(_comLen),
          diskNumStart: _diskStart,
          inAttr: _inattr,
          attr: _attr,
          offset: _offset,
          centralHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)
        };
      },
      toString: function() {
        return JSON.stringify(this.toJSON(), null, "\t");
      }
    };
  };
});

// node_modules/adm-zip/headers/mainHeader.js
var require_mainHeader = __commonJS((exports, module) => {
  var Utils = require_util6();
  var Constants = Utils.Constants;
  module.exports = function() {
    var _volumeEntries = 0, _totalEntries = 0, _size = 0, _offset = 0, _commentLength = 0;
    return {
      get diskEntries() {
        return _volumeEntries;
      },
      set diskEntries(val) {
        _volumeEntries = _totalEntries = val;
      },
      get totalEntries() {
        return _totalEntries;
      },
      set totalEntries(val) {
        _totalEntries = _volumeEntries = val;
      },
      get size() {
        return _size;
      },
      set size(val) {
        _size = val;
      },
      get offset() {
        return _offset;
      },
      set offset(val) {
        _offset = val;
      },
      get commentLength() {
        return _commentLength;
      },
      set commentLength(val) {
        _commentLength = val;
      },
      get mainHeaderSize() {
        return Constants.ENDHDR + _commentLength;
      },
      loadFromBinary: function(data) {
        if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) && (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {
          throw Utils.Errors.INVALID_END();
        }
        if (data.readUInt32LE(0) === Constants.ENDSIG) {
          _volumeEntries = data.readUInt16LE(Constants.ENDSUB);
          _totalEntries = data.readUInt16LE(Constants.ENDTOT);
          _size = data.readUInt32LE(Constants.ENDSIZ);
          _offset = data.readUInt32LE(Constants.ENDOFF);
          _commentLength = data.readUInt16LE(Constants.ENDCOM);
        } else {
          _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);
          _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);
          _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);
          _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);
          _commentLength = 0;
        }
      },
      toBinary: function() {
        var b = Buffer.alloc(Constants.ENDHDR + _commentLength);
        b.writeUInt32LE(Constants.ENDSIG, 0);
        b.writeUInt32LE(0, 4);
        b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);
        b.writeUInt16LE(_totalEntries, Constants.ENDTOT);
        b.writeUInt32LE(_size, Constants.ENDSIZ);
        b.writeUInt32LE(_offset, Constants.ENDOFF);
        b.writeUInt16LE(_commentLength, Constants.ENDCOM);
        b.fill(" ", Constants.ENDHDR);
        return b;
      },
      toJSON: function() {
        const offset = function(nr, len) {
          let offs = nr.toString(16).toUpperCase();
          while (offs.length < len)
            offs = "0" + offs;
          return "0x" + offs;
        };
        return {
          diskEntries: _volumeEntries,
          totalEntries: _totalEntries,
          size: _size + " bytes",
          offset: offset(_offset, 4),
          commentLength: _commentLength
        };
      },
      toString: function() {
        return JSON.stringify(this.toJSON(), null, "\t");
      }
    };
  };
});

// node_modules/adm-zip/headers/index.js
var require_headers = __commonJS((exports) => {
  exports.EntryHeader = require_entryHeader();
  exports.MainHeader = require_mainHeader();
});

// node_modules/adm-zip/methods/deflater.js
var require_deflater = __commonJS((exports, module) => {
  module.exports = function(inbuf) {
    var zlib2 = __require("zlib");
    var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };
    return {
      deflate: function() {
        return zlib2.deflateRawSync(inbuf, opts);
      },
      deflateAsync: function(callback) {
        var tmp = zlib2.createDeflateRaw(opts), parts = [], total = 0;
        tmp.on("data", function(data) {
          parts.push(data);
          total += data.length;
        });
        tmp.on("end", function() {
          var buf = Buffer.alloc(total), written = 0;
          buf.fill(0);
          for (var i2 = 0;i2 < parts.length; i2++) {
            var part = parts[i2];
            part.copy(buf, written);
            written += part.length;
          }
          callback && callback(buf);
        });
        tmp.end(inbuf);
      }
    };
  };
});

// node_modules/adm-zip/methods/inflater.js
var require_inflater = __commonJS((exports, module) => {
  var version = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
  module.exports = function(inbuf, expectedLength) {
    var zlib2 = __require("zlib");
    const option = version >= 15 && expectedLength > 0 ? { maxOutputLength: expectedLength } : {};
    return {
      inflate: function() {
        return zlib2.inflateRawSync(inbuf, option);
      },
      inflateAsync: function(callback) {
        var tmp = zlib2.createInflateRaw(option), parts = [], total = 0;
        tmp.on("data", function(data) {
          parts.push(data);
          total += data.length;
        });
        tmp.on("end", function() {
          var buf = Buffer.alloc(total), written = 0;
          buf.fill(0);
          for (var i2 = 0;i2 < parts.length; i2++) {
            var part = parts[i2];
            part.copy(buf, written);
            written += part.length;
          }
          callback && callback(buf);
        });
        tmp.end(inbuf);
      }
    };
  };
});

// node_modules/adm-zip/methods/zipcrypto.js
var require_zipcrypto = __commonJS((exports, module) => {
  var { randomFillSync } = __require("crypto");
  var Errors = require_errors();
  var crctable = new Uint32Array(256).map((t2, crc) => {
    for (let j = 0;j < 8; j++) {
      if ((crc & 1) !== 0) {
        crc = crc >>> 1 ^ 3988292384;
      } else {
        crc >>>= 1;
      }
    }
    return crc >>> 0;
  });
  var uMul = (a, b) => Math.imul(a, b) >>> 0;
  var crc32update = (pCrc32, bval) => {
    return crctable[(pCrc32 ^ bval) & 255] ^ pCrc32 >>> 8;
  };
  var genSalt = () => {
    if (typeof randomFillSync === "function") {
      return randomFillSync(Buffer.alloc(12));
    } else {
      return genSalt.node();
    }
  };
  genSalt.node = () => {
    const salt = Buffer.alloc(12);
    const len = salt.length;
    for (let i2 = 0;i2 < len; i2++)
      salt[i2] = Math.random() * 256 & 255;
    return salt;
  };
  var config = {
    genSalt
  };
  function Initkeys(pw) {
    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
    this.keys = new Uint32Array([305419896, 591751049, 878082192]);
    for (let i2 = 0;i2 < pass.length; i2++) {
      this.updateKeys(pass[i2]);
    }
  }
  Initkeys.prototype.updateKeys = function(byteValue) {
    const keys = this.keys;
    keys[0] = crc32update(keys[0], byteValue);
    keys[1] += keys[0] & 255;
    keys[1] = uMul(keys[1], 134775813) + 1;
    keys[2] = crc32update(keys[2], keys[1] >>> 24);
    return byteValue;
  };
  Initkeys.prototype.next = function() {
    const k = (this.keys[2] | 2) >>> 0;
    return uMul(k, k ^ 1) >> 8 & 255;
  };
  function make_decrypter(pwd) {
    const keys = new Initkeys(pwd);
    return function(data) {
      const result = Buffer.alloc(data.length);
      let pos = 0;
      for (let c of data) {
        result[pos++] = keys.updateKeys(c ^ keys.next());
      }
      return result;
    };
  }
  function make_encrypter(pwd) {
    const keys = new Initkeys(pwd);
    return function(data, result, pos = 0) {
      if (!result)
        result = Buffer.alloc(data.length);
      for (let c of data) {
        const k = keys.next();
        result[pos++] = c ^ k;
        keys.updateKeys(c);
      }
      return result;
    };
  }
  function decrypt(data, header, pwd) {
    if (!data || !Buffer.isBuffer(data) || data.length < 12) {
      return Buffer.alloc(0);
    }
    const decrypter = make_decrypter(pwd);
    const salt = decrypter(data.slice(0, 12));
    const verifyByte = (header.flags & 8) === 8 ? header.timeHighByte : header.crc >>> 24;
    if (salt[11] !== verifyByte) {
      throw Errors.WRONG_PASSWORD();
    }
    return decrypter(data.slice(12));
  }
  function _salter(data) {
    if (Buffer.isBuffer(data) && data.length >= 12) {
      config.genSalt = function() {
        return data.slice(0, 12);
      };
    } else if (data === "node") {
      config.genSalt = genSalt.node;
    } else {
      config.genSalt = genSalt;
    }
  }
  function encrypt(data, header, pwd, oldlike = false) {
    if (data == null)
      data = Buffer.alloc(0);
    if (!Buffer.isBuffer(data))
      data = Buffer.from(data.toString());
    const encrypter = make_encrypter(pwd);
    const salt = config.genSalt();
    salt[11] = header.crc >>> 24 & 255;
    if (oldlike)
      salt[10] = header.crc >>> 16 & 255;
    const result = Buffer.alloc(data.length + 12);
    encrypter(salt, result);
    return encrypter(data, result, 12);
  }
  module.exports = { decrypt, encrypt, _salter };
});

// node_modules/adm-zip/methods/index.js
var require_methods = __commonJS((exports) => {
  exports.Deflater = require_deflater();
  exports.Inflater = require_inflater();
  exports.ZipCrypto = require_zipcrypto();
});

// node_modules/adm-zip/zipEntry.js
var require_zipEntry = __commonJS((exports, module) => {
  var Utils = require_util6();
  var Headers3 = require_headers();
  var Constants = Utils.Constants;
  var Methods = require_methods();
  module.exports = function(options, input) {
    var _centralHeader = new Headers3.EntryHeader, _entryName = Buffer.alloc(0), _comment = Buffer.alloc(0), _isDirectory = false, uncompressedData = null, _extra = Buffer.alloc(0), _extralocal = Buffer.alloc(0), _efs = true;
    const opts = options;
    const decoder = typeof opts.decoder === "object" ? opts.decoder : Utils.decoder;
    _efs = decoder.hasOwnProperty("efs") ? decoder.efs : false;
    function getCompressedDataFromZip() {
      if (!input || !(input instanceof Uint8Array)) {
        return Buffer.alloc(0);
      }
      _extralocal = _centralHeader.loadLocalHeaderFromBinary(input);
      return input.slice(_centralHeader.realDataOffset, _centralHeader.realDataOffset + _centralHeader.compressedSize);
    }
    function crc32OK(data) {
      if (!_centralHeader.flags_desc) {
        if (Utils.crc32(data) !== _centralHeader.localHeader.crc) {
          return false;
        }
      } else {
        const descriptor = {};
        const dataEndOffset = _centralHeader.realDataOffset + _centralHeader.compressedSize;
        if (input.readUInt32LE(dataEndOffset) == Constants.LOCSIG || input.readUInt32LE(dataEndOffset) == Constants.CENSIG) {
          throw Utils.Errors.DESCRIPTOR_NOT_EXIST();
        }
        if (input.readUInt32LE(dataEndOffset) == Constants.EXTSIG) {
          descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC);
          descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ);
          descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN);
        } else if (input.readUInt16LE(dataEndOffset + 12) === 19280) {
          descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC - 4);
          descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ - 4);
          descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN - 4);
        } else {
          throw Utils.Errors.DESCRIPTOR_UNKNOWN();
        }
        if (descriptor.compressedSize !== _centralHeader.compressedSize || descriptor.size !== _centralHeader.size || descriptor.crc !== _centralHeader.crc) {
          throw Utils.Errors.DESCRIPTOR_FAULTY();
        }
        if (Utils.crc32(data) !== descriptor.crc) {
          return false;
        }
      }
      return true;
    }
    function decompress(async, callback, pass) {
      if (typeof callback === "undefined" && typeof async === "string") {
        pass = async;
        async = undefined;
      }
      if (_isDirectory) {
        if (async && callback) {
          callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR());
        }
        return Buffer.alloc(0);
      }
      var compressedData = getCompressedDataFromZip();
      if (compressedData.length === 0) {
        if (async && callback)
          callback(compressedData);
        return compressedData;
      }
      if (_centralHeader.encrypted) {
        if (typeof pass !== "string" && !Buffer.isBuffer(pass)) {
          throw Utils.Errors.INVALID_PASS_PARAM();
        }
        compressedData = Methods.ZipCrypto.decrypt(compressedData, _centralHeader, pass);
      }
      var data = Buffer.alloc(_centralHeader.size);
      switch (_centralHeader.method) {
        case Utils.Constants.STORED:
          compressedData.copy(data);
          if (!crc32OK(data)) {
            if (async && callback)
              callback(data, Utils.Errors.BAD_CRC());
            throw Utils.Errors.BAD_CRC();
          } else {
            if (async && callback)
              callback(data);
            return data;
          }
        case Utils.Constants.DEFLATED:
          var inflater = new Methods.Inflater(compressedData, _centralHeader.size);
          if (!async) {
            const result = inflater.inflate(data);
            result.copy(data, 0);
            if (!crc32OK(data)) {
              throw Utils.Errors.BAD_CRC(`"${decoder.decode(_entryName)}"`);
            }
            return data;
          } else {
            inflater.inflateAsync(function(result) {
              result.copy(result, 0);
              if (callback) {
                if (!crc32OK(result)) {
                  callback(result, Utils.Errors.BAD_CRC());
                } else {
                  callback(result);
                }
              }
            });
          }
          break;
        default:
          if (async && callback)
            callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD());
          throw Utils.Errors.UNKNOWN_METHOD();
      }
    }
    function compress(async, callback) {
      if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
        if (async && callback)
          callback(getCompressedDataFromZip());
        return getCompressedDataFromZip();
      }
      if (uncompressedData.length && !_isDirectory) {
        var compressedData;
        switch (_centralHeader.method) {
          case Utils.Constants.STORED:
            _centralHeader.compressedSize = _centralHeader.size;
            compressedData = Buffer.alloc(uncompressedData.length);
            uncompressedData.copy(compressedData);
            if (async && callback)
              callback(compressedData);
            return compressedData;
          default:
          case Utils.Constants.DEFLATED:
            var deflater = new Methods.Deflater(uncompressedData);
            if (!async) {
              var deflated = deflater.deflate();
              _centralHeader.compressedSize = deflated.length;
              return deflated;
            } else {
              deflater.deflateAsync(function(data) {
                compressedData = Buffer.alloc(data.length);
                _centralHeader.compressedSize = data.length;
                data.copy(compressedData);
                callback && callback(compressedData);
              });
            }
            deflater = null;
            break;
        }
      } else if (async && callback) {
        callback(Buffer.alloc(0));
      } else {
        return Buffer.alloc(0);
      }
    }
    function readUInt64LE(buffer, offset) {
      return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
    }
    function parseExtra(data) {
      try {
        var offset = 0;
        var signature, size, part;
        while (offset + 4 < data.length) {
          signature = data.readUInt16LE(offset);
          offset += 2;
          size = data.readUInt16LE(offset);
          offset += 2;
          part = data.slice(offset, offset + size);
          offset += size;
          if (Constants.ID_ZIP64 === signature) {
            parseZip64ExtendedInformation(part);
          }
        }
      } catch (error) {
        throw Utils.Errors.EXTRA_FIELD_PARSE_ERROR();
      }
    }
    function parseZip64ExtendedInformation(data) {
      var size, compressedSize, offset, diskNumStart;
      if (data.length >= Constants.EF_ZIP64_SCOMP) {
        size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
        if (_centralHeader.size === Constants.EF_ZIP64_OR_32) {
          _centralHeader.size = size;
        }
      }
      if (data.length >= Constants.EF_ZIP64_RHO) {
        compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
        if (_centralHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
          _centralHeader.compressedSize = compressedSize;
        }
      }
      if (data.length >= Constants.EF_ZIP64_DSN) {
        offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
        if (_centralHeader.offset === Constants.EF_ZIP64_OR_32) {
          _centralHeader.offset = offset;
        }
      }
      if (data.length >= Constants.EF_ZIP64_DSN + 4) {
        diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
        if (_centralHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
          _centralHeader.diskNumStart = diskNumStart;
        }
      }
    }
    return {
      get entryName() {
        return decoder.decode(_entryName);
      },
      get rawEntryName() {
        return _entryName;
      },
      set entryName(val) {
        _entryName = Utils.toBuffer(val, decoder.encode);
        var lastChar = _entryName[_entryName.length - 1];
        _isDirectory = lastChar === 47 || lastChar === 92;
        _centralHeader.fileNameLength = _entryName.length;
      },
      get efs() {
        if (typeof _efs === "function") {
          return _efs(this.entryName);
        } else {
          return _efs;
        }
      },
      get extra() {
        return _extra;
      },
      set extra(val) {
        _extra = val;
        _centralHeader.extraLength = val.length;
        parseExtra(val);
      },
      get comment() {
        return decoder.decode(_comment);
      },
      set comment(val) {
        _comment = Utils.toBuffer(val, decoder.encode);
        _centralHeader.commentLength = _comment.length;
        if (_comment.length > 65535)
          throw Utils.Errors.COMMENT_TOO_LONG();
      },
      get name() {
        var n = decoder.decode(_entryName);
        return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop();
      },
      get isDirectory() {
        return _isDirectory;
      },
      getCompressedData: function() {
        return compress(false, null);
      },
      getCompressedDataAsync: function(callback) {
        compress(true, callback);
      },
      setData: function(value) {
        uncompressedData = Utils.toBuffer(value, Utils.decoder.encode);
        if (!_isDirectory && uncompressedData.length) {
          _centralHeader.size = uncompressedData.length;
          _centralHeader.method = Utils.Constants.DEFLATED;
          _centralHeader.crc = Utils.crc32(value);
          _centralHeader.changed = true;
        } else {
          _centralHeader.method = Utils.Constants.STORED;
        }
      },
      getData: function(pass) {
        if (_centralHeader.changed) {
          return uncompressedData;
        } else {
          return decompress(false, null, pass);
        }
      },
      getDataAsync: function(callback, pass) {
        if (_centralHeader.changed) {
          callback(uncompressedData);
        } else {
          decompress(true, callback, pass);
        }
      },
      set attr(attr) {
        _centralHeader.attr = attr;
      },
      get attr() {
        return _centralHeader.attr;
      },
      set header(data) {
        _centralHeader.loadFromBinary(data);
      },
      get header() {
        return _centralHeader;
      },
      packCentralHeader: function() {
        _centralHeader.flags_efs = this.efs;
        _centralHeader.extraLength = _extra.length;
        var header = _centralHeader.centralHeaderToBinary();
        var addpos = Utils.Constants.CENHDR;
        _entryName.copy(header, addpos);
        addpos += _entryName.length;
        _extra.copy(header, addpos);
        addpos += _centralHeader.extraLength;
        _comment.copy(header, addpos);
        return header;
      },
      packLocalHeader: function() {
        let addpos = 0;
        _centralHeader.flags_efs = this.efs;
        _centralHeader.extraLocalLength = _extralocal.length;
        const localHeaderBuf = _centralHeader.localHeaderToBinary();
        const localHeader = Buffer.alloc(localHeaderBuf.length + _entryName.length + _centralHeader.extraLocalLength);
        localHeaderBuf.copy(localHeader, addpos);
        addpos += localHeaderBuf.length;
        _entryName.copy(localHeader, addpos);
        addpos += _entryName.length;
        _extralocal.copy(localHeader, addpos);
        addpos += _extralocal.length;
        return localHeader;
      },
      toJSON: function() {
        const bytes = function(nr) {
          return "<" + (nr && nr.length + " bytes buffer" || "null") + ">";
        };
        return {
          entryName: this.entryName,
          name: this.name,
          comment: this.comment,
          isDirectory: this.isDirectory,
          header: _centralHeader.toJSON(),
          compressedData: bytes(input),
          data: bytes(uncompressedData)
        };
      },
      toString: function() {
        return JSON.stringify(this.toJSON(), null, "\t");
      }
    };
  };
});

// node_modules/adm-zip/zipFile.js
var require_zipFile = __commonJS((exports, module) => {
  var ZipEntry = require_zipEntry();
  var Headers3 = require_headers();
  var Utils = require_util6();
  module.exports = function(inBuffer, options) {
    var entryList = [], entryTable = {}, _comment = Buffer.alloc(0), mainHeader = new Headers3.MainHeader, loadedEntries = false;
    var password = null;
    const temporary = new Set;
    const opts = options;
    const { noSort, decoder } = opts;
    if (inBuffer) {
      readMainHeader(opts.readEntries);
    } else {
      loadedEntries = true;
    }
    function makeTemporaryFolders() {
      const foldersList = new Set;
      for (const elem of Object.keys(entryTable)) {
        const elements = elem.split("/");
        elements.pop();
        if (!elements.length)
          continue;
        for (let i2 = 0;i2 < elements.length; i2++) {
          const sub = elements.slice(0, i2 + 1).join("/") + "/";
          foldersList.add(sub);
        }
      }
      for (const elem of foldersList) {
        if (!(elem in entryTable)) {
          const tempfolder = new ZipEntry(opts);
          tempfolder.entryName = elem;
          tempfolder.attr = 16;
          tempfolder.temporary = true;
          entryList.push(tempfolder);
          entryTable[tempfolder.entryName] = tempfolder;
          temporary.add(tempfolder);
        }
      }
    }
    function readEntries() {
      loadedEntries = true;
      entryTable = {};
      if (mainHeader.diskEntries > (inBuffer.length - mainHeader.offset) / Utils.Constants.CENHDR) {
        throw Utils.Errors.DISK_ENTRY_TOO_LARGE();
      }
      entryList = new Array(mainHeader.diskEntries);
      var index = mainHeader.offset;
      for (var i2 = 0;i2 < entryList.length; i2++) {
        var tmp = index, entry = new ZipEntry(opts, inBuffer);
        entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);
        entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
        if (entry.header.extraLength) {
          entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
        }
        if (entry.header.commentLength)
          entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
        index += entry.header.centralHeaderSize;
        entryList[i2] = entry;
        entryTable[entry.entryName] = entry;
      }
      temporary.clear();
      makeTemporaryFolders();
    }
    function readMainHeader(readNow) {
      var i2 = inBuffer.length - Utils.Constants.ENDHDR, max = Math.max(0, i2 - 65535), n = max, endStart = inBuffer.length, endOffset = -1, commentEnd = 0;
      const trailingSpace = typeof opts.trailingSpace === "boolean" ? opts.trailingSpace : false;
      if (trailingSpace)
        max = 0;
      for (i2;i2 >= n; i2--) {
        if (inBuffer[i2] !== 80)
          continue;
        if (inBuffer.readUInt32LE(i2) === Utils.Constants.ENDSIG) {
          endOffset = i2;
          commentEnd = i2;
          endStart = i2 + Utils.Constants.ENDHDR;
          n = i2 - Utils.Constants.END64HDR;
          continue;
        }
        if (inBuffer.readUInt32LE(i2) === Utils.Constants.END64SIG) {
          n = max;
          continue;
        }
        if (inBuffer.readUInt32LE(i2) === Utils.Constants.ZIP64SIG) {
          endOffset = i2;
          endStart = i2 + Utils.readBigUInt64LE(inBuffer, i2 + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;
          break;
        }
      }
      if (endOffset == -1)
        throw Utils.Errors.INVALID_FORMAT();
      mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
      if (mainHeader.commentLength) {
        _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);
      }
      if (readNow)
        readEntries();
    }
    function sortEntries() {
      if (entryList.length > 1 && !noSort) {
        entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
      }
    }
    return {
      get entries() {
        if (!loadedEntries) {
          readEntries();
        }
        return entryList.filter((e2) => !temporary.has(e2));
      },
      get comment() {
        return decoder.decode(_comment);
      },
      set comment(val) {
        _comment = Utils.toBuffer(val, decoder.encode);
        mainHeader.commentLength = _comment.length;
      },
      getEntryCount: function() {
        if (!loadedEntries) {
          return mainHeader.diskEntries;
        }
        return entryList.length;
      },
      forEach: function(callback) {
        this.entries.forEach(callback);
      },
      getEntry: function(entryName) {
        if (!loadedEntries) {
          readEntries();
        }
        return entryTable[entryName] || null;
      },
      setEntry: function(entry) {
        if (!loadedEntries) {
          readEntries();
        }
        entryList.push(entry);
        entryTable[entry.entryName] = entry;
        mainHeader.totalEntries = entryList.length;
      },
      deleteFile: function(entryName, withsubfolders = true) {
        if (!loadedEntries) {
          readEntries();
        }
        const entry = entryTable[entryName];
        const list = this.getEntryChildren(entry, withsubfolders).map((child) => child.entryName);
        list.forEach(this.deleteEntry);
      },
      deleteEntry: function(entryName) {
        if (!loadedEntries) {
          readEntries();
        }
        const entry = entryTable[entryName];
        const index = entryList.indexOf(entry);
        if (index >= 0) {
          entryList.splice(index, 1);
          delete entryTable[entryName];
          mainHeader.totalEntries = entryList.length;
        }
      },
      getEntryChildren: function(entry, subfolders = true) {
        if (!loadedEntries) {
          readEntries();
        }
        if (typeof entry === "object") {
          if (entry.isDirectory && subfolders) {
            const list = [];
            const name = entry.entryName;
            for (const zipEntry of entryList) {
              if (zipEntry.entryName.startsWith(name)) {
                list.push(zipEntry);
              }
            }
            return list;
          } else {
            return [entry];
          }
        }
        return [];
      },
      getChildCount: function(entry) {
        if (entry && entry.isDirectory) {
          const list = this.getEntryChildren(entry);
          return list.includes(entry) ? list.length - 1 : list.length;
        }
        return 0;
      },
      compressToBuffer: function() {
        if (!loadedEntries) {
          readEntries();
        }
        sortEntries();
        const dataBlock = [];
        const headerBlocks = [];
        let totalSize = 0;
        let dindex = 0;
        mainHeader.size = 0;
        mainHeader.offset = 0;
        let totalEntries = 0;
        for (const entry of this.entries) {
          const compressedData = entry.getCompressedData();
          entry.header.offset = dindex;
          const localHeader = entry.packLocalHeader();
          const dataLength = localHeader.length + compressedData.length;
          dindex += dataLength;
          dataBlock.push(localHeader);
          dataBlock.push(compressedData);
          const centralHeader = entry.packCentralHeader();
          headerBlocks.push(centralHeader);
          mainHeader.size += centralHeader.length;
          totalSize += dataLength + centralHeader.length;
          totalEntries++;
        }
        totalSize += mainHeader.mainHeaderSize;
        mainHeader.offset = dindex;
        mainHeader.totalEntries = totalEntries;
        dindex = 0;
        const outBuffer = Buffer.alloc(totalSize);
        for (const content of dataBlock) {
          content.copy(outBuffer, dindex);
          dindex += content.length;
        }
        for (const content of headerBlocks) {
          content.copy(outBuffer, dindex);
          dindex += content.length;
        }
        const mh = mainHeader.toBinary();
        if (_comment) {
          _comment.copy(mh, Utils.Constants.ENDHDR);
        }
        mh.copy(outBuffer, dindex);
        inBuffer = outBuffer;
        loadedEntries = false;
        return outBuffer;
      },
      toAsyncBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
        try {
          if (!loadedEntries) {
            readEntries();
          }
          sortEntries();
          const dataBlock = [];
          const centralHeaders = [];
          let totalSize = 0;
          let dindex = 0;
          let totalEntries = 0;
          mainHeader.size = 0;
          mainHeader.offset = 0;
          const compress2Buffer = function(entryLists) {
            if (entryLists.length > 0) {
              const entry = entryLists.shift();
              const name = entry.entryName + entry.extra.toString();
              if (onItemStart)
                onItemStart(name);
              entry.getCompressedDataAsync(function(compressedData) {
                if (onItemEnd)
                  onItemEnd(name);
                entry.header.offset = dindex;
                const localHeader = entry.packLocalHeader();
                const dataLength = localHeader.length + compressedData.length;
                dindex += dataLength;
                dataBlock.push(localHeader);
                dataBlock.push(compressedData);
                const centalHeader = entry.packCentralHeader();
                centralHeaders.push(centalHeader);
                mainHeader.size += centalHeader.length;
                totalSize += dataLength + centalHeader.length;
                totalEntries++;
                compress2Buffer(entryLists);
              });
            } else {
              totalSize += mainHeader.mainHeaderSize;
              mainHeader.offset = dindex;
              mainHeader.totalEntries = totalEntries;
              dindex = 0;
              const outBuffer = Buffer.alloc(totalSize);
              dataBlock.forEach(function(content) {
                content.copy(outBuffer, dindex);
                dindex += content.length;
              });
              centralHeaders.forEach(function(content) {
                content.copy(outBuffer, dindex);
                dindex += content.length;
              });
              const mh = mainHeader.toBinary();
              if (_comment) {
                _comment.copy(mh, Utils.Constants.ENDHDR);
              }
              mh.copy(outBuffer, dindex);
              inBuffer = outBuffer;
              loadedEntries = false;
              onSuccess(outBuffer);
            }
          };
          compress2Buffer(Array.from(this.entries));
        } catch (e2) {
          onFail(e2);
        }
      }
    };
  };
});

// node_modules/adm-zip/adm-zip.js
var require_adm_zip = __commonJS((exports, module) => {
  var Utils = require_util6();
  var pth = __require("path");
  var ZipEntry = require_zipEntry();
  var ZipFile = require_zipFile();
  var get_Bool = (...val) => Utils.findLast(val, (c) => typeof c === "boolean");
  var get_Str = (...val) => Utils.findLast(val, (c) => typeof c === "string");
  var get_Fun = (...val) => Utils.findLast(val, (c) => typeof c === "function");
  var defaultOptions = {
    noSort: false,
    readEntries: false,
    method: Utils.Constants.NONE,
    fs: null
  };
  module.exports = function(input, options) {
    let inBuffer = null;
    const opts = Object.assign(Object.create(null), defaultOptions);
    if (input && typeof input === "object") {
      if (!(input instanceof Uint8Array)) {
        Object.assign(opts, input);
        input = opts.input ? opts.input : undefined;
        if (opts.input)
          delete opts.input;
      }
      if (Buffer.isBuffer(input)) {
        inBuffer = input;
        opts.method = Utils.Constants.BUFFER;
        input = undefined;
      }
    }
    Object.assign(opts, options);
    const filetools = new Utils(opts);
    if (typeof opts.decoder !== "object" || typeof opts.decoder.encode !== "function" || typeof opts.decoder.decode !== "function") {
      opts.decoder = Utils.decoder;
    }
    if (input && typeof input === "string") {
      if (filetools.fs.existsSync(input)) {
        opts.method = Utils.Constants.FILE;
        opts.filename = input;
        inBuffer = filetools.fs.readFileSync(input);
      } else {
        throw Utils.Errors.INVALID_FILENAME();
      }
    }
    const _zip = new ZipFile(inBuffer, opts);
    const { canonical, sanitize, zipnamefix } = Utils;
    function getEntry(entry) {
      if (entry && _zip) {
        var item;
        if (typeof entry === "string")
          item = _zip.getEntry(pth.posix.normalize(entry));
        if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined")
          item = _zip.getEntry(entry.entryName);
        if (item) {
          return item;
        }
      }
      return null;
    }
    function fixPath(zipPath) {
      const { join, normalize, sep } = pth.posix;
      return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
    }
    function filenameFilter(filterfn) {
      if (filterfn instanceof RegExp) {
        return function(rx) {
          return function(filename) {
            return rx.test(filename);
          };
        }(filterfn);
      } else if (typeof filterfn !== "function") {
        return () => true;
      }
      return filterfn;
    }
    const relativePath = (local, entry) => {
      let lastChar = entry.slice(-1);
      lastChar = lastChar === filetools.sep ? filetools.sep : "";
      return pth.relative(local, entry) + lastChar;
    };
    return {
      readFile: function(entry, pass) {
        var item = getEntry(entry);
        return item && item.getData(pass) || null;
      },
      childCount: function(entry) {
        const item = getEntry(entry);
        if (item) {
          return _zip.getChildCount(item);
        }
      },
      readFileAsync: function(entry, callback) {
        var item = getEntry(entry);
        if (item) {
          item.getDataAsync(callback);
        } else {
          callback(null, "getEntry failed for:" + entry);
        }
      },
      readAsText: function(entry, encoding) {
        var item = getEntry(entry);
        if (item) {
          var data = item.getData();
          if (data && data.length) {
            return data.toString(encoding || "utf8");
          }
        }
        return "";
      },
      readAsTextAsync: function(entry, callback, encoding) {
        var item = getEntry(entry);
        if (item) {
          item.getDataAsync(function(data, err) {
            if (err) {
              callback(data, err);
              return;
            }
            if (data && data.length) {
              callback(data.toString(encoding || "utf8"));
            } else {
              callback("");
            }
          });
        } else {
          callback("");
        }
      },
      deleteFile: function(entry, withsubfolders = true) {
        var item = getEntry(entry);
        if (item) {
          _zip.deleteFile(item.entryName, withsubfolders);
        }
      },
      deleteEntry: function(entry) {
        var item = getEntry(entry);
        if (item) {
          _zip.deleteEntry(item.entryName);
        }
      },
      addZipComment: function(comment) {
        _zip.comment = comment;
      },
      getZipComment: function() {
        return _zip.comment || "";
      },
      addZipEntryComment: function(entry, comment) {
        var item = getEntry(entry);
        if (item) {
          item.comment = comment;
        }
      },
      getZipEntryComment: function(entry) {
        var item = getEntry(entry);
        if (item) {
          return item.comment || "";
        }
        return "";
      },
      updateFile: function(entry, content) {
        var item = getEntry(entry);
        if (item) {
          item.setData(content);
        }
      },
      addLocalFile: function(localPath2, zipPath, zipName, comment) {
        if (filetools.fs.existsSync(localPath2)) {
          zipPath = zipPath ? fixPath(zipPath) : "";
          const p = pth.win32.basename(pth.win32.normalize(localPath2));
          zipPath += zipName ? zipName : p;
          const _attr = filetools.fs.statSync(localPath2);
          const data = _attr.isFile() ? filetools.fs.readFileSync(localPath2) : Buffer.alloc(0);
          if (_attr.isDirectory())
            zipPath += filetools.sep;
          this.addFile(zipPath, data, comment, _attr);
        } else {
          throw Utils.Errors.FILE_NOT_FOUND(localPath2);
        }
      },
      addLocalFileAsync: function(options2, callback) {
        options2 = typeof options2 === "object" ? options2 : { localPath: options2 };
        const localPath2 = pth.resolve(options2.localPath);
        const { comment } = options2;
        let { zipPath, zipName } = options2;
        const self2 = this;
        filetools.fs.stat(localPath2, function(err, stats) {
          if (err)
            return callback(err, false);
          zipPath = zipPath ? fixPath(zipPath) : "";
          const p = pth.win32.basename(pth.win32.normalize(localPath2));
          zipPath += zipName ? zipName : p;
          if (stats.isFile()) {
            filetools.fs.readFile(localPath2, function(err2, data) {
              if (err2)
                return callback(err2, false);
              self2.addFile(zipPath, data, comment, stats);
              return setImmediate(callback, undefined, true);
            });
          } else if (stats.isDirectory()) {
            zipPath += filetools.sep;
            self2.addFile(zipPath, Buffer.alloc(0), comment, stats);
            return setImmediate(callback, undefined, true);
          }
        });
      },
      addLocalFolder: function(localPath2, zipPath, filter) {
        filter = filenameFilter(filter);
        zipPath = zipPath ? fixPath(zipPath) : "";
        localPath2 = pth.normalize(localPath2);
        if (filetools.fs.existsSync(localPath2)) {
          const items = filetools.findFiles(localPath2);
          const self2 = this;
          if (items.length) {
            for (const filepath of items) {
              const p = pth.join(zipPath, relativePath(localPath2, filepath));
              if (filter(p)) {
                self2.addLocalFile(filepath, pth.dirname(p));
              }
            }
          }
        } else {
          throw Utils.Errors.FILE_NOT_FOUND(localPath2);
        }
      },
      addLocalFolderAsync: function(localPath2, callback, zipPath, filter) {
        filter = filenameFilter(filter);
        zipPath = zipPath ? fixPath(zipPath) : "";
        localPath2 = pth.normalize(localPath2);
        var self2 = this;
        filetools.fs.open(localPath2, "r", function(err) {
          if (err && err.code === "ENOENT") {
            callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath2));
          } else if (err) {
            callback(undefined, err);
          } else {
            var items = filetools.findFiles(localPath2);
            var i2 = -1;
            var next = function() {
              i2 += 1;
              if (i2 < items.length) {
                var filepath = items[i2];
                var p = relativePath(localPath2, filepath).split("\\").join("/");
                p = p.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
                if (filter(p)) {
                  filetools.fs.stat(filepath, function(er0, stats) {
                    if (er0)
                      callback(undefined, er0);
                    if (stats.isFile()) {
                      filetools.fs.readFile(filepath, function(er1, data) {
                        if (er1) {
                          callback(undefined, er1);
                        } else {
                          self2.addFile(zipPath + p, data, "", stats);
                          next();
                        }
                      });
                    } else {
                      self2.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                      next();
                    }
                  });
                } else {
                  process.nextTick(() => {
                    next();
                  });
                }
              } else {
                callback(true, undefined);
              }
            };
            next();
          }
        });
      },
      addLocalFolderAsync2: function(options2, callback) {
        const self2 = this;
        options2 = typeof options2 === "object" ? options2 : { localPath: options2 };
        localPath = pth.resolve(fixPath(options2.localPath));
        let { zipPath, filter, namefix } = options2;
        if (filter instanceof RegExp) {
          filter = function(rx) {
            return function(filename) {
              return rx.test(filename);
            };
          }(filter);
        } else if (typeof filter !== "function") {
          filter = function() {
            return true;
          };
        }
        zipPath = zipPath ? fixPath(zipPath) : "";
        if (namefix == "latin1") {
          namefix = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
        }
        if (typeof namefix !== "function")
          namefix = (str) => str;
        const relPathFix = (entry) => pth.join(zipPath, namefix(relativePath(localPath, entry)));
        const fileNameFix = (entry) => pth.win32.basename(pth.win32.normalize(namefix(entry)));
        filetools.fs.open(localPath, "r", function(err) {
          if (err && err.code === "ENOENT") {
            callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath));
          } else if (err) {
            callback(undefined, err);
          } else {
            filetools.findFilesAsync(localPath, function(err2, fileEntries) {
              if (err2)
                return callback(err2);
              fileEntries = fileEntries.filter((dir) => filter(relPathFix(dir)));
              if (!fileEntries.length)
                callback(undefined, false);
              setImmediate(fileEntries.reverse().reduce(function(next, entry) {
                return function(err3, done) {
                  if (err3 || done === false)
                    return setImmediate(next, err3, false);
                  self2.addLocalFileAsync({
                    localPath: entry,
                    zipPath: pth.dirname(relPathFix(entry)),
                    zipName: fileNameFix(entry)
                  }, next);
                };
              }, callback));
            });
          }
        });
      },
      addLocalFolderPromise: function(localPath2, props) {
        return new Promise((resolve, reject) => {
          this.addLocalFolderAsync2(Object.assign({ localPath: localPath2 }, props), (err, done) => {
            if (err)
              reject(err);
            if (done)
              resolve(this);
          });
        });
      },
      addFile: function(entryName, content, comment, attr) {
        entryName = zipnamefix(entryName);
        let entry = getEntry(entryName);
        const update = entry != null;
        if (!update) {
          entry = new ZipEntry(opts);
          entry.entryName = entryName;
        }
        entry.comment = comment || "";
        const isStat = typeof attr === "object" && attr instanceof filetools.fs.Stats;
        if (isStat) {
          entry.header.time = attr.mtime;
        }
        var fileattr = entry.isDirectory ? 16 : 0;
        let unix = entry.isDirectory ? 16384 : 32768;
        if (isStat) {
          unix |= 4095 & attr.mode;
        } else if (typeof attr === "number") {
          unix |= 4095 & attr;
        } else {
          unix |= entry.isDirectory ? 493 : 420;
        }
        fileattr = (fileattr | unix << 16) >>> 0;
        entry.attr = fileattr;
        entry.setData(content);
        if (!update)
          _zip.setEntry(entry);
        return entry;
      },
      getEntries: function(password) {
        _zip.password = password;
        return _zip ? _zip.entries : [];
      },
      getEntry: function(name) {
        return getEntry(name);
      },
      getEntryCount: function() {
        return _zip.getEntryCount();
      },
      forEach: function(callback) {
        return _zip.forEach(callback);
      },
      extractEntryTo: function(entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {
        overwrite = get_Bool(false, overwrite);
        keepOriginalPermission = get_Bool(false, keepOriginalPermission);
        maintainEntryPath = get_Bool(true, maintainEntryPath);
        outFileName = get_Str(keepOriginalPermission, outFileName);
        var item = getEntry(entry);
        if (!item) {
          throw Utils.Errors.NO_ENTRY();
        }
        var entryName = canonical(item.entryName);
        var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));
        if (item.isDirectory) {
          var children = _zip.getEntryChildren(item);
          children.forEach(function(child) {
            if (child.isDirectory)
              return;
            var content2 = child.getData();
            if (!content2) {
              throw Utils.Errors.CANT_EXTRACT_FILE();
            }
            var name = canonical(child.entryName);
            var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
            const fileAttr2 = keepOriginalPermission ? child.header.fileAttr : undefined;
            filetools.writeFileTo(childName, content2, overwrite, fileAttr2);
          });
          return true;
        }
        var content = item.getData(_zip.password);
        if (!content)
          throw Utils.Errors.CANT_EXTRACT_FILE();
        if (filetools.fs.existsSync(target) && !overwrite) {
          throw Utils.Errors.CANT_OVERRIDE();
        }
        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
        filetools.writeFileTo(target, content, overwrite, fileAttr);
        return true;
      },
      test: function(pass) {
        if (!_zip) {
          return false;
        }
        for (var entry in _zip.entries) {
          try {
            if (entry.isDirectory) {
              continue;
            }
            var content = _zip.entries[entry].getData(pass);
            if (!content) {
              return false;
            }
          } catch (err) {
            return false;
          }
        }
        return true;
      },
      extractAllTo: function(targetPath, overwrite, keepOriginalPermission, pass) {
        keepOriginalPermission = get_Bool(false, keepOriginalPermission);
        pass = get_Str(keepOriginalPermission, pass);
        overwrite = get_Bool(false, overwrite);
        if (!_zip)
          throw Utils.Errors.NO_ZIP();
        _zip.entries.forEach(function(entry) {
          var entryName = sanitize(targetPath, canonical(entry.entryName));
          if (entry.isDirectory) {
            filetools.makeDir(entryName);
            return;
          }
          var content = entry.getData(pass);
          if (!content) {
            throw Utils.Errors.CANT_EXTRACT_FILE();
          }
          const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
          filetools.writeFileTo(entryName, content, overwrite, fileAttr);
          try {
            filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
          } catch (err) {
            throw Utils.Errors.CANT_EXTRACT_FILE();
          }
        });
      },
      extractAllToAsync: function(targetPath, overwrite, keepOriginalPermission, callback) {
        callback = get_Fun(overwrite, keepOriginalPermission, callback);
        keepOriginalPermission = get_Bool(false, keepOriginalPermission);
        overwrite = get_Bool(false, overwrite);
        if (!callback) {
          return new Promise((resolve, reject) => {
            this.extractAllToAsync(targetPath, overwrite, keepOriginalPermission, function(err) {
              if (err) {
                reject(err);
              } else {
                resolve(this);
              }
            });
          });
        }
        if (!_zip) {
          callback(Utils.Errors.NO_ZIP());
          return;
        }
        targetPath = pth.resolve(targetPath);
        const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName)));
        const getError = (msg, file) => new Error(msg + ': "' + file + '"');
        const dirEntries = [];
        const fileEntries = [];
        _zip.entries.forEach((e2) => {
          if (e2.isDirectory) {
            dirEntries.push(e2);
          } else {
            fileEntries.push(e2);
          }
        });
        for (const entry of dirEntries) {
          const dirPath = getPath(entry);
          const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
          try {
            filetools.makeDir(dirPath);
            if (dirAttr)
              filetools.fs.chmodSync(dirPath, dirAttr);
            filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
          } catch (er) {
            callback(getError("Unable to create folder", dirPath));
          }
        }
        fileEntries.reverse().reduce(function(next, entry) {
          return function(err) {
            if (err) {
              next(err);
            } else {
              const entryName = pth.normalize(canonical(entry.entryName));
              const filePath = sanitize(targetPath, entryName);
              entry.getDataAsync(function(content, err_1) {
                if (err_1) {
                  next(err_1);
                } else if (!content) {
                  next(Utils.Errors.CANT_EXTRACT_FILE());
                } else {
                  const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                  filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function(succ) {
                    if (!succ) {
                      next(getError("Unable to write file", filePath));
                    }
                    filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function(err_2) {
                      if (err_2) {
                        next(getError("Unable to set times", filePath));
                      } else {
                        next();
                      }
                    });
                  });
                }
              });
            }
          };
        }, callback)();
      },
      writeZip: function(targetFileName, callback) {
        if (arguments.length === 1) {
          if (typeof targetFileName === "function") {
            callback = targetFileName;
            targetFileName = "";
          }
        }
        if (!targetFileName && opts.filename) {
          targetFileName = opts.filename;
        }
        if (!targetFileName)
          return;
        var zipData = _zip.compressToBuffer();
        if (zipData) {
          var ok = filetools.writeFileTo(targetFileName, zipData, true);
          if (typeof callback === "function")
            callback(!ok ? new Error("failed") : null, "");
        }
      },
      writeZipPromise: function(targetFileName, props) {
        const { overwrite, perm } = Object.assign({ overwrite: true }, props);
        return new Promise((resolve, reject) => {
          if (!targetFileName && opts.filename)
            targetFileName = opts.filename;
          if (!targetFileName)
            reject("ADM-ZIP: ZIP File Name Missing");
          this.toBufferPromise().then((zipData) => {
            const ret = (done) => done ? resolve(done) : reject("ADM-ZIP: Wasn't able to write zip file");
            filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
          }, reject);
        });
      },
      toBufferPromise: function() {
        return new Promise((resolve, reject) => {
          _zip.toAsyncBuffer(resolve, reject);
        });
      },
      toBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
        if (typeof onSuccess === "function") {
          _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
          return null;
        }
        return _zip.compressToBuffer();
      }
    };
  };
});

// node_modules/env-paths/index.js
import path from "node:path";
import os from "node:os";
import process2 from "node:process";
function envPaths(name, { suffix = "nodejs" } = {}) {
  if (typeof name !== "string") {
    throw new TypeError(`Expected a string, got ${typeof name}`);
  }
  if (suffix) {
    name += `-${suffix}`;
  }
  if (process2.platform === "darwin") {
    return macos(name);
  }
  if (process2.platform === "win32") {
    return windows(name);
  }
  return linux(name);
}
var homedir, tmpdir, env, macos = (name) => {
  const library = path.join(homedir, "Library");
  return {
    data: path.join(library, "Application Support", name),
    config: path.join(library, "Preferences", name),
    cache: path.join(library, "Caches", name),
    log: path.join(library, "Logs", name),
    temp: path.join(tmpdir, name)
  };
}, windows = (name) => {
  const appData = env.APPDATA || path.join(homedir, "AppData", "Roaming");
  const localAppData = env.LOCALAPPDATA || path.join(homedir, "AppData", "Local");
  return {
    data: path.join(localAppData, name, "Data"),
    config: path.join(appData, name, "Config"),
    cache: path.join(localAppData, name, "Cache"),
    log: path.join(localAppData, name, "Log"),
    temp: path.join(tmpdir, name)
  };
}, linux = (name) => {
  const username = path.basename(homedir);
  return {
    data: path.join(env.XDG_DATA_HOME || path.join(homedir, ".local", "share"), name),
    config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, ".config"), name),
    cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, ".cache"), name),
    log: path.join(env.XDG_STATE_HOME || path.join(homedir, ".local", "state"), name),
    temp: path.join(tmpdir, username, name)
  };
};
var init_env_paths = __esm(() => {
  homedir = os.homedir();
  tmpdir = os.tmpdir();
  ({ env } = process2);
});

// node_modules/is-plain-obj/index.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/execa/lib/arguments/file-url.js
import { fileURLToPath } from "node:url";
var safeNormalizeFileUrl = (file, name) => {
  const fileString = normalizeFileUrl(normalizeDenoExecPath(file));
  if (typeof fileString !== "string") {
    throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
  }
  return fileString;
}, normalizeDenoExecPath = (file) => isDenoExecPath(file) ? file.toString() : file, isDenoExecPath = (file) => typeof file !== "string" && file && Object.getPrototypeOf(file) === String.prototype, normalizeFileUrl = (file) => file instanceof URL ? fileURLToPath(file) : file;
var init_file_url = () => {
};

// node_modules/execa/lib/methods/parameters.js
var normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {
  const filePath = safeNormalizeFileUrl(rawFile, "First argument");
  const [commandArguments, options] = isPlainObject2(rawArguments) ? [[], rawArguments] : [rawArguments, rawOptions];
  if (!Array.isArray(commandArguments)) {
    throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
  }
  if (commandArguments.some((commandArgument) => typeof commandArgument === "object" && commandArgument !== null)) {
    throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
  }
  const normalizedArguments = commandArguments.map(String);
  const nullByteArgument = normalizedArguments.find((normalizedArgument) => normalizedArgument.includes("\x00"));
  if (nullByteArgument !== undefined) {
    throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
  }
  if (!isPlainObject2(options)) {
    throw new TypeError(`Last argument must be an options object: ${options}`);
  }
  return [filePath, normalizedArguments, options];
};
var init_parameters = __esm(() => {
  init_file_url();
});

// node_modules/execa/lib/utils/uint-array.js
import { StringDecoder } from "node:string_decoder";
var objectToString, isArrayBuffer = (value) => objectToString.call(value) === "[object ArrayBuffer]", isUint8Array = (value) => objectToString.call(value) === "[object Uint8Array]", bufferToUint8Array = (buffer) => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength), textEncoder, stringToUint8Array = (string) => textEncoder.encode(string), textDecoder, uint8ArrayToString = (uint8Array) => textDecoder.decode(uint8Array), joinToString = (uint8ArraysOrStrings, encoding) => {
  const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
  return strings.join("");
}, uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {
  if (encoding === "utf8" && uint8ArraysOrStrings.every((uint8ArrayOrString) => typeof uint8ArrayOrString === "string")) {
    return uint8ArraysOrStrings;
  }
  const decoder = new StringDecoder(encoding);
  const strings = uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array) => decoder.write(uint8Array));
  const finalString = decoder.end();
  return finalString === "" ? strings : [...strings, finalString];
}, joinToUint8Array = (uint8ArraysOrStrings) => {
  if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
    return uint8ArraysOrStrings[0];
  }
  return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
}, stringsToUint8Arrays = (uint8ArraysOrStrings) => uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString), concatUint8Arrays = (uint8Arrays) => {
  const result = new Uint8Array(getJoinLength(uint8Arrays));
  let index = 0;
  for (const uint8Array of uint8Arrays) {
    result.set(uint8Array, index);
    index += uint8Array.length;
  }
  return result;
}, getJoinLength = (uint8Arrays) => {
  let joinLength = 0;
  for (const uint8Array of uint8Arrays) {
    joinLength += uint8Array.length;
  }
  return joinLength;
};
var init_uint_array = __esm(() => {
  ({ toString: objectToString } = Object.prototype);
  textEncoder = new TextEncoder;
  textDecoder = new TextDecoder;
});

// node_modules/execa/lib/methods/template.js
import { ChildProcess } from "node:child_process";
var isTemplateString = (templates) => Array.isArray(templates) && Array.isArray(templates.raw), parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index, template] of templates.entries()) {
    tokens = parseTemplate({
      templates,
      expressions,
      tokens,
      index,
      template
    });
  }
  if (tokens.length === 0) {
    throw new TypeError("Template script must not be empty");
  }
  const [file, ...commandArguments] = tokens;
  return [file, commandArguments, {}];
}, parseTemplate = ({ templates, expressions, tokens, index, template }) => {
  if (template === undefined) {
    throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
  }
  const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
  const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
  if (index === expressions.length) {
    return newTokens;
  }
  const expression2 = expressions[index];
  const expressionTokens = Array.isArray(expression2) ? expression2.map((expression3) => parseExpression(expression3)) : [parseExpression(expression2)];
  return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
}, splitByWhitespaces = (template, rawTemplate) => {
  if (rawTemplate.length === 0) {
    return { nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false };
  }
  const nextTokens = [];
  let templateStart = 0;
  const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
  for (let templateIndex = 0, rawIndex = 0;templateIndex < template.length; templateIndex += 1, rawIndex += 1) {
    const rawCharacter = rawTemplate[rawIndex];
    if (DELIMITERS.has(rawCharacter)) {
      if (templateStart !== templateIndex) {
        nextTokens.push(template.slice(templateStart, templateIndex));
      }
      templateStart = templateIndex + 1;
    } else if (rawCharacter === "\\") {
      const nextRawCharacter = rawTemplate[rawIndex + 1];
      if (nextRawCharacter === `
`) {
        templateIndex -= 1;
        rawIndex += 1;
      } else if (nextRawCharacter === "u" && rawTemplate[rawIndex + 2] === "{") {
        rawIndex = rawTemplate.indexOf("}", rawIndex + 3);
      } else {
        rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
      }
    }
  }
  const trailingWhitespaces = templateStart === template.length;
  if (!trailingWhitespaces) {
    nextTokens.push(template.slice(templateStart));
  }
  return { nextTokens, leadingWhitespaces, trailingWhitespaces };
}, DELIMITERS, ESCAPE_LENGTH, concatTokens = (tokens, nextTokens, isSeparated) => isSeparated || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens.at(-1)}${nextTokens[0]}`,
  ...nextTokens.slice(1)
], parseExpression = (expression2) => {
  const typeOfExpression = typeof expression2;
  if (typeOfExpression === "string") {
    return expression2;
  }
  if (typeOfExpression === "number") {
    return String(expression2);
  }
  if (isPlainObject2(expression2) && (("stdout" in expression2) || ("isMaxBuffer" in expression2))) {
    return getSubprocessResult(expression2);
  }
  if (expression2 instanceof ChildProcess || Object.prototype.toString.call(expression2) === "[object Promise]") {
    throw new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
}, getSubprocessResult = ({ stdout }) => {
  if (typeof stdout === "string") {
    return stdout;
  }
  if (isUint8Array(stdout)) {
    return uint8ArrayToString(stdout);
  }
  if (stdout === undefined) {
    throw new TypeError(`Missing result.stdout in template expression. This is probably due to the previous subprocess' "stdout" option.`);
  }
  throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
};
var init_template = __esm(() => {
  init_uint_array();
  DELIMITERS = new Set([" ", "\t", "\r", `
`]);
  ESCAPE_LENGTH = { x: 3, u: 5 };
});

// node_modules/execa/lib/utils/standard-stream.js
import process3 from "node:process";
var isStandardStream = (stream) => STANDARD_STREAMS.includes(stream), STANDARD_STREAMS, STANDARD_STREAMS_ALIASES, getStreamName = (fdNumber) => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;
var init_standard_stream = __esm(() => {
  STANDARD_STREAMS = [process3.stdin, process3.stdout, process3.stderr];
  STANDARD_STREAMS_ALIASES = ["stdin", "stdout", "stderr"];
});

// node_modules/execa/lib/arguments/specific.js
import { debuglog } from "node:util";
var normalizeFdSpecificOptions = (options) => {
  const optionsCopy = { ...options };
  for (const optionName of FD_SPECIFIC_OPTIONS) {
    optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
  }
  return optionsCopy;
}, normalizeFdSpecificOption = (options, optionName) => {
  const optionBaseArray = Array.from({ length: getStdioLength(options) + 1 });
  const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
  return addDefaultValue(optionArray, optionName);
}, getStdioLength = ({ stdio }) => Array.isArray(stdio) ? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length) : STANDARD_STREAMS_ALIASES.length, normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject2(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue), normalizeOptionObject = (optionValue, optionArray, optionName) => {
  for (const fdName of Object.keys(optionValue).sort(compareFdName)) {
    for (const fdNumber of parseFdName(fdName, optionName, optionArray)) {
      optionArray[fdNumber] = optionValue[fdName];
    }
  }
  return optionArray;
}, compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1, getFdNameOrder = (fdName) => {
  if (fdName === "stdout" || fdName === "stderr") {
    return 0;
  }
  return fdName === "all" ? 2 : 1;
}, parseFdName = (fdName, optionName, optionArray) => {
  if (fdName === "ipc") {
    return [optionArray.length - 1];
  }
  const fdNumber = parseFd(fdName);
  if (fdNumber === undefined || fdNumber === 0) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
  }
  if (fdNumber >= optionArray.length) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  return fdNumber === "all" ? [1, 2] : [fdNumber];
}, parseFd = (fdName) => {
  if (fdName === "all") {
    return fdName;
  }
  if (STANDARD_STREAMS_ALIASES.includes(fdName)) {
    return STANDARD_STREAMS_ALIASES.indexOf(fdName);
  }
  const regexpResult = FD_REGEXP.exec(fdName);
  if (regexpResult !== null) {
    return Number(regexpResult[1]);
  }
}, FD_REGEXP, addDefaultValue = (optionArray, optionName) => optionArray.map((optionValue) => optionValue === undefined ? DEFAULT_OPTIONS[optionName] : optionValue), verboseDefault, DEFAULT_OPTIONS, FD_SPECIFIC_OPTIONS, getFdSpecificValue = (optionArray, fdNumber) => fdNumber === "ipc" ? optionArray.at(-1) : optionArray[fdNumber];
var init_specific = __esm(() => {
  init_standard_stream();
  FD_REGEXP = /^fd(\d+)$/;
  verboseDefault = debuglog("execa").enabled ? "full" : "none";
  DEFAULT_OPTIONS = {
    lines: false,
    buffer: true,
    maxBuffer: 1000 * 1000 * 100,
    verbose: verboseDefault,
    stripFinalNewline: true
  };
  FD_SPECIFIC_OPTIONS = ["lines", "buffer", "maxBuffer", "verbose", "stripFinalNewline"];
});

// node_modules/execa/lib/verbose/values.js
var isVerbose = ({ verbose }, fdNumber) => getFdVerbose(verbose, fdNumber) !== "none", isFullVerbose = ({ verbose }, fdNumber) => !["none", "short"].includes(getFdVerbose(verbose, fdNumber)), getVerboseFunction = ({ verbose }, fdNumber) => {
  const fdVerbose = getFdVerbose(verbose, fdNumber);
  return isVerboseFunction(fdVerbose) ? fdVerbose : undefined;
}, getFdVerbose = (verbose, fdNumber) => fdNumber === undefined ? getFdGenericVerbose(verbose) : getFdSpecificValue(verbose, fdNumber), getFdGenericVerbose = (verbose) => verbose.find((fdVerbose) => isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose) => verbose.includes(fdVerbose)), isVerboseFunction = (fdVerbose) => typeof fdVerbose === "function", VERBOSE_VALUES;
var init_values = __esm(() => {
  init_specific();
  VERBOSE_VALUES = ["none", "short", "full"];
});

// node_modules/execa/lib/arguments/escape.js
import { platform } from "node:process";
import { stripVTControlCharacters } from "node:util";
var joinCommand = (filePath, rawArguments) => {
  const fileAndArguments = [filePath, ...rawArguments];
  const command = fileAndArguments.join(" ");
  const escapedCommand = fileAndArguments.map((fileAndArgument) => quoteString(escapeControlCharacters(fileAndArgument))).join(" ");
  return { command, escapedCommand };
}, escapeLines = (lines) => stripVTControlCharacters(lines).split(`
`).map((line) => escapeControlCharacters(line)).join(`
`), escapeControlCharacters = (line) => line.replaceAll(SPECIAL_CHAR_REGEXP, (character) => escapeControlCharacter(character)), escapeControlCharacter = (character) => {
  const commonEscape = COMMON_ESCAPES[character];
  if (commonEscape !== undefined) {
    return commonEscape;
  }
  const codepoint = character.codePointAt(0);
  const codepointHex = codepoint.toString(16);
  return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, "0")}` : `\\U${codepointHex}`;
}, getSpecialCharRegExp = () => {
  try {
    return new RegExp("\\p{Separator}|\\p{Other}", "gu");
  } catch {
    return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
  }
}, SPECIAL_CHAR_REGEXP, COMMON_ESCAPES, ASTRAL_START = 65535, quoteString = (escapedArgument) => {
  if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
    return escapedArgument;
  }
  return platform === "win32" ? `"${escapedArgument.replaceAll('"', '""')}"` : `'${escapedArgument.replaceAll("'", "'\\''")}'`;
}, NO_ESCAPE_REGEXP;
var init_escape = __esm(() => {
  SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
  COMMON_ESCAPES = {
    " ": " ",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t"
  };
  NO_ESCAPE_REGEXP = /^[\w./-]+$/;
});

// node_modules/figures/node_modules/is-unicode-supported/index.js
import process4 from "node:process";
function isUnicodeSupported() {
  const { env: env2 } = process4;
  const { TERM, TERM_PROGRAM } = env2;
  if (process4.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env2.WT_SESSION) || Boolean(env2.TERMINUS_SUBLIME) || env2.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env2.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var init_is_unicode_supported = () => {
};

// node_modules/figures/index.js
var common, specialMainSymbols, specialFallbackSymbols, mainSymbols, fallbackSymbols, shouldUseMain, figures, figures_default, replacements;
var init_figures = __esm(() => {
  init_is_unicode_supported();
  common = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols = { ...common, ...specialMainSymbols };
  fallbackSymbols = { ...common, ...specialFallbackSymbols };
  shouldUseMain = isUnicodeSupported();
  figures = shouldUseMain ? mainSymbols : fallbackSymbols;
  figures_default = figures;
  replacements = Object.entries(specialMainSymbols);
});

// node_modules/yoctocolors/base.js
import tty from "node:tty";
var hasColors, format = (open, close2) => {
  if (!hasColors) {
    return (input) => input;
  }
  const openCode = `\x1B[${open}m`;
  const closeCode = `\x1B[${close2}m`;
  return (input) => {
    const string = input + "";
    let index = string.indexOf(closeCode);
    if (index === -1) {
      return openCode + string + closeCode;
    }
    let result = openCode;
    let lastIndex = 0;
    while (index !== -1) {
      result += string.slice(lastIndex, index) + openCode;
      lastIndex = index + closeCode.length;
      index = string.indexOf(closeCode, lastIndex);
    }
    result += string.slice(lastIndex) + closeCode;
    return result;
  };
}, reset, bold, dim, italic, underline, overline, inverse, hidden, strikethrough, black, red, green, yellow, blue, magenta, cyan, white, gray, bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite, bgGray, redBright, greenBright, yellowBright, blueBright, magentaBright, cyanBright, whiteBright, bgRedBright, bgGreenBright, bgYellowBright, bgBlueBright, bgMagentaBright, bgCyanBright, bgWhiteBright;
var init_base2 = __esm(() => {
  hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;
  reset = format(0, 0);
  bold = format(1, 22);
  dim = format(2, 22);
  italic = format(3, 23);
  underline = format(4, 24);
  overline = format(53, 55);
  inverse = format(7, 27);
  hidden = format(8, 28);
  strikethrough = format(9, 29);
  black = format(30, 39);
  red = format(31, 39);
  green = format(32, 39);
  yellow = format(33, 39);
  blue = format(34, 39);
  magenta = format(35, 39);
  cyan = format(36, 39);
  white = format(37, 39);
  gray = format(90, 39);
  bgBlack = format(40, 49);
  bgRed = format(41, 49);
  bgGreen = format(42, 49);
  bgYellow = format(43, 49);
  bgBlue = format(44, 49);
  bgMagenta = format(45, 49);
  bgCyan = format(46, 49);
  bgWhite = format(47, 49);
  bgGray = format(100, 49);
  redBright = format(91, 39);
  greenBright = format(92, 39);
  yellowBright = format(93, 39);
  blueBright = format(94, 39);
  magentaBright = format(95, 39);
  cyanBright = format(96, 39);
  whiteBright = format(97, 39);
  bgRedBright = format(101, 49);
  bgGreenBright = format(102, 49);
  bgYellowBright = format(103, 49);
  bgBlueBright = format(104, 49);
  bgMagentaBright = format(105, 49);
  bgCyanBright = format(106, 49);
  bgWhiteBright = format(107, 49);
});

// node_modules/yoctocolors/index.js
var init_yoctocolors = __esm(() => {
  init_base2();
  init_base2();
});

// node_modules/execa/lib/verbose/default.js
var defaultVerboseFunction = ({
  type: type2,
  message,
  timestamp,
  piped,
  commandId,
  result: { failed = false } = {},
  options: { reject = true }
}) => {
  const timestampString = serializeTimestamp(timestamp);
  const icon = ICONS[type2]({ failed, reject, piped });
  const color = COLORS[type2]({ reject });
  return `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
}, serializeTimestamp = (timestamp) => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`, padField = (field, padding) => String(field).padStart(padding, "0"), getFinalIcon = ({ failed, reject }) => {
  if (!failed) {
    return figures_default.tick;
  }
  return reject ? figures_default.cross : figures_default.warning;
}, ICONS, identity = (string) => string, COLORS;
var init_default = __esm(() => {
  init_figures();
  init_yoctocolors();
  ICONS = {
    command: ({ piped }) => piped ? "|" : "$",
    output: () => " ",
    ipc: () => "*",
    error: getFinalIcon,
    duration: getFinalIcon
  };
  COLORS = {
    command: () => bold,
    output: () => identity,
    ipc: () => identity,
    error: ({ reject }) => reject ? redBright : yellowBright,
    duration: () => gray
  };
});

// node_modules/execa/lib/verbose/custom.js
var applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {
  const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
  return printedLines.map(({ verboseLine, verboseObject }) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine) => printedLine !== undefined).map((printedLine) => appendNewline(printedLine)).join("");
}, applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {
  if (verboseFunction === undefined) {
    return verboseLine;
  }
  const printedLine = verboseFunction(verboseLine, verboseObject);
  if (typeof printedLine === "string") {
    return printedLine;
  }
}, appendNewline = (printedLine) => printedLine.endsWith(`
`) ? printedLine : `${printedLine}
`;
var init_custom = __esm(() => {
  init_values();
});

// node_modules/execa/lib/verbose/log.js
import { inspect } from "node:util";
var verboseLog = ({ type: type2, verboseMessage, fdNumber, verboseInfo, result }) => {
  const verboseObject = getVerboseObject({ type: type2, result, verboseInfo });
  const printedLines = getPrintedLines(verboseMessage, verboseObject);
  const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
  if (finalLines !== "") {
    console.warn(finalLines.slice(0, -1));
  }
}, getVerboseObject = ({
  type: type2,
  result,
  verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } }
}) => ({
  type: type2,
  escapedCommand,
  commandId: `${commandId}`,
  timestamp: new Date,
  piped,
  result,
  options
}), getPrintedLines = (verboseMessage, verboseObject) => verboseMessage.split(`
`).map((message) => getPrintedLine({ ...verboseObject, message })), getPrintedLine = (verboseObject) => {
  const verboseLine = defaultVerboseFunction(verboseObject);
  return { verboseLine, verboseObject };
}, serializeVerboseMessage = (message) => {
  const messageString = typeof message === "string" ? message : inspect(message);
  const escapedMessage = escapeLines(messageString);
  return escapedMessage.replaceAll("\t", " ".repeat(TAB_SIZE));
}, TAB_SIZE = 2;
var init_log = __esm(() => {
  init_escape();
  init_default();
  init_custom();
});

// node_modules/execa/lib/verbose/start.js
var logCommand = (escapedCommand, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  verboseLog({
    type: "command",
    verboseMessage: escapedCommand,
    verboseInfo
  });
};
var init_start = __esm(() => {
  init_values();
  init_log();
});

// node_modules/execa/lib/verbose/info.js
var getVerboseInfo = (verbose, escapedCommand, rawOptions) => {
  validateVerbose(verbose);
  const commandId = getCommandId(verbose);
  return {
    verbose,
    escapedCommand,
    commandId,
    rawOptions
  };
}, getCommandId = (verbose) => isVerbose({ verbose }) ? COMMAND_ID++ : undefined, COMMAND_ID = 0n, validateVerbose = (verbose) => {
  for (const fdVerbose of verbose) {
    if (fdVerbose === false) {
      throw new TypeError(`The "verbose: false" option was renamed to "verbose: 'none'".`);
    }
    if (fdVerbose === true) {
      throw new TypeError(`The "verbose: true" option was renamed to "verbose: 'short'".`);
    }
    if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
      const allowedValues = VERBOSE_VALUES.map((allowedValue) => `'${allowedValue}'`).join(", ");
      throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
    }
  }
};
var init_info = __esm(() => {
  init_values();
});

// node_modules/execa/lib/return/duration.js
import { hrtime } from "node:process";
var getStartTime = () => hrtime.bigint(), getDurationMs = (startTime) => Number(hrtime.bigint() - startTime) / 1e6;
var init_duration = () => {
};

// node_modules/execa/lib/arguments/command.js
var handleCommand = (filePath, rawArguments, rawOptions) => {
  const startTime = getStartTime();
  const { command, escapedCommand } = joinCommand(filePath, rawArguments);
  const verbose = normalizeFdSpecificOption(rawOptions, "verbose");
  const verboseInfo = getVerboseInfo(verbose, escapedCommand, { ...rawOptions });
  logCommand(escapedCommand, verboseInfo);
  return {
    command,
    escapedCommand,
    startTime,
    verboseInfo
  };
};
var init_command = __esm(() => {
  init_start();
  init_info();
  init_duration();
  init_escape();
  init_specific();
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs2 = __require("fs");
  function checkPathExt(path2, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i2 = 0;i2 < pathext.length; i2++) {
      var p = pathext[i2].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path2, options) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path2, options);
  }
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), path2, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs2 = __require("fs");
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), options);
  }
  function checkStat(stat2, options) {
    return stat2.isFile() && checkMode(stat2, options);
  }
  function checkMode(stat2, options) {
    var mod2 = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports, module) => {
  var fs2 = __require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module.exports = isexe;
  isexe.sync = sync;
  function isexe(path2, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path2, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path2, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path2, options) {
    try {
      return core.sync(path2, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = __require("path");
  var COLON2 = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON2;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i2) => new Promise((resolve, reject) => {
      if (i2 === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i2];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i2, 0));
    });
    const subStep = (p, i2, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i2 + 1));
      const ext = pathExt[ii];
      isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i2, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (let i2 = 0;i2 < pathEnv.length; i2++) {
      const ppRaw = pathEnv[i2];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0;j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, { pathExt: pathExtExe });
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports, module) => {
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform2 = options.platform || process.platform;
    if (platform2 !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module.exports = pathKey;
  module.exports.default = pathKey;
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports, module) => {
  var path2 = __require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env2 = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env2[getPathKey({ env: env2 })],
        pathExt: withoutPathExt ? path2.delimiter : undefined
      });
    } catch (e2) {
    } finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports, module) => {
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
    arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  exports.command = escapeCommand;
  exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports, module) => {
  module.exports = /^#!(.*)/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports, module) => {
  var shebangRegex = require_shebang_regex();
  module.exports = (string = "") => {
    const match = string.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path2, argument2] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path2.split("/").pop();
    if (binary === "env") {
      return argument2;
    }
    return argument2 ? `${binary} ${argument2}` : binary;
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports, module) => {
  var fs2 = __require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs2.openSync(command, "r");
      fs2.readSync(fd, buffer, 0, size, 0);
      fs2.closeSync(fd);
    } catch (e2) {
    }
    return shebangCommand(buffer.toString());
  }
  module.exports = readShebang;
});

// node_modules/cross-spawn/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var path2 = __require("path");
  var resolveCommand = require_resolveCommand();
  var escape = require_escape();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path2.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse2(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: undefined,
      original: {
        command,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module.exports = parse2;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports, module) => {
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports, module) => {
  var cp = __require("child_process");
  var parse2 = require_parse2();
  var enoent = require_enoent();
  function spawn(command, args, options) {
    const parsed = parse2(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse2(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;
  module.exports._parse = parse2;
  module.exports._enoent = enoent;
});

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env: env2 = process.env,
    platform: platform2 = process.platform
  } = options;
  if (platform2 !== "win32") {
    return "PATH";
  }
  return Object.keys(env2).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// node_modules/unicorn-magic/node.js
import { promisify as promisify2 } from "node:util";
import { execFile as execFileCallback, execFileSync as execFileSyncOriginal } from "node:child_process";
import path2 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
function toPath(urlOrPath) {
  return urlOrPath instanceof URL ? fileURLToPath2(urlOrPath) : urlOrPath;
}
function traversePathUp(startPath) {
  return {
    *[Symbol.iterator]() {
      let currentPath = path2.resolve(toPath(startPath));
      let previousPath;
      while (previousPath !== currentPath) {
        yield currentPath;
        previousPath = currentPath;
        currentPath = path2.resolve(currentPath, "..");
      }
    }
  };
}
var execFileOriginal, TEN_MEGABYTES_IN_BYTES;
var init_node = __esm(() => {
  execFileOriginal = promisify2(execFileCallback);
  TEN_MEGABYTES_IN_BYTES = 10 * 1024 * 1024;
});

// node_modules/npm-run-path/index.js
import process5 from "node:process";
import path3 from "node:path";
var npmRunPath = ({
  cwd = process5.cwd(),
  path: pathOption = process5.env[pathKey()],
  preferLocal = true,
  execPath = process5.execPath,
  addExecPath = true
} = {}) => {
  const cwdPath = path3.resolve(toPath(cwd));
  const result = [];
  const pathParts = pathOption.split(path3.delimiter);
  if (preferLocal) {
    applyPreferLocal(result, pathParts, cwdPath);
  }
  if (addExecPath) {
    applyExecPath(result, pathParts, execPath, cwdPath);
  }
  return pathOption === "" || pathOption === path3.delimiter ? `${result.join(path3.delimiter)}${pathOption}` : [...result, pathOption].join(path3.delimiter);
}, applyPreferLocal = (result, pathParts, cwdPath) => {
  for (const directory of traversePathUp(cwdPath)) {
    const pathPart = path3.join(directory, "node_modules/.bin");
    if (!pathParts.includes(pathPart)) {
      result.push(pathPart);
    }
  }
}, applyExecPath = (result, pathParts, execPath, cwdPath) => {
  const pathPart = path3.resolve(cwdPath, toPath(execPath), "..");
  if (!pathParts.includes(pathPart)) {
    result.push(pathPart);
  }
}, npmRunPathEnv = ({ env: env2 = process5.env, ...options } = {}) => {
  env2 = { ...env2 };
  const pathName = pathKey({ env: env2 });
  options.path = env2[pathName];
  env2[pathName] = npmRunPath(options);
  return env2;
};
var init_npm_run_path = __esm(() => {
  init_node();
});

// node_modules/execa/lib/return/final-error.js
var getFinalError = (originalError, message, isSync) => {
  const ErrorClass = isSync ? ExecaSyncError : ExecaError;
  const options = originalError instanceof DiscardedError ? {} : { cause: originalError };
  return new ErrorClass(message, options);
}, DiscardedError, setErrorName = (ErrorClass, value) => {
  Object.defineProperty(ErrorClass.prototype, "name", {
    value,
    writable: true,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
}, isExecaError = (error) => isErrorInstance(error) && (execaErrorSymbol in error), execaErrorSymbol, isErrorInstance = (value) => Object.prototype.toString.call(value) === "[object Error]", ExecaError, ExecaSyncError;
var init_final_error = __esm(() => {
  DiscardedError = class DiscardedError extends Error {
  };
  execaErrorSymbol = Symbol("isExecaError");
  ExecaError = class ExecaError extends Error {
  };
  setErrorName(ExecaError, ExecaError.name);
  ExecaSyncError = class ExecaSyncError extends Error {
  };
  setErrorName(ExecaSyncError, ExecaSyncError.name);
});

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = () => {
  const length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
}, getRealtimeSignal = (value, index) => ({
  name: `SIGRT${index + 1}`,
  number: SIGRTMIN + index,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
}), SIGRTMIN = 34, SIGRTMAX = 64;

// node_modules/human-signals/build/src/core.js
var SIGNALS;
var init_core = __esm(() => {
  SIGNALS = [
    {
      name: "SIGHUP",
      number: 1,
      action: "terminate",
      description: "Terminal closed",
      standard: "posix"
    },
    {
      name: "SIGINT",
      number: 2,
      action: "terminate",
      description: "User interruption with CTRL-C",
      standard: "ansi"
    },
    {
      name: "SIGQUIT",
      number: 3,
      action: "core",
      description: "User interruption with CTRL-\\",
      standard: "posix"
    },
    {
      name: "SIGILL",
      number: 4,
      action: "core",
      description: "Invalid machine instruction",
      standard: "ansi"
    },
    {
      name: "SIGTRAP",
      number: 5,
      action: "core",
      description: "Debugger breakpoint",
      standard: "posix"
    },
    {
      name: "SIGABRT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "ansi"
    },
    {
      name: "SIGIOT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "bsd"
    },
    {
      name: "SIGBUS",
      number: 7,
      action: "core",
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: "bsd"
    },
    {
      name: "SIGEMT",
      number: 7,
      action: "terminate",
      description: "Command should be emulated but is not implemented",
      standard: "other"
    },
    {
      name: "SIGFPE",
      number: 8,
      action: "core",
      description: "Floating point arithmetic error",
      standard: "ansi"
    },
    {
      name: "SIGKILL",
      number: 9,
      action: "terminate",
      description: "Forced termination",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGUSR1",
      number: 10,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGSEGV",
      number: 11,
      action: "core",
      description: "Segmentation fault",
      standard: "ansi"
    },
    {
      name: "SIGUSR2",
      number: 12,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGPIPE",
      number: 13,
      action: "terminate",
      description: "Broken pipe or socket",
      standard: "posix"
    },
    {
      name: "SIGALRM",
      number: 14,
      action: "terminate",
      description: "Timeout or timer",
      standard: "posix"
    },
    {
      name: "SIGTERM",
      number: 15,
      action: "terminate",
      description: "Termination",
      standard: "ansi"
    },
    {
      name: "SIGSTKFLT",
      number: 16,
      action: "terminate",
      description: "Stack is empty or overflowed",
      standard: "other"
    },
    {
      name: "SIGCHLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "posix"
    },
    {
      name: "SIGCLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "other"
    },
    {
      name: "SIGCONT",
      number: 18,
      action: "unpause",
      description: "Unpaused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGSTOP",
      number: 19,
      action: "pause",
      description: "Paused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGTSTP",
      number: 20,
      action: "pause",
      description: 'Paused using CTRL-Z or "suspend"',
      standard: "posix"
    },
    {
      name: "SIGTTIN",
      number: 21,
      action: "pause",
      description: "Background process cannot read terminal input",
      standard: "posix"
    },
    {
      name: "SIGBREAK",
      number: 21,
      action: "terminate",
      description: "User interruption with CTRL-BREAK",
      standard: "other"
    },
    {
      name: "SIGTTOU",
      number: 22,
      action: "pause",
      description: "Background process cannot write to terminal output",
      standard: "posix"
    },
    {
      name: "SIGURG",
      number: 23,
      action: "ignore",
      description: "Socket received out-of-band data",
      standard: "bsd"
    },
    {
      name: "SIGXCPU",
      number: 24,
      action: "core",
      description: "Process timed out",
      standard: "bsd"
    },
    {
      name: "SIGXFSZ",
      number: 25,
      action: "core",
      description: "File too big",
      standard: "bsd"
    },
    {
      name: "SIGVTALRM",
      number: 26,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGPROF",
      number: 27,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGWINCH",
      number: 28,
      action: "ignore",
      description: "Terminal window size changed",
      standard: "bsd"
    },
    {
      name: "SIGIO",
      number: 29,
      action: "terminate",
      description: "I/O is available",
      standard: "other"
    },
    {
      name: "SIGPOLL",
      number: 29,
      action: "terminate",
      description: "Watched event",
      standard: "other"
    },
    {
      name: "SIGINFO",
      number: 29,
      action: "ignore",
      description: "Request for process information",
      standard: "other"
    },
    {
      name: "SIGPWR",
      number: 30,
      action: "terminate",
      description: "Device running out of power",
      standard: "systemv"
    },
    {
      name: "SIGSYS",
      number: 31,
      action: "core",
      description: "Invalid system call",
      standard: "other"
    },
    {
      name: "SIGUNUSED",
      number: 31,
      action: "terminate",
      description: "Invalid system call",
      standard: "other"
    }
  ];
});

// node_modules/human-signals/build/src/signals.js
import { constants } from "node:os";
var getSignals = () => {
  const realtimeSignals = getRealtimeSignals();
  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals;
}, normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) => {
  const {
    signals: { [name]: constantSignal }
  } = constants;
  const supported = constantSignal !== undefined;
  const number = supported ? constantSignal : defaultNumber;
  return { name, number, description, supported, action, forced, standard };
};
var init_signals = __esm(() => {
  init_core();
});

// node_modules/human-signals/build/src/main.js
import { constants as constants2 } from "node:os";
var getSignalsByName = () => {
  const signals = getSignals();
  return Object.fromEntries(signals.map(getSignalByName));
}, getSignalByName = ({
  name,
  number,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number, description, supported, action, forced, standard }], signalsByName, getSignalsByNumber = () => {
  const signals = getSignals();
  const length = SIGRTMAX + 1;
  const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
  return Object.assign({}, ...signalsA);
}, getSignalByNumber = (number, signals) => {
  const signal = findSignalByNumber(number, signals);
  if (signal === undefined) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
}, findSignalByNumber = (number, signals) => {
  const signal = signals.find(({ name }) => constants2.signals[name] === number);
  if (signal !== undefined) {
    return signal;
  }
  return signals.find((signalA) => signalA.number === number);
}, signalsByNumber;
var init_main2 = __esm(() => {
  init_signals();
  signalsByName = getSignalsByName();
  signalsByNumber = getSignalsByNumber();
});

// node_modules/execa/lib/terminate/signal.js
import { constants as constants3 } from "node:os";
var normalizeKillSignal = (killSignal) => {
  const optionName = "option `killSignal`";
  if (killSignal === 0) {
    throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
  }
  return normalizeSignal2(killSignal, optionName);
}, normalizeSignalArgument = (signal) => signal === 0 ? signal : normalizeSignal2(signal, "`subprocess.kill()`'s argument"), normalizeSignal2 = (signalNameOrInteger, optionName) => {
  if (Number.isInteger(signalNameOrInteger)) {
    return normalizeSignalInteger(signalNameOrInteger, optionName);
  }
  if (typeof signalNameOrInteger === "string") {
    return normalizeSignalName(signalNameOrInteger, optionName);
  }
  throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.
${getAvailableSignals()}`);
}, normalizeSignalInteger = (signalInteger, optionName) => {
  if (signalsIntegerToName.has(signalInteger)) {
    return signalsIntegerToName.get(signalInteger);
  }
  throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.
${getAvailableSignals()}`);
}, getSignalsIntegerToName = () => new Map(Object.entries(constants3.signals).reverse().map(([signalName, signalInteger]) => [signalInteger, signalName])), signalsIntegerToName, normalizeSignalName = (signalName, optionName) => {
  if (signalName in constants3.signals) {
    return signalName;
  }
  if (signalName.toUpperCase() in constants3.signals) {
    throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
  }
  throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.
${getAvailableSignals()}`);
}, getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`, getAvailableSignalNames = () => Object.keys(constants3.signals).sort().map((signalName) => `'${signalName}'`).join(", "), getAvailableSignalIntegers = () => [...new Set(Object.values(constants3.signals).sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))].join(", "), getSignalDescription = (signal) => signalsByName[signal].description;
var init_signal = __esm(() => {
  init_main2();
  signalsIntegerToName = getSignalsIntegerToName();
});

// node_modules/execa/lib/terminate/kill.js
import { setTimeout as setTimeout2 } from "node:timers/promises";
var normalizeForceKillAfterDelay = (forceKillAfterDelay) => {
  if (forceKillAfterDelay === false) {
    return forceKillAfterDelay;
  }
  if (forceKillAfterDelay === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
    throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
  }
  return forceKillAfterDelay;
}, DEFAULT_FORCE_KILL_TIMEOUT, subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context: context3, controller }, signalOrError, errorArgument) => {
  const { signal, error } = parseKillArguments(signalOrError, errorArgument, killSignal);
  emitKillError(error, onInternalError);
  const killResult = kill(signal);
  setKillTimeout({
    kill,
    signal,
    forceKillAfterDelay,
    killSignal,
    killResult,
    context: context3,
    controller
  });
  return killResult;
}, parseKillArguments = (signalOrError, errorArgument, killSignal) => {
  const [signal = killSignal, error] = isErrorInstance(signalOrError) ? [undefined, signalOrError] : [signalOrError, errorArgument];
  if (typeof signal !== "string" && !Number.isInteger(signal)) {
    throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
  }
  if (error !== undefined && !isErrorInstance(error)) {
    throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
  }
  return { signal: normalizeSignalArgument(signal), error };
}, emitKillError = (error, onInternalError) => {
  if (error !== undefined) {
    onInternalError.reject(error);
  }
}, setKillTimeout = async ({ kill, signal, forceKillAfterDelay, killSignal, killResult, context: context3, controller }) => {
  if (signal === killSignal && killResult) {
    killOnTimeout({
      kill,
      forceKillAfterDelay,
      context: context3,
      controllerSignal: controller.signal
    });
  }
}, killOnTimeout = async ({ kill, forceKillAfterDelay, context: context3, controllerSignal }) => {
  if (forceKillAfterDelay === false) {
    return;
  }
  try {
    await setTimeout2(forceKillAfterDelay, undefined, { signal: controllerSignal });
    if (kill("SIGKILL")) {
      context3.isForcefullyTerminated ??= true;
    }
  } catch {
  }
};
var init_kill = __esm(() => {
  init_final_error();
  init_signal();
  DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
});

// node_modules/execa/lib/utils/abort-signal.js
import { once } from "node:events";
var onAbortedSignal = async (mainSignal, stopSignal) => {
  if (!mainSignal.aborted) {
    await once(mainSignal, "abort", { signal: stopSignal });
  }
};
var init_abort_signal = () => {
};

// node_modules/execa/lib/terminate/cancel.js
var validateCancelSignal = ({ cancelSignal }) => {
  if (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== "[object AbortSignal]") {
    throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
  }
}, throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context: context3, controller }) => cancelSignal === undefined || gracefulCancel ? [] : [terminateOnCancel(subprocess, cancelSignal, context3, controller)], terminateOnCancel = async (subprocess, cancelSignal, context3, { signal }) => {
  await onAbortedSignal(cancelSignal, signal);
  context3.terminationReason ??= "cancel";
  subprocess.kill();
  throw cancelSignal.reason;
};
var init_cancel = __esm(() => {
  init_abort_signal();
});

// node_modules/execa/lib/ipc/validation.js
var validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected }) => {
  validateIpcOption(methodName, isSubprocess, ipc);
  validateConnection(methodName, isSubprocess, isConnected);
}, validateIpcOption = (methodName, isSubprocess, ipc) => {
  if (!ipc) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
  }
}, validateConnection = (methodName, isSubprocess, isConnected) => {
  if (!isConnected) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
  }
}, throwOnEarlyDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("getOneMessage", isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
}, throwOnStrictDeadlockError = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
\t${getMethodName("getOneMessage", isSubprocess)},
\t${getMethodName("sendMessage", isSubprocess, "message, {strict: true}")},
]);`);
}, getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName("sendMessage", isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, { cause: error }), throwOnMissingStrict = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
}, throwOnStrictDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
}, getAbortDisconnectError = () => new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`), throwOnMissingParent = () => {
  throw new Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.");
}, handleEpipeError = ({ error, methodName, isSubprocess }) => {
  if (error.code === "EPIPE") {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, { cause: error });
  }
}, handleSerializationError = ({ error, methodName, isSubprocess, message }) => {
  if (isSerializationError(error)) {
    throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, { cause: error });
  }
}, isSerializationError = ({ code, message }) => SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage) => message.includes(serializationErrorMessage)), SERIALIZATION_ERROR_CODES, SERIALIZATION_ERROR_MESSAGES, getMethodName = (methodName, isSubprocess, parameters = "") => methodName === "cancelSignal" ? "`cancelSignal`'s `controller.abort()`" : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`, getNamespaceName = (isSubprocess) => isSubprocess ? "" : "subprocess.", getOtherProcessName = (isSubprocess) => isSubprocess ? "parent process" : "subprocess", disconnect = (anyProcess) => {
  if (anyProcess.connected) {
    anyProcess.disconnect();
  }
};
var init_validation = __esm(() => {
  SERIALIZATION_ERROR_CODES = new Set([
    "ERR_MISSING_ARGS",
    "ERR_INVALID_ARG_TYPE"
  ]);
  SERIALIZATION_ERROR_MESSAGES = [
    "could not be cloned",
    "circular structure",
    "call stack size exceeded"
  ];
});

// node_modules/execa/lib/utils/deferred.js
var createDeferred = () => {
  const methods = {};
  const promise = new Promise((resolve, reject) => {
    Object.assign(methods, { resolve, reject });
  });
  return Object.assign(promise, methods);
};

// node_modules/execa/lib/arguments/fd-options.js
var getToStream = (destination, to = "stdin") => {
  const isWritable = true;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
  const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
  const destinationStream = destination.stdio[fdNumber];
  if (destinationStream === null) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
  }
  return destinationStream;
}, getFromStream = (source, from = "stdout") => {
  const isWritable = false;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
  const sourceStream = fdNumber === "all" ? source.all : source.stdio[fdNumber];
  if (sourceStream === null || sourceStream === undefined) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
  }
  return sourceStream;
}, SUBPROCESS_OPTIONS, getFdNumber = (fileDescriptors, fdName, isWritable) => {
  const fdNumber = parseFdNumber(fdName, isWritable);
  validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
  return fdNumber;
}, parseFdNumber = (fdName, isWritable) => {
  const fdNumber = parseFd(fdName);
  if (fdNumber !== undefined) {
    return fdNumber;
  }
  const { validOptions, defaultValue } = isWritable ? { validOptions: '"stdin"', defaultValue: "stdin" } : { validOptions: '"stdout", "stderr", "all"', defaultValue: "stdout" };
  throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
}, validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {
  const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
  if (fileDescriptor === undefined) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  if (fileDescriptor.direction === "input" && !isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
  }
  if (fileDescriptor.direction !== "input" && isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
  }
}, getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {
  if (fdNumber === "all" && !options.all) {
    return `The "all" option must be true to use "from: 'all'".`;
  }
  const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
  return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
}, getInvalidStdioOption = (fdNumber, { stdin, stdout, stderr, stdio }) => {
  const usedDescriptor = getUsedDescriptor(fdNumber);
  if (usedDescriptor === 0 && stdin !== undefined) {
    return { optionName: "stdin", optionValue: stdin };
  }
  if (usedDescriptor === 1 && stdout !== undefined) {
    return { optionName: "stdout", optionValue: stdout };
  }
  if (usedDescriptor === 2 && stderr !== undefined) {
    return { optionName: "stderr", optionValue: stderr };
  }
  return { optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor] };
}, getUsedDescriptor = (fdNumber) => fdNumber === "all" ? 1 : fdNumber, getOptionName = (isWritable) => isWritable ? "to" : "from", serializeOptionValue = (value) => {
  if (typeof value === "string") {
    return `'${value}'`;
  }
  return typeof value === "number" ? `${value}` : "Stream";
};
var init_fd_options = __esm(() => {
  init_specific();
  SUBPROCESS_OPTIONS = new WeakMap;
});

// node_modules/execa/lib/utils/max-listeners.js
import { addAbortListener } from "node:events";
var incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {
  const maxListeners = eventEmitter.getMaxListeners();
  if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
    return;
  }
  eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
  addAbortListener(signal, () => {
    eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
  });
};
var init_max_listeners = () => {
};

// node_modules/execa/lib/ipc/reference.js
var addReference = (channel, reference) => {
  if (reference) {
    addReferenceCount(channel);
  }
}, addReferenceCount = (channel) => {
  channel.refCounted();
}, removeReference = (channel, reference) => {
  if (reference) {
    removeReferenceCount(channel);
  }
}, removeReferenceCount = (channel) => {
  channel.unrefCounted();
}, undoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    removeReferenceCount(channel);
    removeReferenceCount(channel);
  }
}, redoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    addReferenceCount(channel);
    addReferenceCount(channel);
  }
};

// node_modules/execa/lib/ipc/incoming.js
import { once as once2 } from "node:events";
import { scheduler } from "node:timers/promises";
var onMessage = async ({ anyProcess, channel, isSubprocess, ipcEmitter }, wrappedMessage) => {
  if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {
    return;
  }
  if (!INCOMING_MESSAGES.has(anyProcess)) {
    INCOMING_MESSAGES.set(anyProcess, []);
  }
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  incomingMessages.push(wrappedMessage);
  if (incomingMessages.length > 1) {
    return;
  }
  while (incomingMessages.length > 0) {
    await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
    await scheduler.yield();
    const message = await handleStrictRequest({
      wrappedMessage: incomingMessages[0],
      anyProcess,
      channel,
      isSubprocess,
      ipcEmitter
    });
    incomingMessages.shift();
    ipcEmitter.emit("message", message);
    ipcEmitter.emit("message:done");
  }
}, onDisconnect = async ({ anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage }) => {
  abortOnDisconnect();
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  while (incomingMessages?.length > 0) {
    await once2(ipcEmitter, "message:done");
  }
  anyProcess.removeListener("message", boundOnMessage);
  redoAddedReferences(channel, isSubprocess);
  ipcEmitter.connected = false;
  ipcEmitter.emit("disconnect");
}, INCOMING_MESSAGES;
var init_incoming = __esm(() => {
  init_outgoing();
  init_strict();
  init_graceful();
  INCOMING_MESSAGES = new WeakMap;
});

// node_modules/execa/lib/ipc/forward.js
import { EventEmitter } from "node:events";
var getIpcEmitter = (anyProcess, channel, isSubprocess) => {
  if (IPC_EMITTERS.has(anyProcess)) {
    return IPC_EMITTERS.get(anyProcess);
  }
  const ipcEmitter = new EventEmitter;
  ipcEmitter.connected = true;
  IPC_EMITTERS.set(anyProcess, ipcEmitter);
  forwardEvents({
    ipcEmitter,
    anyProcess,
    channel,
    isSubprocess
  });
  return ipcEmitter;
}, IPC_EMITTERS, forwardEvents = ({ ipcEmitter, anyProcess, channel, isSubprocess }) => {
  const boundOnMessage = onMessage.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter
  });
  anyProcess.on("message", boundOnMessage);
  anyProcess.once("disconnect", onDisconnect.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter,
    boundOnMessage
  }));
  undoAddedReferences(channel, isSubprocess);
}, isConnected = (anyProcess) => {
  const ipcEmitter = IPC_EMITTERS.get(anyProcess);
  return ipcEmitter === undefined ? anyProcess.channel !== null : ipcEmitter.connected;
};
var init_forward = __esm(() => {
  init_incoming();
  IPC_EMITTERS = new WeakMap;
});

// node_modules/execa/lib/ipc/strict.js
import { once as once3 } from "node:events";
var handleSendStrict = ({ anyProcess, channel, isSubprocess, message, strict }) => {
  if (!strict) {
    return message;
  }
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
  return {
    id: count++,
    type: REQUEST_TYPE,
    message,
    hasListeners
  };
}, count = 0n, validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {
    return;
  }
  for (const { id } of outgoingMessages) {
    if (id !== undefined) {
      STRICT_RESPONSES[id].resolve({ isDeadlock: true, hasListeners: false });
    }
  }
}, handleStrictRequest = async ({ wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter }) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {
    return wrappedMessage;
  }
  const { id, message } = wrappedMessage;
  const response = { id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter) };
  try {
    await sendMessage({
      anyProcess,
      channel,
      isSubprocess,
      ipc: true
    }, response);
  } catch (error) {
    ipcEmitter.emit("strict:error", error);
  }
  return message;
}, handleStrictResponse = (wrappedMessage) => {
  if (wrappedMessage?.type !== RESPONSE_TYPE) {
    return false;
  }
  const { id, message: hasListeners } = wrappedMessage;
  STRICT_RESPONSES[id]?.resolve({ isDeadlock: false, hasListeners });
  return true;
}, waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {
  if (wrappedMessage?.type !== REQUEST_TYPE) {
    return;
  }
  const deferred = createDeferred();
  STRICT_RESPONSES[wrappedMessage.id] = deferred;
  const controller = new AbortController;
  try {
    const { isDeadlock, hasListeners } = await Promise.race([
      deferred,
      throwOnDisconnect(anyProcess, isSubprocess, controller)
    ]);
    if (isDeadlock) {
      throwOnStrictDeadlockError(isSubprocess);
    }
    if (!hasListeners) {
      throwOnMissingStrict(isSubprocess);
    }
  } finally {
    controller.abort();
    delete STRICT_RESPONSES[wrappedMessage.id];
  }
}, STRICT_RESPONSES, throwOnDisconnect = async (anyProcess, isSubprocess, { signal }) => {
  incrementMaxListeners(anyProcess, 1, signal);
  await once3(anyProcess, "disconnect", { signal });
  throwOnStrictDisconnect(isSubprocess);
}, REQUEST_TYPE = "execa:ipc:request", RESPONSE_TYPE = "execa:ipc:response";
var init_strict = __esm(() => {
  init_max_listeners();
  init_send();
  init_validation();
  init_forward();
  init_outgoing();
  STRICT_RESPONSES = {};
});

// node_modules/execa/lib/ipc/outgoing.js
var startSendMessage = (anyProcess, wrappedMessage, strict) => {
  if (!OUTGOING_MESSAGES.has(anyProcess)) {
    OUTGOING_MESSAGES.set(anyProcess, new Set);
  }
  const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
  const onMessageSent = createDeferred();
  const id = strict ? wrappedMessage.id : undefined;
  const outgoingMessage = { onMessageSent, id };
  outgoingMessages.add(outgoingMessage);
  return { outgoingMessages, outgoingMessage };
}, endSendMessage = ({ outgoingMessages, outgoingMessage }) => {
  outgoingMessages.delete(outgoingMessage);
  outgoingMessage.onMessageSent.resolve();
}, waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {
  while (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {
    const outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];
    validateStrictDeadlock(outgoingMessages, wrappedMessage);
    await Promise.all(outgoingMessages.map(({ onMessageSent }) => onMessageSent));
  }
}, OUTGOING_MESSAGES, hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount("message") > getMinListenerCount(anyProcess), getMinListenerCount = (anyProcess) => SUBPROCESS_OPTIONS.has(anyProcess) && !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, "ipc") ? 1 : 0;
var init_outgoing = __esm(() => {
  init_specific();
  init_fd_options();
  init_strict();
  OUTGOING_MESSAGES = new WeakMap;
});

// node_modules/execa/lib/ipc/send.js
import { promisify as promisify3 } from "node:util";
var sendMessage = ({ anyProcess, channel, isSubprocess, ipc }, message, { strict = false } = {}) => {
  const methodName = "sendMessage";
  validateIpcMethod({
    methodName,
    isSubprocess,
    ipc,
    isConnected: anyProcess.connected
  });
  return sendMessageAsync({
    anyProcess,
    channel,
    methodName,
    isSubprocess,
    message,
    strict
  });
}, sendMessageAsync = async ({ anyProcess, channel, methodName, isSubprocess, message, strict }) => {
  const wrappedMessage = handleSendStrict({
    anyProcess,
    channel,
    isSubprocess,
    message,
    strict
  });
  const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);
  try {
    await sendOneMessage({
      anyProcess,
      methodName,
      isSubprocess,
      wrappedMessage,
      message
    });
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    endSendMessage(outgoingMessagesState);
  }
}, sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message }) => {
  const sendMethod = getSendMethod(anyProcess);
  try {
    await Promise.all([
      waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),
      sendMethod(wrappedMessage)
    ]);
  } catch (error) {
    handleEpipeError({ error, methodName, isSubprocess });
    handleSerializationError({
      error,
      methodName,
      isSubprocess,
      message
    });
    throw error;
  }
}, getSendMethod = (anyProcess) => {
  if (PROCESS_SEND_METHODS.has(anyProcess)) {
    return PROCESS_SEND_METHODS.get(anyProcess);
  }
  const sendMethod = promisify3(anyProcess.send.bind(anyProcess));
  PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
  return sendMethod;
}, PROCESS_SEND_METHODS;
var init_send = __esm(() => {
  init_validation();
  init_outgoing();
  init_strict();
  PROCESS_SEND_METHODS = new WeakMap;
});

// node_modules/execa/lib/ipc/graceful.js
import { scheduler as scheduler2 } from "node:timers/promises";
var sendAbort = (subprocess, message) => {
  const methodName = "cancelSignal";
  validateConnection(methodName, false, subprocess.connected);
  return sendOneMessage({
    anyProcess: subprocess,
    methodName,
    isSubprocess: false,
    wrappedMessage: { type: GRACEFUL_CANCEL_TYPE, message },
    message
  });
}, getCancelSignal = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  await startIpc({
    anyProcess,
    channel,
    isSubprocess,
    ipc
  });
  return cancelController.signal;
}, startIpc = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  if (cancelListening) {
    return;
  }
  cancelListening = true;
  if (!ipc) {
    throwOnMissingParent();
    return;
  }
  if (channel === null) {
    abortOnDisconnect();
    return;
  }
  getIpcEmitter(anyProcess, channel, isSubprocess);
  await scheduler2.yield();
}, cancelListening = false, handleAbort = (wrappedMessage) => {
  if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {
    return false;
  }
  cancelController.abort(wrappedMessage.message);
  return true;
}, GRACEFUL_CANCEL_TYPE = "execa:ipc:cancel", abortOnDisconnect = () => {
  cancelController.abort(getAbortDisconnectError());
}, cancelController;
var init_graceful = __esm(() => {
  init_send();
  init_forward();
  init_validation();
  cancelController = new AbortController;
});

// node_modules/execa/lib/terminate/graceful.js
var validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization }) => {
  if (!gracefulCancel) {
    return;
  }
  if (cancelSignal === undefined) {
    throw new Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");
  }
  if (!ipc) {
    throw new Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");
  }
  if (serialization === "json") {
    throw new Error("The `serialization` option cannot be 'json' when setting the `gracefulCancel` option.");
  }
}, throwOnGracefulCancel = ({
  subprocess,
  cancelSignal,
  gracefulCancel,
  forceKillAfterDelay,
  context: context3,
  controller
}) => gracefulCancel ? [sendOnAbort({
  subprocess,
  cancelSignal,
  forceKillAfterDelay,
  context: context3,
  controller
})] : [], sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context: context3, controller: { signal } }) => {
  await onAbortedSignal(cancelSignal, signal);
  const reason = getReason(cancelSignal);
  await sendAbort(subprocess, reason);
  killOnTimeout({
    kill: subprocess.kill,
    forceKillAfterDelay,
    context: context3,
    controllerSignal: signal
  });
  context3.terminationReason ??= "gracefulCancel";
  throw cancelSignal.reason;
}, getReason = ({ reason }) => {
  if (!(reason instanceof DOMException)) {
    return reason;
  }
  const error = new Error(reason.message);
  Object.defineProperty(error, "stack", {
    value: reason.stack,
    enumerable: false,
    configurable: true,
    writable: true
  });
  return error;
};
var init_graceful2 = __esm(() => {
  init_abort_signal();
  init_graceful();
  init_kill();
});

// node_modules/execa/lib/terminate/timeout.js
import { setTimeout as setTimeout3 } from "node:timers/promises";
var validateTimeout = ({ timeout }) => {
  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
}, throwOnTimeout = (subprocess, timeout, context3, controller) => timeout === 0 || timeout === undefined ? [] : [killAfterTimeout(subprocess, timeout, context3, controller)], killAfterTimeout = async (subprocess, timeout, context3, { signal }) => {
  await setTimeout3(timeout, undefined, { signal });
  context3.terminationReason ??= "timeout";
  subprocess.kill();
  throw new DiscardedError;
};
var init_timeout = __esm(() => {
  init_final_error();
});

// node_modules/execa/lib/methods/node.js
import { execPath, execArgv } from "node:process";
import path4 from "node:path";
var mapNode = ({ options }) => {
  if (options.node === false) {
    throw new TypeError('The "node" option cannot be false with `execaNode()`.');
  }
  return { options: { ...options, node: true } };
}, handleNodeOption = (file, commandArguments, {
  node: shouldHandleNode = false,
  nodePath = execPath,
  nodeOptions = execArgv.filter((nodeOption) => !nodeOption.startsWith("--inspect")),
  cwd,
  execPath: formerNodePath,
  ...options
}) => {
  if (formerNodePath !== undefined) {
    throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
  }
  const normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The "nodePath" option');
  const resolvedNodePath = path4.resolve(cwd, normalizedNodePath);
  const newOptions = {
    ...options,
    nodePath: resolvedNodePath,
    node: shouldHandleNode,
    cwd
  };
  if (!shouldHandleNode) {
    return [file, commandArguments, newOptions];
  }
  if (path4.basename(file, ".exe") === "node") {
    throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
  }
  return [
    resolvedNodePath,
    [...nodeOptions, file, ...commandArguments],
    { ipc: true, ...newOptions, shell: false }
  ];
};
var init_node2 = __esm(() => {
  init_file_url();
});

// node_modules/execa/lib/ipc/ipc-input.js
import { serialize } from "node:v8";
var validateIpcInputOption = ({ ipcInput, ipc, serialization }) => {
  if (ipcInput === undefined) {
    return;
  }
  if (!ipc) {
    throw new Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");
  }
  validateIpcInput[serialization](ipcInput);
}, validateAdvancedInput = (ipcInput) => {
  try {
    serialize(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with a structured clone.", { cause: error });
  }
}, validateJsonInput = (ipcInput) => {
  try {
    JSON.stringify(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with JSON.", { cause: error });
  }
}, validateIpcInput, sendIpcInput = async (subprocess, ipcInput) => {
  if (ipcInput === undefined) {
    return;
  }
  await subprocess.sendMessage(ipcInput);
};
var init_ipc_input = __esm(() => {
  validateIpcInput = {
    advanced: validateAdvancedInput,
    json: validateJsonInput
  };
});

// node_modules/execa/lib/arguments/encoding-option.js
var validateEncoding = ({ encoding }) => {
  if (ENCODINGS.has(encoding)) {
    return;
  }
  const correctEncoding = getCorrectEncoding(encoding);
  if (correctEncoding !== undefined) {
    throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
  }
  const correctEncodings = [...ENCODINGS].map((correctEncoding2) => serializeEncoding(correctEncoding2)).join(", ");
  throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
}, TEXT_ENCODINGS, BINARY_ENCODINGS, ENCODINGS, getCorrectEncoding = (encoding) => {
  if (encoding === null) {
    return "buffer";
  }
  if (typeof encoding !== "string") {
    return;
  }
  const lowerEncoding = encoding.toLowerCase();
  if (lowerEncoding in ENCODING_ALIASES) {
    return ENCODING_ALIASES[lowerEncoding];
  }
  if (ENCODINGS.has(lowerEncoding)) {
    return lowerEncoding;
  }
}, ENCODING_ALIASES, serializeEncoding = (encoding) => typeof encoding === "string" ? `"${encoding}"` : String(encoding);
var init_encoding_option = __esm(() => {
  TEXT_ENCODINGS = new Set(["utf8", "utf16le"]);
  BINARY_ENCODINGS = new Set(["buffer", "hex", "base64", "base64url", "latin1", "ascii"]);
  ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);
  ENCODING_ALIASES = {
    "utf-8": "utf8",
    "utf-16le": "utf16le",
    "ucs-2": "utf16le",
    ucs2: "utf16le",
    binary: "latin1"
  };
});

// node_modules/execa/lib/arguments/cwd.js
import { statSync as statSync2 } from "node:fs";
import path5 from "node:path";
import process6 from "node:process";
var normalizeCwd = (cwd = getDefaultCwd()) => {
  const cwdString = safeNormalizeFileUrl(cwd, 'The "cwd" option');
  return path5.resolve(cwdString);
}, getDefaultCwd = () => {
  try {
    return process6.cwd();
  } catch (error) {
    error.message = `The current directory does not exist.
${error.message}`;
    throw error;
  }
}, fixCwdError = (originalMessage, cwd) => {
  if (cwd === getDefaultCwd()) {
    return originalMessage;
  }
  let cwdStat;
  try {
    cwdStat = statSync2(cwd);
  } catch (error) {
    return `The "cwd" option is invalid: ${cwd}.
${error.message}
${originalMessage}`;
  }
  if (!cwdStat.isDirectory()) {
    return `The "cwd" option is not a directory: ${cwd}.
${originalMessage}`;
  }
  return originalMessage;
};
var init_cwd = __esm(() => {
  init_file_url();
});

// node_modules/execa/lib/arguments/options.js
import path6 from "node:path";
import process7 from "node:process";
var import_cross_spawn, normalizeOptions = (filePath, rawArguments, rawOptions) => {
  rawOptions.cwd = normalizeCwd(rawOptions.cwd);
  const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);
  const { command: file, args: commandArguments, options: initialOptions } = import_cross_spawn.default._parse(processedFile, processedArguments, processedOptions);
  const fdOptions = normalizeFdSpecificOptions(initialOptions);
  const options = addDefaultOptions(fdOptions);
  validateTimeout(options);
  validateEncoding(options);
  validateIpcInputOption(options);
  validateCancelSignal(options);
  validateGracefulCancel(options);
  options.shell = normalizeFileUrl(options.shell);
  options.env = getEnv(options);
  options.killSignal = normalizeKillSignal(options.killSignal);
  options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
  options.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);
  if (process7.platform === "win32" && path6.basename(file, ".exe") === "cmd") {
    commandArguments.unshift("/q");
  }
  return { file, commandArguments, options };
}, addDefaultOptions = ({
  extendEnv = true,
  preferLocal = false,
  cwd,
  localDir: localDirectory = cwd,
  encoding = "utf8",
  reject = true,
  cleanup = true,
  all = false,
  windowsHide = true,
  killSignal = "SIGTERM",
  forceKillAfterDelay = true,
  gracefulCancel = false,
  ipcInput,
  ipc = ipcInput !== undefined || gracefulCancel,
  serialization = "advanced",
  ...options
}) => ({
  ...options,
  extendEnv,
  preferLocal,
  cwd,
  localDirectory,
  encoding,
  reject,
  cleanup,
  all,
  windowsHide,
  killSignal,
  forceKillAfterDelay,
  gracefulCancel,
  ipcInput,
  ipc,
  serialization
}), getEnv = ({ env: envOption, extendEnv, preferLocal, node: node2, localDirectory, nodePath }) => {
  const env2 = extendEnv ? { ...process7.env, ...envOption } : envOption;
  if (preferLocal || node2) {
    return npmRunPathEnv({
      env: env2,
      cwd: localDirectory,
      execPath: nodePath,
      preferLocal,
      addExecPath: node2
    });
  }
  return env2;
};
var init_options = __esm(() => {
  import_cross_spawn = __toESM(require_cross_spawn(), 1);
  init_npm_run_path();
  init_kill();
  init_signal();
  init_cancel();
  init_graceful2();
  init_timeout();
  init_node2();
  init_ipc_input();
  init_encoding_option();
  init_cwd();
  init_file_url();
  init_specific();
});

// node_modules/execa/lib/arguments/shell.js
var concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0 ? [[file, ...commandArguments].join(" "), [], options] : [file, commandArguments, options];

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  if (typeof input === "string") {
    return stripFinalNewlineString(input);
  }
  if (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {
    throw new Error("Input must be a string or a Uint8Array");
  }
  return stripFinalNewlineBinary(input);
}
var stripFinalNewlineString = (input) => input.at(-1) === LF2 ? input.slice(0, input.at(-2) === CR2 ? -2 : -1) : input, stripFinalNewlineBinary = (input) => input.at(-1) === LF_BINARY ? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1) : input, LF2 = `
`, LF_BINARY, CR2 = "\r", CR_BINARY;
var init_strip_final_newline = __esm(() => {
  LF_BINARY = LF2.codePointAt(0);
  CR_BINARY = CR2.codePointAt(0);
});

// node_modules/is-stream/index.js
function isStream(stream, { checkOpen = true } = {}) {
  return stream !== null && typeof stream === "object" && (stream.writable || stream.readable || !checkOpen || stream.writable === undefined && stream.readable === undefined) && typeof stream.pipe === "function";
}
function isWritableStream(stream, { checkOpen = true } = {}) {
  return isStream(stream, { checkOpen }) && (stream.writable || !checkOpen) && typeof stream.write === "function" && typeof stream.end === "function" && typeof stream.writable === "boolean" && typeof stream.writableObjectMode === "boolean" && typeof stream.destroy === "function" && typeof stream.destroyed === "boolean";
}
function isReadableStream(stream, { checkOpen = true } = {}) {
  return isStream(stream, { checkOpen }) && (stream.readable || !checkOpen) && typeof stream.read === "function" && typeof stream.readable === "boolean" && typeof stream.readableObjectMode === "boolean" && typeof stream.destroy === "function" && typeof stream.destroyed === "boolean";
}
function isDuplexStream(stream, options) {
  return isWritableStream(stream, options) && isReadableStream(stream, options);
}

// node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
class c {
  #t;
  #n;
  #r = false;
  #e = undefined;
  constructor(e2, t2) {
    this.#t = e2, this.#n = t2;
  }
  next() {
    const e2 = () => this.#s();
    return this.#e = this.#e ? this.#e.then(e2, e2) : e2(), this.#e;
  }
  return(e2) {
    const t2 = () => this.#i(e2);
    return this.#e ? this.#e.then(t2, t2) : t2();
  }
  async#s() {
    if (this.#r)
      return {
        done: true,
        value: undefined
      };
    let e2;
    try {
      e2 = await this.#t.read();
    } catch (t2) {
      throw this.#e = undefined, this.#r = true, this.#t.releaseLock(), t2;
    }
    return e2.done && (this.#e = undefined, this.#r = true, this.#t.releaseLock()), e2;
  }
  async#i(e2) {
    if (this.#r)
      return {
        done: true,
        value: e2
      };
    if (this.#r = true, !this.#n) {
      const t2 = this.#t.cancel(e2);
      return this.#t.releaseLock(), await t2, {
        done: true,
        value: e2
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e2
    };
  }
}
function i2() {
  return this[n].next();
}
function o(r2) {
  return this[n].return(r2);
}
function h2({ preventCancel: r2 = false } = {}) {
  const e2 = this.getReader(), t2 = new c(e2, r2), s2 = Object.create(u);
  return s2[n] = t2, s2;
}
var a, n, u;
var init_asyncIterator = __esm(() => {
  a = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  n = Symbol();
  Object.defineProperty(i2, "name", { value: "next" });
  Object.defineProperty(o, "name", { value: "return" });
  u = Object.create(a, {
    next: {
      enumerable: true,
      configurable: true,
      writable: true,
      value: i2
    },
    return: {
      enumerable: true,
      configurable: true,
      writable: true,
      value: o
    }
  });
});

// node_modules/@sec-ant/readable-stream/dist/ponyfill/fromAnyIterable.js
var init_fromAnyIterable = () => {
};

// node_modules/@sec-ant/readable-stream/dist/ponyfill/index.js
var init_ponyfill = __esm(() => {
  init_asyncIterator();
  init_fromAnyIterable();
});

// node_modules/get-stream/source/stream.js
var getAsyncIterable = (stream) => {
  if (isReadableStream(stream, { checkOpen: false }) && nodeImports.on !== undefined) {
    return getStreamIterable(stream);
  }
  if (typeof stream?.[Symbol.asyncIterator] === "function") {
    return stream;
  }
  if (toString.call(stream) === "[object ReadableStream]") {
    return h2.call(stream);
  }
  throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
}, toString, getStreamIterable = async function* (stream) {
  const controller = new AbortController;
  const state = {};
  handleStreamEnd(stream, controller, state);
  try {
    for await (const [chunk] of nodeImports.on(stream, "data", { signal: controller.signal })) {
      yield chunk;
    }
  } catch (error) {
    if (state.error !== undefined) {
      throw state.error;
    } else if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    stream.destroy();
  }
}, handleStreamEnd = async (stream, controller, state) => {
  try {
    await nodeImports.finished(stream, {
      cleanup: true,
      readable: true,
      writable: false,
      error: false
    });
  } catch (error) {
    state.error = error;
  } finally {
    controller.abort();
  }
}, nodeImports;
var init_stream = __esm(() => {
  init_ponyfill();
  ({ toString } = Object.prototype);
  nodeImports = {};
});

// node_modules/get-stream/source/contents.js
var getStreamContents = async (stream, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  const asyncIterable = getAsyncIterable(stream);
  const state = init();
  state.length = 0;
  try {
    for await (const chunk of asyncIterable) {
      const chunkType = getChunkType(chunk);
      const convertedChunk = convertChunk[chunkType](chunk, state);
      appendChunk({
        convertedChunk,
        state,
        getSize,
        truncateChunk,
        addChunk,
        maxBuffer
      });
    }
    appendFinalChunk({
      state,
      convertChunk,
      getSize,
      truncateChunk,
      addChunk,
      getFinalChunk,
      maxBuffer
    });
    return finalize(state);
  } catch (error) {
    const normalizedError = typeof error === "object" && error !== null ? error : new Error(error);
    normalizedError.bufferedData = finalize(state);
    throw normalizedError;
  }
}, appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state);
  if (convertedChunk !== undefined) {
    appendChunk({
      convertedChunk,
      state,
      getSize,
      truncateChunk,
      addChunk,
      maxBuffer
    });
  }
}, appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
  if (truncatedChunk !== undefined) {
    addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
  }
  throw new MaxBufferError;
}, addNewChunk = (convertedChunk, state, addChunk, newLength) => {
  state.contents = addChunk(convertedChunk, state, newLength);
  state.length = newLength;
}, getChunkType = (chunk) => {
  const typeOfChunk = typeof chunk;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk)) {
    return "buffer";
  }
  const prototypeName = objectToString2.call(chunk);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString2.call(chunk.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
}, objectToString2, MaxBufferError;
var init_contents = __esm(() => {
  init_stream();
  ({ toString: objectToString2 } = Object.prototype);
  MaxBufferError = class MaxBufferError extends Error {
    name = "MaxBufferError";
    constructor() {
      super("maxBuffer exceeded");
    }
  };
});

// node_modules/get-stream/source/utils.js
var identity2 = (value) => value, noop2 = () => {
  return;
}, getContentsProperty = ({ contents }) => contents, throwObjectStream = (chunk) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
}, getLengthProperty = (convertedChunk) => convertedChunk.length;

// node_modules/get-stream/source/array.js
async function getStreamAsArray(stream, options) {
  return getStreamContents(stream, arrayMethods, options);
}
var initArray = () => ({ contents: [] }), increment = () => 1, addArrayChunk = (convertedChunk, { contents }) => {
  contents.push(convertedChunk);
  return contents;
}, arrayMethods;
var init_array = __esm(() => {
  init_contents();
  arrayMethods = {
    init: initArray,
    convertChunk: {
      string: identity2,
      buffer: identity2,
      arrayBuffer: identity2,
      dataView: identity2,
      typedArray: identity2,
      others: identity2
    },
    getSize: increment,
    truncateChunk: noop2,
    addChunk: addArrayChunk,
    getFinalChunk: noop2,
    finalize: getContentsProperty
  };
});

// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream, options) {
  return getStreamContents(stream, arrayBufferMethods, options);
}
var initArrayBuffer = () => ({ contents: new ArrayBuffer(0) }), useTextEncoder = (chunk) => textEncoder2.encode(chunk), textEncoder2, useUint8Array = (chunk) => new Uint8Array(chunk), useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength), truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize), addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
}, resizeArrayBufferSlow = (contents, length) => {
  if (length <= contents.byteLength) {
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
}, resizeArrayBuffer = (contents, length) => {
  if (length <= contents.maxByteLength) {
    contents.resize(length);
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
}, getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR)), SCALE_FACTOR = 2, finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length), hasArrayBufferResize = () => ("resize" in ArrayBuffer.prototype), arrayBufferMethods;
var init_array_buffer = __esm(() => {
  init_contents();
  textEncoder2 = new TextEncoder;
  arrayBufferMethods = {
    init: initArrayBuffer,
    convertChunk: {
      string: useTextEncoder,
      buffer: useUint8Array,
      arrayBuffer: useUint8Array,
      dataView: useUint8ArrayWithOffset,
      typedArray: useUint8ArrayWithOffset,
      others: throwObjectStream
    },
    getSize: getLengthProperty,
    truncateChunk: truncateArrayBufferChunk,
    addChunk: addArrayBufferChunk,
    getFinalChunk: noop2,
    finalize: finalizeArrayBuffer
  };
});

// node_modules/get-stream/source/string.js
async function getStreamAsString(stream, options) {
  return getStreamContents(stream, stringMethods, options);
}
var initString = () => ({ contents: "", textDecoder: new TextDecoder }), useTextDecoder = (chunk, { textDecoder: textDecoder2 }) => textDecoder2.decode(chunk, { stream: true }), addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk, truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize), getFinalStringChunk = ({ textDecoder: textDecoder2 }) => {
  const finalChunk = textDecoder2.decode();
  return finalChunk === "" ? undefined : finalChunk;
}, stringMethods;
var init_string = __esm(() => {
  init_contents();
  stringMethods = {
    init: initString,
    convertChunk: {
      string: identity2,
      buffer: useTextDecoder,
      arrayBuffer: useTextDecoder,
      dataView: useTextDecoder,
      typedArray: useTextDecoder,
      others: throwObjectStream
    },
    getSize: getLengthProperty,
    truncateChunk: truncateStringChunk,
    addChunk: addStringChunk,
    getFinalChunk: getFinalStringChunk,
    finalize: getContentsProperty
  };
});

// node_modules/get-stream/source/exports.js
var init_exports = __esm(() => {
  init_array();
  init_array_buffer();
  init_string();
  init_contents();
});

// node_modules/get-stream/source/index.js
import { on } from "node:events";
import { finished } from "node:stream/promises";
var init_source = __esm(() => {
  init_stream();
  init_exports();
  Object.assign(nodeImports, { on, finished });
});

// node_modules/execa/lib/io/max-buffer.js
var handleMaxBuffer = ({ error, stream, readableObjectMode, lines, encoding, fdNumber }) => {
  if (!(error instanceof MaxBufferError)) {
    throw error;
  }
  if (fdNumber === "all") {
    return error;
  }
  const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
  error.maxBufferInfo = { fdNumber, unit };
  stream.destroy();
  throw error;
}, getMaxBufferUnit = (readableObjectMode, lines, encoding) => {
  if (readableObjectMode) {
    return "objects";
  }
  if (lines) {
    return "lines";
  }
  if (encoding === "buffer") {
    return "bytes";
  }
  return "characters";
}, checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {
  if (ipcOutput.length !== maxBuffer) {
    return;
  }
  const error = new MaxBufferError;
  error.maxBufferInfo = { fdNumber: "ipc" };
  throw error;
}, getMaxBufferMessage = (error, maxBuffer) => {
  const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
  return `Command's ${streamName} was larger than ${threshold} ${unit}`;
}, getMaxBufferInfo = (error, maxBuffer) => {
  if (error?.maxBufferInfo === undefined) {
    return { streamName: "output", threshold: maxBuffer[1], unit: "bytes" };
  }
  const { maxBufferInfo: { fdNumber, unit } } = error;
  delete error.maxBufferInfo;
  const threshold = getFdSpecificValue(maxBuffer, fdNumber);
  if (fdNumber === "ipc") {
    return { streamName: "IPC output", threshold, unit: "messages" };
  }
  return { streamName: getStreamName(fdNumber), threshold, unit };
}, isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === "ENOBUFS" && output !== null && output.some((result) => result !== null && result.length > getMaxBufferSync(maxBuffer)), truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {
  if (!isMaxBuffer) {
    return result;
  }
  const maxBufferValue = getMaxBufferSync(maxBuffer);
  return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
}, getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;
var init_max_buffer = __esm(() => {
  init_source();
  init_standard_stream();
  init_specific();
});

// node_modules/execa/lib/return/message.js
import { inspect as inspect2 } from "node:util";
var createMessages = ({
  stdio,
  all,
  ipcOutput,
  originalError,
  signal,
  signalDescription,
  exitCode,
  escapedCommand,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal,
  maxBuffer,
  timeout,
  cwd
}) => {
  const errorCode = originalError?.code;
  const prefix = getErrorPrefix({
    originalError,
    timedOut,
    timeout,
    isMaxBuffer,
    maxBuffer,
    errorCode,
    signal,
    signalDescription,
    exitCode,
    isCanceled,
    isGracefullyCanceled,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal
  });
  const originalMessage = getOriginalMessage(originalError, cwd);
  const suffix = originalMessage === undefined ? "" : `
${originalMessage}`;
  const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
  const messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];
  const message = [
    shortMessage,
    ...messageStdio,
    ...stdio.slice(3),
    ipcOutput.map((ipcMessage) => serializeIpcMessage(ipcMessage)).join(`
`)
  ].map((messagePart) => escapeLines(stripFinalNewline(serializeMessagePart(messagePart)))).filter(Boolean).join(`

`);
  return { originalMessage, shortMessage, message };
}, getErrorPrefix = ({
  originalError,
  timedOut,
  timeout,
  isMaxBuffer,
  maxBuffer,
  errorCode,
  signal,
  signalDescription,
  exitCode,
  isCanceled,
  isGracefullyCanceled,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal
}) => {
  const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
  if (timedOut) {
    return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
  }
  if (isGracefullyCanceled) {
    if (signal === undefined) {
      return `Command was gracefully canceled with exit code ${exitCode}`;
    }
    return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal} (${signalDescription})`;
  }
  if (isCanceled) {
    return `Command was canceled${forcefulSuffix}`;
  }
  if (isMaxBuffer) {
    return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
  }
  if (errorCode !== undefined) {
    return `Command failed with ${errorCode}${forcefulSuffix}`;
  }
  if (isForcefullyTerminated) {
    return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
  }
  if (signal !== undefined) {
    return `Command was killed with ${signal} (${signalDescription})`;
  }
  if (exitCode !== undefined) {
    return `Command failed with exit code ${exitCode}`;
  }
  return "Command failed";
}, getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : "", getOriginalMessage = (originalError, cwd) => {
  if (originalError instanceof DiscardedError) {
    return;
  }
  const originalMessage = isExecaError(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
  const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));
  return escapedOriginalMessage === "" ? undefined : escapedOriginalMessage;
}, serializeIpcMessage = (ipcMessage) => typeof ipcMessage === "string" ? ipcMessage : inspect2(ipcMessage), serializeMessagePart = (messagePart) => Array.isArray(messagePart) ? messagePart.map((messageItem) => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join(`
`) : serializeMessageItem(messagePart), serializeMessageItem = (messageItem) => {
  if (typeof messageItem === "string") {
    return messageItem;
  }
  if (isUint8Array(messageItem)) {
    return uint8ArrayToString(messageItem);
  }
  return "";
};
var init_message = __esm(() => {
  init_strip_final_newline();
  init_uint_array();
  init_cwd();
  init_escape();
  init_max_buffer();
  init_signal();
  init_final_error();
});

// node_modules/execa/lib/return/result.js
var makeSuccessResult = ({
  command,
  escapedCommand,
  stdio,
  all,
  ipcOutput,
  options: { cwd },
  startTime
}) => omitUndefinedProperties({
  command,
  escapedCommand,
  cwd,
  durationMs: getDurationMs(startTime),
  failed: false,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isTerminated: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  exitCode: 0,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
}), makeEarlyError = ({
  error,
  command,
  escapedCommand,
  fileDescriptors,
  options,
  startTime,
  isSync
}) => makeError({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  stdio: Array.from({ length: fileDescriptors.length }),
  ipcOutput: [],
  options,
  isSync
}), makeError = ({
  error: originalError,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode: rawExitCode,
  signal: rawSignal,
  stdio,
  all,
  ipcOutput,
  options: {
    timeoutDuration,
    timeout = timeoutDuration,
    forceKillAfterDelay,
    killSignal,
    cwd,
    maxBuffer
  },
  isSync
}) => {
  const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
  const { originalMessage, shortMessage, message } = createMessages({
    stdio,
    all,
    ipcOutput,
    originalError,
    signal,
    signalDescription,
    exitCode,
    escapedCommand,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal,
    maxBuffer,
    timeout,
    cwd
  });
  const error = getFinalError(originalError, message, isSync);
  Object.assign(error, getErrorProperties({
    error,
    command,
    escapedCommand,
    startTime,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    exitCode,
    signal,
    signalDescription,
    stdio,
    all,
    ipcOutput,
    cwd,
    originalMessage,
    shortMessage
  }));
  return error;
}, getErrorProperties = ({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  stdio,
  all,
  ipcOutput,
  cwd,
  originalMessage,
  shortMessage
}) => omitUndefinedProperties({
  shortMessage,
  originalMessage,
  command,
  escapedCommand,
  cwd,
  durationMs: getDurationMs(startTime),
  failed: true,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isTerminated: signal !== undefined,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  code: error.cause?.code,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
}), omitUndefinedProperties = (result) => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined)), normalizeExitPayload = (rawExitCode, rawSignal) => {
  const exitCode = rawExitCode === null ? undefined : rawExitCode;
  const signal = rawSignal === null ? undefined : rawSignal;
  const signalDescription = signal === undefined ? undefined : getSignalDescription(rawSignal);
  return { exitCode, signal, signalDescription };
};
var init_result = __esm(() => {
  init_signal();
  init_duration();
  init_final_error();
  init_message();
});

// node_modules/parse-ms/index.js
function parseNumber(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 86400000),
    hours: Math.trunc(milliseconds / 3600000 % 24),
    minutes: Math.trunc(milliseconds / 60000 % 60),
    seconds: Math.trunc(milliseconds / 1000 % 60),
    milliseconds: Math.trunc(milliseconds % 1000),
    microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),
    nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000)
  };
}
function parseBigint(milliseconds) {
  return {
    days: milliseconds / 86400000n,
    hours: milliseconds / 3600000n % 24n,
    minutes: milliseconds / 60000n % 60n,
    seconds: milliseconds / 1000n % 60n,
    milliseconds: milliseconds % 1000n,
    microseconds: 0n,
    nanoseconds: 0n
  };
}
function parseMilliseconds(milliseconds) {
  switch (typeof milliseconds) {
    case "number": {
      if (Number.isFinite(milliseconds)) {
        return parseNumber(milliseconds);
      }
      break;
    }
    case "bigint": {
      return parseBigint(milliseconds);
    }
  }
  throw new TypeError("Expected a finite number or bigint");
}
var toZeroIfInfinity = (value) => Number.isFinite(value) ? value : 0;

// node_modules/pretty-ms/index.js
function prettyMilliseconds(milliseconds, options) {
  const isBigInt = typeof milliseconds === "bigint";
  if (!isBigInt && !Number.isFinite(milliseconds)) {
    throw new TypeError("Expected a finite number or bigint");
  }
  options = { ...options };
  const sign = milliseconds < 0 ? "-" : "";
  milliseconds = milliseconds < 0 ? -milliseconds : milliseconds;
  if (options.colonNotation) {
    options.compact = false;
    options.formatSubMilliseconds = false;
    options.separateMilliseconds = false;
    options.verbose = false;
  }
  if (options.compact) {
    options.unitCount = 1;
    options.secondsDecimalDigits = 0;
    options.millisecondsDecimalDigits = 0;
  }
  let result = [];
  const floorDecimals = (value, decimalDigits) => {
    const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
    const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
    return flooredValue.toFixed(decimalDigits);
  };
  const add = (value, long, short, valueString) => {
    if ((result.length === 0 || !options.colonNotation) && isZero(value) && !(options.colonNotation && short === "m")) {
      return;
    }
    valueString ??= String(value);
    if (options.colonNotation) {
      const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length;
      const minLength = result.length > 0 ? 2 : 1;
      valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
    } else {
      valueString += options.verbose ? " " + pluralize(long, value) : short;
    }
    result.push(valueString);
  };
  const parsed = parseMilliseconds(milliseconds);
  const days = BigInt(parsed.days);
  if (options.hideYearAndDays) {
    add(BigInt(days) * 24n + BigInt(parsed.hours), "hour", "h");
  } else {
    if (options.hideYear) {
      add(days, "day", "d");
    } else {
      add(days / 365n, "year", "y");
      add(days % 365n, "day", "d");
    }
    add(Number(parsed.hours), "hour", "h");
  }
  add(Number(parsed.minutes), "minute", "m");
  if (!options.hideSeconds) {
    if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1000) {
      const seconds = Number(parsed.seconds);
      const milliseconds2 = Number(parsed.milliseconds);
      const microseconds = Number(parsed.microseconds);
      const nanoseconds = Number(parsed.nanoseconds);
      add(seconds, "second", "s");
      if (options.formatSubMilliseconds) {
        add(milliseconds2, "millisecond", "ms");
        add(microseconds, "microsecond", "s");
        add(nanoseconds, "nanosecond", "ns");
      } else {
        const millisecondsAndBelow = milliseconds2 + microseconds / 1000 + nanoseconds / 1e6;
        const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0;
        const roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
        const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
        add(Number.parseFloat(millisecondsString), "millisecond", "ms", millisecondsString);
      }
    } else {
      const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1000 % 60;
      const secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1;
      const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
      const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
      add(Number.parseFloat(secondsString), "second", "s", secondsString);
    }
  }
  if (result.length === 0) {
    return sign + "0" + (options.verbose ? " milliseconds" : "ms");
  }
  const separator = options.colonNotation ? ":" : " ";
  if (typeof options.unitCount === "number") {
    result = result.slice(0, Math.max(options.unitCount, 1));
  }
  return sign + result.join(separator);
}
var isZero = (value) => value === 0 || value === 0n, pluralize = (word, count2) => count2 === 1 || count2 === 1n ? word : `${word}s`, SECOND_ROUNDING_EPSILON = 0.0000001, ONE_DAY_IN_MILLISECONDS;
var init_pretty_ms = __esm(() => {
  ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
});

// node_modules/execa/lib/verbose/error.js
var logError = (result, verboseInfo) => {
  if (result.failed) {
    verboseLog({
      type: "error",
      verboseMessage: result.shortMessage,
      verboseInfo,
      result
    });
  }
};
var init_error = __esm(() => {
  init_log();
});

// node_modules/execa/lib/verbose/complete.js
var logResult = (result, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  logError(result, verboseInfo);
  logDuration(result, verboseInfo);
}, logDuration = (result, verboseInfo) => {
  const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
  verboseLog({
    type: "duration",
    verboseMessage,
    verboseInfo,
    result
  });
};
var init_complete = __esm(() => {
  init_pretty_ms();
  init_values();
  init_log();
  init_error();
});

// node_modules/execa/lib/return/reject.js
var handleResult = (result, verboseInfo, { reject }) => {
  logResult(result, verboseInfo);
  if (result.failed && reject) {
    throw result;
  }
  return result;
};
var init_reject = __esm(() => {
  init_complete();
});

// node_modules/execa/lib/stdio/type.js
var getStdioItemType = (value, optionName) => {
  if (isAsyncGenerator(value)) {
    return "asyncGenerator";
  }
  if (isSyncGenerator(value)) {
    return "generator";
  }
  if (isUrl(value)) {
    return "fileUrl";
  }
  if (isFilePathObject(value)) {
    return "filePath";
  }
  if (isWebStream(value)) {
    return "webStream";
  }
  if (isStream(value, { checkOpen: false })) {
    return "native";
  }
  if (isUint8Array(value)) {
    return "uint8Array";
  }
  if (isAsyncIterableObject(value)) {
    return "asyncIterable";
  }
  if (isIterableObject(value)) {
    return "iterable";
  }
  if (isTransformStream(value)) {
    return getTransformStreamType({ transform: value }, optionName);
  }
  if (isTransformOptions(value)) {
    return getTransformObjectType(value, optionName);
  }
  return "native";
}, getTransformObjectType = (value, optionName) => {
  if (isDuplexStream(value.transform, { checkOpen: false })) {
    return getDuplexType(value, optionName);
  }
  if (isTransformStream(value.transform)) {
    return getTransformStreamType(value, optionName);
  }
  return getGeneratorObjectType(value, optionName);
}, getDuplexType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "Duplex stream");
  return "duplex";
}, getTransformStreamType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "web TransformStream");
  return "webTransform";
}, validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName) => {
  checkUndefinedOption(final, `${optionName}.final`, typeName);
  checkUndefinedOption(binary, `${optionName}.binary`, typeName);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
}, checkUndefinedOption = (value, optionName, typeName) => {
  if (value !== undefined) {
    throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
  }
}, getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName) => {
  if (transform !== undefined && !isGenerator(transform)) {
    throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
  }
  if (isDuplexStream(final, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
  }
  if (isTransformStream(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
  }
  if (final !== undefined && !isGenerator(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
  }
  checkBooleanOption(binary, `${optionName}.binary`);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
  return isAsyncGenerator(transform) || isAsyncGenerator(final) ? "asyncGenerator" : "generator";
}, checkBooleanOption = (value, optionName) => {
  if (value !== undefined && typeof value !== "boolean") {
    throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
  }
}, isGenerator = (value) => isAsyncGenerator(value) || isSyncGenerator(value), isAsyncGenerator = (value) => Object.prototype.toString.call(value) === "[object AsyncGeneratorFunction]", isSyncGenerator = (value) => Object.prototype.toString.call(value) === "[object GeneratorFunction]", isTransformOptions = (value) => isPlainObject2(value) && (value.transform !== undefined || value.final !== undefined), isUrl = (value) => Object.prototype.toString.call(value) === "[object URL]", isRegularUrl = (value) => isUrl(value) && value.protocol !== "file:", isFilePathObject = (value) => isPlainObject2(value) && Object.keys(value).length > 0 && Object.keys(value).every((key) => FILE_PATH_KEYS.has(key)) && isFilePathString(value.file), FILE_PATH_KEYS, isFilePathString = (file) => typeof file === "string", isUnknownStdioString = (type2, value) => type2 === "native" && typeof value === "string" && !KNOWN_STDIO_STRINGS.has(value), KNOWN_STDIO_STRINGS, isReadableStream2 = (value) => Object.prototype.toString.call(value) === "[object ReadableStream]", isWritableStream2 = (value) => Object.prototype.toString.call(value) === "[object WritableStream]", isWebStream = (value) => isReadableStream2(value) || isWritableStream2(value), isTransformStream = (value) => isReadableStream2(value?.readable) && isWritableStream2(value?.writable), isAsyncIterableObject = (value) => isObject(value) && typeof value[Symbol.asyncIterator] === "function", isIterableObject = (value) => isObject(value) && typeof value[Symbol.iterator] === "function", isObject = (value) => typeof value === "object" && value !== null, TRANSFORM_TYPES, FILE_TYPES, SPECIAL_DUPLICATE_TYPES_SYNC, SPECIAL_DUPLICATE_TYPES, FORBID_DUPLICATE_TYPES, TYPE_TO_MESSAGE;
var init_type = __esm(() => {
  init_uint_array();
  FILE_PATH_KEYS = new Set(["file", "append"]);
  KNOWN_STDIO_STRINGS = new Set(["ipc", "ignore", "inherit", "overlapped", "pipe"]);
  TRANSFORM_TYPES = new Set(["generator", "asyncGenerator", "duplex", "webTransform"]);
  FILE_TYPES = new Set(["fileUrl", "filePath", "fileNumber"]);
  SPECIAL_DUPLICATE_TYPES_SYNC = new Set(["fileUrl", "filePath"]);
  SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, "webStream", "nodeStream"]);
  FORBID_DUPLICATE_TYPES = new Set(["webTransform", "duplex"]);
  TYPE_TO_MESSAGE = {
    generator: "a generator",
    asyncGenerator: "an async generator",
    fileUrl: "a file URL",
    filePath: "a file path string",
    fileNumber: "a file descriptor number",
    webStream: "a web stream",
    nodeStream: "a Node.js stream",
    webTransform: "a web TransformStream",
    duplex: "a Duplex stream",
    native: "any value",
    iterable: "an iterable",
    asyncIterable: "an async iterable",
    string: "a string",
    uint8Array: "a Uint8Array"
  };
});

// node_modules/execa/lib/transform/object-mode.js
var getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === "output" ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms), getOutputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = objectMode ?? writableObjectMode;
  return { writableObjectMode, readableObjectMode };
}, getInputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
  return { writableObjectMode, readableObjectMode };
}, getFdObjectMode = (stdioItems, direction) => {
  const lastTransform = stdioItems.findLast(({ type: type2 }) => TRANSFORM_TYPES.has(type2));
  if (lastTransform === undefined) {
    return false;
  }
  return direction === "input" ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};
var init_object_mode = __esm(() => {
  init_type();
});

// node_modules/execa/lib/transform/normalize.js
var normalizeTransforms = (stdioItems, optionName, direction, options) => [
  ...stdioItems.filter(({ type: type2 }) => !TRANSFORM_TYPES.has(type2)),
  ...getTransforms(stdioItems, optionName, direction, options)
], getTransforms = (stdioItems, optionName, direction, { encoding }) => {
  const transforms = stdioItems.filter(({ type: type2 }) => TRANSFORM_TYPES.has(type2));
  const newTransforms = Array.from({ length: transforms.length });
  for (const [index, stdioItem] of Object.entries(transforms)) {
    newTransforms[index] = normalizeTransform({
      stdioItem,
      index: Number(index),
      newTransforms,
      optionName,
      direction,
      encoding
    });
  }
  return sortTransforms(newTransforms, direction);
}, normalizeTransform = ({ stdioItem, stdioItem: { type: type2 }, index, newTransforms, optionName, direction, encoding }) => {
  if (type2 === "duplex") {
    return normalizeDuplex({ stdioItem, optionName });
  }
  if (type2 === "webTransform") {
    return normalizeTransformStream({
      stdioItem,
      index,
      newTransforms,
      direction
    });
  }
  return normalizeGenerator({
    stdioItem,
    index,
    newTransforms,
    direction,
    encoding
  });
}, normalizeDuplex = ({
  stdioItem,
  stdioItem: {
    value: {
      transform,
      transform: { writableObjectMode, readableObjectMode },
      objectMode = readableObjectMode
    }
  },
  optionName
}) => {
  if (objectMode && !readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  if (!objectMode && readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
}, normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction }) => {
  const { transform, objectMode } = isPlainObject2(value) ? value : { transform: value };
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
}, normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding }) => {
  const {
    transform,
    final,
    binary: binaryOption = false,
    preserveNewlines = false,
    objectMode
  } = isPlainObject2(value) ? value : { transform: value };
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: {
      transform,
      final,
      binary,
      preserveNewlines,
      writableObjectMode,
      readableObjectMode
    }
  };
}, sortTransforms = (newTransforms, direction) => direction === "input" ? newTransforms.reverse() : newTransforms;
var init_normalize = __esm(() => {
  init_encoding_option();
  init_type();
  init_object_mode();
});

// node_modules/execa/lib/stdio/direction.js
import process8 from "node:process";
var getStreamDirection = (stdioItems, fdNumber, optionName) => {
  const directions = stdioItems.map((stdioItem) => getStdioItemDirection(stdioItem, fdNumber));
  if (directions.includes("input") && directions.includes("output")) {
    throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
  }
  return directions.find(Boolean) ?? DEFAULT_DIRECTION;
}, getStdioItemDirection = ({ type: type2, value }, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type2](value), KNOWN_DIRECTIONS, anyDirection = () => {
  return;
}, alwaysInput = () => "input", guessStreamDirection, getStandardStreamDirection = (value) => {
  if ([0, process8.stdin].includes(value)) {
    return "input";
  }
  if ([1, 2, process8.stdout, process8.stderr].includes(value)) {
    return "output";
  }
}, DEFAULT_DIRECTION = "output";
var init_direction = __esm(() => {
  init_type();
  KNOWN_DIRECTIONS = ["input", "output", "output"];
  guessStreamDirection = {
    generator: anyDirection,
    asyncGenerator: anyDirection,
    fileUrl: anyDirection,
    filePath: anyDirection,
    iterable: alwaysInput,
    asyncIterable: alwaysInput,
    uint8Array: alwaysInput,
    webStream: (value) => isWritableStream2(value) ? "output" : "input",
    nodeStream(value) {
      if (!isReadableStream(value, { checkOpen: false })) {
        return "output";
      }
      return isWritableStream(value, { checkOpen: false }) ? undefined : "input";
    },
    webTransform: anyDirection,
    duplex: anyDirection,
    native(value) {
      const standardStreamDirection = getStandardStreamDirection(value);
      if (standardStreamDirection !== undefined) {
        return standardStreamDirection;
      }
      if (isStream(value, { checkOpen: false })) {
        return guessStreamDirection.nodeStream(value);
      }
    }
  };
});

// node_modules/execa/lib/ipc/array.js
var normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes("ipc") ? [...stdioArray, "ipc"] : stdioArray;

// node_modules/execa/lib/stdio/stdio-option.js
var normalizeStdioOption = ({ stdio, ipc, buffer, ...options }, verboseInfo, isSync) => {
  const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue2(stdioOption, fdNumber));
  return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : normalizeIpcStdioArray(stdioArray, ipc);
}, getStdioArray = (stdio, options) => {
  if (stdio === undefined) {
    return STANDARD_STREAMS_ALIASES.map((alias) => options[alias]);
  }
  if (hasAlias(options)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return [stdio, stdio, stdio];
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
  return Array.from({ length }, (_, fdNumber) => stdio[fdNumber]);
}, hasAlias = (options) => STANDARD_STREAMS_ALIASES.some((alias) => options[alias] !== undefined), addDefaultValue2 = (stdioOption, fdNumber) => {
  if (Array.isArray(stdioOption)) {
    return stdioOption.map((item) => addDefaultValue2(item, fdNumber));
  }
  if (stdioOption === null || stdioOption === undefined) {
    return fdNumber >= STANDARD_STREAMS_ALIASES.length ? "ignore" : "pipe";
  }
  return stdioOption;
}, normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) => !buffer[fdNumber] && fdNumber !== 0 && !isFullVerbose(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? "ignore" : stdioOption), isOutputPipeOnly = (stdioOption) => stdioOption === "pipe" || Array.isArray(stdioOption) && stdioOption.every((item) => item === "pipe");
var init_stdio_option = __esm(() => {
  init_standard_stream();
  init_values();
});

// node_modules/execa/lib/stdio/native.js
import { readFileSync } from "node:fs";
import tty2 from "node:tty";
var handleNativeStream = ({ stdioItem, stdioItem: { type: type2 }, isStdioArray, fdNumber, direction, isSync }) => {
  if (!isStdioArray || type2 !== "native") {
    return stdioItem;
  }
  return isSync ? handleNativeStreamSync({ stdioItem, fdNumber, direction }) : handleNativeStreamAsync({ stdioItem, fdNumber });
}, handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction }) => {
  const targetFd = getTargetFd({
    value,
    optionName,
    fdNumber,
    direction
  });
  if (targetFd !== undefined) {
    return targetFd;
  }
  if (isStream(value, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
  }
  return stdioItem;
}, getTargetFd = ({ value, optionName, fdNumber, direction }) => {
  const targetFdNumber = getTargetFdNumber(value, fdNumber);
  if (targetFdNumber === undefined) {
    return;
  }
  if (direction === "output") {
    return { type: "fileNumber", value: targetFdNumber, optionName };
  }
  if (tty2.isatty(targetFdNumber)) {
    throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
  }
  return { type: "uint8Array", value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName };
}, getTargetFdNumber = (value, fdNumber) => {
  if (value === "inherit") {
    return fdNumber;
  }
  if (typeof value === "number") {
    return value;
  }
  const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
  if (standardStreamIndex !== -1) {
    return standardStreamIndex;
  }
}, handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber }) => {
  if (value === "inherit") {
    return { type: "nodeStream", value: getStandardStream(fdNumber, value, optionName), optionName };
  }
  if (typeof value === "number") {
    return { type: "nodeStream", value: getStandardStream(value, value, optionName), optionName };
  }
  if (isStream(value, { checkOpen: false })) {
    return { type: "nodeStream", value, optionName };
  }
  return stdioItem;
}, getStandardStream = (fdNumber, value, optionName) => {
  const standardStream = STANDARD_STREAMS[fdNumber];
  if (standardStream === undefined) {
    throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
  }
  return standardStream;
};
var init_native = __esm(() => {
  init_standard_stream();
  init_uint_array();
  init_fd_options();
});

// node_modules/execa/lib/stdio/input-option.js
var handleInputOptions = ({ input, inputFile }, fdNumber) => fdNumber === 0 ? [
  ...handleInputOption(input),
  ...handleInputFileOption(inputFile)
] : [], handleInputOption = (input) => input === undefined ? [] : [{
  type: getInputType(input),
  value: input,
  optionName: "input"
}], getInputType = (input) => {
  if (isReadableStream(input, { checkOpen: false })) {
    return "nodeStream";
  }
  if (typeof input === "string") {
    return "string";
  }
  if (isUint8Array(input)) {
    return "uint8Array";
  }
  throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.");
}, handleInputFileOption = (inputFile) => inputFile === undefined ? [] : [{
  ...getInputFileType(inputFile),
  optionName: "inputFile"
}], getInputFileType = (inputFile) => {
  if (isUrl(inputFile)) {
    return { type: "fileUrl", value: inputFile };
  }
  if (isFilePathString(inputFile)) {
    return { type: "filePath", value: { file: inputFile } };
  }
  throw new Error("The `inputFile` option must be a file path string or a file URL.");
};
var init_input_option = __esm(() => {
  init_uint_array();
  init_type();
});

// node_modules/execa/lib/stdio/duplicate.js
var filterDuplicates = (stdioItems) => stdioItems.filter((stdioItemOne, indexOne) => stdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === "generator" || stdioItemOne.type === "asyncGenerator")), getDuplicateStream = ({ stdioItem: { type: type2, value, optionName }, direction, fileDescriptors, isSync }) => {
  const otherStdioItems = getOtherStdioItems(fileDescriptors, type2);
  if (otherStdioItems.length === 0) {
    return;
  }
  if (isSync) {
    validateDuplicateStreamSync({
      otherStdioItems,
      type: type2,
      value,
      optionName,
      direction
    });
    return;
  }
  if (SPECIAL_DUPLICATE_TYPES.has(type2)) {
    return getDuplicateStreamInstance({
      otherStdioItems,
      type: type2,
      value,
      optionName,
      direction
    });
  }
  if (FORBID_DUPLICATE_TYPES.has(type2)) {
    validateDuplicateTransform({
      otherStdioItems,
      type: type2,
      value,
      optionName
    });
  }
}, getOtherStdioItems = (fileDescriptors, type2) => fileDescriptors.flatMap(({ direction, stdioItems }) => stdioItems.filter((stdioItem) => stdioItem.type === type2).map((stdioItem) => ({ ...stdioItem, direction }))), validateDuplicateStreamSync = ({ otherStdioItems, type: type2, value, optionName, direction }) => {
  if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type2)) {
    getDuplicateStreamInstance({
      otherStdioItems,
      type: type2,
      value,
      optionName,
      direction
    });
  }
}, getDuplicateStreamInstance = ({ otherStdioItems, type: type2, value, optionName, direction }) => {
  const duplicateStdioItems = otherStdioItems.filter((stdioItem) => hasSameValue(stdioItem, value));
  if (duplicateStdioItems.length === 0) {
    return;
  }
  const differentStdioItem = duplicateStdioItems.find((stdioItem) => stdioItem.direction !== direction);
  throwOnDuplicateStream(differentStdioItem, optionName, type2);
  return direction === "output" ? duplicateStdioItems[0].stream : undefined;
}, hasSameValue = ({ type: type2, value }, secondValue) => {
  if (type2 === "filePath") {
    return value.file === secondValue.file;
  }
  if (type2 === "fileUrl") {
    return value.href === secondValue.href;
  }
  return value === secondValue;
}, validateDuplicateTransform = ({ otherStdioItems, type: type2, value, optionName }) => {
  const duplicateStdioItem = otherStdioItems.find(({ value: { transform } }) => transform === value.transform);
  throwOnDuplicateStream(duplicateStdioItem, optionName, type2);
}, throwOnDuplicateStream = (stdioItem, optionName, type2) => {
  if (stdioItem !== undefined) {
    throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type2]} that is the same.`);
  }
};
var init_duplicate = __esm(() => {
  init_type();
});

// node_modules/execa/lib/stdio/handle.js
var handleStdio = (addProperties, options, verboseInfo, isSync) => {
  const stdio = normalizeStdioOption(options, verboseInfo, isSync);
  const initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({
    stdioOption,
    fdNumber,
    options,
    isSync
  }));
  const fileDescriptors = getFinalFileDescriptors({
    initialFileDescriptors,
    addProperties,
    options,
    isSync
  });
  options.stdio = fileDescriptors.map(({ stdioItems }) => forwardStdio(stdioItems));
  return fileDescriptors;
}, getFileDescriptor = ({ stdioOption, fdNumber, options, isSync }) => {
  const optionName = getStreamName(fdNumber);
  const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
    stdioOption,
    fdNumber,
    options,
    optionName
  });
  const direction = getStreamDirection(initialStdioItems, fdNumber, optionName);
  const stdioItems = initialStdioItems.map((stdioItem) => handleNativeStream({
    stdioItem,
    isStdioArray,
    fdNumber,
    direction,
    isSync
  }));
  const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);
  const objectMode = getFdObjectMode(normalizedStdioItems, direction);
  validateFileObjectMode(normalizedStdioItems, objectMode);
  return { direction, objectMode, stdioItems: normalizedStdioItems };
}, initializeStdioItems = ({ stdioOption, fdNumber, options, optionName }) => {
  const values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];
  const initialStdioItems = [
    ...values.map((value) => initializeStdioItem(value, optionName)),
    ...handleInputOptions(options, fdNumber)
  ];
  const stdioItems = filterDuplicates(initialStdioItems);
  const isStdioArray = stdioItems.length > 1;
  validateStdioArray(stdioItems, isStdioArray, optionName);
  validateStreams(stdioItems);
  return { stdioItems, isStdioArray };
}, initializeStdioItem = (value, optionName) => ({
  type: getStdioItemType(value, optionName),
  value,
  optionName
}), validateStdioArray = (stdioItems, isStdioArray, optionName) => {
  if (stdioItems.length === 0) {
    throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
  }
  if (!isStdioArray) {
    return;
  }
  for (const { value, optionName: optionName2 } of stdioItems) {
    if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
      throw new Error(`The \`${optionName2}\` option must not include \`${value}\`.`);
    }
  }
}, INVALID_STDIO_ARRAY_OPTIONS, validateStreams = (stdioItems) => {
  for (const stdioItem of stdioItems) {
    validateFileStdio(stdioItem);
  }
}, validateFileStdio = ({ type: type2, value, optionName }) => {
  if (isRegularUrl(value)) {
    throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
  }
  if (isUnknownStdioString(type2, value)) {
    throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
  }
}, validateFileObjectMode = (stdioItems, objectMode) => {
  if (!objectMode) {
    return;
  }
  const fileStdioItem = stdioItems.find(({ type: type2 }) => FILE_TYPES.has(type2));
  if (fileStdioItem !== undefined) {
    throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
  }
}, getFinalFileDescriptors = ({ initialFileDescriptors, addProperties, options, isSync }) => {
  const fileDescriptors = [];
  try {
    for (const fileDescriptor of initialFileDescriptors) {
      fileDescriptors.push(getFinalFileDescriptor({
        fileDescriptor,
        fileDescriptors,
        addProperties,
        options,
        isSync
      }));
    }
    return fileDescriptors;
  } catch (error) {
    cleanupCustomStreams(fileDescriptors);
    throw error;
  }
}, getFinalFileDescriptor = ({
  fileDescriptor: { direction, objectMode, stdioItems },
  fileDescriptors,
  addProperties,
  options,
  isSync
}) => {
  const finalStdioItems = stdioItems.map((stdioItem) => addStreamProperties({
    stdioItem,
    addProperties,
    direction,
    options,
    fileDescriptors,
    isSync
  }));
  return { direction, objectMode, stdioItems: finalStdioItems };
}, addStreamProperties = ({ stdioItem, addProperties, direction, options, fileDescriptors, isSync }) => {
  const duplicateStream = getDuplicateStream({
    stdioItem,
    direction,
    fileDescriptors,
    isSync
  });
  if (duplicateStream !== undefined) {
    return { ...stdioItem, stream: duplicateStream };
  }
  return {
    ...stdioItem,
    ...addProperties[direction][stdioItem.type](stdioItem, options)
  };
}, cleanupCustomStreams = (fileDescriptors) => {
  for (const { stdioItems } of fileDescriptors) {
    for (const { stream } of stdioItems) {
      if (stream !== undefined && !isStandardStream(stream)) {
        stream.destroy();
      }
    }
  }
}, forwardStdio = (stdioItems) => {
  if (stdioItems.length > 1) {
    return stdioItems.some(({ value: value2 }) => value2 === "overlapped") ? "overlapped" : "pipe";
  }
  const [{ type: type2, value }] = stdioItems;
  return type2 === "native" ? value : "pipe";
};
var init_handle = __esm(() => {
  init_standard_stream();
  init_normalize();
  init_object_mode();
  init_type();
  init_direction();
  init_stdio_option();
  init_native();
  init_input_option();
  init_duplicate();
  INVALID_STDIO_ARRAY_OPTIONS = new Set(["ignore", "ipc"]);
});

// node_modules/execa/lib/stdio/handle-sync.js
import { readFileSync as readFileSync2 } from "node:fs";
var handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true), forbiddenIfSync = ({ type: type2, optionName }) => {
  throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type2]);
}, forbiddenNativeIfSync = ({ optionName, value }) => {
  if (value === "ipc" || value === "overlapped") {
    throwInvalidSyncValue(optionName, `"${value}"`);
  }
  return {};
}, throwInvalidSyncValue = (optionName, value) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
}, addProperties, addPropertiesSync;
var init_handle_sync = __esm(() => {
  init_uint_array();
  init_handle();
  init_type();
  addProperties = {
    generator() {
    },
    asyncGenerator: forbiddenIfSync,
    webStream: forbiddenIfSync,
    nodeStream: forbiddenIfSync,
    webTransform: forbiddenIfSync,
    duplex: forbiddenIfSync,
    asyncIterable: forbiddenIfSync,
    native: forbiddenNativeIfSync
  };
  addPropertiesSync = {
    input: {
      ...addProperties,
      fileUrl: ({ value }) => ({ contents: [bufferToUint8Array(readFileSync2(value))] }),
      filePath: ({ value: { file } }) => ({ contents: [bufferToUint8Array(readFileSync2(file))] }),
      fileNumber: forbiddenIfSync,
      iterable: ({ value }) => ({ contents: [...value] }),
      string: ({ value }) => ({ contents: [value] }),
      uint8Array: ({ value }) => ({ contents: [value] })
    },
    output: {
      ...addProperties,
      fileUrl: ({ value }) => ({ path: value }),
      filePath: ({ value: { file, append } }) => ({ path: file, append }),
      fileNumber: ({ value }) => ({ path: value }),
      iterable: forbiddenIfSync,
      string: forbiddenIfSync,
      uint8Array: forbiddenIfSync
    }
  };
});

// node_modules/execa/lib/io/strip-newline.js
var stripNewline = (value, { stripFinalNewline: stripFinalNewline2 }, fdNumber) => getStripFinalNewline(stripFinalNewline2, fdNumber) && value !== undefined && !Array.isArray(value) ? stripFinalNewline(value) : value, getStripFinalNewline = (stripFinalNewline2, fdNumber) => fdNumber === "all" ? stripFinalNewline2[1] || stripFinalNewline2[2] : stripFinalNewline2[fdNumber];
var init_strip_newline = __esm(() => {
  init_strip_final_newline();
});

// node_modules/execa/lib/transform/split.js
var getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped ? undefined : initializeSplitLines(preserveNewlines, state), splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode ? chunk.flatMap((item) => splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines), splitLinesItemSync = (chunk, preserveNewlines) => {
  const { transform, final } = initializeSplitLines(preserveNewlines, {});
  return [...transform(chunk), ...final()];
}, initializeSplitLines = (preserveNewlines, state) => {
  state.previousChunks = "";
  return {
    transform: splitGenerator.bind(undefined, state, preserveNewlines),
    final: linesFinal.bind(undefined, state)
  };
}, splitGenerator = function* (state, preserveNewlines, chunk) {
  if (typeof chunk !== "string") {
    yield chunk;
    return;
  }
  let { previousChunks } = state;
  let start = -1;
  for (let end = 0;end < chunk.length; end += 1) {
    if (chunk[end] === `
`) {
      const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
      let line = chunk.slice(start + 1, end + 1 - newlineLength);
      if (previousChunks.length > 0) {
        line = concatString(previousChunks, line);
        previousChunks = "";
      }
      yield line;
      start = end;
    }
  }
  if (start !== chunk.length - 1) {
    previousChunks = concatString(previousChunks, chunk.slice(start + 1));
  }
  state.previousChunks = previousChunks;
}, getNewlineLength = (chunk, end, preserveNewlines, state) => {
  if (preserveNewlines) {
    return 0;
  }
  state.isWindowsNewline = end !== 0 && chunk[end - 1] === "\r";
  return state.isWindowsNewline ? 2 : 1;
}, linesFinal = function* ({ previousChunks }) {
  if (previousChunks.length > 0) {
    yield previousChunks;
  }
}, getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state }) => binary || preserveNewlines || readableObjectMode ? undefined : { transform: appendNewlineGenerator.bind(undefined, state) }, appendNewlineGenerator = function* ({ isWindowsNewline = false }, chunk) {
  const { unixNewline, windowsNewline, LF: LF3, concatBytes } = typeof chunk === "string" ? linesStringInfo : linesUint8ArrayInfo;
  if (chunk.at(-1) === LF3) {
    yield chunk;
    return;
  }
  const newline = isWindowsNewline ? windowsNewline : unixNewline;
  yield concatBytes(chunk, newline);
}, concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`, linesStringInfo, concatUint8Array = (firstChunk, secondChunk) => {
  const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
  chunk.set(firstChunk, 0);
  chunk.set(secondChunk, firstChunk.length);
  return chunk;
}, linesUint8ArrayInfo;
var init_split = __esm(() => {
  linesStringInfo = {
    windowsNewline: `\r
`,
    unixNewline: `
`,
    LF: `
`,
    concatBytes: concatString
  };
  linesUint8ArrayInfo = {
    windowsNewline: new Uint8Array([13, 10]),
    unixNewline: new Uint8Array([10]),
    LF: 10,
    concatBytes: concatUint8Array
  };
});

// node_modules/execa/lib/transform/validate.js
import { Buffer as Buffer4 } from "node:buffer";
var getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode ? undefined : validateStringTransformInput.bind(undefined, optionName), validateStringTransformInput = function* (optionName, chunk) {
  if (typeof chunk !== "string" && !isUint8Array(chunk) && !Buffer4.isBuffer(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
  }
  yield chunk;
}, getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode ? validateObjectTransformReturn.bind(undefined, optionName) : validateStringTransformReturn.bind(undefined, optionName), validateObjectTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  yield chunk;
}, validateStringTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  if (typeof chunk !== "string" && !isUint8Array(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
  }
  yield chunk;
}, validateEmptyReturn = (optionName, chunk) => {
  if (chunk === null || chunk === undefined) {
    throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
  }
};
var init_validate = __esm(() => {
  init_uint_array();
});

// node_modules/execa/lib/transform/encoding-transform.js
import { Buffer as Buffer5 } from "node:buffer";
import { StringDecoder as StringDecoder2 } from "node:string_decoder";
var getEncodingTransformGenerator = (binary, encoding, skipped) => {
  if (skipped) {
    return;
  }
  if (binary) {
    return { transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder) };
  }
  const stringDecoder = new StringDecoder2(encoding);
  return {
    transform: encodingStringGenerator.bind(undefined, stringDecoder),
    final: encodingStringFinal.bind(undefined, stringDecoder)
  };
}, encodingUint8ArrayGenerator = function* (textEncoder3, chunk) {
  if (Buffer5.isBuffer(chunk)) {
    yield bufferToUint8Array(chunk);
  } else if (typeof chunk === "string") {
    yield textEncoder3.encode(chunk);
  } else {
    yield chunk;
  }
}, encodingStringGenerator = function* (stringDecoder, chunk) {
  yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
}, encodingStringFinal = function* (stringDecoder) {
  const lastChunk = stringDecoder.end();
  if (lastChunk !== "") {
    yield lastChunk;
  }
};
var init_encoding_transform = __esm(() => {
  init_uint_array();
});

// node_modules/execa/lib/transform/run-async.js
import { callbackify } from "node:util";
var pushChunks, transformChunk = async function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator } = generators[index];
  for await (const transformedChunk of transform(chunk)) {
    yield* transformChunk(transformedChunk, generators, index + 1);
  }
}, finalChunks = async function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunks(final, Number(index), generators);
  }
}, generatorFinalChunks = async function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for await (const finalChunk of final()) {
    yield* transformChunk(finalChunk, generators, index + 1);
  }
}, destroyTransform, identityGenerator = function* (chunk) {
  yield chunk;
};
var init_run_async = __esm(() => {
  pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {
    state.currentIterable = getChunks(...getChunksArguments);
    try {
      for await (const chunk of state.currentIterable) {
        transformStream.push(chunk);
      }
    } finally {
      delete state.currentIterable;
    }
  });
  destroyTransform = callbackify(async ({ currentIterable }, error) => {
    if (currentIterable !== undefined) {
      await (error ? currentIterable.throw(error) : currentIterable.return());
      return;
    }
    if (error) {
      throw error;
    }
  });
});

// node_modules/execa/lib/transform/run-sync.js
var pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {
  try {
    for (const chunk of getChunksSync(...getChunksArguments)) {
      transformStream.push(chunk);
    }
    done();
  } catch (error) {
    done(error);
  }
}, runTransformSync = (generators, chunks) => [
  ...chunks.flatMap((chunk) => [...transformChunkSync(chunk, generators, 0)]),
  ...finalChunksSync(generators)
], transformChunkSync = function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator2 } = generators[index];
  for (const transformedChunk of transform(chunk)) {
    yield* transformChunkSync(transformedChunk, generators, index + 1);
  }
}, finalChunksSync = function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunksSync(final, Number(index), generators);
  }
}, generatorFinalChunksSync = function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for (const finalChunk of final()) {
    yield* transformChunkSync(finalChunk, generators, index + 1);
  }
}, identityGenerator2 = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/generator.js
import { Transform, getDefaultHighWaterMark } from "node:stream";
var generatorToStream = ({
  value,
  value: { transform, final, writableObjectMode, readableObjectMode },
  optionName
}, { encoding }) => {
  const state = {};
  const generators = addInternalGenerators(value, encoding, optionName);
  const transformAsync = isAsyncGenerator(transform);
  const finalAsync = isAsyncGenerator(final);
  const transformMethod = transformAsync ? pushChunks.bind(undefined, transformChunk, state) : pushChunksSync.bind(undefined, transformChunkSync);
  const finalMethod = transformAsync || finalAsync ? pushChunks.bind(undefined, finalChunks, state) : pushChunksSync.bind(undefined, finalChunksSync);
  const destroyMethod = transformAsync || finalAsync ? destroyTransform.bind(undefined, state) : undefined;
  const stream = new Transform({
    writableObjectMode,
    writableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),
    readableObjectMode,
    readableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),
    transform(chunk, encoding2, done) {
      transformMethod([chunk, generators, 0], this, done);
    },
    flush(done) {
      finalMethod([generators], this, done);
    },
    destroy: destroyMethod
  });
  return { stream };
}, runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {
  const generators = stdioItems.filter(({ type: type2 }) => type2 === "generator");
  const reversedGenerators = isInput ? generators.reverse() : generators;
  for (const { value, optionName } of reversedGenerators) {
    const generators2 = addInternalGenerators(value, encoding, optionName);
    chunks = runTransformSync(generators2, chunks);
  }
  return chunks;
}, addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName) => {
  const state = {};
  return [
    { transform: getValidateTransformInput(writableObjectMode, optionName) },
    getEncodingTransformGenerator(binary, encoding, writableObjectMode),
    getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
    { transform, final },
    { transform: getValidateTransformReturn(readableObjectMode, optionName) },
    getAppendNewlineGenerator({
      binary,
      preserveNewlines,
      readableObjectMode,
      state
    })
  ].filter(Boolean);
};
var init_generator = __esm(() => {
  init_type();
  init_split();
  init_validate();
  init_encoding_transform();
  init_run_async();
});

// node_modules/execa/lib/io/input-sync.js
var addInputOptionsSync = (fileDescriptors, options) => {
  for (const fdNumber of getInputFdNumbers(fileDescriptors)) {
    addInputOptionSync(fileDescriptors, fdNumber, options);
  }
}, getInputFdNumbers = (fileDescriptors) => new Set(Object.entries(fileDescriptors).filter(([, { direction }]) => direction === "input").map(([fdNumber]) => Number(fdNumber))), addInputOptionSync = (fileDescriptors, fdNumber, options) => {
  const { stdioItems } = fileDescriptors[fdNumber];
  const allStdioItems = stdioItems.filter(({ contents }) => contents !== undefined);
  if (allStdioItems.length === 0) {
    return;
  }
  if (fdNumber !== 0) {
    const [{ type: type2, optionName }] = allStdioItems;
    throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type2]} with synchronous methods.`);
  }
  const allContents = allStdioItems.map(({ contents }) => contents);
  const transformedContents = allContents.map((contents) => applySingleInputGeneratorsSync(contents, stdioItems));
  options.input = joinToUint8Array(transformedContents);
}, applySingleInputGeneratorsSync = (contents, stdioItems) => {
  const newContents = runGeneratorsSync(contents, stdioItems, "utf8", true);
  validateSerializable(newContents);
  return joinToUint8Array(newContents);
}, validateSerializable = (newContents) => {
  const invalidItem = newContents.find((item) => typeof item !== "string" && !isUint8Array(item));
  if (invalidItem !== undefined) {
    throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
  }
};
var init_input_sync = __esm(() => {
  init_generator();
  init_uint_array();
  init_type();
});

// node_modules/execa/lib/verbose/output.js
var shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber }) => fdNumber !== "all" && isFullVerbose(verboseInfo, fdNumber) && !BINARY_ENCODINGS.has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type: type2, value }) => type2 === "native" && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type: type2 }) => TRANSFORM_TYPES.has(type2))), fdUsesVerbose = (fdNumber) => fdNumber === 1 || fdNumber === 2, PIPED_STDIO_VALUES, logLines = async (linesIterable, stream, fdNumber, verboseInfo) => {
  for await (const line of linesIterable) {
    if (!isPipingStream(stream)) {
      logLine(line, fdNumber, verboseInfo);
    }
  }
}, logLinesSync = (linesArray, fdNumber, verboseInfo) => {
  for (const line of linesArray) {
    logLine(line, fdNumber, verboseInfo);
  }
}, isPipingStream = (stream) => stream._readableState.pipes.length > 0, logLine = (line, fdNumber, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(line);
  verboseLog({
    type: "output",
    verboseMessage,
    fdNumber,
    verboseInfo
  });
};
var init_output = __esm(() => {
  init_encoding_option();
  init_type();
  init_log();
  init_values();
  PIPED_STDIO_VALUES = new Set(["pipe", "overlapped"]);
});

// node_modules/execa/lib/io/output-sync.js
import { writeFileSync, appendFileSync } from "node:fs";
var transformOutputSync = ({ fileDescriptors, syncResult: { output }, options, isMaxBuffer, verboseInfo }) => {
  if (output === null) {
    return { output: Array.from({ length: 3 }) };
  }
  const state = {};
  const outputFiles = new Set([]);
  const transformedOutput = output.map((result, fdNumber) => transformOutputResultSync({
    result,
    fileDescriptors,
    fdNumber,
    state,
    outputFiles,
    isMaxBuffer,
    verboseInfo
  }, options));
  return { output: transformedOutput, ...state };
}, transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines, stripFinalNewline: stripFinalNewline2, maxBuffer }) => {
  if (result === null) {
    return;
  }
  const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
  const uint8ArrayResult = bufferToUint8Array(truncatedResult);
  const { stdioItems, objectMode } = fileDescriptors[fdNumber];
  const chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);
  const { serializedResult, finalResult = serializedResult } = serializeChunks({
    chunks,
    objectMode,
    encoding,
    lines,
    stripFinalNewline: stripFinalNewline2,
    fdNumber
  });
  logOutputSync({
    serializedResult,
    fdNumber,
    state,
    verboseInfo,
    encoding,
    stdioItems,
    objectMode
  });
  const returnedResult = buffer[fdNumber] ? finalResult : undefined;
  try {
    if (state.error === undefined) {
      writeToFiles(serializedResult, stdioItems, outputFiles);
    }
    return returnedResult;
  } catch (error) {
    state.error = error;
    return returnedResult;
  }
}, runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {
  try {
    return runGeneratorsSync(chunks, stdioItems, encoding, false);
  } catch (error) {
    state.error = error;
    return chunks;
  }
}, serializeChunks = ({ chunks, objectMode, encoding, lines, stripFinalNewline: stripFinalNewline2, fdNumber }) => {
  if (objectMode) {
    return { serializedResult: chunks };
  }
  if (encoding === "buffer") {
    return { serializedResult: joinToUint8Array(chunks) };
  }
  const serializedResult = joinToString(chunks, encoding);
  if (lines[fdNumber]) {
    return { serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline2[fdNumber], objectMode) };
  }
  return { serializedResult };
}, logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode }) => {
  if (!shouldLogOutput({
    stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesArray = splitLinesSync(serializedResult, false, objectMode);
  try {
    logLinesSync(linesArray, fdNumber, verboseInfo);
  } catch (error) {
    state.error ??= error;
  }
}, writeToFiles = (serializedResult, stdioItems, outputFiles) => {
  for (const { path: path7, append } of stdioItems.filter(({ type: type2 }) => FILE_TYPES.has(type2))) {
    const pathString = typeof path7 === "string" ? path7 : path7.toString();
    if (append || outputFiles.has(pathString)) {
      appendFileSync(path7, serializedResult);
    } else {
      outputFiles.add(pathString);
      writeFileSync(path7, serializedResult);
    }
  }
};
var init_output_sync = __esm(() => {
  init_output();
  init_generator();
  init_split();
  init_uint_array();
  init_type();
  init_max_buffer();
});

// node_modules/execa/lib/resolve/all-sync.js
var getAllSync = ([, stdout, stderr], options) => {
  if (!options.all) {
    return;
  }
  if (stdout === undefined) {
    return stderr;
  }
  if (stderr === undefined) {
    return stdout;
  }
  if (Array.isArray(stdout)) {
    return Array.isArray(stderr) ? [...stdout, ...stderr] : [...stdout, stripNewline(stderr, options, "all")];
  }
  if (Array.isArray(stderr)) {
    return [stripNewline(stdout, options, "all"), ...stderr];
  }
  if (isUint8Array(stdout) && isUint8Array(stderr)) {
    return concatUint8Arrays([stdout, stderr]);
  }
  return `${stdout}${stderr}`;
};
var init_all_sync = __esm(() => {
  init_uint_array();
  init_strip_newline();
});

// node_modules/execa/lib/resolve/exit-async.js
import { once as once4 } from "node:events";
var waitForExit = async (subprocess, context3) => {
  const [exitCode, signal] = await waitForExitOrError(subprocess);
  context3.isForcefullyTerminated ??= false;
  return [exitCode, signal];
}, waitForExitOrError = async (subprocess) => {
  const [spawnPayload, exitPayload] = await Promise.allSettled([
    once4(subprocess, "spawn"),
    once4(subprocess, "exit")
  ]);
  if (spawnPayload.status === "rejected") {
    return [];
  }
  return exitPayload.status === "rejected" ? waitForSubprocessExit(subprocess) : exitPayload.value;
}, waitForSubprocessExit = async (subprocess) => {
  try {
    return await once4(subprocess, "exit");
  } catch {
    return waitForSubprocessExit(subprocess);
  }
}, waitForSuccessfulExit = async (exitPromise) => {
  const [exitCode, signal] = await exitPromise;
  if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {
    throw new DiscardedError;
  }
  return [exitCode, signal];
}, isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined, isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;
var init_exit_async = __esm(() => {
  init_final_error();
});

// node_modules/execa/lib/resolve/exit-sync.js
var getExitResultSync = ({ error, status: exitCode, signal, output }, { maxBuffer }) => {
  const resultError = getResultError(error, exitCode, signal);
  const timedOut = resultError?.code === "ETIMEDOUT";
  const isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);
  return {
    resultError,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer
  };
}, getResultError = (error, exitCode, signal) => {
  if (error !== undefined) {
    return error;
  }
  return isFailedExit(exitCode, signal) ? new DiscardedError : undefined;
};
var init_exit_sync = __esm(() => {
  init_final_error();
  init_max_buffer();
  init_exit_async();
});

// node_modules/execa/lib/methods/main-sync.js
import { spawnSync } from "node:child_process";
var execaCoreSync = (rawFile, rawArguments, rawOptions) => {
  const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
  const result = spawnSubprocessSync({
    file,
    commandArguments,
    options,
    command,
    escapedCommand,
    verboseInfo,
    fileDescriptors,
    startTime
  });
  return handleResult(result, verboseInfo, options);
}, handleSyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const syncOptions = normalizeSyncOptions(rawOptions);
  const { file, commandArguments, options } = normalizeOptions(rawFile, rawArguments, syncOptions);
  validateSyncOptions(options);
  const fileDescriptors = handleStdioSync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
}, normalizeSyncOptions = (options) => options.node && !options.ipc ? { ...options, ipc: false } : options, validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal }) => {
  if (ipcInput) {
    throwInvalidSyncOption("ipcInput");
  }
  if (ipc) {
    throwInvalidSyncOption("ipc: true");
  }
  if (detached) {
    throwInvalidSyncOption("detached: true");
  }
  if (cancelSignal) {
    throwInvalidSyncOption("cancelSignal");
  }
}, throwInvalidSyncOption = (value) => {
  throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
}, spawnSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime }) => {
  const syncResult = runSubprocessSync({
    file,
    commandArguments,
    options,
    command,
    escapedCommand,
    fileDescriptors,
    startTime
  });
  if (syncResult.failed) {
    return syncResult;
  }
  const { resultError, exitCode, signal, timedOut, isMaxBuffer } = getExitResultSync(syncResult, options);
  const { output, error = resultError } = transformOutputSync({
    fileDescriptors,
    syncResult,
    options,
    isMaxBuffer,
    verboseInfo
  });
  const stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));
  const all = stripNewline(getAllSync(output, options), options, "all");
  return getSyncResult({
    error,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer,
    stdio,
    all,
    options,
    command,
    escapedCommand,
    startTime
  });
}, runSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime }) => {
  try {
    addInputOptionsSync(fileDescriptors, options);
    const normalizedOptions = normalizeSpawnSyncOptions(options);
    return spawnSync(...concatenateShell(file, commandArguments, normalizedOptions));
  } catch (error) {
    return makeEarlyError({
      error,
      command,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      isSync: true
    });
  }
}, normalizeSpawnSyncOptions = ({ encoding, maxBuffer, ...options }) => ({ ...options, encoding: "buffer", maxBuffer: getMaxBufferSync(maxBuffer) }), getSyncResult = ({ error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime }) => error === undefined ? makeSuccessResult({
  command,
  escapedCommand,
  stdio,
  all,
  ipcOutput: [],
  options,
  startTime
}) : makeError({
  error,
  command,
  escapedCommand,
  timedOut,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer,
  isForcefullyTerminated: false,
  exitCode,
  signal,
  stdio,
  all,
  ipcOutput: [],
  options,
  startTime,
  isSync: true
});
var init_main_sync = __esm(() => {
  init_command();
  init_options();
  init_result();
  init_reject();
  init_handle_sync();
  init_strip_newline();
  init_input_sync();
  init_output_sync();
  init_max_buffer();
  init_all_sync();
  init_exit_sync();
});

// node_modules/execa/lib/ipc/get-one.js
import { once as once5, on as on2 } from "node:events";
var getOneMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true, filter } = {}) => {
  validateIpcMethod({
    methodName: "getOneMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  return getOneMessageAsync({
    anyProcess,
    channel,
    isSubprocess,
    filter,
    reference
  });
}, getOneMessageAsync = async ({ anyProcess, channel, isSubprocess, filter, reference }) => {
  addReference(channel, reference);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  try {
    return await Promise.race([
      getMessage(ipcEmitter, filter, controller),
      throwOnDisconnect2(ipcEmitter, isSubprocess, controller),
      throwOnStrictError(ipcEmitter, isSubprocess, controller)
    ]);
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    controller.abort();
    removeReference(channel, reference);
  }
}, getMessage = async (ipcEmitter, filter, { signal }) => {
  if (filter === undefined) {
    const [message] = await once5(ipcEmitter, "message", { signal });
    return message;
  }
  for await (const [message] of on2(ipcEmitter, "message", { signal })) {
    if (filter(message)) {
      return message;
    }
  }
}, throwOnDisconnect2 = async (ipcEmitter, isSubprocess, { signal }) => {
  await once5(ipcEmitter, "disconnect", { signal });
  throwOnEarlyDisconnect(isSubprocess);
}, throwOnStrictError = async (ipcEmitter, isSubprocess, { signal }) => {
  const [error] = await once5(ipcEmitter, "strict:error", { signal });
  throw getStrictResponseError(error, isSubprocess);
};
var init_get_one = __esm(() => {
  init_validation();
  init_forward();
});

// node_modules/execa/lib/ipc/get-each.js
import { once as once6, on as on3 } from "node:events";
var getEachMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true } = {}) => loopOnMessages({
  anyProcess,
  channel,
  isSubprocess,
  ipc,
  shouldAwait: !isSubprocess,
  reference
}), loopOnMessages = ({ anyProcess, channel, isSubprocess, ipc, shouldAwait, reference }) => {
  validateIpcMethod({
    methodName: "getEachMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  addReference(channel, reference);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  const state = {};
  stopOnDisconnect(anyProcess, ipcEmitter, controller);
  abortOnStrictError({
    ipcEmitter,
    isSubprocess,
    controller,
    state
  });
  return iterateOnMessages({
    anyProcess,
    channel,
    ipcEmitter,
    isSubprocess,
    shouldAwait,
    controller,
    state,
    reference
  });
}, stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {
  try {
    await once6(ipcEmitter, "disconnect", { signal: controller.signal });
    controller.abort();
  } catch {
  }
}, abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state }) => {
  try {
    const [error] = await once6(ipcEmitter, "strict:error", { signal: controller.signal });
    state.error = getStrictResponseError(error, isSubprocess);
    controller.abort();
  } catch {
  }
}, iterateOnMessages = async function* ({ anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference }) {
  try {
    for await (const [message] of on3(ipcEmitter, "message", { signal: controller.signal })) {
      throwIfStrictError(state);
      yield message;
    }
  } catch {
    throwIfStrictError(state);
  } finally {
    controller.abort();
    removeReference(channel, reference);
    if (!isSubprocess) {
      disconnect(anyProcess);
    }
    if (shouldAwait) {
      await anyProcess;
    }
  }
}, throwIfStrictError = ({ error }) => {
  if (error) {
    throw error;
  }
};
var init_get_each = __esm(() => {
  init_validation();
  init_forward();
});

// node_modules/execa/lib/ipc/methods.js
import process9 from "node:process";
var addIpcMethods = (subprocess, { ipc }) => {
  Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
}, getIpcExport = () => {
  const anyProcess = process9;
  const isSubprocess = true;
  const ipc = process9.channel !== undefined;
  return {
    ...getIpcMethods(anyProcess, isSubprocess, ipc),
    getCancelSignal: getCancelSignal.bind(undefined, {
      anyProcess,
      channel: anyProcess.channel,
      isSubprocess,
      ipc
    })
  };
}, getIpcMethods = (anyProcess, isSubprocess, ipc) => ({
  sendMessage: sendMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getOneMessage: getOneMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getEachMessage: getEachMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  })
});
var init_methods = __esm(() => {
  init_send();
  init_get_one();
  init_get_each();
  init_graceful();
});

// node_modules/execa/lib/return/early-error.js
import { ChildProcess as ChildProcess2 } from "node:child_process";
import {
  PassThrough as PassThrough3,
  Readable,
  Writable,
  Duplex
} from "node:stream";
var handleEarlyError = ({ error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo }) => {
  cleanupCustomStreams(fileDescriptors);
  const subprocess = new ChildProcess2;
  createDummyStreams(subprocess, fileDescriptors);
  Object.assign(subprocess, { readable, writable, duplex });
  const earlyError = makeEarlyError({
    error,
    command,
    escapedCommand,
    fileDescriptors,
    options,
    startTime,
    isSync: false
  });
  const promise = handleDummyPromise(earlyError, verboseInfo, options);
  return { subprocess, promise };
}, createDummyStreams = (subprocess, fileDescriptors) => {
  const stdin = createDummyStream();
  const stdout = createDummyStream();
  const stderr = createDummyStream();
  const extraStdio = Array.from({ length: fileDescriptors.length - 3 }, createDummyStream);
  const all = createDummyStream();
  const stdio = [stdin, stdout, stderr, ...extraStdio];
  Object.assign(subprocess, {
    stdin,
    stdout,
    stderr,
    all,
    stdio
  });
}, createDummyStream = () => {
  const stream = new PassThrough3;
  stream.end();
  return stream;
}, readable = () => new Readable({ read() {
} }), writable = () => new Writable({ write() {
} }), duplex = () => new Duplex({ read() {
}, write() {
} }), handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);
var init_early_error = __esm(() => {
  init_handle();
  init_result();
  init_reject();
});

// node_modules/execa/lib/stdio/handle-async.js
import { createReadStream as createReadStream2, createWriteStream } from "node:fs";
import { Buffer as Buffer6 } from "node:buffer";
import { Readable as Readable2, Writable as Writable2, Duplex as Duplex2 } from "node:stream";
var handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false), forbiddenIfAsync = ({ type: type2, optionName }) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type2]}.`);
}, addProperties2, addPropertiesAsync;
var init_handle_async = __esm(() => {
  init_generator();
  init_handle();
  init_type();
  addProperties2 = {
    fileNumber: forbiddenIfAsync,
    generator: generatorToStream,
    asyncGenerator: generatorToStream,
    nodeStream: ({ value }) => ({ stream: value }),
    webTransform({ value: { transform, writableObjectMode, readableObjectMode } }) {
      const objectMode = writableObjectMode || readableObjectMode;
      const stream = Duplex2.fromWeb(transform, { objectMode });
      return { stream };
    },
    duplex: ({ value: { transform } }) => ({ stream: transform }),
    native() {
    }
  };
  addPropertiesAsync = {
    input: {
      ...addProperties2,
      fileUrl: ({ value }) => ({ stream: createReadStream2(value) }),
      filePath: ({ value: { file } }) => ({ stream: createReadStream2(file) }),
      webStream: ({ value }) => ({ stream: Readable2.fromWeb(value) }),
      iterable: ({ value }) => ({ stream: Readable2.from(value) }),
      asyncIterable: ({ value }) => ({ stream: Readable2.from(value) }),
      string: ({ value }) => ({ stream: Readable2.from(value) }),
      uint8Array: ({ value }) => ({ stream: Readable2.from(Buffer6.from(value)) })
    },
    output: {
      ...addProperties2,
      fileUrl: ({ value }) => ({ stream: createWriteStream(value) }),
      filePath: ({ value: { file, append } }) => ({ stream: createWriteStream(file, append ? { flags: "a" } : {}) }),
      webStream: ({ value }) => ({ stream: Writable2.fromWeb(value) }),
      iterable: forbiddenIfAsync,
      asyncIterable: forbiddenIfAsync,
      string: forbiddenIfAsync,
      uint8Array: forbiddenIfAsync
    }
  };
});

// node_modules/@sindresorhus/merge-streams/index.js
import { on as on4, once as once7 } from "node:events";
import { PassThrough as PassThroughStream, getDefaultHighWaterMark as getDefaultHighWaterMark2 } from "node:stream";
import { finished as finished2 } from "node:stream/promises";
function mergeStreams(streams) {
  if (!Array.isArray(streams)) {
    throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
  }
  for (const stream of streams) {
    validateStream(stream);
  }
  const objectMode = streams.some(({ readableObjectMode }) => readableObjectMode);
  const highWaterMark = getHighWaterMark(streams, objectMode);
  const passThroughStream = new MergedStream({
    objectMode,
    writableHighWaterMark: highWaterMark,
    readableHighWaterMark: highWaterMark
  });
  for (const stream of streams) {
    passThroughStream.add(stream);
  }
  return passThroughStream;
}
var getHighWaterMark = (streams, objectMode) => {
  if (streams.length === 0) {
    return getDefaultHighWaterMark2(objectMode);
  }
  const highWaterMarks = streams.filter(({ readableObjectMode }) => readableObjectMode === objectMode).map(({ readableHighWaterMark }) => readableHighWaterMark);
  return Math.max(...highWaterMarks);
}, MergedStream, onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
  const controller = new AbortController;
  try {
    await Promise.race([
      onMergedStreamEnd(passThroughStream, controller),
      onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller)
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);
  }
}, onMergedStreamEnd = async (passThroughStream, { signal }) => {
  try {
    await finished2(passThroughStream, { signal, cleanup: true });
  } catch (error) {
    errorOrAbortStream(passThroughStream, error);
    throw error;
  }
}, onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, { signal }) => {
  for await (const [unpipedStream] of on4(passThroughStream, "unpipe", { signal })) {
    if (streams.has(unpipedStream)) {
      unpipedStream.emit(unpipeEvent);
    }
  }
}, validateStream = (stream) => {
  if (typeof stream?.pipe !== "function") {
    throw new TypeError(`Expected a readable stream, got: \`${typeof stream}\`.`);
  }
}, endWhenStreamsDone = async ({ passThroughStream, stream, streams, ended, aborted, onFinished, unpipeEvent }) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
  const controller = new AbortController;
  try {
    await Promise.race([
      afterMergedStreamFinished(onFinished, stream, controller),
      onInputStreamEnd({
        passThroughStream,
        stream,
        streams,
        ended,
        aborted,
        controller
      }),
      onInputStreamUnpipe({
        stream,
        streams,
        ended,
        aborted,
        unpipeEvent,
        controller
      })
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);
  }
  if (streams.size > 0 && streams.size === ended.size + aborted.size) {
    if (ended.size === 0 && aborted.size > 0) {
      abortStream(passThroughStream);
    } else {
      endStream(passThroughStream);
    }
  }
}, afterMergedStreamFinished = async (onFinished, stream, { signal }) => {
  try {
    await onFinished;
    if (!signal.aborted) {
      abortStream(stream);
    }
  } catch (error) {
    if (!signal.aborted) {
      errorOrAbortStream(stream, error);
    }
  }
}, onInputStreamEnd = async ({ passThroughStream, stream, streams, ended, aborted, controller: { signal } }) => {
  try {
    await finished2(stream, {
      signal,
      cleanup: true,
      readable: true,
      writable: false
    });
    if (streams.has(stream)) {
      ended.add(stream);
    }
  } catch (error) {
    if (signal.aborted || !streams.has(stream)) {
      return;
    }
    if (isAbortError(error)) {
      aborted.add(stream);
    } else {
      errorStream(passThroughStream, error);
    }
  }
}, onInputStreamUnpipe = async ({ stream, streams, ended, aborted, unpipeEvent, controller: { signal } }) => {
  await once7(stream, unpipeEvent, { signal });
  if (!stream.readable) {
    return once7(signal, "abort", { signal });
  }
  streams.delete(stream);
  ended.delete(stream);
  aborted.delete(stream);
}, endStream = (stream) => {
  if (stream.writable) {
    stream.end();
  }
}, errorOrAbortStream = (stream, error) => {
  if (isAbortError(error)) {
    abortStream(stream);
  } else {
    errorStream(stream, error);
  }
}, isAbortError = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE", abortStream = (stream) => {
  if (stream.readable || stream.writable) {
    stream.destroy();
  }
}, errorStream = (stream, error) => {
  if (!stream.destroyed) {
    stream.once("error", noop3);
    stream.destroy(error);
  }
}, noop3 = () => {
}, updateMaxListeners = (passThroughStream, increment2) => {
  const maxListeners = passThroughStream.getMaxListeners();
  if (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {
    passThroughStream.setMaxListeners(maxListeners + increment2);
  }
}, PASSTHROUGH_LISTENERS_COUNT = 2, PASSTHROUGH_LISTENERS_PER_STREAM = 1;
var init_merge_streams = __esm(() => {
  MergedStream = class MergedStream extends PassThroughStream {
    #streams = new Set([]);
    #ended = new Set([]);
    #aborted = new Set([]);
    #onFinished;
    #unpipeEvent = Symbol("unpipe");
    #streamPromises = new WeakMap;
    add(stream) {
      validateStream(stream);
      if (this.#streams.has(stream)) {
        return;
      }
      this.#streams.add(stream);
      this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
      const streamPromise = endWhenStreamsDone({
        passThroughStream: this,
        stream,
        streams: this.#streams,
        ended: this.#ended,
        aborted: this.#aborted,
        onFinished: this.#onFinished,
        unpipeEvent: this.#unpipeEvent
      });
      this.#streamPromises.set(stream, streamPromise);
      stream.pipe(this, { end: false });
    }
    async remove(stream) {
      validateStream(stream);
      if (!this.#streams.has(stream)) {
        return false;
      }
      const streamPromise = this.#streamPromises.get(stream);
      if (streamPromise === undefined) {
        return false;
      }
      this.#streamPromises.delete(stream);
      stream.unpipe(this);
      await streamPromise;
      return true;
    }
  };
});

// node_modules/execa/lib/io/pipeline.js
import { finished as finished3 } from "node:stream/promises";
var pipeStreams = (source, destination) => {
  source.pipe(destination);
  onSourceFinish(source, destination);
  onDestinationFinish(source, destination);
}, onSourceFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(source, { cleanup: true, readable: true, writable: false });
  } catch {
  }
  endDestinationStream(destination);
}, endDestinationStream = (destination) => {
  if (destination.writable) {
    destination.end();
  }
}, onDestinationFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(destination, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  abortSourceStream(source);
}, abortSourceStream = (source) => {
  if (source.readable) {
    source.destroy();
  }
};
var init_pipeline = __esm(() => {
  init_standard_stream();
});

// node_modules/execa/lib/io/output-async.js
var pipeOutputAsync = (subprocess, fileDescriptors, controller) => {
  const pipeGroups = new Map;
  for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)) {
    for (const { stream } of stdioItems.filter(({ type: type2 }) => TRANSFORM_TYPES.has(type2))) {
      pipeTransform(subprocess, stream, direction, fdNumber);
    }
    for (const { stream } of stdioItems.filter(({ type: type2 }) => !TRANSFORM_TYPES.has(type2))) {
      pipeStdioItem({
        subprocess,
        stream,
        direction,
        fdNumber,
        pipeGroups,
        controller
      });
    }
  }
  for (const [outputStream, inputStreams] of pipeGroups.entries()) {
    const inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);
    pipeStreams(inputStream, outputStream);
  }
}, pipeTransform = (subprocess, stream, direction, fdNumber) => {
  if (direction === "output") {
    pipeStreams(subprocess.stdio[fdNumber], stream);
  } else {
    pipeStreams(stream, subprocess.stdio[fdNumber]);
  }
  const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
  if (streamProperty !== undefined) {
    subprocess[streamProperty] = stream;
  }
  subprocess.stdio[fdNumber] = stream;
}, SUBPROCESS_STREAM_PROPERTIES, pipeStdioItem = ({ subprocess, stream, direction, fdNumber, pipeGroups, controller }) => {
  if (stream === undefined) {
    return;
  }
  setStandardStreamMaxListeners(stream, controller);
  const [inputStream, outputStream] = direction === "output" ? [stream, subprocess.stdio[fdNumber]] : [subprocess.stdio[fdNumber], stream];
  const outputStreams = pipeGroups.get(inputStream) ?? [];
  pipeGroups.set(inputStream, [...outputStreams, outputStream]);
}, setStandardStreamMaxListeners = (stream, { signal }) => {
  if (isStandardStream(stream)) {
    incrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);
  }
}, MAX_LISTENERS_INCREMENT = 2;
var init_output_async = __esm(() => {
  init_merge_streams();
  init_standard_stream();
  init_max_listeners();
  init_type();
  init_pipeline();
  SUBPROCESS_STREAM_PROPERTIES = ["stdin", "stdout", "stderr"];
});

// node_modules/signal-exit/dist/mjs/signals.js
var signals;
var init_signals2 = __esm(() => {
  signals = [];
  signals.push("SIGHUP", "SIGINT", "SIGTERM");
  if (process.platform !== "win32") {
    signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
  }
});

// node_modules/signal-exit/dist/mjs/index.js
class Emitter {
  emitted = {
    afterExit: false,
    exit: false
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list = this.listeners[ev];
    const i3 = list.indexOf(fn);
    if (i3 === -1) {
      return;
    }
    if (i3 === 0 && list.length === 1) {
      list.length = 0;
    } else {
      list.splice(i3, 1);
    }
  }
  emit(ev, code, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code, signal) === true || ret;
    }
    if (ev === "exit") {
      ret = this.emit("afterExit", code, signal) || ret;
    }
    return ret;
  }
}

class SignalExitBase {
}
var processOk = (process10) => !!process10 && typeof process10 === "object" && typeof process10.removeListener === "function" && typeof process10.emit === "function" && typeof process10.reallyExit === "function" && typeof process10.listeners === "function" && typeof process10.kill === "function" && typeof process10.pid === "number" && typeof process10.on === "function", kExitEmitter, global2, ObjectDefineProperty, signalExitWrap = (handler) => {
  return {
    onExit(cb, opts) {
      return handler.onExit(cb, opts);
    },
    load() {
      return handler.load();
    },
    unload() {
      return handler.unload();
    }
  };
}, SignalExitFallback, SignalExit, process10, onExit, load, unload;
var init_mjs = __esm(() => {
  init_signals2();
  kExitEmitter = Symbol.for("signal-exit emitter");
  global2 = globalThis;
  ObjectDefineProperty = Object.defineProperty.bind(Object);
  SignalExitFallback = class SignalExitFallback extends SignalExitBase {
    onExit() {
      return () => {
      };
    }
    load() {
    }
    unload() {
    }
  };
  SignalExit = class SignalExit extends SignalExitBase {
    #hupSig = process10.platform === "win32" ? "SIGINT" : "SIGHUP";
    #emitter = new Emitter;
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process10) {
      super();
      this.#process = process10;
      this.#sigListeners = {};
      for (const sig of signals) {
        this.#sigListeners[sig] = () => {
          const listeners = this.#process.listeners(sig);
          let { count: count2 } = this.#emitter;
          const p = process10;
          if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
            count2 += p.__signal_exit_emitter__.count;
          }
          if (listeners.length === count2) {
            this.unload();
            const ret = this.#emitter.emit("exit", null, sig);
            const s2 = sig === "SIGHUP" ? this.#hupSig : sig;
            if (!ret)
              process10.kill(process10.pid, s2);
          }
        };
      }
      this.#originalProcessReallyExit = process10.reallyExit;
      this.#originalProcessEmit = process10.emit;
    }
    onExit(cb, opts) {
      if (!processOk(this.#process)) {
        return () => {
        };
      }
      if (this.#loaded === false) {
        this.load();
      }
      const ev = opts?.alwaysLast ? "afterExit" : "exit";
      this.#emitter.on(ev, cb);
      return () => {
        this.#emitter.removeListener(ev, cb);
        if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
          this.unload();
        }
      };
    }
    load() {
      if (this.#loaded) {
        return;
      }
      this.#loaded = true;
      this.#emitter.count += 1;
      for (const sig of signals) {
        try {
          const fn = this.#sigListeners[sig];
          if (fn)
            this.#process.on(sig, fn);
        } catch (_) {
        }
      }
      this.#process.emit = (ev, ...a2) => {
        return this.#processEmit(ev, ...a2);
      };
      this.#process.reallyExit = (code) => {
        return this.#processReallyExit(code);
      };
    }
    unload() {
      if (!this.#loaded) {
        return;
      }
      this.#loaded = false;
      signals.forEach((sig) => {
        const listener = this.#sigListeners[sig];
        if (!listener) {
          throw new Error("Listener not defined for signal: " + sig);
        }
        try {
          this.#process.removeListener(sig, listener);
        } catch (_) {
        }
      });
      this.#process.emit = this.#originalProcessEmit;
      this.#process.reallyExit = this.#originalProcessReallyExit;
      this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
      if (!processOk(this.#process)) {
        return 0;
      }
      this.#process.exitCode = code || 0;
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
      const og = this.#originalProcessEmit;
      if (ev === "exit" && processOk(this.#process)) {
        if (typeof args[0] === "number") {
          this.#process.exitCode = args[0];
        }
        const ret = og.call(this.#process, ev, ...args);
        this.#emitter.emit("exit", this.#process.exitCode, null);
        return ret;
      } else {
        return og.call(this.#process, ev, ...args);
      }
    }
  };
  process10 = globalThis.process;
  ({
    onExit,
    load,
    unload
  } = signalExitWrap(processOk(process10) ? new SignalExit(process10) : new SignalExitFallback));
});

// node_modules/execa/lib/terminate/cleanup.js
import { addAbortListener as addAbortListener2 } from "node:events";
var cleanupOnExit = (subprocess, { cleanup, detached }, { signal }) => {
  if (!cleanup || detached) {
    return;
  }
  const removeExitHandler = onExit(() => {
    subprocess.kill();
  });
  addAbortListener2(signal, () => {
    removeExitHandler();
  });
};
var init_cleanup = __esm(() => {
  init_mjs();
});

// node_modules/execa/lib/pipe/pipe-arguments.js
var normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments) => {
  const startTime = getStartTime();
  const {
    destination,
    destinationStream,
    destinationError,
    from,
    unpipeSignal
  } = getDestinationStream(boundOptions, createNested, pipeArguments);
  const { sourceStream, sourceError } = getSourceStream(source, from);
  const { options: sourceOptions, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  return {
    sourcePromise,
    sourceStream,
    sourceOptions,
    sourceError,
    destination,
    destinationStream,
    destinationError,
    unpipeSignal,
    fileDescriptors,
    startTime
  };
}, getDestinationStream = (boundOptions, createNested, pipeArguments) => {
  try {
    const {
      destination,
      pipeOptions: { from, to, unpipeSignal } = {}
    } = getDestination(boundOptions, createNested, ...pipeArguments);
    const destinationStream = getToStream(destination, to);
    return {
      destination,
      destinationStream,
      from,
      unpipeSignal
    };
  } catch (error) {
    return { destinationError: error };
  }
}, getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {
  if (Array.isArray(firstArgument)) {
    const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
    return { destination, pipeOptions: boundOptions };
  }
  if (typeof firstArgument === "string" || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
    }
    const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
    const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
    return { destination, pipeOptions: rawOptions };
  }
  if (SUBPROCESS_OPTIONS.has(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");
    }
    return { destination: firstArgument, pipeOptions: pipeArguments[0] };
  }
  throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
}, mapDestinationArguments = ({ options }) => ({ options: { ...options, stdin: "pipe", piped: true } }), getSourceStream = (source, from) => {
  try {
    const sourceStream = getFromStream(source, from);
    return { sourceStream };
  } catch (error) {
    return { sourceError: error };
  }
};
var init_pipe_arguments = __esm(() => {
  init_parameters();
  init_duration();
  init_fd_options();
  init_file_url();
});

// node_modules/execa/lib/pipe/throw.js
var handlePipeArgumentsError = ({
  sourceStream,
  sourceError,
  destinationStream,
  destinationError,
  fileDescriptors,
  sourceOptions,
  startTime
}) => {
  const error = getPipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError
  });
  if (error !== undefined) {
    throw createNonCommandError({
      error,
      fileDescriptors,
      sourceOptions,
      startTime
    });
  }
}, getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError }) => {
  if (sourceError !== undefined && destinationError !== undefined) {
    return destinationError;
  }
  if (destinationError !== undefined) {
    abortSourceStream(sourceStream);
    return destinationError;
  }
  if (sourceError !== undefined) {
    endDestinationStream(destinationStream);
    return sourceError;
  }
}, createNonCommandError = ({ error, fileDescriptors, sourceOptions, startTime }) => makeEarlyError({
  error,
  command: PIPE_COMMAND_MESSAGE,
  escapedCommand: PIPE_COMMAND_MESSAGE,
  fileDescriptors,
  options: sourceOptions,
  startTime,
  isSync: false
}), PIPE_COMMAND_MESSAGE = "source.pipe(destination)";
var init_throw = __esm(() => {
  init_result();
  init_pipeline();
});

// node_modules/execa/lib/pipe/sequence.js
var waitForBothSubprocesses = async (subprocessPromises) => {
  const [
    { status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason },
    { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }
  ] = await subprocessPromises;
  if (!destinationResult.pipedFrom.includes(sourceResult)) {
    destinationResult.pipedFrom.push(sourceResult);
  }
  if (destinationStatus === "rejected") {
    throw destinationResult;
  }
  if (sourceStatus === "rejected") {
    throw sourceResult;
  }
  return destinationResult;
};

// node_modules/execa/lib/pipe/streaming.js
import { finished as finished4 } from "node:stream/promises";
var pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {
  const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
  incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
  incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
  cleanupMergedStreamsMap(destinationStream);
  return mergedStream;
}, pipeFirstSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = mergeStreams([sourceStream]);
  pipeStreams(mergedStream, destinationStream);
  MERGED_STREAMS.set(destinationStream, mergedStream);
  return mergedStream;
}, pipeMoreSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = MERGED_STREAMS.get(destinationStream);
  mergedStream.add(sourceStream);
  return mergedStream;
}, cleanupMergedStreamsMap = async (destinationStream) => {
  try {
    await finished4(destinationStream, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  MERGED_STREAMS.delete(destinationStream);
}, MERGED_STREAMS, SOURCE_LISTENERS_PER_PIPE = 2, DESTINATION_LISTENERS_PER_PIPE = 1;
var init_streaming = __esm(() => {
  init_merge_streams();
  init_max_listeners();
  init_pipeline();
  MERGED_STREAMS = new WeakMap;
});

// node_modules/execa/lib/pipe/abort.js
import { aborted } from "node:util";
var unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined ? [] : [unpipeOnSignalAbort(unpipeSignal, unpipeContext)], unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime }) => {
  await aborted(unpipeSignal, sourceStream);
  await mergedStream.remove(sourceStream);
  const error = new Error("Pipe canceled by `unpipeSignal` option.");
  throw createNonCommandError({
    error,
    fileDescriptors,
    sourceOptions,
    startTime
  });
};
var init_abort = __esm(() => {
  init_throw();
});

// node_modules/execa/lib/pipe/setup.js
var pipeToSubprocess = (sourceInfo, ...pipeArguments) => {
  if (isPlainObject2(pipeArguments[0])) {
    return pipeToSubprocess.bind(undefined, {
      ...sourceInfo,
      boundOptions: { ...sourceInfo.boundOptions, ...pipeArguments[0] }
    });
  }
  const { destination, ...normalizedInfo } = normalizePipeArguments(sourceInfo, ...pipeArguments);
  const promise = handlePipePromise({ ...normalizedInfo, destination });
  promise.pipe = pipeToSubprocess.bind(undefined, {
    ...sourceInfo,
    source: destination,
    sourcePromise: promise,
    boundOptions: {}
  });
  return promise;
}, handlePipePromise = async ({
  sourcePromise,
  sourceStream,
  sourceOptions,
  sourceError,
  destination,
  destinationStream,
  destinationError,
  unpipeSignal,
  fileDescriptors,
  startTime
}) => {
  const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
  handlePipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError,
    fileDescriptors,
    sourceOptions,
    startTime
  });
  const maxListenersController = new AbortController;
  try {
    const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
    return await Promise.race([
      waitForBothSubprocesses(subprocessPromises),
      ...unpipeOnAbort(unpipeSignal, {
        sourceStream,
        mergedStream,
        sourceOptions,
        fileDescriptors,
        startTime
      })
    ]);
  } finally {
    maxListenersController.abort();
  }
}, getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);
var init_setup = __esm(() => {
  init_pipe_arguments();
  init_throw();
  init_streaming();
  init_abort();
});

// node_modules/execa/lib/io/iterate.js
import { on as on5 } from "node:events";
import { getDefaultHighWaterMark as getDefaultHighWaterMark3 } from "node:stream";
var iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines }) => {
  const controller = new AbortController;
  stopReadingOnExit(subprocess, controller);
  return iterateOnStream({
    stream: subprocessStdout,
    controller,
    binary,
    shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
    encoding,
    shouldSplit: !subprocessStdout.readableObjectMode,
    preserveNewlines
  });
}, stopReadingOnExit = async (subprocess, controller) => {
  try {
    await subprocess;
  } catch {
  } finally {
    controller.abort();
  }
}, iterateForResult = ({ stream, onStreamEnd, lines, encoding, stripFinalNewline: stripFinalNewline2, allMixed }) => {
  const controller = new AbortController;
  stopReadingOnStreamEnd(onStreamEnd, controller, stream);
  const objectMode = stream.readableObjectMode && !allMixed;
  return iterateOnStream({
    stream,
    controller,
    binary: encoding === "buffer",
    shouldEncode: !objectMode,
    encoding,
    shouldSplit: !objectMode && lines,
    preserveNewlines: !stripFinalNewline2
  });
}, stopReadingOnStreamEnd = async (onStreamEnd, controller, stream) => {
  try {
    await onStreamEnd;
  } catch {
    stream.destroy();
  } finally {
    controller.abort();
  }
}, iterateOnStream = ({ stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => {
  const onStdoutChunk = on5(stream, "data", {
    signal: controller.signal,
    highWaterMark: HIGH_WATER_MARK,
    highWatermark: HIGH_WATER_MARK
  });
  return iterateOnData({
    onStdoutChunk,
    controller,
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
}, DEFAULT_OBJECT_HIGH_WATER_MARK, HIGH_WATER_MARK, iterateOnData = async function* ({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
  const generators = getGenerators({
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
  try {
    for await (const [chunk] of onStdoutChunk) {
      yield* transformChunkSync(chunk, generators, 0);
    }
  } catch (error) {
    if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    yield* finalChunksSync(generators);
  }
}, getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => [
  getEncodingTransformGenerator(binary, encoding, !shouldEncode),
  getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {})
].filter(Boolean);
var init_iterate = __esm(() => {
  init_encoding_transform();
  init_split();
  DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark3(true);
  HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
});

// node_modules/execa/lib/io/contents.js
import { setImmediate as setImmediate2 } from "node:timers/promises";
var getStreamOutput = async ({ stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  const logPromise = logOutputAsync({
    stream,
    onStreamEnd,
    fdNumber,
    encoding,
    allMixed,
    verboseInfo,
    streamInfo
  });
  if (!buffer) {
    await Promise.all([resumeStream(stream), logPromise]);
    return;
  }
  const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline2, fdNumber);
  const iterable = iterateForResult({
    stream,
    onStreamEnd,
    lines,
    encoding,
    stripFinalNewline: stripFinalNewlineValue,
    allMixed
  });
  const [output] = await Promise.all([
    getStreamContents2({
      stream,
      iterable,
      fdNumber,
      encoding,
      maxBuffer,
      lines
    }),
    logPromise
  ]);
  return output;
}, logOutputAsync = async ({ stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } }) => {
  if (!shouldLogOutput({
    stdioItems: fileDescriptors[fdNumber]?.stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesIterable = iterateForResult({
    stream,
    onStreamEnd,
    lines: true,
    encoding,
    stripFinalNewline: true,
    allMixed
  });
  await logLines(linesIterable, stream, fdNumber, verboseInfo);
}, resumeStream = async (stream) => {
  await setImmediate2();
  if (stream.readableFlowing === null) {
    stream.resume();
  }
}, getStreamContents2 = async ({ stream, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines }) => {
  try {
    if (readableObjectMode || lines) {
      return await getStreamAsArray(iterable, { maxBuffer });
    }
    if (encoding === "buffer") {
      return new Uint8Array(await getStreamAsArrayBuffer(iterable, { maxBuffer }));
    }
    return await getStreamAsString(iterable, { maxBuffer });
  } catch (error) {
    return handleBufferedData(handleMaxBuffer({
      error,
      stream,
      readableObjectMode,
      lines,
      encoding,
      fdNumber
    }));
  }
}, getBufferedData = async (streamPromise) => {
  try {
    return await streamPromise;
  } catch (error) {
    return handleBufferedData(error);
  }
}, handleBufferedData = ({ bufferedData }) => isArrayBuffer(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;
var init_contents2 = __esm(() => {
  init_source();
  init_uint_array();
  init_output();
  init_iterate();
  init_max_buffer();
  init_strip_newline();
});

// node_modules/execa/lib/resolve/wait-stream.js
import { finished as finished5 } from "node:stream/promises";
var waitForStream = async (stream, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {}) => {
  const state = handleStdinDestroy(stream, streamInfo);
  const abortController = new AbortController;
  try {
    await Promise.race([
      ...stopOnExit ? [streamInfo.exitPromise] : [],
      finished5(stream, { cleanup: true, signal: abortController.signal })
    ]);
  } catch (error) {
    if (!state.stdinCleanedUp) {
      handleStreamError(error, fdNumber, streamInfo, isSameDirection);
    }
  } finally {
    abortController.abort();
  }
}, handleStdinDestroy = (stream, { originalStreams: [originalStdin], subprocess }) => {
  const state = { stdinCleanedUp: false };
  if (stream === originalStdin) {
    spyOnStdinDestroy(stream, subprocess, state);
  }
  return state;
}, spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {
  const { _destroy } = subprocessStdin;
  subprocessStdin._destroy = (...destroyArguments) => {
    setStdinCleanedUp(subprocess, state);
    _destroy.call(subprocessStdin, ...destroyArguments);
  };
}, setStdinCleanedUp = ({ exitCode, signalCode }, state) => {
  if (exitCode !== null || signalCode !== null) {
    state.stdinCleanedUp = true;
  }
}, handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {
  if (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {
    throw error;
  }
}, shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {
  if (streamInfo.propagating) {
    return isStreamEpipe(error) || isStreamAbort(error);
  }
  streamInfo.propagating = true;
  return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error) : isStreamAbort(error);
}, isInputFileDescriptor = ({ fileDescriptors }, fdNumber) => fdNumber !== "all" && fileDescriptors[fdNumber].direction === "input", isStreamAbort = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE", isStreamEpipe = (error) => error?.code === "EPIPE";
var init_wait_stream = () => {
};

// node_modules/execa/lib/resolve/stdio.js
var waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => subprocess.stdio.map((stream, fdNumber) => waitForSubprocessStream({
  stream,
  fdNumber,
  encoding,
  buffer: buffer[fdNumber],
  maxBuffer: maxBuffer[fdNumber],
  lines: lines[fdNumber],
  allMixed: false,
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
})), waitForSubprocessStream = async ({ stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  if (!stream) {
    return;
  }
  const onStreamEnd = waitForStream(stream, fdNumber, streamInfo);
  if (isInputFileDescriptor(streamInfo, fdNumber)) {
    await onStreamEnd;
    return;
  }
  const [output] = await Promise.all([
    getStreamOutput({
      stream,
      onStreamEnd,
      fdNumber,
      encoding,
      buffer,
      maxBuffer,
      lines,
      allMixed,
      stripFinalNewline: stripFinalNewline2,
      verboseInfo,
      streamInfo
    }),
    onStreamEnd
  ]);
  return output;
};
var init_stdio = __esm(() => {
  init_contents2();
  init_wait_stream();
});

// node_modules/execa/lib/resolve/all-async.js
var makeAllStream = ({ stdout, stderr }, { all }) => all && (stdout || stderr) ? mergeStreams([stdout, stderr].filter(Boolean)) : undefined, waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => waitForSubprocessStream({
  ...getAllStream(subprocess, buffer),
  fdNumber: "all",
  encoding,
  maxBuffer: maxBuffer[1] + maxBuffer[2],
  lines: lines[1] || lines[2],
  allMixed: getAllMixed(subprocess),
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
}), getAllStream = ({ stdout, stderr, all }, [, bufferStdout, bufferStderr]) => {
  const buffer = bufferStdout || bufferStderr;
  if (!buffer) {
    return { stream: all, buffer };
  }
  if (!bufferStdout) {
    return { stream: stderr, buffer };
  }
  if (!bufferStderr) {
    return { stream: stdout, buffer };
  }
  return { stream: all, buffer };
}, getAllMixed = ({ all, stdout, stderr }) => all && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;
var init_all_async = __esm(() => {
  init_merge_streams();
  init_stdio();
});

// node_modules/execa/lib/verbose/ipc.js
var shouldLogIpc = (verboseInfo) => isFullVerbose(verboseInfo, "ipc"), logIpcOutput = (message, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(message);
  verboseLog({
    type: "ipc",
    verboseMessage,
    fdNumber: "ipc",
    verboseInfo
  });
};
var init_ipc = __esm(() => {
  init_log();
  init_values();
});

// node_modules/execa/lib/ipc/buffer-messages.js
var waitForIpcOutput = async ({
  subprocess,
  buffer: bufferArray,
  maxBuffer: maxBufferArray,
  ipc,
  ipcOutput,
  verboseInfo
}) => {
  if (!ipc) {
    return ipcOutput;
  }
  const isVerbose2 = shouldLogIpc(verboseInfo);
  const buffer = getFdSpecificValue(bufferArray, "ipc");
  const maxBuffer = getFdSpecificValue(maxBufferArray, "ipc");
  for await (const message of loopOnMessages({
    anyProcess: subprocess,
    channel: subprocess.channel,
    isSubprocess: false,
    ipc,
    shouldAwait: false,
    reference: true
  })) {
    if (buffer) {
      checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
      ipcOutput.push(message);
    }
    if (isVerbose2) {
      logIpcOutput(message, verboseInfo);
    }
  }
  return ipcOutput;
}, getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {
  await Promise.allSettled([ipcOutputPromise]);
  return ipcOutput;
};
var init_buffer_messages = __esm(() => {
  init_max_buffer();
  init_ipc();
  init_specific();
  init_get_each();
});

// node_modules/execa/lib/resolve/wait-subprocess.js
import { once as once8 } from "node:events";
var waitForSubprocessResult = async ({
  subprocess,
  options: {
    encoding,
    buffer,
    maxBuffer,
    lines,
    timeoutDuration: timeout,
    cancelSignal,
    gracefulCancel,
    forceKillAfterDelay,
    stripFinalNewline: stripFinalNewline2,
    ipc,
    ipcInput
  },
  context: context3,
  verboseInfo,
  fileDescriptors,
  originalStreams,
  onInternalError,
  controller
}) => {
  const exitPromise = waitForExit(subprocess, context3);
  const streamInfo = {
    originalStreams,
    fileDescriptors,
    subprocess,
    exitPromise,
    propagating: false
  };
  const stdioPromises = waitForStdioStreams({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const allPromise = waitForAllStream({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const ipcOutput = [];
  const ipcOutputPromise = waitForIpcOutput({
    subprocess,
    buffer,
    maxBuffer,
    ipc,
    ipcOutput,
    verboseInfo
  });
  const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
  const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
  try {
    return await Promise.race([
      Promise.all([
        {},
        waitForSuccessfulExit(exitPromise),
        Promise.all(stdioPromises),
        allPromise,
        ipcOutputPromise,
        sendIpcInput(subprocess, ipcInput),
        ...originalPromises,
        ...customStreamsEndPromises
      ]),
      onInternalError,
      throwOnSubprocessError(subprocess, controller),
      ...throwOnTimeout(subprocess, timeout, context3, controller),
      ...throwOnCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        context: context3,
        controller
      }),
      ...throwOnGracefulCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        forceKillAfterDelay,
        context: context3,
        controller
      })
    ]);
  } catch (error) {
    context3.terminationReason ??= "other";
    return Promise.all([
      { error },
      exitPromise,
      Promise.all(stdioPromises.map((stdioPromise) => getBufferedData(stdioPromise))),
      getBufferedData(allPromise),
      getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
      Promise.allSettled(originalPromises),
      Promise.allSettled(customStreamsEndPromises)
    ]);
  }
}, waitForOriginalStreams = (originalStreams, subprocess, streamInfo) => originalStreams.map((stream, fdNumber) => stream === subprocess.stdio[fdNumber] ? undefined : waitForStream(stream, fdNumber, streamInfo)), waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({ stdioItems }, fdNumber) => stdioItems.filter(({ value, stream = value }) => isStream(stream, { checkOpen: false }) && !isStandardStream(stream)).map(({ type: type2, value, stream = value }) => waitForStream(stream, fdNumber, streamInfo, {
  isSameDirection: TRANSFORM_TYPES.has(type2),
  stopOnExit: type2 === "native"
}))), throwOnSubprocessError = async (subprocess, { signal }) => {
  const [error] = await once8(subprocess, "error", { signal });
  throw error;
};
var init_wait_subprocess = __esm(() => {
  init_timeout();
  init_cancel();
  init_graceful2();
  init_standard_stream();
  init_type();
  init_contents2();
  init_buffer_messages();
  init_ipc_input();
  init_all_async();
  init_stdio();
  init_exit_async();
  init_wait_stream();
});

// node_modules/execa/lib/convert/concurrent.js
var initializeConcurrentStreams = () => ({
  readableDestroy: new WeakMap,
  writableFinal: new WeakMap,
  writableDestroy: new WeakMap
}), addConcurrentStream = (concurrentStreams, stream, waitName) => {
  const weakMap = concurrentStreams[waitName];
  if (!weakMap.has(stream)) {
    weakMap.set(stream, []);
  }
  const promises = weakMap.get(stream);
  const promise = createDeferred();
  promises.push(promise);
  const resolve = promise.resolve.bind(promise);
  return { resolve, promises };
}, waitForConcurrentStreams = async ({ resolve, promises }, subprocess) => {
  resolve();
  const [isSubprocessExit] = await Promise.race([
    Promise.allSettled([true, subprocess]),
    Promise.all([false, ...promises])
  ]);
  return !isSubprocessExit;
};
var init_concurrent = () => {
};

// node_modules/execa/lib/convert/shared.js
import { finished as finished6 } from "node:stream/promises";
var safeWaitForSubprocessStdin = async (subprocessStdin) => {
  if (subprocessStdin === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdin(subprocessStdin);
  } catch {
  }
}, safeWaitForSubprocessStdout = async (subprocessStdout) => {
  if (subprocessStdout === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdout(subprocessStdout);
  } catch {
  }
}, waitForSubprocessStdin = async (subprocessStdin) => {
  await finished6(subprocessStdin, { cleanup: true, readable: false, writable: true });
}, waitForSubprocessStdout = async (subprocessStdout) => {
  await finished6(subprocessStdout, { cleanup: true, readable: true, writable: false });
}, waitForSubprocess = async (subprocess, error) => {
  await subprocess;
  if (error) {
    throw error;
  }
}, destroyOtherStream = (stream, isOpen, error) => {
  if (error && !isStreamAbort(error)) {
    stream.destroy(error);
  } else if (isOpen) {
    stream.destroy();
  }
};
var init_shared = __esm(() => {
  init_wait_stream();
});

// node_modules/execa/lib/convert/readable.js
import { Readable as Readable3 } from "node:stream";
import { callbackify as callbackify2 } from "node:util";
var createReadable = ({ subprocess, concurrentStreams, encoding }, { from, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const readable2 = new Readable3({
    read,
    destroy: callbackify2(onReadableDestroy.bind(undefined, { subprocessStdout, subprocess, waitReadableDestroy })),
    highWaterMark: readableHighWaterMark,
    objectMode: readableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: readable2,
    subprocess
  });
  return readable2;
}, getSubprocessStdout = (subprocess, from, concurrentStreams) => {
  const subprocessStdout = getFromStream(subprocess, from);
  const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, "readableDestroy");
  return { subprocessStdout, waitReadableDestroy };
}, getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary) => binary ? { readableEncoding, readableObjectMode, readableHighWaterMark } : { readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK }, getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines }) => {
  const onStdoutDataDone = createDeferred();
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: !binary,
    encoding,
    preserveNewlines
  });
  return {
    read() {
      onRead(this, onStdoutData, onStdoutDataDone);
    },
    onStdoutDataDone
  };
}, onRead = async (readable2, onStdoutData, onStdoutDataDone) => {
  try {
    const { value, done } = await onStdoutData.next();
    if (done) {
      onStdoutDataDone.resolve();
    } else {
      readable2.push(value);
    }
  } catch {
  }
}, onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable: readable2, subprocess, subprocessStdin }) => {
  try {
    await waitForSubprocessStdout(subprocessStdout);
    await subprocess;
    await safeWaitForSubprocessStdin(subprocessStdin);
    await onStdoutDataDone;
    if (readable2.readable) {
      readable2.push(null);
    }
  } catch (error) {
    await safeWaitForSubprocessStdin(subprocessStdin);
    destroyOtherReadable(readable2, error);
  }
}, onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error) => {
  if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
    destroyOtherReadable(subprocessStdout, error);
    await waitForSubprocess(subprocess, error);
  }
}, destroyOtherReadable = (stream, error) => {
  destroyOtherStream(stream, stream.readable, error);
};
var init_readable = __esm(() => {
  init_encoding_option();
  init_fd_options();
  init_iterate();
  init_concurrent();
  init_shared();
});

// node_modules/execa/lib/convert/writable.js
import { Writable as Writable3 } from "node:stream";
import { callbackify as callbackify3 } from "node:util";
var createWritable = ({ subprocess, concurrentStreams }, { to } = {}) => {
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const writable2 = new Writable3({
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify3(onWritableDestroy.bind(undefined, {
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    })),
    highWaterMark: subprocessStdin.writableHighWaterMark,
    objectMode: subprocessStdin.writableObjectMode
  });
  onStdinFinished(subprocessStdin, writable2);
  return writable2;
}, getSubprocessStdin = (subprocess, to, concurrentStreams) => {
  const subprocessStdin = getToStream(subprocess, to);
  const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, "writableFinal");
  const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, "writableDestroy");
  return { subprocessStdin, waitWritableFinal, waitWritableDestroy };
}, getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({
  write: onWrite.bind(undefined, subprocessStdin),
  final: callbackify3(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal))
}), onWrite = (subprocessStdin, chunk, encoding, done) => {
  if (subprocessStdin.write(chunk, encoding)) {
    done();
  } else {
    subprocessStdin.once("drain", done);
  }
}, onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {
  if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
    if (subprocessStdin.writable) {
      subprocessStdin.end();
    }
    await subprocess;
  }
}, onStdinFinished = async (subprocessStdin, writable2, subprocessStdout) => {
  try {
    await waitForSubprocessStdin(subprocessStdin);
    if (writable2.writable) {
      writable2.end();
    }
  } catch (error) {
    await safeWaitForSubprocessStdout(subprocessStdout);
    destroyOtherWritable(writable2, error);
  }
}, onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error) => {
  await waitForConcurrentStreams(waitWritableFinal, subprocess);
  if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
    destroyOtherWritable(subprocessStdin, error);
    await waitForSubprocess(subprocess, error);
  }
}, destroyOtherWritable = (stream, error) => {
  destroyOtherStream(stream, stream.writable, error);
};
var init_writable = __esm(() => {
  init_fd_options();
  init_concurrent();
  init_shared();
});

// node_modules/execa/lib/convert/duplex.js
import { Duplex as Duplex3 } from "node:stream";
import { callbackify as callbackify4 } from "node:util";
var createDuplex = ({ subprocess, concurrentStreams, encoding }, { from, to, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const duplex2 = new Duplex3({
    read,
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify4(onDuplexDestroy.bind(undefined, {
      subprocessStdout,
      subprocessStdin,
      subprocess,
      waitReadableDestroy,
      waitWritableFinal,
      waitWritableDestroy
    })),
    readableHighWaterMark,
    writableHighWaterMark: subprocessStdin.writableHighWaterMark,
    readableObjectMode,
    writableObjectMode: subprocessStdin.writableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: duplex2,
    subprocess,
    subprocessStdin
  });
  onStdinFinished(subprocessStdin, duplex2, subprocessStdout);
  return duplex2;
}, onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error) => {
  await Promise.all([
    onReadableDestroy({ subprocessStdout, subprocess, waitReadableDestroy }, error),
    onWritableDestroy({
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    }, error)
  ]);
};
var init_duplex = __esm(() => {
  init_encoding_option();
  init_readable();
  init_writable();
});

// node_modules/execa/lib/convert/iterable.js
var createIterable = (subprocess, encoding, {
  from,
  binary: binaryOption = false,
  preserveNewlines = false
} = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const subprocessStdout = getFromStream(subprocess, from);
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: true,
    encoding,
    preserveNewlines
  });
  return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
}, iterateOnStdoutData = async function* (onStdoutData, subprocessStdout, subprocess) {
  try {
    yield* onStdoutData;
  } finally {
    if (subprocessStdout.readable) {
      subprocessStdout.destroy();
    }
    await subprocess;
  }
};
var init_iterable = __esm(() => {
  init_encoding_option();
  init_fd_options();
  init_iterate();
});

// node_modules/execa/lib/convert/add.js
var addConvertedStreams = (subprocess, { encoding }) => {
  const concurrentStreams = initializeConcurrentStreams();
  subprocess.readable = createReadable.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.writable = createWritable.bind(undefined, { subprocess, concurrentStreams });
  subprocess.duplex = createDuplex.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.iterable = createIterable.bind(undefined, subprocess, encoding);
  subprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});
};
var init_add = __esm(() => {
  init_concurrent();
  init_readable();
  init_writable();
  init_duplex();
  init_iterable();
});

// node_modules/execa/lib/methods/promise.js
var mergePromise = (subprocess, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = descriptor.value.bind(promise);
    Reflect.defineProperty(subprocess, property, { ...descriptor, value });
  }
}, nativePromisePrototype, descriptors;
var init_promise = __esm(() => {
  nativePromisePrototype = (async () => {
  })().constructor.prototype;
  descriptors = ["then", "catch", "finally"].map((property) => [
    property,
    Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
  ]);
});

// node_modules/execa/lib/methods/main-async.js
import { setMaxListeners } from "node:events";
import { spawn } from "node:child_process";
var execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {
  const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
  const { subprocess, promise } = spawnSubprocessAsync({
    file,
    commandArguments,
    options,
    startTime,
    verboseInfo,
    command,
    escapedCommand,
    fileDescriptors
  });
  subprocess.pipe = pipeToSubprocess.bind(undefined, {
    source: subprocess,
    sourcePromise: promise,
    boundOptions: {},
    createNested
  });
  mergePromise(subprocess, promise);
  SUBPROCESS_OPTIONS.set(subprocess, { options, fileDescriptors });
  return subprocess;
}, handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const { file, commandArguments, options: normalizedOptions } = normalizeOptions(rawFile, rawArguments, rawOptions);
  const options = handleAsyncOptions(normalizedOptions);
  const fileDescriptors = handleStdioAsync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
}, handleAsyncOptions = ({ timeout, signal, ...options }) => {
  if (signal !== undefined) {
    throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
  }
  return { ...options, timeoutDuration: timeout };
}, spawnSubprocessAsync = ({ file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors }) => {
  let subprocess;
  try {
    subprocess = spawn(...concatenateShell(file, commandArguments, options));
  } catch (error) {
    return handleEarlyError({
      error,
      command,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      verboseInfo
    });
  }
  const controller = new AbortController;
  setMaxListeners(Number.POSITIVE_INFINITY, controller.signal);
  const originalStreams = [...subprocess.stdio];
  pipeOutputAsync(subprocess, fileDescriptors, controller);
  cleanupOnExit(subprocess, options, controller);
  const context3 = {};
  const onInternalError = createDeferred();
  subprocess.kill = subprocessKill.bind(undefined, {
    kill: subprocess.kill.bind(subprocess),
    options,
    onInternalError,
    context: context3,
    controller
  });
  subprocess.all = makeAllStream(subprocess, options);
  addConvertedStreams(subprocess, options);
  addIpcMethods(subprocess, options);
  const promise = handlePromise({
    subprocess,
    options,
    startTime,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    command,
    escapedCommand,
    context: context3,
    onInternalError,
    controller
  });
  return { subprocess, promise };
}, handlePromise = async ({ subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context: context3, onInternalError, controller }) => {
  const [
    errorInfo,
    [exitCode, signal],
    stdioResults,
    allResult,
    ipcOutput
  ] = await waitForSubprocessResult({
    subprocess,
    options,
    context: context3,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    onInternalError,
    controller
  });
  controller.abort();
  onInternalError.resolve();
  const stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));
  const all = stripNewline(allResult, options, "all");
  const result = getAsyncResult({
    errorInfo,
    exitCode,
    signal,
    stdio,
    all,
    ipcOutput,
    context: context3,
    options,
    command,
    escapedCommand,
    startTime
  });
  return handleResult(result, verboseInfo, options);
}, getAsyncResult = ({ errorInfo, exitCode, signal, stdio, all, ipcOutput, context: context3, options, command, escapedCommand, startTime }) => ("error" in errorInfo) ? makeError({
  error: errorInfo.error,
  command,
  escapedCommand,
  timedOut: context3.terminationReason === "timeout",
  isCanceled: context3.terminationReason === "cancel" || context3.terminationReason === "gracefulCancel",
  isGracefullyCanceled: context3.terminationReason === "gracefulCancel",
  isMaxBuffer: errorInfo.error instanceof MaxBufferError,
  isForcefullyTerminated: context3.isForcefullyTerminated,
  exitCode,
  signal,
  stdio,
  all,
  ipcOutput,
  options,
  startTime,
  isSync: false
}) : makeSuccessResult({
  command,
  escapedCommand,
  stdio,
  all,
  ipcOutput,
  options,
  startTime
});
var init_main_async = __esm(() => {
  init_source();
  init_command();
  init_options();
  init_fd_options();
  init_methods();
  init_result();
  init_reject();
  init_early_error();
  init_handle_async();
  init_strip_newline();
  init_output_async();
  init_kill();
  init_cleanup();
  init_setup();
  init_all_async();
  init_wait_subprocess();
  init_add();
  init_promise();
});

// node_modules/execa/lib/methods/bind.js
var mergeOptions = (boundOptions, options) => {
  const newOptions = Object.fromEntries(Object.entries(options).map(([optionName, optionValue]) => [
    optionName,
    mergeOption(optionName, boundOptions[optionName], optionValue)
  ]));
  return { ...boundOptions, ...newOptions };
}, mergeOption = (optionName, boundOptionValue, optionValue) => {
  if (DEEP_OPTIONS.has(optionName) && isPlainObject2(boundOptionValue) && isPlainObject2(optionValue)) {
    return { ...boundOptionValue, ...optionValue };
  }
  return optionValue;
}, DEEP_OPTIONS;
var init_bind = __esm(() => {
  init_specific();
  DEEP_OPTIONS = new Set(["env", ...FD_SPECIFIC_OPTIONS]);
});

// node_modules/execa/lib/methods/create.js
var createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {
  const createNested = (mapArguments2, boundOptions2, setBoundExeca2) => createExeca(mapArguments2, boundOptions2, deepOptions, setBoundExeca2);
  const boundExeca = (...execaArguments) => callBoundExeca({
    mapArguments,
    deepOptions,
    boundOptions,
    setBoundExeca,
    createNested
  }, ...execaArguments);
  if (setBoundExeca !== undefined) {
    setBoundExeca(boundExeca, createNested, boundOptions);
  }
  return boundExeca;
}, callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments) => {
  if (isPlainObject2(firstArgument)) {
    return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
  }
  const { file, commandArguments, options, isSync } = parseArguments({
    mapArguments,
    firstArgument,
    nextArguments,
    deepOptions,
    boundOptions
  });
  return isSync ? execaCoreSync(file, commandArguments, options) : execaCoreAsync(file, commandArguments, options, createNested);
}, parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions }) => {
  const callArguments = isTemplateString(firstArgument) ? parseTemplates(firstArgument, nextArguments) : [firstArgument, ...nextArguments];
  const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
  const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
  const {
    file = initialFile,
    commandArguments = initialArguments,
    options = mergedOptions,
    isSync = false
  } = mapArguments({ file: initialFile, commandArguments: initialArguments, options: mergedOptions });
  return {
    file,
    commandArguments,
    options,
    isSync
  };
};
var init_create = __esm(() => {
  init_parameters();
  init_template();
  init_main_sync();
  init_main_async();
  init_bind();
});

// node_modules/execa/lib/methods/command.js
var mapCommandAsync = ({ file, commandArguments }) => parseCommand(file, commandArguments), mapCommandSync = ({ file, commandArguments }) => ({ ...parseCommand(file, commandArguments), isSync: true }), parseCommand = (command, unusedArguments) => {
  if (unusedArguments.length > 0) {
    throw new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);
  }
  const [file, ...commandArguments] = parseCommandString(command);
  return { file, commandArguments };
}, parseCommandString = (command) => {
  if (typeof command !== "string") {
    throw new TypeError(`The command must be a string: ${String(command)}.`);
  }
  const trimmedCommand = command.trim();
  if (trimmedCommand === "") {
    return [];
  }
  const tokens = [];
  for (const token of trimmedCommand.split(SPACES_REGEXP)) {
    const previousToken = tokens.at(-1);
    if (previousToken && previousToken.endsWith("\\")) {
      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
    } else {
      tokens.push(token);
    }
  }
  return tokens;
}, SPACES_REGEXP;
var init_command2 = __esm(() => {
  SPACES_REGEXP = / +/g;
});

// node_modules/execa/lib/methods/script.js
var setScriptSync = (boundExeca, createNested, boundOptions) => {
  boundExeca.sync = createNested(mapScriptSync, boundOptions);
  boundExeca.s = boundExeca.sync;
}, mapScriptAsync = ({ options }) => getScriptOptions(options), mapScriptSync = ({ options }) => ({ ...getScriptOptions(options), isSync: true }), getScriptOptions = (options) => ({ options: { ...getScriptStdinOption(options), ...options } }), getScriptStdinOption = ({ input, inputFile, stdio }) => input === undefined && inputFile === undefined && stdio === undefined ? { stdin: "inherit" } : {}, deepScriptOptions;
var init_script = __esm(() => {
  deepScriptOptions = { preferLocal: true };
});

// node_modules/execa/index.js
var execa, execaSync, execaCommand, execaCommandSync, execaNode, $, sendMessage2, getOneMessage2, getEachMessage2, getCancelSignal2;
var init_execa = __esm(() => {
  init_create();
  init_command2();
  init_node2();
  init_script();
  init_methods();
  execa = createExeca(() => ({}));
  execaSync = createExeca(() => ({ isSync: true }));
  execaCommand = createExeca(mapCommandAsync);
  execaCommandSync = createExeca(mapCommandSync);
  execaNode = createExeca(mapNode);
  $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);
  ({
    sendMessage: sendMessage2,
    getOneMessage: getOneMessage2,
    getEachMessage: getEachMessage2,
    getCancelSignal: getCancelSignal2
  } = getIpcExport());
});

// node_modules/@isaacs/fs-minipass/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter2 } from "node:events";
import Stream3 from "node:stream";
import { StringDecoder as StringDecoder3 } from "node:string_decoder";

class Pipe {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {
  }
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}
var proc, isStream2 = (s2) => !!s2 && typeof s2 === "object" && (s2 instanceof Minipass || s2 instanceof Stream3 || isReadable(s2) || isWritable(s2)), isReadable = (s2) => !!s2 && typeof s2 === "object" && s2 instanceof EventEmitter2 && typeof s2.pipe === "function" && s2.pipe !== Stream3.Writable.prototype.pipe, isWritable = (s2) => !!s2 && typeof s2 === "object" && s2 instanceof EventEmitter2 && typeof s2.write === "function" && typeof s2.end === "function", EOF, MAYBE_EMIT_END, EMITTED_END, EMITTING_END, EMITTED_ERROR, CLOSED, READ, FLUSH, FLUSHCHUNK, ENCODING, DECODER, FLOWING, PAUSED, RESUME, BUFFER, PIPES, BUFFERLENGTH, BUFFERPUSH, BUFFERSHIFT, OBJECTMODE, DESTROYED, ERROR, EMITDATA, EMITEND, EMITEND2, ASYNC, ABORT, ABORTED, SIGNAL, DATALISTENERS, DISCARDED, defer = (fn) => Promise.resolve().then(fn), nodefer = (fn) => fn(), isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b), PipeProxyErrors, isObjectModeOptions = (o2) => !!o2.objectMode, isEncodingOptions = (o2) => !o2.objectMode && !!o2.encoding && o2.encoding !== "buffer", Minipass;
var init_esm = __esm(() => {
  proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  EOF = Symbol("EOF");
  MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  EMITTED_END = Symbol("emittedEnd");
  EMITTING_END = Symbol("emittingEnd");
  EMITTED_ERROR = Symbol("emittedError");
  CLOSED = Symbol("closed");
  READ = Symbol("read");
  FLUSH = Symbol("flush");
  FLUSHCHUNK = Symbol("flushChunk");
  ENCODING = Symbol("encoding");
  DECODER = Symbol("decoder");
  FLOWING = Symbol("flowing");
  PAUSED = Symbol("paused");
  RESUME = Symbol("resume");
  BUFFER = Symbol("buffer");
  PIPES = Symbol("pipes");
  BUFFERLENGTH = Symbol("bufferLength");
  BUFFERPUSH = Symbol("bufferPush");
  BUFFERSHIFT = Symbol("bufferShift");
  OBJECTMODE = Symbol("objectMode");
  DESTROYED = Symbol("destroyed");
  ERROR = Symbol("error");
  EMITDATA = Symbol("emitData");
  EMITEND = Symbol("emitEnd");
  EMITEND2 = Symbol("emitEnd2");
  ASYNC = Symbol("async");
  ABORT = Symbol("abort");
  ABORTED = Symbol("aborted");
  SIGNAL = Symbol("signal");
  DATALISTENERS = Symbol("dataListeners");
  DISCARDED = Symbol("discarded");
  PipeProxyErrors = class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  };
  Minipass = class Minipass extends EventEmitter2 {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    writable = true;
    readable = true;
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions(options)) {
        this[OBJECTMODE] = true;
        this[ENCODING] = null;
      } else if (isEncodingOptions(options)) {
        this[ENCODING] = options.encoding;
        this[OBJECTMODE] = false;
      } else {
        this[OBJECTMODE] = false;
        this[ENCODING] = null;
      }
      this[ASYNC] = !!options.async;
      this[DECODER] = this[ENCODING] ? new StringDecoder3(this[ENCODING]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL] = signal;
        if (signal.aborted) {
          this[ABORT]();
        } else {
          signal.addEventListener("abort", () => this[ABORT]());
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a2) {
      this[ASYNC] = this[ASYNC] || !!a2;
    }
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL]?.reason);
      this.destroy(this[SIGNAL]?.reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : nodefer;
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE]) {
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING]) {
        chunk = this[DECODER].write(chunk);
      }
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    read(n2) {
      if (this[DESTROYED])
        return null;
      this[DISCARDED] = false;
      if (this[BUFFERLENGTH] === 0 || n2 === 0 || n2 && n2 > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n2 = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ];
      }
      const ret = this[READ](n2 || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n2, chunk) {
      if (this[OBJECTMODE])
        this[BUFFERSHIFT]();
      else {
        const c3 = chunk;
        if (n2 === c3.length || n2 === null)
          this[BUFFERSHIFT]();
        else if (typeof c3 === "string") {
          this[BUFFER][0] = c3.slice(n2);
          chunk = c3.slice(0, n2);
          this[BUFFERLENGTH] -= n2;
        } else {
          this[BUFFER][0] = c3.subarray(n2);
          chunk = c3.subarray(0, n2);
          this[BUFFERLENGTH] -= n2;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== undefined)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this[FLOWING] || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      if (!this[DATALISTENERS] && !this[PIPES].length) {
        this[DISCARDED] = true;
      }
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
      this[DISCARDED] = false;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this[FLOWING];
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return dest;
      this[DISCARDED] = false;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES].length === 1) {
          if (this[FLOWING] && this[DATALISTENERS] === 0) {
            this[FLOWING] = false;
          }
          this[PIPES] = [];
        } else
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    on(ev, handler) {
      const ret = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED] = false;
        this[DATALISTENERS]++;
        if (!this[PIPES].length && !this[FLOWING]) {
          this[RESUME]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
        super.emit("readable");
      } else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        const h3 = handler;
        if (this[ASYNC])
          defer(() => h3.call(this, this[EMITTED_ERROR]));
        else
          h3.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    off(ev, handler) {
      const ret = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS] = this.listeners("data").length;
        if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    removeAllListeners(ev) {
      const ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === undefined) {
        this[DATALISTENERS] = 0;
        if (!this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return false;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, ...args);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = this[DISCARDED] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return false;
      this[EMITTED_END] = true;
      this.readable = false;
      return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c3) => {
        buf.push(c3);
        if (!this[OBJECTMODE])
          buf.dataLength += c3.length;
      });
      await p;
      return buf;
    }
    async concat() {
      if (this[OBJECTMODE]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    async promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [Symbol.asyncIterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: undefined, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED, ondestroy);
          stop();
          resolve({ done: true, value: undefined });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    [Symbol.iterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR, stop);
        this.off(DESTROYED, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: undefined };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[DISCARDED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static get isStream() {
      return isStream2;
    }
  };
});

// node_modules/@isaacs/fs-minipass/dist/esm/index.js
import EE from "events";
import fs2 from "fs";
var writev, _autoClose, _close, _ended, _fd, _finished, _flags, _flush, _handleChunk, _makeBuf, _mode, _needDrain, _onerror, _onopen, _onread, _onwrite, _open, _path, _pos, _queue, _read, _readSize, _reading, _remain, _size, _write, _writing, _defaultFlag, _errored, ReadStream, ReadStreamSync, WriteStream, WriteStreamSync;
var init_esm2 = __esm(() => {
  init_esm();
  writev = fs2.writev;
  _autoClose = Symbol("_autoClose");
  _close = Symbol("_close");
  _ended = Symbol("_ended");
  _fd = Symbol("_fd");
  _finished = Symbol("_finished");
  _flags = Symbol("_flags");
  _flush = Symbol("_flush");
  _handleChunk = Symbol("_handleChunk");
  _makeBuf = Symbol("_makeBuf");
  _mode = Symbol("_mode");
  _needDrain = Symbol("_needDrain");
  _onerror = Symbol("_onerror");
  _onopen = Symbol("_onopen");
  _onread = Symbol("_onread");
  _onwrite = Symbol("_onwrite");
  _open = Symbol("_open");
  _path = Symbol("_path");
  _pos = Symbol("_pos");
  _queue = Symbol("_queue");
  _read = Symbol("_read");
  _readSize = Symbol("_readSize");
  _reading = Symbol("_reading");
  _remain = Symbol("_remain");
  _size = Symbol("_size");
  _write = Symbol("_write");
  _writing = Symbol("_writing");
  _defaultFlag = Symbol("_defaultFlag");
  _errored = Symbol("_errored");
  ReadStream = class ReadStream extends Minipass {
    [_errored] = false;
    [_fd];
    [_path];
    [_readSize];
    [_reading] = false;
    [_size];
    [_remain];
    [_autoClose];
    constructor(path7, opt) {
      opt = opt || {};
      super(opt);
      this.readable = true;
      this.writable = false;
      if (typeof path7 !== "string") {
        throw new TypeError("path must be a string");
      }
      this[_errored] = false;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : undefined;
      this[_path] = path7;
      this[_readSize] = opt.readSize || 16 * 1024 * 1024;
      this[_reading] = false;
      this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
      this[_remain] = this[_size];
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      if (typeof this[_fd] === "number") {
        this[_read]();
      } else {
        this[_open]();
      }
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (er) {
        this[_onerror](er);
      } else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_read]();
      }
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = true;
        const buf = this[_makeBuf]();
        if (buf.length === 0) {
          return process.nextTick(() => this[_onread](null, 0, buf));
        }
        fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = false;
      if (er) {
        this[_onerror](er);
      } else if (this[_handleChunk](br, buf)) {
        this[_read]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = undefined;
        fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = true;
      this[_close]();
      this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret = false;
      this[_remain] -= br;
      if (br > 0) {
        ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);
      }
      if (br === 0 || this[_remain] <= 0) {
        ret = false;
        this[_close]();
        super.end();
      }
      return ret;
    }
    emit(ev, ...args) {
      switch (ev) {
        case "prefinish":
        case "finish":
          return false;
        case "drain":
          if (typeof this[_fd] === "number") {
            this[_read]();
          }
          return false;
        case "error":
          if (this[_errored]) {
            return false;
          }
          this[_errored] = true;
          return super.emit(ev, ...args);
        default:
          return super.emit(ev, ...args);
      }
    }
  };
  ReadStreamSync = class ReadStreamSync extends ReadStream {
    [_open]() {
      let threw = true;
      try {
        this[_onopen](null, fs2.openSync(this[_path], "r"));
        threw = false;
      } finally {
        if (threw) {
          this[_close]();
        }
      }
    }
    [_read]() {
      let threw = true;
      try {
        if (!this[_reading]) {
          this[_reading] = true;
          do {
            const buf = this[_makeBuf]();
            const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf)) {
              break;
            }
          } while (true);
          this[_reading] = false;
        }
        threw = false;
      } finally {
        if (threw) {
          this[_close]();
        }
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = undefined;
        fs2.closeSync(fd);
        this.emit("close");
      }
    }
  };
  WriteStream = class WriteStream extends EE {
    readable = false;
    writable = true;
    [_errored] = false;
    [_writing] = false;
    [_ended] = false;
    [_queue] = [];
    [_needDrain] = false;
    [_path];
    [_mode];
    [_autoClose];
    [_fd];
    [_defaultFlag];
    [_flags];
    [_finished] = false;
    [_pos];
    constructor(path7, opt) {
      opt = opt || {};
      super(opt);
      this[_path] = path7;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : undefined;
      this[_mode] = opt.mode === undefined ? 438 : opt.mode;
      this[_pos] = typeof opt.start === "number" ? opt.start : undefined;
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      const defaultFlag = this[_pos] !== undefined ? "r+" : "w";
      this[_defaultFlag] = opt.flags === undefined;
      this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;
      if (this[_fd] === undefined) {
        this[_open]();
      }
    }
    emit(ev, ...args) {
      if (ev === "error") {
        if (this[_errored]) {
          return false;
        }
        this[_errored] = true;
      }
      return super.emit(ev, ...args);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close]();
      this[_writing] = true;
      this.emit("error", er);
    }
    [_open]() {
      fs2.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
        this[_flags] = "w";
        this[_open]();
      } else if (er) {
        this[_onerror](er);
      } else {
        this[_fd] = fd;
        this.emit("open", fd);
        if (!this[_writing]) {
          this[_flush]();
        }
      }
    }
    end(buf, enc) {
      if (buf) {
        this.write(buf, enc);
      }
      this[_ended] = true;
      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number") {
        this[_onwrite](null, 0);
      }
      return this;
    }
    write(buf, enc) {
      if (typeof buf === "string") {
        buf = Buffer.from(buf, enc);
      }
      if (this[_ended]) {
        this.emit("error", new Error("write() after end()"));
        return false;
      }
      if (this[_fd] === undefined || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);
        this[_needDrain] = true;
        return false;
      }
      this[_writing] = true;
      this[_write](buf);
      return true;
    }
    [_write](buf) {
      fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      if (er) {
        this[_onerror](er);
      } else {
        if (this[_pos] !== undefined && typeof bw === "number") {
          this[_pos] += bw;
        }
        if (this[_queue].length) {
          this[_flush]();
        } else {
          this[_writing] = false;
          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;
            this[_close]();
            this.emit("finish");
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit("drain");
          }
        }
      }
    }
    [_flush]() {
      if (this[_queue].length === 0) {
        if (this[_ended]) {
          this[_onwrite](null, 0);
        }
      } else if (this[_queue].length === 1) {
        this[_write](this[_queue].pop());
      } else {
        const iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = undefined;
        fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  };
  WriteStreamSync = class WriteStreamSync extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+") {
        try {
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er?.code === "ENOENT") {
            this[_flags] = "w";
            return this[_open]();
          } else {
            throw er;
          }
        }
      } else {
        fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
      }
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = undefined;
        fs2.closeSync(fd);
        this.emit("close");
      }
    }
    [_write](buf) {
      let threw = true;
      try {
        this[_onwrite](null, fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
        threw = false;
      } finally {
        if (threw) {
          try {
            this[_close]();
          } catch {
          }
        }
      }
    }
  };
});

// node_modules/tar/dist/esm/options.js
var argmap, isSyncFile = (o2) => !!o2.sync && !!o2.file, isAsyncFile = (o2) => !o2.sync && !!o2.file, isSyncNoFile = (o2) => !!o2.sync && !o2.file, isAsyncNoFile = (o2) => !o2.sync && !o2.file, isFile = (o2) => !!o2.file, dealiasKey = (k) => {
  const d = argmap.get(k);
  if (d)
    return d;
  return k;
}, dealias = (opt = {}) => {
  if (!opt)
    return {};
  const result = {};
  for (const [key, v] of Object.entries(opt)) {
    const k = dealiasKey(key);
    result[k] = v;
  }
  if (result.chmod === undefined && result.noChmod === false) {
    result.chmod = true;
  }
  delete result.noChmod;
  return result;
};
var init_options2 = __esm(() => {
  argmap = new Map([
    ["C", "cwd"],
    ["f", "file"],
    ["z", "gzip"],
    ["P", "preservePaths"],
    ["U", "unlink"],
    ["strip-components", "strip"],
    ["stripComponents", "strip"],
    ["keep-newer", "newer"],
    ["keepNewer", "newer"],
    ["keep-newer-files", "newer"],
    ["keepNewerFiles", "newer"],
    ["k", "keep"],
    ["keep-existing", "keep"],
    ["keepExisting", "keep"],
    ["m", "noMtime"],
    ["no-mtime", "noMtime"],
    ["p", "preserveOwner"],
    ["L", "follow"],
    ["h", "follow"],
    ["onentry", "onReadEntry"]
  ]);
});

// node_modules/tar/dist/esm/make-command.js
var makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => {
  return Object.assign((opt_ = [], entries, cb) => {
    if (Array.isArray(opt_)) {
      entries = opt_;
      opt_ = {};
    }
    if (typeof entries === "function") {
      cb = entries;
      entries = undefined;
    }
    if (!entries) {
      entries = [];
    } else {
      entries = Array.from(entries);
    }
    const opt = dealias(opt_);
    validate?.(opt, entries);
    if (isSyncFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      return syncFile(opt, entries);
    } else if (isAsyncFile(opt)) {
      const p = asyncFile(opt, entries);
      const c3 = cb ? cb : undefined;
      return c3 ? p.then(() => c3(), c3) : p;
    } else if (isSyncNoFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      return syncNoFile(opt, entries);
    } else if (isAsyncNoFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return asyncNoFile(opt, entries);
    } else {
      throw new Error("impossible options??");
    }
  }, {
    syncFile,
    asyncFile,
    syncNoFile,
    asyncNoFile,
    validate
  });
};
var init_make_command = __esm(() => {
  init_options2();
});

// node_modules/minizlib/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter3 } from "node:events";
import Stream4 from "node:stream";
import { StringDecoder as StringDecoder4 } from "node:string_decoder";

class Pipe2 {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME2]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {
  }
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}
var proc2, isStream3 = (s2) => !!s2 && typeof s2 === "object" && (s2 instanceof Minipass2 || s2 instanceof Stream4 || isReadable2(s2) || isWritable2(s2)), isReadable2 = (s2) => !!s2 && typeof s2 === "object" && s2 instanceof EventEmitter3 && typeof s2.pipe === "function" && s2.pipe !== Stream4.Writable.prototype.pipe, isWritable2 = (s2) => !!s2 && typeof s2 === "object" && s2 instanceof EventEmitter3 && typeof s2.write === "function" && typeof s2.end === "function", EOF2, MAYBE_EMIT_END2, EMITTED_END2, EMITTING_END2, EMITTED_ERROR2, CLOSED2, READ2, FLUSH2, FLUSHCHUNK2, ENCODING2, DECODER2, FLOWING2, PAUSED2, RESUME2, BUFFER2, PIPES2, BUFFERLENGTH2, BUFFERPUSH2, BUFFERSHIFT2, OBJECTMODE2, DESTROYED2, ERROR2, EMITDATA2, EMITEND3, EMITEND22, ASYNC2, ABORT2, ABORTED2, SIGNAL2, DATALISTENERS2, DISCARDED2, defer2 = (fn) => Promise.resolve().then(fn), nodefer2 = (fn) => fn(), isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike2 = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b), PipeProxyErrors2, isObjectModeOptions2 = (o2) => !!o2.objectMode, isEncodingOptions2 = (o2) => !o2.objectMode && !!o2.encoding && o2.encoding !== "buffer", Minipass2;
var init_esm3 = __esm(() => {
  proc2 = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  EOF2 = Symbol("EOF");
  MAYBE_EMIT_END2 = Symbol("maybeEmitEnd");
  EMITTED_END2 = Symbol("emittedEnd");
  EMITTING_END2 = Symbol("emittingEnd");
  EMITTED_ERROR2 = Symbol("emittedError");
  CLOSED2 = Symbol("closed");
  READ2 = Symbol("read");
  FLUSH2 = Symbol("flush");
  FLUSHCHUNK2 = Symbol("flushChunk");
  ENCODING2 = Symbol("encoding");
  DECODER2 = Symbol("decoder");
  FLOWING2 = Symbol("flowing");
  PAUSED2 = Symbol("paused");
  RESUME2 = Symbol("resume");
  BUFFER2 = Symbol("buffer");
  PIPES2 = Symbol("pipes");
  BUFFERLENGTH2 = Symbol("bufferLength");
  BUFFERPUSH2 = Symbol("bufferPush");
  BUFFERSHIFT2 = Symbol("bufferShift");
  OBJECTMODE2 = Symbol("objectMode");
  DESTROYED2 = Symbol("destroyed");
  ERROR2 = Symbol("error");
  EMITDATA2 = Symbol("emitData");
  EMITEND3 = Symbol("emitEnd");
  EMITEND22 = Symbol("emitEnd2");
  ASYNC2 = Symbol("async");
  ABORT2 = Symbol("abort");
  ABORTED2 = Symbol("aborted");
  SIGNAL2 = Symbol("signal");
  DATALISTENERS2 = Symbol("dataListeners");
  DISCARDED2 = Symbol("discarded");
  PipeProxyErrors2 = class PipeProxyErrors2 extends Pipe2 {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  };
  Minipass2 = class Minipass2 extends EventEmitter3 {
    [FLOWING2] = false;
    [PAUSED2] = false;
    [PIPES2] = [];
    [BUFFER2] = [];
    [OBJECTMODE2];
    [ENCODING2];
    [ASYNC2];
    [DECODER2];
    [EOF2] = false;
    [EMITTED_END2] = false;
    [EMITTING_END2] = false;
    [CLOSED2] = false;
    [EMITTED_ERROR2] = null;
    [BUFFERLENGTH2] = 0;
    [DESTROYED2] = false;
    [SIGNAL2];
    [ABORTED2] = false;
    [DATALISTENERS2] = 0;
    [DISCARDED2] = false;
    writable = true;
    readable = true;
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions2(options)) {
        this[OBJECTMODE2] = true;
        this[ENCODING2] = null;
      } else if (isEncodingOptions2(options)) {
        this[ENCODING2] = options.encoding;
        this[OBJECTMODE2] = false;
      } else {
        this[OBJECTMODE2] = false;
        this[ENCODING2] = null;
      }
      this[ASYNC2] = !!options.async;
      this[DECODER2] = this[ENCODING2] ? new StringDecoder4(this[ENCODING2]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER2] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES2] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL2] = signal;
        if (signal.aborted) {
          this[ABORT2]();
        } else {
          signal.addEventListener("abort", () => this[ABORT2]());
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH2];
    }
    get encoding() {
      return this[ENCODING2];
    }
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    get objectMode() {
      return this[OBJECTMODE2];
    }
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    get ["async"]() {
      return this[ASYNC2];
    }
    set ["async"](a2) {
      this[ASYNC2] = this[ASYNC2] || !!a2;
    }
    [ABORT2]() {
      this[ABORTED2] = true;
      this.emit("abort", this[SIGNAL2]?.reason);
      this.destroy(this[SIGNAL2]?.reason);
    }
    get aborted() {
      return this[ABORTED2];
    }
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED2])
        return false;
      if (this[EOF2])
        throw new Error("write after end");
      if (this[DESTROYED2]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC2] ? defer2 : nodefer2;
      if (!this[OBJECTMODE2] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView2(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike2(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE2]) {
        if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
          this[FLUSH2](true);
        if (this[FLOWING2])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH2](chunk);
        if (this[BUFFERLENGTH2] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING2];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH2] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING2];
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING2] && !this[DECODER2]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING2]) {
        chunk = this[DECODER2].write(chunk);
      }
      if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
        this[FLUSH2](true);
      if (this[FLOWING2])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH2](chunk);
      if (this[BUFFERLENGTH2] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING2];
    }
    read(n2) {
      if (this[DESTROYED2])
        return null;
      this[DISCARDED2] = false;
      if (this[BUFFERLENGTH2] === 0 || n2 === 0 || n2 && n2 > this[BUFFERLENGTH2]) {
        this[MAYBE_EMIT_END2]();
        return null;
      }
      if (this[OBJECTMODE2])
        n2 = null;
      if (this[BUFFER2].length > 1 && !this[OBJECTMODE2]) {
        this[BUFFER2] = [
          this[ENCODING2] ? this[BUFFER2].join("") : Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])
        ];
      }
      const ret = this[READ2](n2 || null, this[BUFFER2][0]);
      this[MAYBE_EMIT_END2]();
      return ret;
    }
    [READ2](n2, chunk) {
      if (this[OBJECTMODE2])
        this[BUFFERSHIFT2]();
      else {
        const c3 = chunk;
        if (n2 === c3.length || n2 === null)
          this[BUFFERSHIFT2]();
        else if (typeof c3 === "string") {
          this[BUFFER2][0] = c3.slice(n2);
          chunk = c3.slice(0, n2);
          this[BUFFERLENGTH2] -= n2;
        } else {
          this[BUFFER2][0] = c3.subarray(n2);
          chunk = c3.subarray(0, n2);
          this[BUFFERLENGTH2] -= n2;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER2].length && !this[EOF2])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== undefined)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF2] = true;
      this.writable = false;
      if (this[FLOWING2] || !this[PAUSED2])
        this[MAYBE_EMIT_END2]();
      return this;
    }
    [RESUME2]() {
      if (this[DESTROYED2])
        return;
      if (!this[DATALISTENERS2] && !this[PIPES2].length) {
        this[DISCARDED2] = true;
      }
      this[PAUSED2] = false;
      this[FLOWING2] = true;
      this.emit("resume");
      if (this[BUFFER2].length)
        this[FLUSH2]();
      else if (this[EOF2])
        this[MAYBE_EMIT_END2]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME2]();
    }
    pause() {
      this[FLOWING2] = false;
      this[PAUSED2] = true;
      this[DISCARDED2] = false;
    }
    get destroyed() {
      return this[DESTROYED2];
    }
    get flowing() {
      return this[FLOWING2];
    }
    get paused() {
      return this[PAUSED2];
    }
    [BUFFERPUSH2](chunk) {
      if (this[OBJECTMODE2])
        this[BUFFERLENGTH2] += 1;
      else
        this[BUFFERLENGTH2] += chunk.length;
      this[BUFFER2].push(chunk);
    }
    [BUFFERSHIFT2]() {
      if (this[OBJECTMODE2])
        this[BUFFERLENGTH2] -= 1;
      else
        this[BUFFERLENGTH2] -= this[BUFFER2][0].length;
      return this[BUFFER2].shift();
    }
    [FLUSH2](noDrain = false) {
      do {
      } while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
      if (!noDrain && !this[BUFFER2].length && !this[EOF2])
        this.emit("drain");
    }
    [FLUSHCHUNK2](chunk) {
      this.emit("data", chunk);
      return this[FLOWING2];
    }
    pipe(dest, opts) {
      if (this[DESTROYED2])
        return dest;
      this[DISCARDED2] = false;
      const ended = this[EMITTED_END2];
      opts = opts || {};
      if (dest === proc2.stdout || dest === proc2.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES2].push(!opts.proxyErrors ? new Pipe2(this, dest, opts) : new PipeProxyErrors2(this, dest, opts));
        if (this[ASYNC2])
          defer2(() => this[RESUME2]());
        else
          this[RESUME2]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES2].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES2].length === 1) {
          if (this[FLOWING2] && this[DATALISTENERS2] === 0) {
            this[FLOWING2] = false;
          }
          this[PIPES2] = [];
        } else
          this[PIPES2].splice(this[PIPES2].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    on(ev, handler) {
      const ret = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED2] = false;
        this[DATALISTENERS2]++;
        if (!this[PIPES2].length && !this[FLOWING2]) {
          this[RESUME2]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH2] !== 0) {
        super.emit("readable");
      } else if (isEndish2(ev) && this[EMITTED_END2]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR2]) {
        const h3 = handler;
        if (this[ASYNC2])
          defer2(() => h3.call(this, this[EMITTED_ERROR2]));
        else
          h3.call(this, this[EMITTED_ERROR2]);
      }
      return ret;
    }
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    off(ev, handler) {
      const ret = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS2] = this.listeners("data").length;
        if (this[DATALISTENERS2] === 0 && !this[DISCARDED2] && !this[PIPES2].length) {
          this[FLOWING2] = false;
        }
      }
      return ret;
    }
    removeAllListeners(ev) {
      const ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === undefined) {
        this[DATALISTENERS2] = 0;
        if (!this[DISCARDED2] && !this[PIPES2].length) {
          this[FLOWING2] = false;
        }
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END2];
    }
    [MAYBE_EMIT_END2]() {
      if (!this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2]) {
        this[EMITTING_END2] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED2])
          this.emit("close");
        this[EMITTING_END2] = false;
      }
    }
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE2] && !data ? false : this[ASYNC2] ? (defer2(() => this[EMITDATA2](data)), true) : this[EMITDATA2](data);
      } else if (ev === "end") {
        return this[EMITEND3]();
      } else if (ev === "close") {
        this[CLOSED2] = true;
        if (!this[EMITTED_END2] && !this[DESTROYED2])
          return false;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR2] = data;
        super.emit(ERROR2, data);
        const ret2 = !this[SIGNAL2] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END2]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END2]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, ...args);
      this[MAYBE_EMIT_END2]();
      return ret;
    }
    [EMITDATA2](data) {
      for (const p of this[PIPES2]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = this[DISCARDED2] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END2]();
      return ret;
    }
    [EMITEND3]() {
      if (this[EMITTED_END2])
        return false;
      this[EMITTED_END2] = true;
      this.readable = false;
      return this[ASYNC2] ? (defer2(() => this[EMITEND22]()), true) : this[EMITEND22]();
    }
    [EMITEND22]() {
      if (this[DECODER2]) {
        const data = this[DECODER2].end();
        if (data) {
          for (const p of this[PIPES2]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED2])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES2]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE2])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c3) => {
        buf.push(c3);
        if (!this[OBJECTMODE2])
          buf.dataLength += c3.length;
      });
      await p;
      return buf;
    }
    async concat() {
      if (this[OBJECTMODE2]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    async promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED2, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [Symbol.asyncIterator]() {
      this[DISCARDED2] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: undefined, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF2])
          return stop();
        let resolve;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED2, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED2, ondestroy);
          this.pause();
          resolve({ value, done: !!this[EOF2] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED2, ondestroy);
          stop();
          resolve({ done: true, value: undefined });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED2, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    [Symbol.iterator]() {
      this[DISCARDED2] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR2, stop);
        this.off(DESTROYED2, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: undefined };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR2, stop);
      this.once(DESTROYED2, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED2]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED2);
        return this;
      }
      this[DESTROYED2] = true;
      this[DISCARDED2] = true;
      this[BUFFER2].length = 0;
      this[BUFFERLENGTH2] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED2])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED2);
      return this;
    }
    static get isStream() {
      return isStream3;
    }
  };
});

// node_modules/minizlib/dist/esm/constants.js
import realZlib from "zlib";
var realZlibConstants, constants4;
var init_constants = __esm(() => {
  realZlibConstants = realZlib.constants || { ZLIB_VERNUM: 4736 };
  constants4 = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants));
});

// node_modules/minizlib/dist/esm/index.js
import assert from "assert";
import { Buffer as Buffer7 } from "buffer";
import * as realZlib2 from "zlib";
var OriginalBufferConcat, desc, noop4 = (args) => args, passthroughBufferConcat, _superWrite, ZlibError, _flushFlag, ZlibBase, Zlib, Gzip, Unzip, Brotli, BrotliCompress, BrotliDecompress;
var init_esm4 = __esm(() => {
  init_esm3();
  init_constants();
  init_constants();
  OriginalBufferConcat = Buffer7.concat;
  desc = Object.getOwnPropertyDescriptor(Buffer7, "concat");
  passthroughBufferConcat = desc?.writable === true || desc?.set !== undefined ? (makeNoOp) => {
    Buffer7.concat = makeNoOp ? noop4 : OriginalBufferConcat;
  } : (_) => {
  };
  _superWrite = Symbol("_superWrite");
  ZlibError = class ZlibError extends Error {
    code;
    errno;
    constructor(err) {
      super("zlib: " + err.message);
      this.code = err.code;
      this.errno = err.errno;
      if (!this.code)
        this.code = "ZLIB_ERROR";
      this.message = "zlib: " + err.message;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  };
  _flushFlag = Symbol("flushFlag");
  ZlibBase = class ZlibBase extends Minipass2 {
    #sawError = false;
    #ended = false;
    #flushFlag;
    #finishFlushFlag;
    #fullFlushFlag;
    #handle;
    #onError;
    get sawError() {
      return this.#sawError;
    }
    get handle() {
      return this.#handle;
    }
    get flushFlag() {
      return this.#flushFlag;
    }
    constructor(opts, mode) {
      if (!opts || typeof opts !== "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts);
      this.#flushFlag = opts.flush ?? 0;
      this.#finishFlushFlag = opts.finishFlush ?? 0;
      this.#fullFlushFlag = opts.fullFlushFlag ?? 0;
      try {
        this.#handle = new realZlib2[mode](opts);
      } catch (er) {
        throw new ZlibError(er);
      }
      this.#onError = (err) => {
        if (this.#sawError)
          return;
        this.#sawError = true;
        this.close();
        this.emit("error", err);
      };
      this.#handle?.on("error", (er) => this.#onError(new ZlibError(er)));
      this.once("end", () => this.close);
    }
    close() {
      if (this.#handle) {
        this.#handle.close();
        this.#handle = undefined;
        this.emit("close");
      }
    }
    reset() {
      if (!this.#sawError) {
        assert(this.#handle, "zlib binding closed");
        return this.#handle.reset?.();
      }
    }
    flush(flushFlag) {
      if (this.ended)
        return;
      if (typeof flushFlag !== "number")
        flushFlag = this.#fullFlushFlag;
      this.write(Object.assign(Buffer7.alloc(0), { [_flushFlag]: flushFlag }));
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        encoding = undefined;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (chunk) {
        if (encoding)
          this.write(chunk, encoding);
        else
          this.write(chunk);
      }
      this.flush(this.#finishFlushFlag);
      this.#ended = true;
      return super.end(cb);
    }
    get ended() {
      return this.#ended;
    }
    [_superWrite](data) {
      return super.write(data);
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (typeof chunk === "string")
        chunk = Buffer7.from(chunk, encoding);
      if (this.#sawError)
        return;
      assert(this.#handle, "zlib binding closed");
      const nativeHandle = this.#handle._handle;
      const originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {
      };
      const originalClose = this.#handle.close;
      this.#handle.close = () => {
      };
      passthroughBufferConcat(true);
      let result = undefined;
      try {
        const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this.#flushFlag;
        result = this.#handle._processChunk(chunk, flushFlag);
        passthroughBufferConcat(false);
      } catch (err) {
        passthroughBufferConcat(false);
        this.#onError(new ZlibError(err));
      } finally {
        if (this.#handle) {
          this.#handle._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this.#handle.close = originalClose;
          this.#handle.removeAllListeners("error");
        }
      }
      if (this.#handle)
        this.#handle.on("error", (er) => this.#onError(new ZlibError(er)));
      let writeReturn;
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          const r2 = result[0];
          writeReturn = this[_superWrite](Buffer7.from(r2));
          for (let i3 = 1;i3 < result.length; i3++) {
            writeReturn = this[_superWrite](result[i3]);
          }
        } else {
          writeReturn = this[_superWrite](Buffer7.from(result));
        }
      }
      if (cb)
        cb();
      return writeReturn;
    }
  };
  Zlib = class Zlib extends ZlibBase {
    #level;
    #strategy;
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants4.Z_NO_FLUSH;
      opts.finishFlush = opts.finishFlush || constants4.Z_FINISH;
      opts.fullFlushFlag = constants4.Z_FULL_FLUSH;
      super(opts, mode);
      this.#level = opts.level;
      this.#strategy = opts.strategy;
    }
    params(level, strategy) {
      if (this.sawError)
        return;
      if (!this.handle)
        throw new Error("cannot switch params when binding is closed");
      if (!this.handle.params)
        throw new Error("not supported in this implementation");
      if (this.#level !== level || this.#strategy !== strategy) {
        this.flush(constants4.Z_SYNC_FLUSH);
        assert(this.handle, "zlib binding closed");
        const origFlush = this.handle.flush;
        this.handle.flush = (flushFlag, cb) => {
          if (typeof flushFlag === "function") {
            cb = flushFlag;
            flushFlag = this.flushFlag;
          }
          this.flush(flushFlag);
          cb?.();
        };
        try {
          this.handle.params(level, strategy);
        } finally {
          this.handle.flush = origFlush;
        }
        if (this.handle) {
          this.#level = level;
          this.#strategy = strategy;
        }
      }
    }
  };
  Gzip = class Gzip extends Zlib {
    #portable;
    constructor(opts) {
      super(opts, "Gzip");
      this.#portable = opts && !!opts.portable;
    }
    [_superWrite](data) {
      if (!this.#portable)
        return super[_superWrite](data);
      this.#portable = false;
      data[9] = 255;
      return super[_superWrite](data);
    }
  };
  Unzip = class Unzip extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  };
  Brotli = class Brotli extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants4.BROTLI_OPERATION_PROCESS;
      opts.finishFlush = opts.finishFlush || constants4.BROTLI_OPERATION_FINISH;
      opts.fullFlushFlag = constants4.BROTLI_OPERATION_FLUSH;
      super(opts, mode);
    }
  };
  BrotliCompress = class BrotliCompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  };
  BrotliDecompress = class BrotliDecompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  };
});

// node_modules/yallist/dist/esm/index.js
function insertAfter(self2, node2, value) {
  const prev = node2;
  const next = node2 ? node2.next : self2.head;
  const inserted = new Node(value, prev, next, self2);
  if (inserted.next === undefined) {
    self2.tail = inserted;
  }
  if (inserted.prev === undefined) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, undefined, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, undefined, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}

class Node {
  list;
  next;
  prev;
  value;
  constructor(value, prev, next, list) {
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = undefined;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = undefined;
    }
  }
}
var Yallist;
var init_esm5 = __esm(() => {
  Yallist = class Yallist {
    tail;
    head;
    length = 0;
    static create(list = []) {
      return new Yallist(list);
    }
    constructor(list = []) {
      for (const item of list) {
        this.push(item);
      }
    }
    *[Symbol.iterator]() {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    }
    removeNode(node2) {
      if (node2.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      const next = node2.next;
      const prev = node2.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node2 === this.head) {
        this.head = next;
      }
      if (node2 === this.tail) {
        this.tail = prev;
      }
      this.length--;
      node2.next = undefined;
      node2.prev = undefined;
      node2.list = undefined;
      return next;
    }
    unshiftNode(node2) {
      if (node2 === this.head) {
        return;
      }
      if (node2.list) {
        node2.list.removeNode(node2);
      }
      const head = this.head;
      node2.list = this;
      node2.next = head;
      if (head) {
        head.prev = node2;
      }
      this.head = node2;
      if (!this.tail) {
        this.tail = node2;
      }
      this.length++;
    }
    pushNode(node2) {
      if (node2 === this.tail) {
        return;
      }
      if (node2.list) {
        node2.list.removeNode(node2);
      }
      const tail = this.tail;
      node2.list = this;
      node2.prev = tail;
      if (tail) {
        tail.next = node2;
      }
      this.tail = node2;
      if (!this.head) {
        this.head = node2;
      }
      this.length++;
    }
    push(...args) {
      for (let i3 = 0, l = args.length;i3 < l; i3++) {
        push(this, args[i3]);
      }
      return this.length;
    }
    unshift(...args) {
      for (var i3 = 0, l = args.length;i3 < l; i3++) {
        unshift(this, args[i3]);
      }
      return this.length;
    }
    pop() {
      if (!this.tail) {
        return;
      }
      const res = this.tail.value;
      const t2 = this.tail;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = undefined;
      } else {
        this.head = undefined;
      }
      t2.list = undefined;
      this.length--;
      return res;
    }
    shift() {
      if (!this.head) {
        return;
      }
      const res = this.head.value;
      const h3 = this.head;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = undefined;
      } else {
        this.tail = undefined;
      }
      h3.list = undefined;
      this.length--;
      return res;
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this.head, i3 = 0;walker; i3++) {
        fn.call(thisp, walker.value, i3, this);
        walker = walker.next;
      }
    }
    forEachReverse(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this.tail, i3 = this.length - 1;walker; i3--) {
        fn.call(thisp, walker.value, i3, this);
        walker = walker.prev;
      }
    }
    get(n2) {
      let i3 = 0;
      let walker = this.head;
      for (;!!walker && i3 < n2; i3++) {
        walker = walker.next;
      }
      if (i3 === n2 && !!walker) {
        return walker.value;
      }
    }
    getReverse(n2) {
      let i3 = 0;
      let walker = this.tail;
      for (;!!walker && i3 < n2; i3++) {
        walker = walker.prev;
      }
      if (i3 === n2 && !!walker) {
        return walker.value;
      }
    }
    map(fn, thisp) {
      thisp = thisp || this;
      const res = new Yallist;
      for (let walker = this.head;walker; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    }
    mapReverse(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist;
      for (let walker = this.tail;walker; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    }
    reduce(fn, initial) {
      let acc;
      let walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i3 = 0;walker; i3++) {
        acc = fn(acc, walker.value, i3);
        walker = walker.next;
      }
      return acc;
    }
    reduceReverse(fn, initial) {
      let acc;
      let walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (let i3 = this.length - 1;walker; i3--) {
        acc = fn(acc, walker.value, i3);
        walker = walker.prev;
      }
      return acc;
    }
    toArray() {
      const arr = new Array(this.length);
      for (let i3 = 0, walker = this.head;walker; i3++) {
        arr[i3] = walker.value;
        walker = walker.next;
      }
      return arr;
    }
    toArrayReverse() {
      const arr = new Array(this.length);
      for (let i3 = 0, walker = this.tail;walker; i3++) {
        arr[i3] = walker.value;
        walker = walker.prev;
      }
      return arr;
    }
    slice(from = 0, to = this.length) {
      if (to < 0) {
        to += this.length;
      }
      if (from < 0) {
        from += this.length;
      }
      const ret = new Yallist;
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      let walker = this.head;
      let i3 = 0;
      for (i3 = 0;!!walker && i3 < from; i3++) {
        walker = walker.next;
      }
      for (;!!walker && i3 < to; i3++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    }
    sliceReverse(from = 0, to = this.length) {
      if (to < 0) {
        to += this.length;
      }
      if (from < 0) {
        from += this.length;
      }
      const ret = new Yallist;
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      let i3 = this.length;
      let walker = this.tail;
      for (;!!walker && i3 > to; i3--) {
        walker = walker.prev;
      }
      for (;!!walker && i3 > from; i3--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    }
    splice(start, deleteCount = 0, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      let walker = this.head;
      for (let i3 = 0;!!walker && i3 < start; i3++) {
        walker = walker.next;
      }
      const ret = [];
      for (let i3 = 0;!!walker && i3 < deleteCount; i3++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (!walker) {
        walker = this.tail;
      } else if (walker !== this.tail) {
        walker = walker.prev;
      }
      for (const v of nodes) {
        walker = insertAfter(this, walker, v);
      }
      return ret;
    }
    reverse() {
      const head = this.head;
      const tail = this.tail;
      for (let walker = head;walker; walker = walker.prev) {
        const p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    }
  };
});

// node_modules/tar/dist/esm/large-numbers.js
var encode = (num, buf) => {
  if (!Number.isSafeInteger(num)) {
    throw Error("cannot encode number outside of javascript safe integer range");
  } else if (num < 0) {
    encodeNegative(num, buf);
  } else {
    encodePositive(num, buf);
  }
  return buf;
}, encodePositive = (num, buf) => {
  buf[0] = 128;
  for (var i3 = buf.length;i3 > 1; i3--) {
    buf[i3 - 1] = num & 255;
    num = Math.floor(num / 256);
  }
}, encodeNegative = (num, buf) => {
  buf[0] = 255;
  var flipped = false;
  num = num * -1;
  for (var i3 = buf.length;i3 > 1; i3--) {
    var byte = num & 255;
    num = Math.floor(num / 256);
    if (flipped) {
      buf[i3 - 1] = onesComp(byte);
    } else if (byte === 0) {
      buf[i3 - 1] = 0;
    } else {
      flipped = true;
      buf[i3 - 1] = twosComp(byte);
    }
  }
}, parse2 = (buf) => {
  const pre = buf[0];
  const value = pre === 128 ? pos(buf.subarray(1, buf.length)) : pre === 255 ? twos(buf) : null;
  if (value === null) {
    throw Error("invalid base256 encoding");
  }
  if (!Number.isSafeInteger(value)) {
    throw Error("parsed number outside of javascript safe integer range");
  }
  return value;
}, twos = (buf) => {
  var len = buf.length;
  var sum = 0;
  var flipped = false;
  for (var i3 = len - 1;i3 > -1; i3--) {
    var byte = Number(buf[i3]);
    var f3;
    if (flipped) {
      f3 = onesComp(byte);
    } else if (byte === 0) {
      f3 = byte;
    } else {
      flipped = true;
      f3 = twosComp(byte);
    }
    if (f3 !== 0) {
      sum -= f3 * Math.pow(256, len - i3 - 1);
    }
  }
  return sum;
}, pos = (buf) => {
  var len = buf.length;
  var sum = 0;
  for (var i3 = len - 1;i3 > -1; i3--) {
    var byte = Number(buf[i3]);
    if (byte !== 0) {
      sum += byte * Math.pow(256, len - i3 - 1);
    }
  }
  return sum;
}, onesComp = (byte) => (255 ^ byte) & 255, twosComp = (byte) => (255 ^ byte) + 1 & 255;

// node_modules/tar/dist/esm/types.js
var isCode = (c3) => name.has(c3), name, code;
var init_types = __esm(() => {
  name = new Map([
    ["0", "File"],
    ["", "OldFile"],
    ["1", "Link"],
    ["2", "SymbolicLink"],
    ["3", "CharacterDevice"],
    ["4", "BlockDevice"],
    ["5", "Directory"],
    ["6", "FIFO"],
    ["7", "ContiguousFile"],
    ["g", "GlobalExtendedHeader"],
    ["x", "ExtendedHeader"],
    ["A", "SolarisACL"],
    ["D", "GNUDumpDir"],
    ["I", "Inode"],
    ["K", "NextFileHasLongLinkpath"],
    ["L", "NextFileHasLongPath"],
    ["M", "ContinuationFile"],
    ["N", "OldGnuLongPath"],
    ["S", "SparseFile"],
    ["V", "TapeVolumeHeader"],
    ["X", "OldExtendedHeader"]
  ]);
  code = new Map(Array.from(name).map((kv) => [kv[1], kv[0]]));
});

// node_modules/tar/dist/esm/header.js
import { posix as pathModule } from "node:path";

class Header {
  cksumValid = false;
  needPax = false;
  nullBlock = false;
  block;
  path;
  mode;
  uid;
  gid;
  size;
  cksum;
  #type = "Unsupported";
  linkpath;
  uname;
  gname;
  devmaj = 0;
  devmin = 0;
  atime;
  ctime;
  mtime;
  charset;
  comment;
  constructor(data, off = 0, ex, gex) {
    if (Buffer.isBuffer(data)) {
      this.decode(data, off || 0, ex, gex);
    } else if (data) {
      this.#slurp(data);
    }
  }
  decode(buf, off, ex, gex) {
    if (!off) {
      off = 0;
    }
    if (!buf || !(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }
    this.path = decString(buf, off, 100);
    this.mode = decNumber(buf, off + 100, 8);
    this.uid = decNumber(buf, off + 108, 8);
    this.gid = decNumber(buf, off + 116, 8);
    this.size = decNumber(buf, off + 124, 12);
    this.mtime = decDate(buf, off + 136, 12);
    this.cksum = decNumber(buf, off + 148, 12);
    if (gex)
      this.#slurp(gex, true);
    if (ex)
      this.#slurp(ex);
    const t2 = decString(buf, off + 156, 1);
    if (isCode(t2)) {
      this.#type = t2 || "0";
    }
    if (this.#type === "0" && this.path.slice(-1) === "/") {
      this.#type = "5";
    }
    if (this.#type === "5") {
      this.size = 0;
    }
    this.linkpath = decString(buf, off + 157, 100);
    if (buf.subarray(off + 257, off + 265).toString() === "ustar\x0000") {
      this.uname = decString(buf, off + 265, 32);
      this.gname = decString(buf, off + 297, 32);
      this.devmaj = decNumber(buf, off + 329, 8) ?? 0;
      this.devmin = decNumber(buf, off + 337, 8) ?? 0;
      if (buf[off + 475] !== 0) {
        const prefix = decString(buf, off + 345, 155);
        this.path = prefix + "/" + this.path;
      } else {
        const prefix = decString(buf, off + 345, 130);
        if (prefix) {
          this.path = prefix + "/" + this.path;
        }
        this.atime = decDate(buf, off + 476, 12);
        this.ctime = decDate(buf, off + 488, 12);
      }
    }
    let sum = 8 * 32;
    for (let i3 = off;i3 < off + 148; i3++) {
      sum += buf[i3];
    }
    for (let i3 = off + 156;i3 < off + 512; i3++) {
      sum += buf[i3];
    }
    this.cksumValid = sum === this.cksum;
    if (this.cksum === undefined && sum === 8 * 32) {
      this.nullBlock = true;
    }
  }
  #slurp(ex, gex = false) {
    Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {
      return !(v === null || v === undefined || k === "path" && gex || k === "linkpath" && gex || k === "global");
    })));
  }
  encode(buf, off = 0) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512);
    }
    if (this.#type === "Unsupported") {
      this.#type = "0";
    }
    if (!(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }
    const prefixSize = this.ctime || this.atime ? 130 : 155;
    const split = splitPrefix(this.path || "", prefixSize);
    const path7 = split[0];
    const prefix = split[1];
    this.needPax = !!split[2];
    this.needPax = encString(buf, off, 100, path7) || this.needPax;
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
    buf[off + 156] = this.#type.charCodeAt(0);
    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
    buf.write("ustar\x0000", off + 257, 8);
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
    if (buf[off + 475] !== 0) {
      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
    } else {
      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
    }
    let sum = 8 * 32;
    for (let i3 = off;i3 < off + 148; i3++) {
      sum += buf[i3];
    }
    for (let i3 = off + 156;i3 < off + 512; i3++) {
      sum += buf[i3];
    }
    this.cksum = sum;
    encNumber(buf, off + 148, 8, this.cksum);
    this.cksumValid = true;
    return this.needPax;
  }
  get type() {
    return this.#type === "Unsupported" ? this.#type : name.get(this.#type);
  }
  get typeKey() {
    return this.#type;
  }
  set type(type2) {
    const c3 = String(code.get(type2));
    if (isCode(c3) || c3 === "Unsupported") {
      this.#type = c3;
    } else if (isCode(type2)) {
      this.#type = type2;
    } else {
      throw new TypeError("invalid entry type: " + type2);
    }
  }
}
var splitPrefix = (p, prefixSize) => {
  const pathSize = 100;
  let pp = p;
  let prefix = "";
  let ret = undefined;
  const root = pathModule.parse(p).root || ".";
  if (Buffer.byteLength(pp) < pathSize) {
    ret = [pp, prefix, false];
  } else {
    prefix = pathModule.dirname(pp);
    pp = pathModule.basename(pp);
    do {
      if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
        ret = [pp, prefix, false];
      } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
        ret = [pp.slice(0, pathSize - 1), prefix, true];
      } else {
        pp = pathModule.join(pathModule.basename(prefix), pp);
        prefix = pathModule.dirname(prefix);
      }
    } while (prefix !== root && ret === undefined);
    if (!ret) {
      ret = [p.slice(0, pathSize - 1), "", true];
    }
  }
  return ret;
}, decString = (buf, off, size) => buf.subarray(off, off + size).toString("utf8").replace(/\0.*/, ""), decDate = (buf, off, size) => numToDate(decNumber(buf, off, size)), numToDate = (num) => num === undefined ? undefined : new Date(num * 1000), decNumber = (buf, off, size) => Number(buf[off]) & 128 ? parse2(buf.subarray(off, off + size)) : decSmallNumber(buf, off, size), nanUndef = (value) => isNaN(value) ? undefined : value, decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf.subarray(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8)), MAXNUM, encNumber = (buf, off, size, num) => num === undefined ? false : num > MAXNUM[size] || num < 0 ? (encode(num, buf.subarray(off, off + size)), true) : (encSmallNumber(buf, off, size, num), false), encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, "ascii"), octalString = (num, size) => padOctal(Math.floor(num).toString(8), size), padOctal = (str, size) => (str.length === size - 1 ? str : new Array(size - str.length - 1).join("0") + str + " ") + "\x00", encDate = (buf, off, size, date) => date === undefined ? false : encNumber(buf, off, size, date.getTime() / 1000), NULLS, encString = (buf, off, size, str) => str === undefined ? false : (buf.write(str + NULLS, off, size, "utf8"), str.length !== Buffer.byteLength(str) || str.length > size);
var init_header = __esm(() => {
  init_types();
  MAXNUM = {
    12: 8589934591,
    8: 2097151
  };
  NULLS = new Array(156).join("\x00");
});

// node_modules/tar/dist/esm/pax.js
import { basename } from "node:path";

class Pax {
  atime;
  mtime;
  ctime;
  charset;
  comment;
  gid;
  uid;
  gname;
  uname;
  linkpath;
  dev;
  ino;
  nlink;
  path;
  size;
  mode;
  global;
  constructor(obj, global3 = false) {
    this.atime = obj.atime;
    this.charset = obj.charset;
    this.comment = obj.comment;
    this.ctime = obj.ctime;
    this.dev = obj.dev;
    this.gid = obj.gid;
    this.global = global3;
    this.gname = obj.gname;
    this.ino = obj.ino;
    this.linkpath = obj.linkpath;
    this.mtime = obj.mtime;
    this.nlink = obj.nlink;
    this.path = obj.path;
    this.size = obj.size;
    this.uid = obj.uid;
    this.uname = obj.uname;
  }
  encode() {
    const body = this.encodeBody();
    if (body === "") {
      return Buffer.allocUnsafe(0);
    }
    const bodyLen = Buffer.byteLength(body);
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
    const buf = Buffer.allocUnsafe(bufLen);
    for (let i3 = 0;i3 < 512; i3++) {
      buf[i3] = 0;
    }
    new Header({
      path: ("PaxHeader/" + basename(this.path ?? "")).slice(0, 99),
      mode: this.mode || 420,
      uid: this.uid,
      gid: this.gid,
      size: bodyLen,
      mtime: this.mtime,
      type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
      linkpath: "",
      uname: this.uname || "",
      gname: this.gname || "",
      devmaj: 0,
      devmin: 0,
      atime: this.atime,
      ctime: this.ctime
    }).encode(buf);
    buf.write(body, 512, bodyLen, "utf8");
    for (let i3 = bodyLen + 512;i3 < buf.length; i3++) {
      buf[i3] = 0;
    }
    return buf;
  }
  encodeBody() {
    return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
  }
  encodeField(field) {
    if (this[field] === undefined) {
      return "";
    }
    const r2 = this[field];
    const v = r2 instanceof Date ? r2.getTime() / 1000 : r2;
    const s2 = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + `
`;
    const byteLen = Buffer.byteLength(s2);
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
    if (byteLen + digits >= Math.pow(10, digits)) {
      digits += 1;
    }
    const len = digits + byteLen;
    return len + s2;
  }
  static parse(str, ex, g = false) {
    return new Pax(merge(parseKV(str), ex), g);
  }
}
var merge = (a2, b) => b ? Object.assign({}, b, a2) : a2, parseKV = (str) => str.replace(/\n$/, "").split(`
`).reduce(parseKVLine, Object.create(null)), parseKVLine = (set, line) => {
  const n2 = parseInt(line, 10);
  if (n2 !== Buffer.byteLength(line) + 1) {
    return set;
  }
  line = line.slice((n2 + " ").length);
  const kv = line.split("=");
  const r2 = kv.shift();
  if (!r2) {
    return set;
  }
  const k = r2.replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
  const v = kv.join("=");
  set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(Number(v) * 1000) : /^[0-9]+$/.test(v) ? +v : v;
  return set;
};
var init_pax = __esm(() => {
  init_header();
});

// node_modules/tar/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter4 } from "node:events";
import Stream5 from "node:stream";
import { StringDecoder as StringDecoder5 } from "node:string_decoder";

class Pipe3 {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME3]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {
  }
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}
var proc3, isStream4 = (s2) => !!s2 && typeof s2 === "object" && (s2 instanceof Minipass3 || s2 instanceof Stream5 || isReadable3(s2) || isWritable3(s2)), isReadable3 = (s2) => !!s2 && typeof s2 === "object" && s2 instanceof EventEmitter4 && typeof s2.pipe === "function" && s2.pipe !== Stream5.Writable.prototype.pipe, isWritable3 = (s2) => !!s2 && typeof s2 === "object" && s2 instanceof EventEmitter4 && typeof s2.write === "function" && typeof s2.end === "function", EOF3, MAYBE_EMIT_END3, EMITTED_END3, EMITTING_END3, EMITTED_ERROR3, CLOSED3, READ3, FLUSH3, FLUSHCHUNK3, ENCODING3, DECODER3, FLOWING3, PAUSED3, RESUME3, BUFFER3, PIPES3, BUFFERLENGTH3, BUFFERPUSH3, BUFFERSHIFT3, OBJECTMODE3, DESTROYED3, ERROR3, EMITDATA3, EMITEND5, EMITEND23, ASYNC3, ABORT3, ABORTED3, SIGNAL3, DATALISTENERS3, DISCARDED3, defer3 = (fn) => Promise.resolve().then(fn), nodefer3 = (fn) => fn(), isEndish3 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike3 = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView3 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b), PipeProxyErrors3, isObjectModeOptions3 = (o2) => !!o2.objectMode, isEncodingOptions3 = (o2) => !o2.objectMode && !!o2.encoding && o2.encoding !== "buffer", Minipass3;
var init_esm6 = __esm(() => {
  proc3 = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  EOF3 = Symbol("EOF");
  MAYBE_EMIT_END3 = Symbol("maybeEmitEnd");
  EMITTED_END3 = Symbol("emittedEnd");
  EMITTING_END3 = Symbol("emittingEnd");
  EMITTED_ERROR3 = Symbol("emittedError");
  CLOSED3 = Symbol("closed");
  READ3 = Symbol("read");
  FLUSH3 = Symbol("flush");
  FLUSHCHUNK3 = Symbol("flushChunk");
  ENCODING3 = Symbol("encoding");
  DECODER3 = Symbol("decoder");
  FLOWING3 = Symbol("flowing");
  PAUSED3 = Symbol("paused");
  RESUME3 = Symbol("resume");
  BUFFER3 = Symbol("buffer");
  PIPES3 = Symbol("pipes");
  BUFFERLENGTH3 = Symbol("bufferLength");
  BUFFERPUSH3 = Symbol("bufferPush");
  BUFFERSHIFT3 = Symbol("bufferShift");
  OBJECTMODE3 = Symbol("objectMode");
  DESTROYED3 = Symbol("destroyed");
  ERROR3 = Symbol("error");
  EMITDATA3 = Symbol("emitData");
  EMITEND5 = Symbol("emitEnd");
  EMITEND23 = Symbol("emitEnd2");
  ASYNC3 = Symbol("async");
  ABORT3 = Symbol("abort");
  ABORTED3 = Symbol("aborted");
  SIGNAL3 = Symbol("signal");
  DATALISTENERS3 = Symbol("dataListeners");
  DISCARDED3 = Symbol("discarded");
  PipeProxyErrors3 = class PipeProxyErrors3 extends Pipe3 {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  };
  Minipass3 = class Minipass3 extends EventEmitter4 {
    [FLOWING3] = false;
    [PAUSED3] = false;
    [PIPES3] = [];
    [BUFFER3] = [];
    [OBJECTMODE3];
    [ENCODING3];
    [ASYNC3];
    [DECODER3];
    [EOF3] = false;
    [EMITTED_END3] = false;
    [EMITTING_END3] = false;
    [CLOSED3] = false;
    [EMITTED_ERROR3] = null;
    [BUFFERLENGTH3] = 0;
    [DESTROYED3] = false;
    [SIGNAL3];
    [ABORTED3] = false;
    [DATALISTENERS3] = 0;
    [DISCARDED3] = false;
    writable = true;
    readable = true;
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions3(options)) {
        this[OBJECTMODE3] = true;
        this[ENCODING3] = null;
      } else if (isEncodingOptions3(options)) {
        this[ENCODING3] = options.encoding;
        this[OBJECTMODE3] = false;
      } else {
        this[OBJECTMODE3] = false;
        this[ENCODING3] = null;
      }
      this[ASYNC3] = !!options.async;
      this[DECODER3] = this[ENCODING3] ? new StringDecoder5(this[ENCODING3]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER3] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES3] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL3] = signal;
        if (signal.aborted) {
          this[ABORT3]();
        } else {
          signal.addEventListener("abort", () => this[ABORT3]());
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH3];
    }
    get encoding() {
      return this[ENCODING3];
    }
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    get objectMode() {
      return this[OBJECTMODE3];
    }
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    get ["async"]() {
      return this[ASYNC3];
    }
    set ["async"](a2) {
      this[ASYNC3] = this[ASYNC3] || !!a2;
    }
    [ABORT3]() {
      this[ABORTED3] = true;
      this.emit("abort", this[SIGNAL3]?.reason);
      this.destroy(this[SIGNAL3]?.reason);
    }
    get aborted() {
      return this[ABORTED3];
    }
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED3])
        return false;
      if (this[EOF3])
        throw new Error("write after end");
      if (this[DESTROYED3]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC3] ? defer3 : nodefer3;
      if (!this[OBJECTMODE3] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView3(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike3(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE3]) {
        if (this[FLOWING3] && this[BUFFERLENGTH3] !== 0)
          this[FLUSH3](true);
        if (this[FLOWING3])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH3](chunk);
        if (this[BUFFERLENGTH3] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING3];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH3] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING3];
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING3] && !this[DECODER3]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING3]) {
        chunk = this[DECODER3].write(chunk);
      }
      if (this[FLOWING3] && this[BUFFERLENGTH3] !== 0)
        this[FLUSH3](true);
      if (this[FLOWING3])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH3](chunk);
      if (this[BUFFERLENGTH3] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING3];
    }
    read(n2) {
      if (this[DESTROYED3])
        return null;
      this[DISCARDED3] = false;
      if (this[BUFFERLENGTH3] === 0 || n2 === 0 || n2 && n2 > this[BUFFERLENGTH3]) {
        this[MAYBE_EMIT_END3]();
        return null;
      }
      if (this[OBJECTMODE3])
        n2 = null;
      if (this[BUFFER3].length > 1 && !this[OBJECTMODE3]) {
        this[BUFFER3] = [
          this[ENCODING3] ? this[BUFFER3].join("") : Buffer.concat(this[BUFFER3], this[BUFFERLENGTH3])
        ];
      }
      const ret = this[READ3](n2 || null, this[BUFFER3][0]);
      this[MAYBE_EMIT_END3]();
      return ret;
    }
    [READ3](n2, chunk) {
      if (this[OBJECTMODE3])
        this[BUFFERSHIFT3]();
      else {
        const c3 = chunk;
        if (n2 === c3.length || n2 === null)
          this[BUFFERSHIFT3]();
        else if (typeof c3 === "string") {
          this[BUFFER3][0] = c3.slice(n2);
          chunk = c3.slice(0, n2);
          this[BUFFERLENGTH3] -= n2;
        } else {
          this[BUFFER3][0] = c3.subarray(n2);
          chunk = c3.subarray(0, n2);
          this[BUFFERLENGTH3] -= n2;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER3].length && !this[EOF3])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== undefined)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF3] = true;
      this.writable = false;
      if (this[FLOWING3] || !this[PAUSED3])
        this[MAYBE_EMIT_END3]();
      return this;
    }
    [RESUME3]() {
      if (this[DESTROYED3])
        return;
      if (!this[DATALISTENERS3] && !this[PIPES3].length) {
        this[DISCARDED3] = true;
      }
      this[PAUSED3] = false;
      this[FLOWING3] = true;
      this.emit("resume");
      if (this[BUFFER3].length)
        this[FLUSH3]();
      else if (this[EOF3])
        this[MAYBE_EMIT_END3]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME3]();
    }
    pause() {
      this[FLOWING3] = false;
      this[PAUSED3] = true;
      this[DISCARDED3] = false;
    }
    get destroyed() {
      return this[DESTROYED3];
    }
    get flowing() {
      return this[FLOWING3];
    }
    get paused() {
      return this[PAUSED3];
    }
    [BUFFERPUSH3](chunk) {
      if (this[OBJECTMODE3])
        this[BUFFERLENGTH3] += 1;
      else
        this[BUFFERLENGTH3] += chunk.length;
      this[BUFFER3].push(chunk);
    }
    [BUFFERSHIFT3]() {
      if (this[OBJECTMODE3])
        this[BUFFERLENGTH3] -= 1;
      else
        this[BUFFERLENGTH3] -= this[BUFFER3][0].length;
      return this[BUFFER3].shift();
    }
    [FLUSH3](noDrain = false) {
      do {
      } while (this[FLUSHCHUNK3](this[BUFFERSHIFT3]()) && this[BUFFER3].length);
      if (!noDrain && !this[BUFFER3].length && !this[EOF3])
        this.emit("drain");
    }
    [FLUSHCHUNK3](chunk) {
      this.emit("data", chunk);
      return this[FLOWING3];
    }
    pipe(dest, opts) {
      if (this[DESTROYED3])
        return dest;
      this[DISCARDED3] = false;
      const ended = this[EMITTED_END3];
      opts = opts || {};
      if (dest === proc3.stdout || dest === proc3.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES3].push(!opts.proxyErrors ? new Pipe3(this, dest, opts) : new PipeProxyErrors3(this, dest, opts));
        if (this[ASYNC3])
          defer3(() => this[RESUME3]());
        else
          this[RESUME3]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES3].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES3].length === 1) {
          if (this[FLOWING3] && this[DATALISTENERS3] === 0) {
            this[FLOWING3] = false;
          }
          this[PIPES3] = [];
        } else
          this[PIPES3].splice(this[PIPES3].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    on(ev, handler) {
      const ret = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED3] = false;
        this[DATALISTENERS3]++;
        if (!this[PIPES3].length && !this[FLOWING3]) {
          this[RESUME3]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH3] !== 0) {
        super.emit("readable");
      } else if (isEndish3(ev) && this[EMITTED_END3]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR3]) {
        const h3 = handler;
        if (this[ASYNC3])
          defer3(() => h3.call(this, this[EMITTED_ERROR3]));
        else
          h3.call(this, this[EMITTED_ERROR3]);
      }
      return ret;
    }
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    off(ev, handler) {
      const ret = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS3] = this.listeners("data").length;
        if (this[DATALISTENERS3] === 0 && !this[DISCARDED3] && !this[PIPES3].length) {
          this[FLOWING3] = false;
        }
      }
      return ret;
    }
    removeAllListeners(ev) {
      const ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === undefined) {
        this[DATALISTENERS3] = 0;
        if (!this[DISCARDED3] && !this[PIPES3].length) {
          this[FLOWING3] = false;
        }
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END3];
    }
    [MAYBE_EMIT_END3]() {
      if (!this[EMITTING_END3] && !this[EMITTED_END3] && !this[DESTROYED3] && this[BUFFER3].length === 0 && this[EOF3]) {
        this[EMITTING_END3] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED3])
          this.emit("close");
        this[EMITTING_END3] = false;
      }
    }
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED3 && this[DESTROYED3]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE3] && !data ? false : this[ASYNC3] ? (defer3(() => this[EMITDATA3](data)), true) : this[EMITDATA3](data);
      } else if (ev === "end") {
        return this[EMITEND5]();
      } else if (ev === "close") {
        this[CLOSED3] = true;
        if (!this[EMITTED_END3] && !this[DESTROYED3])
          return false;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR3] = data;
        super.emit(ERROR3, data);
        const ret2 = !this[SIGNAL3] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END3]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END3]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, ...args);
      this[MAYBE_EMIT_END3]();
      return ret;
    }
    [EMITDATA3](data) {
      for (const p of this[PIPES3]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = this[DISCARDED3] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END3]();
      return ret;
    }
    [EMITEND5]() {
      if (this[EMITTED_END3])
        return false;
      this[EMITTED_END3] = true;
      this.readable = false;
      return this[ASYNC3] ? (defer3(() => this[EMITEND23]()), true) : this[EMITEND23]();
    }
    [EMITEND23]() {
      if (this[DECODER3]) {
        const data = this[DECODER3].end();
        if (data) {
          for (const p of this[PIPES3]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED3])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES3]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE3])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c3) => {
        buf.push(c3);
        if (!this[OBJECTMODE3])
          buf.dataLength += c3.length;
      });
      await p;
      return buf;
    }
    async concat() {
      if (this[OBJECTMODE3]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING3] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    async promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED3, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [Symbol.asyncIterator]() {
      this[DISCARDED3] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: undefined, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF3])
          return stop();
        let resolve;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED3, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED3, ondestroy);
          this.pause();
          resolve({ value, done: !!this[EOF3] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED3, ondestroy);
          stop();
          resolve({ done: true, value: undefined });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED3, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    [Symbol.iterator]() {
      this[DISCARDED3] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR3, stop);
        this.off(DESTROYED3, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: undefined };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR3, stop);
      this.once(DESTROYED3, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED3]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED3);
        return this;
      }
      this[DESTROYED3] = true;
      this[DISCARDED3] = true;
      this[BUFFER3].length = 0;
      this[BUFFERLENGTH3] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED3])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED3);
      return this;
    }
    static get isStream() {
      return isStream4;
    }
  };
});

// node_modules/tar/dist/esm/normalize-windows-path.js
var platform2, normalizeWindowsPath;
var init_normalize_windows_path = __esm(() => {
  platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  normalizeWindowsPath = platform2 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
});

// node_modules/tar/dist/esm/read-entry.js
var ReadEntry;
var init_read_entry = __esm(() => {
  init_esm6();
  init_normalize_windows_path();
  ReadEntry = class ReadEntry extends Minipass3 {
    extended;
    globalExtended;
    header;
    startBlockSize;
    blockRemain;
    remain;
    type;
    meta = false;
    ignore = false;
    path;
    mode;
    uid;
    gid;
    uname;
    gname;
    size = 0;
    mtime;
    atime;
    ctime;
    linkpath;
    dev;
    ino;
    nlink;
    invalid = false;
    absolute;
    unsupported = false;
    constructor(header, ex, gex) {
      super({});
      this.pause();
      this.extended = ex;
      this.globalExtended = gex;
      this.header = header;
      this.remain = header.size ?? 0;
      this.startBlockSize = 512 * Math.ceil(this.remain / 512);
      this.blockRemain = this.startBlockSize;
      this.type = header.type;
      switch (this.type) {
        case "File":
        case "OldFile":
        case "Link":
        case "SymbolicLink":
        case "CharacterDevice":
        case "BlockDevice":
        case "Directory":
        case "FIFO":
        case "ContiguousFile":
        case "GNUDumpDir":
          break;
        case "NextFileHasLongLinkpath":
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
        case "GlobalExtendedHeader":
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this.meta = true;
          break;
        default:
          this.ignore = true;
      }
      if (!header.path) {
        throw new Error("no path provided for tar.ReadEntry");
      }
      this.path = normalizeWindowsPath(header.path);
      this.mode = header.mode;
      if (this.mode) {
        this.mode = this.mode & 4095;
      }
      this.uid = header.uid;
      this.gid = header.gid;
      this.uname = header.uname;
      this.gname = header.gname;
      this.size = this.remain;
      this.mtime = header.mtime;
      this.atime = header.atime;
      this.ctime = header.ctime;
      this.linkpath = header.linkpath ? normalizeWindowsPath(header.linkpath) : undefined;
      this.uname = header.uname;
      this.gname = header.gname;
      if (ex) {
        this.#slurp(ex);
      }
      if (gex) {
        this.#slurp(gex, true);
      }
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain) {
        throw new Error("writing more to entry than is appropriate");
      }
      const r2 = this.remain;
      const br = this.blockRemain;
      this.remain = Math.max(0, r2 - writeLen);
      this.blockRemain = Math.max(0, br - writeLen);
      if (this.ignore) {
        return true;
      }
      if (r2 >= writeLen) {
        return super.write(data);
      }
      return super.write(data.subarray(0, r2));
    }
    #slurp(ex, gex = false) {
      if (ex.path)
        ex.path = normalizeWindowsPath(ex.path);
      if (ex.linkpath)
        ex.linkpath = normalizeWindowsPath(ex.linkpath);
      Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {
        return !(v === null || v === undefined || k === "path" && gex);
      })));
    }
  };
});

// node_modules/tar/dist/esm/warn-method.js
var warnMethod = (self2, code2, message, data = {}) => {
  if (self2.file) {
    data.file = self2.file;
  }
  if (self2.cwd) {
    data.cwd = self2.cwd;
  }
  data.code = message instanceof Error && message.code || code2;
  data.tarCode = code2;
  if (!self2.strict && data.recoverable !== false) {
    if (message instanceof Error) {
      data = Object.assign(message, data);
      message = message.message;
    }
    self2.emit("warn", code2, message, data);
  } else if (message instanceof Error) {
    self2.emit("error", Object.assign(message, data));
  } else {
    self2.emit("error", Object.assign(new Error(`${code2}: ${message}`), data));
  }
};

// node_modules/tar/dist/esm/parse.js
import { EventEmitter as EE2 } from "events";
var maxMetaEntrySize, gzipHeader, STATE, WRITEENTRY, READENTRY, NEXTENTRY, PROCESSENTRY, EX, GEX, META, EMITMETA, BUFFER4, QUEUE, ENDED, EMITTEDEND, EMIT, UNZIP, CONSUMECHUNK, CONSUMECHUNKSUB, CONSUMEBODY, CONSUMEMETA, CONSUMEHEADER, CONSUMING, BUFFERCONCAT, MAYBEEND, WRITING, ABORTED4, DONE, SAW_VALID_ENTRY, SAW_NULL_BLOCK, SAW_EOF, CLOSESTREAM, noop5 = () => true, Parser;
var init_parse = __esm(() => {
  init_esm4();
  init_esm5();
  init_header();
  init_pax();
  init_read_entry();
  maxMetaEntrySize = 1024 * 1024;
  gzipHeader = Buffer.from([31, 139]);
  STATE = Symbol("state");
  WRITEENTRY = Symbol("writeEntry");
  READENTRY = Symbol("readEntry");
  NEXTENTRY = Symbol("nextEntry");
  PROCESSENTRY = Symbol("processEntry");
  EX = Symbol("extendedHeader");
  GEX = Symbol("globalExtendedHeader");
  META = Symbol("meta");
  EMITMETA = Symbol("emitMeta");
  BUFFER4 = Symbol("buffer");
  QUEUE = Symbol("queue");
  ENDED = Symbol("ended");
  EMITTEDEND = Symbol("emittedEnd");
  EMIT = Symbol("emit");
  UNZIP = Symbol("unzip");
  CONSUMECHUNK = Symbol("consumeChunk");
  CONSUMECHUNKSUB = Symbol("consumeChunkSub");
  CONSUMEBODY = Symbol("consumeBody");
  CONSUMEMETA = Symbol("consumeMeta");
  CONSUMEHEADER = Symbol("consumeHeader");
  CONSUMING = Symbol("consuming");
  BUFFERCONCAT = Symbol("bufferConcat");
  MAYBEEND = Symbol("maybeEnd");
  WRITING = Symbol("writing");
  ABORTED4 = Symbol("aborted");
  DONE = Symbol("onDone");
  SAW_VALID_ENTRY = Symbol("sawValidEntry");
  SAW_NULL_BLOCK = Symbol("sawNullBlock");
  SAW_EOF = Symbol("sawEOF");
  CLOSESTREAM = Symbol("closeStream");
  Parser = class Parser extends EE2 {
    file;
    strict;
    maxMetaEntrySize;
    filter;
    brotli;
    writable = true;
    readable = false;
    [QUEUE] = new Yallist;
    [BUFFER4];
    [READENTRY];
    [WRITEENTRY];
    [STATE] = "begin";
    [META] = "";
    [EX];
    [GEX];
    [ENDED] = false;
    [UNZIP];
    [ABORTED4] = false;
    [SAW_VALID_ENTRY];
    [SAW_NULL_BLOCK] = false;
    [SAW_EOF] = false;
    [WRITING] = false;
    [CONSUMING] = false;
    [EMITTEDEND] = false;
    constructor(opt = {}) {
      super();
      this.file = opt.file || "";
      this.on(DONE, () => {
        if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
          this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
        }
      });
      if (opt.ondone) {
        this.on(DONE, opt.ondone);
      } else {
        this.on(DONE, () => {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        });
      }
      this.strict = !!opt.strict;
      this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
      this.filter = typeof opt.filter === "function" ? opt.filter : noop5;
      const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
      this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli : isTBR ? undefined : false;
      this.on("end", () => this[CLOSESTREAM]());
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      if (typeof opt.onReadEntry === "function") {
        this.on("entry", opt.onReadEntry);
      }
    }
    warn(code2, message, data = {}) {
      warnMethod(this, code2, message, data);
    }
    [CONSUMEHEADER](chunk, position2) {
      if (this[SAW_VALID_ENTRY] === undefined) {
        this[SAW_VALID_ENTRY] = false;
      }
      let header;
      try {
        header = new Header(chunk, position2, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }
      if (header.nullBlock) {
        if (this[SAW_NULL_BLOCK]) {
          this[SAW_EOF] = true;
          if (this[STATE] === "begin") {
            this[STATE] = "header";
          }
          this[EMIT]("eof");
        } else {
          this[SAW_NULL_BLOCK] = true;
          this[EMIT]("nullBlock");
        }
      } else {
        this[SAW_NULL_BLOCK] = false;
        if (!header.cksumValid) {
          this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
        } else if (!header.path) {
          this.warn("TAR_ENTRY_INVALID", "path is required", { header });
        } else {
          const type2 = header.type;
          if (/^(Symbolic)?Link$/.test(type2) && !header.linkpath) {
            this.warn("TAR_ENTRY_INVALID", "linkpath required", {
              header
            });
          } else if (!/^(Symbolic)?Link$/.test(type2) && !/^(Global)?ExtendedHeader$/.test(type2) && header.linkpath) {
            this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {
              header
            });
          } else {
            const entry = this[WRITEENTRY] = new ReadEntry(header, this[EX], this[GEX]);
            if (!this[SAW_VALID_ENTRY]) {
              if (entry.remain) {
                const onend = () => {
                  if (!entry.invalid) {
                    this[SAW_VALID_ENTRY] = true;
                  }
                };
                entry.on("end", onend);
              } else {
                this[SAW_VALID_ENTRY] = true;
              }
            }
            if (entry.meta) {
              if (entry.size > this.maxMetaEntrySize) {
                entry.ignore = true;
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = "ignore";
                entry.resume();
              } else if (entry.size > 0) {
                this[META] = "";
                entry.on("data", (c3) => this[META] += c3);
                this[STATE] = "meta";
              }
            } else {
              this[EX] = undefined;
              entry.ignore = entry.ignore || !this.filter(entry.path, entry);
              if (entry.ignore) {
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = entry.remain ? "ignore" : "header";
                entry.resume();
              } else {
                if (entry.remain) {
                  this[STATE] = "body";
                } else {
                  this[STATE] = "header";
                  entry.end();
                }
                if (!this[READENTRY]) {
                  this[QUEUE].push(entry);
                  this[NEXTENTRY]();
                } else {
                  this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
    }
    [CLOSESTREAM]() {
      queueMicrotask(() => this.emit("close"));
    }
    [PROCESSENTRY](entry) {
      let go = true;
      if (!entry) {
        this[READENTRY] = undefined;
        go = false;
      } else if (Array.isArray(entry)) {
        const [ev, ...args] = entry;
        this.emit(ev, ...args);
      } else {
        this[READENTRY] = entry;
        this.emit("entry", entry);
        if (!entry.emittedEnd) {
          entry.on("end", () => this[NEXTENTRY]());
          go = false;
        }
      }
      return go;
    }
    [NEXTENTRY]() {
      do {
      } while (this[PROCESSENTRY](this[QUEUE].shift()));
      if (!this[QUEUE].length) {
        const re = this[READENTRY];
        const drainNow = !re || re.flowing || re.size === re.remain;
        if (drainNow) {
          if (!this[WRITING]) {
            this.emit("drain");
          }
        } else {
          re.once("drain", () => this.emit("drain"));
        }
      }
    }
    [CONSUMEBODY](chunk, position2) {
      const entry = this[WRITEENTRY];
      if (!entry) {
        throw new Error("attempt to consume body without entry??");
      }
      const br = entry.blockRemain ?? 0;
      const c3 = br >= chunk.length && position2 === 0 ? chunk : chunk.subarray(position2, position2 + br);
      entry.write(c3);
      if (!entry.blockRemain) {
        this[STATE] = "header";
        this[WRITEENTRY] = undefined;
        entry.end();
      }
      return c3.length;
    }
    [CONSUMEMETA](chunk, position2) {
      const entry = this[WRITEENTRY];
      const ret = this[CONSUMEBODY](chunk, position2);
      if (!this[WRITEENTRY] && entry) {
        this[EMITMETA](entry);
      }
      return ret;
    }
    [EMIT](ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY]) {
        this.emit(ev, data, extra);
      } else {
        this[QUEUE].push([ev, data, extra]);
      }
    }
    [EMITMETA](entry) {
      this[EMIT]("meta", this[META]);
      switch (entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], false);
          break;
        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], true);
          break;
        case "NextFileHasLongPath":
        case "OldGnuLongPath": {
          const ex = this[EX] ?? Object.create(null);
          this[EX] = ex;
          ex.path = this[META].replace(/\0.*/, "");
          break;
        }
        case "NextFileHasLongLinkpath": {
          const ex = this[EX] || Object.create(null);
          this[EX] = ex;
          ex.linkpath = this[META].replace(/\0.*/, "");
          break;
        }
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }
    abort(error) {
      this[ABORTED4] = true;
      this.emit("abort", error);
      this.warn("TAR_ABORT", error, { recoverable: false });
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
      }
      if (this[ABORTED4]) {
        cb?.();
        return false;
      }
      const needSniff = this[UNZIP] === undefined || this.brotli === undefined && this[UNZIP] === false;
      if (needSniff && chunk) {
        if (this[BUFFER4]) {
          chunk = Buffer.concat([this[BUFFER4], chunk]);
          this[BUFFER4] = undefined;
        }
        if (chunk.length < gzipHeader.length) {
          this[BUFFER4] = chunk;
          cb?.();
          return true;
        }
        for (let i3 = 0;this[UNZIP] === undefined && i3 < gzipHeader.length; i3++) {
          if (chunk[i3] !== gzipHeader[i3]) {
            this[UNZIP] = false;
          }
        }
        const maybeBrotli = this.brotli === undefined;
        if (this[UNZIP] === false && maybeBrotli) {
          if (chunk.length < 512) {
            if (this[ENDED]) {
              this.brotli = true;
            } else {
              this[BUFFER4] = chunk;
              cb?.();
              return true;
            }
          } else {
            try {
              new Header(chunk.subarray(0, 512));
              this.brotli = false;
            } catch (_) {
              this.brotli = true;
            }
          }
        }
        if (this[UNZIP] === undefined || this[UNZIP] === false && this.brotli) {
          const ended = this[ENDED];
          this[ENDED] = false;
          this[UNZIP] = this[UNZIP] === undefined ? new Unzip({}) : new BrotliDecompress({});
          this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
          this[UNZIP].on("error", (er) => this.abort(er));
          this[UNZIP].on("end", () => {
            this[ENDED] = true;
            this[CONSUMECHUNK]();
          });
          this[WRITING] = true;
          const ret2 = !!this[UNZIP][ended ? "end" : "write"](chunk);
          this[WRITING] = false;
          cb?.();
          return ret2;
        }
      }
      this[WRITING] = true;
      if (this[UNZIP]) {
        this[UNZIP].write(chunk);
      } else {
        this[CONSUMECHUNK](chunk);
      }
      this[WRITING] = false;
      const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
      if (!ret && !this[QUEUE].length) {
        this[READENTRY]?.once("drain", () => this.emit("drain"));
      }
      cb?.();
      return ret;
    }
    [BUFFERCONCAT](c3) {
      if (c3 && !this[ABORTED4]) {
        this[BUFFER4] = this[BUFFER4] ? Buffer.concat([this[BUFFER4], c3]) : c3;
      }
    }
    [MAYBEEND]() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED4] && !this[CONSUMING]) {
        this[EMITTEDEND] = true;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          const have = this[BUFFER4] ? this[BUFFER4].length : 0;
          this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
          if (this[BUFFER4]) {
            entry.write(this[BUFFER4]);
          }
          entry.end();
        }
        this[EMIT](DONE);
      }
    }
    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING] && chunk) {
        this[BUFFERCONCAT](chunk);
      } else if (!chunk && !this[BUFFER4]) {
        this[MAYBEEND]();
      } else if (chunk) {
        this[CONSUMING] = true;
        if (this[BUFFER4]) {
          this[BUFFERCONCAT](chunk);
          const c3 = this[BUFFER4];
          this[BUFFER4] = undefined;
          this[CONSUMECHUNKSUB](c3);
        } else {
          this[CONSUMECHUNKSUB](chunk);
        }
        while (this[BUFFER4] && this[BUFFER4]?.length >= 512 && !this[ABORTED4] && !this[SAW_EOF]) {
          const c3 = this[BUFFER4];
          this[BUFFER4] = undefined;
          this[CONSUMECHUNKSUB](c3);
        }
        this[CONSUMING] = false;
      }
      if (!this[BUFFER4] || this[ENDED]) {
        this[MAYBEEND]();
      }
    }
    [CONSUMECHUNKSUB](chunk) {
      let position2 = 0;
      const length = chunk.length;
      while (position2 + 512 <= length && !this[ABORTED4] && !this[SAW_EOF]) {
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position2);
            position2 += 512;
            break;
          case "ignore":
          case "body":
            position2 += this[CONSUMEBODY](chunk, position2);
            break;
          case "meta":
            position2 += this[CONSUMEMETA](chunk, position2);
            break;
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      }
      if (position2 < length) {
        if (this[BUFFER4]) {
          this[BUFFER4] = Buffer.concat([
            chunk.subarray(position2),
            this[BUFFER4]
          ]);
        } else {
          this[BUFFER4] = chunk.subarray(position2);
        }
      }
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        encoding = undefined;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (cb)
        this.once("finish", cb);
      if (!this[ABORTED4]) {
        if (this[UNZIP]) {
          if (chunk)
            this[UNZIP].write(chunk);
          this[UNZIP].end();
        } else {
          this[ENDED] = true;
          if (this.brotli === undefined)
            chunk = chunk || Buffer.alloc(0);
          if (chunk)
            this.write(chunk);
          this[MAYBEEND]();
        }
      }
      return this;
    }
  };
});

// node_modules/tar/dist/esm/strip-trailing-slashes.js
var stripTrailingSlashes = (str) => {
  let i3 = str.length - 1;
  let slashesStart = -1;
  while (i3 > -1 && str.charAt(i3) === "/") {
    slashesStart = i3;
    i3--;
  }
  return slashesStart === -1 ? str : str.slice(0, slashesStart);
};

// node_modules/tar/dist/esm/list.js
import fs3 from "node:fs";
import { dirname, parse as parse3 } from "path";
var onReadEntryFunction = (opt) => {
  const onReadEntry = opt.onReadEntry;
  opt.onReadEntry = onReadEntry ? (e2) => {
    onReadEntry(e2);
    e2.resume();
  } : (e2) => e2.resume();
}, filesFilter = (opt, files2) => {
  const map = new Map(files2.map((f3) => [stripTrailingSlashes(f3), true]));
  const filter = opt.filter;
  const mapHas = (file, r2 = "") => {
    const root = r2 || parse3(file).root || ".";
    let ret;
    if (file === root)
      ret = false;
    else {
      const m2 = map.get(file);
      if (m2 !== undefined) {
        ret = m2;
      } else {
        ret = mapHas(dirname(file), root);
      }
    }
    map.set(file, ret);
    return ret;
  };
  opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripTrailingSlashes(file)) : (file) => mapHas(stripTrailingSlashes(file));
}, listFileSync = (opt) => {
  const p = new Parser(opt);
  const file = opt.file;
  let fd;
  try {
    const stat2 = fs3.statSync(file);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    if (stat2.size < readSize) {
      p.end(fs3.readFileSync(file));
    } else {
      let pos2 = 0;
      const buf = Buffer.allocUnsafe(readSize);
      fd = fs3.openSync(file, "r");
      while (pos2 < stat2.size) {
        const bytesRead = fs3.readSync(fd, buf, 0, readSize, pos2);
        pos2 += bytesRead;
        p.write(buf.subarray(0, bytesRead));
      }
      p.end();
    }
  } finally {
    if (typeof fd === "number") {
      try {
        fs3.closeSync(fd);
      } catch (er) {
      }
    }
  }
}, listFile = (opt, _files) => {
  const parse4 = new Parser(opt);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const file = opt.file;
  const p = new Promise((resolve, reject) => {
    parse4.on("error", reject);
    parse4.on("end", resolve);
    fs3.stat(file, (er, stat2) => {
      if (er) {
        reject(er);
      } else {
        const stream = new ReadStream(file, {
          readSize,
          size: stat2.size
        });
        stream.on("error", reject);
        stream.pipe(parse4);
      }
    });
  });
  return p;
}, list;
var init_list = __esm(() => {
  init_esm2();
  init_make_command();
  init_parse();
  list = makeCommand(listFileSync, listFile, (opt) => new Parser(opt), (opt) => new Parser(opt), (opt, files2) => {
    if (files2?.length)
      filesFilter(opt, files2);
    if (!opt.noResume)
      onReadEntryFunction(opt);
  });
});

// node_modules/tar/dist/esm/mode-fix.js
var modeFix = (mode, isDir, portable) => {
  mode &= 4095;
  if (portable) {
    mode = (mode | 384) & ~18;
  }
  if (isDir) {
    if (mode & 256) {
      mode |= 64;
    }
    if (mode & 32) {
      mode |= 8;
    }
    if (mode & 4) {
      mode |= 1;
    }
  }
  return mode;
};

// node_modules/tar/dist/esm/strip-absolute-path.js
import { win32 } from "node:path";
var isAbsolute, parse4, stripAbsolutePath = (path7) => {
  let r2 = "";
  let parsed = parse4(path7);
  while (isAbsolute(path7) || parsed.root) {
    const root = path7.charAt(0) === "/" && path7.slice(0, 4) !== "//?/" ? "/" : parsed.root;
    path7 = path7.slice(root.length);
    r2 += root;
    parsed = parse4(path7);
  }
  return [r2, path7];
};
var init_strip_absolute_path = __esm(() => {
  ({ isAbsolute, parse: parse4 } = win32);
});

// node_modules/tar/dist/esm/winchars.js
var raw, win, toWin, toRaw, encode2 = (s2) => raw.reduce((s3, c3) => s3.split(c3).join(toWin.get(c3)), s2), decode = (s2) => win.reduce((s3, c3) => s3.split(c3).join(toRaw.get(c3)), s2);
var init_winchars = __esm(() => {
  raw = ["|", "<", ">", "?", ":"];
  win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
  toWin = new Map(raw.map((char, i3) => [char, win[i3]]));
  toRaw = new Map(win.map((char, i3) => [char, raw[i3]]));
});

// node_modules/tar/dist/esm/write-entry.js
import fs4 from "fs";
import path7 from "path";
var prefixPath = (path8, prefix) => {
  if (!prefix) {
    return normalizeWindowsPath(path8);
  }
  path8 = normalizeWindowsPath(path8).replace(/^\.(\/|$)/, "");
  return stripTrailingSlashes(prefix) + "/" + path8;
}, maxReadSize, PROCESS, FILE, DIRECTORY, SYMLINK, HARDLINK, HEADER, READ4, LSTAT, ONLSTAT, ONREAD, ONREADLINK, OPENFILE, ONOPENFILE, CLOSE, MODE, AWAITDRAIN, ONDRAIN, PREFIX, WriteEntry, WriteEntrySync, WriteEntryTar, getType = (stat2) => stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
var init_write_entry = __esm(() => {
  init_esm6();
  init_header();
  init_normalize_windows_path();
  init_options2();
  init_pax();
  init_strip_absolute_path();
  init_winchars();
  maxReadSize = 16 * 1024 * 1024;
  PROCESS = Symbol("process");
  FILE = Symbol("file");
  DIRECTORY = Symbol("directory");
  SYMLINK = Symbol("symlink");
  HARDLINK = Symbol("hardlink");
  HEADER = Symbol("header");
  READ4 = Symbol("read");
  LSTAT = Symbol("lstat");
  ONLSTAT = Symbol("onlstat");
  ONREAD = Symbol("onread");
  ONREADLINK = Symbol("onreadlink");
  OPENFILE = Symbol("openfile");
  ONOPENFILE = Symbol("onopenfile");
  CLOSE = Symbol("close");
  MODE = Symbol("mode");
  AWAITDRAIN = Symbol("awaitDrain");
  ONDRAIN = Symbol("ondrain");
  PREFIX = Symbol("prefix");
  WriteEntry = class WriteEntry extends Minipass3 {
    path;
    portable;
    myuid = process.getuid && process.getuid() || 0;
    myuser = process.env.USER || "";
    maxReadSize;
    linkCache;
    statCache;
    preservePaths;
    cwd;
    strict;
    mtime;
    noPax;
    noMtime;
    prefix;
    fd;
    blockLen = 0;
    blockRemain = 0;
    buf;
    pos = 0;
    remain = 0;
    length = 0;
    offset = 0;
    win32;
    absolute;
    header;
    type;
    linkpath;
    stat;
    onWriteEntry;
    #hadError = false;
    constructor(p, opt_ = {}) {
      const opt = dealias(opt_);
      super();
      this.path = normalizeWindowsPath(p);
      this.portable = !!opt.portable;
      this.maxReadSize = opt.maxReadSize || maxReadSize;
      this.linkCache = opt.linkCache || new Map;
      this.statCache = opt.statCache || new Map;
      this.preservePaths = !!opt.preservePaths;
      this.cwd = normalizeWindowsPath(opt.cwd || process.cwd());
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime;
      this.prefix = opt.prefix ? normalizeWindowsPath(opt.prefix) : undefined;
      this.onWriteEntry = opt.onWriteEntry;
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root && typeof stripped === "string") {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.win32 = !!opt.win32 || process.platform === "win32";
      if (this.win32) {
        this.path = decode(this.path.replace(/\\/g, "/"));
        p = p.replace(/\\/g, "/");
      }
      this.absolute = normalizeWindowsPath(opt.absolute || path7.resolve(this.cwd, p));
      if (this.path === "") {
        this.path = "./";
      }
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      const cs = this.statCache.get(this.absolute);
      if (cs) {
        this[ONLSTAT](cs);
      } else {
        this[LSTAT]();
      }
    }
    warn(code2, message, data = {}) {
      return warnMethod(this, code2, message, data);
    }
    emit(ev, ...data) {
      if (ev === "error") {
        this.#hadError = true;
      }
      return super.emit(ev, ...data);
    }
    [LSTAT]() {
      fs4.lstat(this.absolute, (er, stat2) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONLSTAT](stat2);
      });
    }
    [ONLSTAT](stat2) {
      this.statCache.set(this.absolute, stat2);
      this.stat = stat2;
      if (!stat2.isFile()) {
        stat2.size = 0;
      }
      this.type = getType(stat2);
      this.emit("stat", stat2);
      this[PROCESS]();
    }
    [PROCESS]() {
      switch (this.type) {
        case "File":
          return this[FILE]();
        case "Directory":
          return this[DIRECTORY]();
        case "SymbolicLink":
          return this[SYMLINK]();
        default:
          return this.end();
      }
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    [PREFIX](path8) {
      return prefixPath(path8, this.prefix);
    }
    [HEADER]() {
      if (!this.stat) {
        throw new Error("cannot write header before stat");
      }
      if (this.type === "Directory" && this.portable) {
        this.noMtime = true;
      }
      this.onWriteEntry?.(this);
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? undefined : this.stat.uid,
        gid: this.portable ? undefined : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,
        type: this.type === "Unsupported" ? undefined : this.type,
        uname: this.portable ? undefined : this.stat.uid === this.myuid ? this.myuser : "",
        atime: this.portable ? undefined : this.stat.atime,
        ctime: this.portable ? undefined : this.stat.ctime
      });
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? undefined : this.header.atime,
          ctime: this.portable ? undefined : this.header.ctime,
          gid: this.portable ? undefined : this.header.gid,
          mtime: this.noMtime ? undefined : this.mtime || this.header.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.header.size,
          uid: this.portable ? undefined : this.header.uid,
          uname: this.portable ? undefined : this.header.uname,
          dev: this.portable ? undefined : this.stat.dev,
          ino: this.portable ? undefined : this.stat.ino,
          nlink: this.portable ? undefined : this.stat.nlink
        }).encode());
      }
      const block = this.header?.block;
      if (!block) {
        throw new Error("failed to encode header");
      }
      super.write(block);
    }
    [DIRECTORY]() {
      if (!this.stat) {
        throw new Error("cannot create directory entry without stat");
      }
      if (this.path.slice(-1) !== "/") {
        this.path += "/";
      }
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [SYMLINK]() {
      fs4.readlink(this.absolute, (er, linkpath) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONREADLINK](linkpath);
      });
    }
    [ONREADLINK](linkpath) {
      this.linkpath = normalizeWindowsPath(linkpath);
      this[HEADER]();
      this.end();
    }
    [HARDLINK](linkpath) {
      if (!this.stat) {
        throw new Error("cannot create link entry without stat");
      }
      this.type = "Link";
      this.linkpath = normalizeWindowsPath(path7.relative(this.cwd, linkpath));
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [FILE]() {
      if (!this.stat) {
        throw new Error("cannot create file entry without stat");
      }
      if (this.stat.nlink > 1) {
        const linkKey = `${this.stat.dev}:${this.stat.ino}`;
        const linkpath = this.linkCache.get(linkKey);
        if (linkpath?.indexOf(this.cwd) === 0) {
          return this[HARDLINK](linkpath);
        }
        this.linkCache.set(linkKey, this.absolute);
      }
      this[HEADER]();
      if (this.stat.size === 0) {
        return this.end();
      }
      this[OPENFILE]();
    }
    [OPENFILE]() {
      fs4.open(this.absolute, "r", (er, fd) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONOPENFILE](fd);
      });
    }
    [ONOPENFILE](fd) {
      this.fd = fd;
      if (this.#hadError) {
        return this[CLOSE]();
      }
      if (!this.stat) {
        throw new Error("should stat before calling onopenfile");
      }
      this.blockLen = 512 * Math.ceil(this.stat.size / 512);
      this.blockRemain = this.blockLen;
      const bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen);
      this.offset = 0;
      this.pos = 0;
      this.remain = this.stat.size;
      this.length = this.buf.length;
      this[READ4]();
    }
    [READ4]() {
      const { fd, buf, offset, length, pos: pos2 } = this;
      if (fd === undefined || buf === undefined) {
        throw new Error("cannot read file without first opening");
      }
      fs4.read(fd, buf, offset, length, pos2, (er, bytesRead) => {
        if (er) {
          return this[CLOSE](() => this.emit("error", er));
        }
        this[ONREAD](bytesRead);
      });
    }
    [CLOSE](cb = () => {
    }) {
      if (this.fd !== undefined)
        fs4.close(this.fd, cb);
    }
    [ONREAD](bytesRead) {
      if (bytesRead <= 0 && this.remain > 0) {
        const er = Object.assign(new Error("encountered unexpected EOF"), {
          path: this.absolute,
          syscall: "read",
          code: "EOF"
        });
        return this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead > this.remain) {
        const er = Object.assign(new Error("did not encounter expected EOF"), {
          path: this.absolute,
          syscall: "read",
          code: "EOF"
        });
        return this[CLOSE](() => this.emit("error", er));
      }
      if (!this.buf) {
        throw new Error("should have created buffer prior to reading");
      }
      if (bytesRead === this.remain) {
        for (let i3 = bytesRead;i3 < this.length && bytesRead < this.blockRemain; i3++) {
          this.buf[i3 + this.offset] = 0;
          bytesRead++;
          this.remain++;
        }
      }
      const chunk = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.subarray(this.offset, this.offset + bytesRead);
      const flushed = this.write(chunk);
      if (!flushed) {
        this[AWAITDRAIN](() => this[ONDRAIN]());
      } else {
        this[ONDRAIN]();
      }
    }
    [AWAITDRAIN](cb) {
      this.once("drain", cb);
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
      }
      if (this.blockRemain < chunk.length) {
        const er = Object.assign(new Error("writing more data than expected"), {
          path: this.absolute
        });
        return this.emit("error", er);
      }
      this.remain -= chunk.length;
      this.blockRemain -= chunk.length;
      this.pos += chunk.length;
      this.offset += chunk.length;
      return super.write(chunk, null, cb);
    }
    [ONDRAIN]() {
      if (!this.remain) {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
      }
      if (!this.buf) {
        throw new Error("buffer lost somehow in ONDRAIN");
      }
      if (this.offset >= this.length) {
        this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
        this.offset = 0;
      }
      this.length = this.buf.length - this.offset;
      this[READ4]();
    }
  };
  WriteEntrySync = class WriteEntrySync extends WriteEntry {
    sync = true;
    [LSTAT]() {
      this[ONLSTAT](fs4.lstatSync(this.absolute));
    }
    [SYMLINK]() {
      this[ONREADLINK](fs4.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
      this[ONOPENFILE](fs4.openSync(this.absolute, "r"));
    }
    [READ4]() {
      let threw = true;
      try {
        const { fd, buf, offset, length, pos: pos2 } = this;
        if (fd === undefined || buf === undefined) {
          throw new Error("fd and buf must be set in READ method");
        }
        const bytesRead = fs4.readSync(fd, buf, offset, length, pos2);
        this[ONREAD](bytesRead);
        threw = false;
      } finally {
        if (threw) {
          try {
            this[CLOSE](() => {
            });
          } catch (er) {
          }
        }
      }
    }
    [AWAITDRAIN](cb) {
      cb();
    }
    [CLOSE](cb = () => {
    }) {
      if (this.fd !== undefined)
        fs4.closeSync(this.fd);
      cb();
    }
  };
  WriteEntryTar = class WriteEntryTar extends Minipass3 {
    blockLen = 0;
    blockRemain = 0;
    buf = 0;
    pos = 0;
    remain = 0;
    length = 0;
    preservePaths;
    portable;
    strict;
    noPax;
    noMtime;
    readEntry;
    type;
    prefix;
    path;
    mode;
    uid;
    gid;
    uname;
    gname;
    header;
    mtime;
    atime;
    ctime;
    linkpath;
    size;
    onWriteEntry;
    warn(code2, message, data = {}) {
      return warnMethod(this, code2, message, data);
    }
    constructor(readEntry, opt_ = {}) {
      const opt = dealias(opt_);
      super();
      this.preservePaths = !!opt.preservePaths;
      this.portable = !!opt.portable;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.onWriteEntry = opt.onWriteEntry;
      this.readEntry = readEntry;
      const { type: type2 } = readEntry;
      if (type2 === "Unsupported") {
        throw new Error("writing entry that should be ignored");
      }
      this.type = type2;
      if (this.type === "Directory" && this.portable) {
        this.noMtime = true;
      }
      this.prefix = opt.prefix;
      this.path = normalizeWindowsPath(readEntry.path);
      this.mode = readEntry.mode !== undefined ? this[MODE](readEntry.mode) : undefined;
      this.uid = this.portable ? undefined : readEntry.uid;
      this.gid = this.portable ? undefined : readEntry.gid;
      this.uname = this.portable ? undefined : readEntry.uname;
      this.gname = this.portable ? undefined : readEntry.gname;
      this.size = readEntry.size;
      this.mtime = this.noMtime ? undefined : opt.mtime || readEntry.mtime;
      this.atime = this.portable ? undefined : readEntry.atime;
      this.ctime = this.portable ? undefined : readEntry.ctime;
      this.linkpath = readEntry.linkpath !== undefined ? normalizeWindowsPath(readEntry.linkpath) : undefined;
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root && typeof stripped === "string") {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.remain = readEntry.size;
      this.blockRemain = readEntry.startBlockSize;
      this.onWriteEntry?.(this);
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this.mode,
        uid: this.portable ? undefined : this.uid,
        gid: this.portable ? undefined : this.gid,
        size: this.size,
        mtime: this.noMtime ? undefined : this.mtime,
        type: this.type,
        uname: this.portable ? undefined : this.uname,
        atime: this.portable ? undefined : this.atime,
        ctime: this.portable ? undefined : this.ctime
      });
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? undefined : this.atime,
          ctime: this.portable ? undefined : this.ctime,
          gid: this.portable ? undefined : this.gid,
          mtime: this.noMtime ? undefined : this.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.size,
          uid: this.portable ? undefined : this.uid,
          uname: this.portable ? undefined : this.uname,
          dev: this.portable ? undefined : this.readEntry.dev,
          ino: this.portable ? undefined : this.readEntry.ino,
          nlink: this.portable ? undefined : this.readEntry.nlink
        }).encode());
      }
      const b = this.header?.block;
      if (!b)
        throw new Error("failed to encode header");
      super.write(b);
      readEntry.pipe(this);
    }
    [PREFIX](path8) {
      return prefixPath(path8, this.prefix);
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
      }
      const writeLen = chunk.length;
      if (writeLen > this.blockRemain) {
        throw new Error("writing more to entry than is appropriate");
      }
      this.blockRemain -= writeLen;
      return super.write(chunk, cb);
    }
    end(chunk, encoding, cb) {
      if (this.blockRemain) {
        super.write(Buffer.alloc(this.blockRemain));
      }
      if (typeof chunk === "function") {
        cb = chunk;
        encoding = undefined;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding ?? "utf8");
      }
      if (cb)
        this.once("finish", cb);
      chunk ? super.end(chunk, cb) : super.end(cb);
      return this;
    }
  };
});

// node_modules/tar/dist/esm/pack.js
import fs5 from "fs";
import path8 from "path";

class PackJob {
  path;
  absolute;
  entry;
  stat;
  readdir;
  pending = false;
  ignore = false;
  piped = false;
  constructor(path9, absolute) {
    this.path = path9 || "./";
    this.absolute = absolute;
  }
}
var EOF4, ONSTAT, ENDED2, QUEUE2, CURRENT, PROCESS2, PROCESSING, PROCESSJOB, JOBS, JOBDONE, ADDFSENTRY, ADDTARENTRY, STAT, READDIR, ONREADDIR, PIPE, ENTRY, ENTRYOPT, WRITEENTRYCLASS, WRITE, ONDRAIN2, Pack, PackSync;
var init_pack = __esm(() => {
  init_write_entry();
  init_esm6();
  init_esm4();
  init_esm5();
  init_read_entry();
  init_normalize_windows_path();
  EOF4 = Buffer.alloc(1024);
  ONSTAT = Symbol("onStat");
  ENDED2 = Symbol("ended");
  QUEUE2 = Symbol("queue");
  CURRENT = Symbol("current");
  PROCESS2 = Symbol("process");
  PROCESSING = Symbol("processing");
  PROCESSJOB = Symbol("processJob");
  JOBS = Symbol("jobs");
  JOBDONE = Symbol("jobDone");
  ADDFSENTRY = Symbol("addFSEntry");
  ADDTARENTRY = Symbol("addTarEntry");
  STAT = Symbol("stat");
  READDIR = Symbol("readdir");
  ONREADDIR = Symbol("onreaddir");
  PIPE = Symbol("pipe");
  ENTRY = Symbol("entry");
  ENTRYOPT = Symbol("entryOpt");
  WRITEENTRYCLASS = Symbol("writeEntryClass");
  WRITE = Symbol("write");
  ONDRAIN2 = Symbol("ondrain");
  Pack = class Pack extends Minipass3 {
    opt;
    cwd;
    maxReadSize;
    preservePaths;
    strict;
    noPax;
    prefix;
    linkCache;
    statCache;
    file;
    portable;
    zip;
    readdirCache;
    noDirRecurse;
    follow;
    noMtime;
    mtime;
    filter;
    jobs;
    [WRITEENTRYCLASS];
    onWriteEntry;
    [QUEUE2];
    [JOBS] = 0;
    [PROCESSING] = false;
    [ENDED2] = false;
    constructor(opt = {}) {
      super();
      this.opt = opt;
      this.file = opt.file || "";
      this.cwd = opt.cwd || process.cwd();
      this.maxReadSize = opt.maxReadSize;
      this.preservePaths = !!opt.preservePaths;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.prefix = normalizeWindowsPath(opt.prefix || "");
      this.linkCache = opt.linkCache || new Map;
      this.statCache = opt.statCache || new Map;
      this.readdirCache = opt.readdirCache || new Map;
      this.onWriteEntry = opt.onWriteEntry;
      this[WRITEENTRYCLASS] = WriteEntry;
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      this.portable = !!opt.portable;
      if (opt.gzip || opt.brotli) {
        if (opt.gzip && opt.brotli) {
          throw new TypeError("gzip and brotli are mutually exclusive");
        }
        if (opt.gzip) {
          if (typeof opt.gzip !== "object") {
            opt.gzip = {};
          }
          if (this.portable) {
            opt.gzip.portable = true;
          }
          this.zip = new Gzip(opt.gzip);
        }
        if (opt.brotli) {
          if (typeof opt.brotli !== "object") {
            opt.brotli = {};
          }
          this.zip = new BrotliCompress(opt.brotli);
        }
        if (!this.zip)
          throw new Error("impossible");
        const zip2 = this.zip;
        zip2.on("data", (chunk) => super.write(chunk));
        zip2.on("end", () => super.end());
        zip2.on("drain", () => this[ONDRAIN2]());
        this.on("resume", () => zip2.resume());
      } else {
        this.on("drain", this[ONDRAIN2]);
      }
      this.noDirRecurse = !!opt.noDirRecurse;
      this.follow = !!opt.follow;
      this.noMtime = !!opt.noMtime;
      if (opt.mtime)
        this.mtime = opt.mtime;
      this.filter = typeof opt.filter === "function" ? opt.filter : () => true;
      this[QUEUE2] = new Yallist;
      this[JOBS] = 0;
      this.jobs = Number(opt.jobs) || 4;
      this[PROCESSING] = false;
      this[ENDED2] = false;
    }
    [WRITE](chunk) {
      return super.write(chunk);
    }
    add(path9) {
      this.write(path9);
      return this;
    }
    end(path9, encoding, cb) {
      if (typeof path9 === "function") {
        cb = path9;
        path9 = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (path9) {
        this.add(path9);
      }
      this[ENDED2] = true;
      this[PROCESS2]();
      if (cb)
        cb();
      return this;
    }
    write(path9) {
      if (this[ENDED2]) {
        throw new Error("write after end");
      }
      if (path9 instanceof ReadEntry) {
        this[ADDTARENTRY](path9);
      } else {
        this[ADDFSENTRY](path9);
      }
      return this.flowing;
    }
    [ADDTARENTRY](p) {
      const absolute = normalizeWindowsPath(path8.resolve(this.cwd, p.path));
      if (!this.filter(p.path, p)) {
        p.resume();
      } else {
        const job = new PackJob(p.path, absolute);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
        job.entry.on("end", () => this[JOBDONE](job));
        this[JOBS] += 1;
        this[QUEUE2].push(job);
      }
      this[PROCESS2]();
    }
    [ADDFSENTRY](p) {
      const absolute = normalizeWindowsPath(path8.resolve(this.cwd, p));
      this[QUEUE2].push(new PackJob(p, absolute));
      this[PROCESS2]();
    }
    [STAT](job) {
      job.pending = true;
      this[JOBS] += 1;
      const stat2 = this.follow ? "stat" : "lstat";
      fs5[stat2](job.absolute, (er, stat3) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er) {
          this.emit("error", er);
        } else {
          this[ONSTAT](job, stat3);
        }
      });
    }
    [ONSTAT](job, stat2) {
      this.statCache.set(job.absolute, stat2);
      job.stat = stat2;
      if (!this.filter(job.path, stat2)) {
        job.ignore = true;
      }
      this[PROCESS2]();
    }
    [READDIR](job) {
      job.pending = true;
      this[JOBS] += 1;
      fs5.readdir(job.absolute, (er, entries) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er) {
          return this.emit("error", er);
        }
        this[ONREADDIR](job, entries);
      });
    }
    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries);
      job.readdir = entries;
      this[PROCESS2]();
    }
    [PROCESS2]() {
      if (this[PROCESSING]) {
        return;
      }
      this[PROCESSING] = true;
      for (let w = this[QUEUE2].head;!!w && this[JOBS] < this.jobs; w = w.next) {
        this[PROCESSJOB](w.value);
        if (w.value.ignore) {
          const p = w.next;
          this[QUEUE2].removeNode(w);
          w.next = p;
        }
      }
      this[PROCESSING] = false;
      if (this[ENDED2] && !this[QUEUE2].length && this[JOBS] === 0) {
        if (this.zip) {
          this.zip.end(EOF4);
        } else {
          super.write(EOF4);
          super.end();
        }
      }
    }
    get [CURRENT]() {
      return this[QUEUE2] && this[QUEUE2].head && this[QUEUE2].head.value;
    }
    [JOBDONE](_job) {
      this[QUEUE2].shift();
      this[JOBS] -= 1;
      this[PROCESS2]();
    }
    [PROCESSJOB](job) {
      if (job.pending) {
        return;
      }
      if (job.entry) {
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
        return;
      }
      if (!job.stat) {
        const sc = this.statCache.get(job.absolute);
        if (sc) {
          this[ONSTAT](job, sc);
        } else {
          this[STAT](job);
        }
      }
      if (!job.stat) {
        return;
      }
      if (job.ignore) {
        return;
      }
      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        const rc = this.readdirCache.get(job.absolute);
        if (rc) {
          this[ONREADDIR](job, rc);
        } else {
          this[READDIR](job);
        }
        if (!job.readdir) {
          return;
        }
      }
      job.entry = this[ENTRY](job);
      if (!job.entry) {
        job.ignore = true;
        return;
      }
      if (job === this[CURRENT] && !job.piped) {
        this[PIPE](job);
      }
    }
    [ENTRYOPT](job) {
      return {
        onwarn: (code2, msg, data) => this.warn(code2, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime,
        prefix: this.prefix,
        onWriteEntry: this.onWriteEntry
      };
    }
    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        const e2 = new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job));
        return e2.on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }
    [ONDRAIN2]() {
      if (this[CURRENT] && this[CURRENT].entry) {
        this[CURRENT].entry.resume();
      }
    }
    [PIPE](job) {
      job.piped = true;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base2 = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base2 + entry);
        });
      }
      const source = job.entry;
      const zip2 = this.zip;
      if (!source)
        throw new Error("cannot pipe without source");
      if (zip2) {
        source.on("data", (chunk) => {
          if (!zip2.write(chunk)) {
            source.pause();
          }
        });
      } else {
        source.on("data", (chunk) => {
          if (!super.write(chunk)) {
            source.pause();
          }
        });
      }
    }
    pause() {
      if (this.zip) {
        this.zip.pause();
      }
      return super.pause();
    }
    warn(code2, message, data = {}) {
      warnMethod(this, code2, message, data);
    }
  };
  PackSync = class PackSync extends Pack {
    sync = true;
    constructor(opt) {
      super(opt);
      this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    pause() {
    }
    resume() {
    }
    [STAT](job) {
      const stat2 = this.follow ? "statSync" : "lstatSync";
      this[ONSTAT](job, fs5[stat2](job.absolute));
    }
    [READDIR](job) {
      this[ONREADDIR](job, fs5.readdirSync(job.absolute));
    }
    [PIPE](job) {
      const source = job.entry;
      const zip2 = this.zip;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base2 = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base2 + entry);
        });
      }
      if (!source)
        throw new Error("Cannot pipe without source");
      if (zip2) {
        source.on("data", (chunk) => {
          zip2.write(chunk);
        });
      } else {
        source.on("data", (chunk) => {
          super[WRITE](chunk);
        });
      }
    }
  };
});

// node_modules/tar/dist/esm/create.js
import path9 from "node:path";
var createFileSync = (opt, files2) => {
  const p = new PackSync(opt);
  const stream = new WriteStreamSync(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream);
  addFilesSync(p, files2);
}, createFile = (opt, files2) => {
  const p = new Pack(opt);
  const stream = new WriteStream(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream);
  const promise = new Promise((res, rej) => {
    stream.on("error", rej);
    stream.on("close", res);
    p.on("error", rej);
  });
  addFilesAsync(p, files2);
  return promise;
}, addFilesSync = (p, files2) => {
  files2.forEach((file) => {
    if (file.charAt(0) === "@") {
      list({
        file: path9.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onReadEntry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  });
  p.end();
}, addFilesAsync = async (p, files2) => {
  for (let i3 = 0;i3 < files2.length; i3++) {
    const file = String(files2[i3]);
    if (file.charAt(0) === "@") {
      await list({
        file: path9.resolve(String(p.cwd), file.slice(1)),
        noResume: true,
        onReadEntry: (entry) => {
          p.add(entry);
        }
      });
    } else {
      p.add(file);
    }
  }
  p.end();
}, createSync = (opt, files2) => {
  const p = new PackSync(opt);
  addFilesSync(p, files2);
  return p;
}, createAsync = (opt, files2) => {
  const p = new Pack(opt);
  addFilesAsync(p, files2);
  return p;
}, create;
var init_create2 = __esm(() => {
  init_esm2();
  init_list();
  init_make_command();
  init_pack();
  create = makeCommand(createFileSync, createFile, createSync, createAsync, (_opt, files2) => {
    if (!files2?.length) {
      throw new TypeError("no paths specified to add to archive");
    }
  });
});

// node_modules/tar/dist/esm/get-write-flag.js
import fs6 from "fs";
var platform3, isWindows, O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP, fMapEnabled, fMapLimit, fMapFlag, getWriteFlag;
var init_get_write_flag = __esm(() => {
  platform3 = process.env.__FAKE_PLATFORM__ || process.platform;
  isWindows = platform3 === "win32";
  ({ O_CREAT, O_TRUNC, O_WRONLY } = fs6.constants);
  UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) || fs6.constants.UV_FS_O_FILEMAP || 0;
  fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
  fMapLimit = 512 * 1024;
  fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
  getWriteFlag = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
});

// node_modules/chownr/dist/esm/index.js
import fs7 from "node:fs";
import path10 from "node:path";
var lchownSync = (path11, uid, gid) => {
  try {
    return fs7.lchownSync(path11, uid, gid);
  } catch (er) {
    if (er?.code !== "ENOENT")
      throw er;
  }
}, chown = (cpath, uid, gid, cb) => {
  fs7.lchown(cpath, uid, gid, (er) => {
    cb(er && er?.code !== "ENOENT" ? er : null);
  });
}, chownrKid = (p, child, uid, gid, cb) => {
  if (child.isDirectory()) {
    chownr(path10.resolve(p, child.name), uid, gid, (er) => {
      if (er)
        return cb(er);
      const cpath = path10.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    });
  } else {
    const cpath = path10.resolve(p, child.name);
    chown(cpath, uid, gid, cb);
  }
}, chownr = (p, uid, gid, cb) => {
  fs7.readdir(p, { withFileTypes: true }, (er, children) => {
    if (er) {
      if (er.code === "ENOENT")
        return cb();
      else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
        return cb(er);
    }
    if (er || !children.length)
      return chown(p, uid, gid, cb);
    let len = children.length;
    let errState = null;
    const then = (er2) => {
      if (errState)
        return;
      if (er2)
        return cb(errState = er2);
      if (--len === 0)
        return chown(p, uid, gid, cb);
    };
    for (const child of children) {
      chownrKid(p, child, uid, gid, then);
    }
  });
}, chownrKidSync = (p, child, uid, gid) => {
  if (child.isDirectory())
    chownrSync(path10.resolve(p, child.name), uid, gid);
  lchownSync(path10.resolve(p, child.name), uid, gid);
}, chownrSync = (p, uid, gid) => {
  let children;
  try {
    children = fs7.readdirSync(p, { withFileTypes: true });
  } catch (er) {
    const e2 = er;
    if (e2?.code === "ENOENT")
      return;
    else if (e2?.code === "ENOTDIR" || e2?.code === "ENOTSUP")
      return lchownSync(p, uid, gid);
    else
      throw e2;
  }
  for (const child of children) {
    chownrKidSync(p, child, uid, gid);
  }
  return lchownSync(p, uid, gid);
};
var init_esm7 = () => {
};

// node_modules/mkdirp/dist/mjs/opts-arg.js
import { mkdir, mkdirSync, stat as stat2, statSync as statSync3 } from "fs";
var optsArg = (opts) => {
  if (!opts) {
    opts = { mode: 511 };
  } else if (typeof opts === "object") {
    opts = { mode: 511, ...opts };
  } else if (typeof opts === "number") {
    opts = { mode: opts };
  } else if (typeof opts === "string") {
    opts = { mode: parseInt(opts, 8) };
  } else {
    throw new TypeError("invalid options argument");
  }
  const resolved = opts;
  const optsFs = opts.fs || {};
  opts.mkdir = opts.mkdir || optsFs.mkdir || mkdir;
  opts.mkdirAsync = opts.mkdirAsync ? opts.mkdirAsync : async (path11, options) => {
    return new Promise((res, rej) => resolved.mkdir(path11, options, (er, made) => er ? rej(er) : res(made)));
  };
  opts.stat = opts.stat || optsFs.stat || stat2;
  opts.statAsync = opts.statAsync ? opts.statAsync : async (path11) => new Promise((res, rej) => resolved.stat(path11, (err, stats) => err ? rej(err) : res(stats)));
  opts.statSync = opts.statSync || optsFs.statSync || statSync3;
  opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || mkdirSync;
  return resolved;
};
var init_opts_arg = () => {
};

// node_modules/mkdirp/dist/mjs/mkdirp-manual.js
import { dirname as dirname2 } from "path";
var mkdirpManualSync = (path11, options, made) => {
  const parent = dirname2(path11);
  const opts = { ...optsArg(options), recursive: false };
  if (parent === path11) {
    try {
      return opts.mkdirSync(path11, opts);
    } catch (er) {
      const fer = er;
      if (fer && fer.code !== "EISDIR") {
        throw er;
      }
      return;
    }
  }
  try {
    opts.mkdirSync(path11, opts);
    return made || path11;
  } catch (er) {
    const fer = er;
    if (fer && fer.code === "ENOENT") {
      return mkdirpManualSync(path11, opts, mkdirpManualSync(parent, opts, made));
    }
    if (fer && fer.code !== "EEXIST" && fer && fer.code !== "EROFS") {
      throw er;
    }
    try {
      if (!opts.statSync(path11).isDirectory())
        throw er;
    } catch (_) {
      throw er;
    }
  }
}, mkdirpManual;
var init_mkdirp_manual = __esm(() => {
  init_opts_arg();
  mkdirpManual = Object.assign(async (path11, options, made) => {
    const opts = optsArg(options);
    opts.recursive = false;
    const parent = dirname2(path11);
    if (parent === path11) {
      return opts.mkdirAsync(path11, opts).catch((er) => {
        const fer = er;
        if (fer && fer.code !== "EISDIR") {
          throw er;
        }
      });
    }
    return opts.mkdirAsync(path11, opts).then(() => made || path11, async (er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path11, opts, made2));
      }
      if (fer && fer.code !== "EEXIST" && fer.code !== "EROFS") {
        throw er;
      }
      return opts.statAsync(path11).then((st) => {
        if (st.isDirectory()) {
          return made;
        } else {
          throw er;
        }
      }, () => {
        throw er;
      });
    });
  }, { sync: mkdirpManualSync });
});

// node_modules/mkdirp/dist/mjs/find-made.js
import { dirname as dirname3 } from "path";
var findMade = async (opts, parent, path11) => {
  if (path11 === parent) {
    return;
  }
  return opts.statAsync(parent).then((st) => st.isDirectory() ? path11 : undefined, (er) => {
    const fer = er;
    return fer && fer.code === "ENOENT" ? findMade(opts, dirname3(parent), parent) : undefined;
  });
}, findMadeSync = (opts, parent, path11) => {
  if (path11 === parent) {
    return;
  }
  try {
    return opts.statSync(parent).isDirectory() ? path11 : undefined;
  } catch (er) {
    const fer = er;
    return fer && fer.code === "ENOENT" ? findMadeSync(opts, dirname3(parent), parent) : undefined;
  }
};
var init_find_made = () => {
};

// node_modules/mkdirp/dist/mjs/mkdirp-native.js
import { dirname as dirname4 } from "path";
var mkdirpNativeSync = (path11, options) => {
  const opts = optsArg(options);
  opts.recursive = true;
  const parent = dirname4(path11);
  if (parent === path11) {
    return opts.mkdirSync(path11, opts);
  }
  const made = findMadeSync(opts, path11);
  try {
    opts.mkdirSync(path11, opts);
    return made;
  } catch (er) {
    const fer = er;
    if (fer && fer.code === "ENOENT") {
      return mkdirpManualSync(path11, opts);
    } else {
      throw er;
    }
  }
}, mkdirpNative;
var init_mkdirp_native = __esm(() => {
  init_find_made();
  init_mkdirp_manual();
  init_opts_arg();
  mkdirpNative = Object.assign(async (path11, options) => {
    const opts = { ...optsArg(options), recursive: true };
    const parent = dirname4(path11);
    if (parent === path11) {
      return await opts.mkdirAsync(path11, opts);
    }
    return findMade(opts, path11).then((made) => opts.mkdirAsync(path11, opts).then((m2) => made || m2).catch((er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManual(path11, opts);
      } else {
        throw er;
      }
    }));
  }, { sync: mkdirpNativeSync });
});

// node_modules/mkdirp/dist/mjs/path-arg.js
import { parse as parse5, resolve } from "path";
var platform4, pathArg = (path11) => {
  if (/\0/.test(path11)) {
    throw Object.assign(new TypeError("path must be a string without null bytes"), {
      path: path11,
      code: "ERR_INVALID_ARG_VALUE"
    });
  }
  path11 = resolve(path11);
  if (platform4 === "win32") {
    const badWinChars = /[*|"<>?:]/;
    const { root } = parse5(path11);
    if (badWinChars.test(path11.substring(root.length))) {
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path11,
        code: "EINVAL"
      });
    }
  }
  return path11;
};
var init_path_arg = __esm(() => {
  platform4 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
});

// node_modules/mkdirp/dist/mjs/use-native.js
import { mkdir as mkdir2, mkdirSync as mkdirSync2 } from "fs";
var version, versArr, hasNative, useNativeSync, useNative;
var init_use_native = __esm(() => {
  init_opts_arg();
  version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  versArr = version.replace(/^v/, "").split(".");
  hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  useNativeSync = !hasNative ? () => false : (opts) => optsArg(opts).mkdirSync === mkdirSync2;
  useNative = Object.assign(!hasNative ? () => false : (opts) => optsArg(opts).mkdir === mkdir2, {
    sync: useNativeSync
  });
});

// node_modules/mkdirp/dist/mjs/index.js
var mkdirpSync = (path11, opts) => {
  path11 = pathArg(path11);
  const resolved = optsArg(opts);
  return useNativeSync(resolved) ? mkdirpNativeSync(path11, resolved) : mkdirpManualSync(path11, resolved);
}, mkdirp;
var init_mjs2 = __esm(() => {
  init_mkdirp_manual();
  init_mkdirp_native();
  init_opts_arg();
  init_path_arg();
  init_use_native();
  init_mkdirp_manual();
  init_mkdirp_native();
  init_use_native();
  mkdirp = Object.assign(async (path11, opts) => {
    path11 = pathArg(path11);
    const resolved = optsArg(opts);
    return useNative(resolved) ? mkdirpNative(path11, resolved) : mkdirpManual(path11, resolved);
  }, {
    mkdirpSync,
    mkdirpNative,
    mkdirpNativeSync,
    mkdirpManual,
    mkdirpManualSync,
    sync: mkdirpSync,
    native: mkdirpNative,
    nativeSync: mkdirpNativeSync,
    manual: mkdirpManual,
    manualSync: mkdirpManualSync,
    useNative,
    useNativeSync
  });
});

// node_modules/tar/dist/esm/cwd-error.js
var CwdError;
var init_cwd_error = __esm(() => {
  CwdError = class CwdError extends Error {
    path;
    code;
    syscall = "chdir";
    constructor(path11, code2) {
      super(`${code2}: Cannot cd into '${path11}'`);
      this.path = path11;
      this.code = code2;
    }
    get name() {
      return "CwdError";
    }
  };
});

// node_modules/tar/dist/esm/symlink-error.js
var SymlinkError;
var init_symlink_error = __esm(() => {
  SymlinkError = class SymlinkError extends Error {
    path;
    symlink;
    syscall = "symlink";
    code = "TAR_SYMLINK_ERROR";
    constructor(symlink, path11) {
      super("TAR_SYMLINK_ERROR: Cannot extract through symbolic link");
      this.symlink = symlink;
      this.path = path11;
    }
    get name() {
      return "SymlinkError";
    }
  };
});

// node_modules/tar/dist/esm/mkdir.js
import fs8 from "fs";
import path11 from "node:path";
var cGet = (cache, key) => cache.get(normalizeWindowsPath(key)), cSet = (cache, key, val) => cache.set(normalizeWindowsPath(key), val), checkCwd = (dir, cb) => {
  fs8.stat(dir, (er, st) => {
    if (er || !st.isDirectory()) {
      er = new CwdError(dir, er?.code || "ENOTDIR");
    }
    cb(er);
  });
}, mkdir3 = (dir, opt, cb) => {
  dir = normalizeWindowsPath(dir);
  const umask = opt.umask ?? 18;
  const mode = opt.mode | 448;
  const needChmod = (mode & umask) !== 0;
  const uid = opt.uid;
  const gid = opt.gid;
  const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
  const preserve = opt.preserve;
  const unlink = opt.unlink;
  const cache = opt.cache;
  const cwd = normalizeWindowsPath(opt.cwd);
  const done = (er, created) => {
    if (er) {
      cb(er);
    } else {
      cSet(cache, dir, true);
      if (created && doChown) {
        chownr(created, uid, gid, (er2) => done(er2));
      } else if (needChmod) {
        fs8.chmod(dir, mode, cb);
      } else {
        cb();
      }
    }
  };
  if (cache && cGet(cache, dir) === true) {
    return done();
  }
  if (dir === cwd) {
    return checkCwd(dir, done);
  }
  if (preserve) {
    return mkdirp(dir, { mode }).then((made) => done(null, made ?? undefined), done);
  }
  const sub = normalizeWindowsPath(path11.relative(cwd, dir));
  const parts = sub.split("/");
  mkdir_(cwd, parts, mode, cache, unlink, cwd, undefined, done);
}, mkdir_ = (base2, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length) {
    return cb(null, created);
  }
  const p = parts.shift();
  const part = normalizeWindowsPath(path11.resolve(base2 + "/" + p));
  if (cGet(cache, part)) {
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
  }
  fs8.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
}, onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
  if (er) {
    fs8.lstat(part, (statEr, st) => {
      if (statEr) {
        statEr.path = statEr.path && normalizeWindowsPath(statEr.path);
        cb(statEr);
      } else if (st.isDirectory()) {
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      } else if (unlink) {
        fs8.unlink(part, (er2) => {
          if (er2) {
            return cb(er2);
          }
          fs8.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
        });
      } else if (st.isSymbolicLink()) {
        return cb(new SymlinkError(part, part + "/" + parts.join("/")));
      } else {
        cb(er);
      }
    });
  } else {
    created = created || part;
    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
  }
}, checkCwdSync = (dir) => {
  let ok = false;
  let code2 = undefined;
  try {
    ok = fs8.statSync(dir).isDirectory();
  } catch (er) {
    code2 = er?.code;
  } finally {
    if (!ok) {
      throw new CwdError(dir, code2 ?? "ENOTDIR");
    }
  }
}, mkdirSync3 = (dir, opt) => {
  dir = normalizeWindowsPath(dir);
  const umask = opt.umask ?? 18;
  const mode = opt.mode | 448;
  const needChmod = (mode & umask) !== 0;
  const uid = opt.uid;
  const gid = opt.gid;
  const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
  const preserve = opt.preserve;
  const unlink = opt.unlink;
  const cache = opt.cache;
  const cwd = normalizeWindowsPath(opt.cwd);
  const done = (created2) => {
    cSet(cache, dir, true);
    if (created2 && doChown) {
      chownrSync(created2, uid, gid);
    }
    if (needChmod) {
      fs8.chmodSync(dir, mode);
    }
  };
  if (cache && cGet(cache, dir) === true) {
    return done();
  }
  if (dir === cwd) {
    checkCwdSync(cwd);
    return done();
  }
  if (preserve) {
    return done(mkdirpSync(dir, mode) ?? undefined);
  }
  const sub = normalizeWindowsPath(path11.relative(cwd, dir));
  const parts = sub.split("/");
  let created = undefined;
  for (let p = parts.shift(), part = cwd;p && (part += "/" + p); p = parts.shift()) {
    part = normalizeWindowsPath(path11.resolve(part));
    if (cGet(cache, part)) {
      continue;
    }
    try {
      fs8.mkdirSync(part, mode);
      created = created || part;
      cSet(cache, part, true);
    } catch (er) {
      const st = fs8.lstatSync(part);
      if (st.isDirectory()) {
        cSet(cache, part, true);
        continue;
      } else if (unlink) {
        fs8.unlinkSync(part);
        fs8.mkdirSync(part, mode);
        created = created || part;
        cSet(cache, part, true);
        continue;
      } else if (st.isSymbolicLink()) {
        return new SymlinkError(part, part + "/" + parts.join("/"));
      }
    }
  }
  return done(created);
};
var init_mkdir = __esm(() => {
  init_esm7();
  init_mjs2();
  init_cwd_error();
  init_normalize_windows_path();
  init_symlink_error();
});

// node_modules/tar/dist/esm/normalize-unicode.js
var normalizeCache, hasOwnProperty, normalizeUnicode = (s2) => {
  if (!hasOwnProperty.call(normalizeCache, s2)) {
    normalizeCache[s2] = s2.normalize("NFD");
  }
  return normalizeCache[s2];
};
var init_normalize_unicode = __esm(() => {
  normalizeCache = Object.create(null);
  ({ hasOwnProperty } = Object.prototype);
});

// node_modules/tar/dist/esm/path-reservations.js
import { join } from "node:path";

class PathReservations {
  #queues = new Map;
  #reservations = new Map;
  #running = new Set;
  reserve(paths, fn) {
    paths = isWindows2 ? ["win32 parallelization disabled"] : paths.map((p) => {
      return stripTrailingSlashes(join(normalizeUnicode(p))).toLowerCase();
    });
    const dirs = new Set(paths.map((path12) => getDirs(path12)).reduce((a2, b) => a2.concat(b)));
    this.#reservations.set(fn, { dirs, paths });
    for (const p of paths) {
      const q = this.#queues.get(p);
      if (!q) {
        this.#queues.set(p, [fn]);
      } else {
        q.push(fn);
      }
    }
    for (const dir of dirs) {
      const q = this.#queues.get(dir);
      if (!q) {
        this.#queues.set(dir, [new Set([fn])]);
      } else {
        const l = q[q.length - 1];
        if (l instanceof Set) {
          l.add(fn);
        } else {
          q.push(new Set([fn]));
        }
      }
    }
    return this.#run(fn);
  }
  #getQueues(fn) {
    const res = this.#reservations.get(fn);
    if (!res) {
      throw new Error("function does not have any path reservations");
    }
    return {
      paths: res.paths.map((path12) => this.#queues.get(path12)),
      dirs: [...res.dirs].map((path12) => this.#queues.get(path12))
    };
  }
  check(fn) {
    const { paths, dirs } = this.#getQueues(fn);
    return paths.every((q) => q && q[0] === fn) && dirs.every((q) => q && q[0] instanceof Set && q[0].has(fn));
  }
  #run(fn) {
    if (this.#running.has(fn) || !this.check(fn)) {
      return false;
    }
    this.#running.add(fn);
    fn(() => this.#clear(fn));
    return true;
  }
  #clear(fn) {
    if (!this.#running.has(fn)) {
      return false;
    }
    const res = this.#reservations.get(fn);
    if (!res) {
      throw new Error("invalid reservation");
    }
    const { paths, dirs } = res;
    const next = new Set;
    for (const path12 of paths) {
      const q = this.#queues.get(path12);
      if (!q || q?.[0] !== fn) {
        continue;
      }
      const q0 = q[1];
      if (!q0) {
        this.#queues.delete(path12);
        continue;
      }
      q.shift();
      if (typeof q0 === "function") {
        next.add(q0);
      } else {
        for (const f3 of q0) {
          next.add(f3);
        }
      }
    }
    for (const dir of dirs) {
      const q = this.#queues.get(dir);
      const q0 = q?.[0];
      if (!q || !(q0 instanceof Set))
        continue;
      if (q0.size === 1 && q.length === 1) {
        this.#queues.delete(dir);
        continue;
      } else if (q0.size === 1) {
        q.shift();
        const n2 = q[0];
        if (typeof n2 === "function") {
          next.add(n2);
        }
      } else {
        q0.delete(fn);
      }
    }
    this.#running.delete(fn);
    next.forEach((fn2) => this.#run(fn2));
    return true;
  }
}
var platform5, isWindows2, getDirs = (path12) => {
  const dirs = path12.split("/").slice(0, -1).reduce((set, path13) => {
    const s2 = set[set.length - 1];
    if (s2 !== undefined) {
      path13 = join(s2, path13);
    }
    set.push(path13 || "/");
    return set;
  }, []);
  return dirs;
};
var init_path_reservations = __esm(() => {
  init_normalize_unicode();
  platform5 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  isWindows2 = platform5 === "win32";
});

// node_modules/tar/dist/esm/unpack.js
import assert2 from "node:assert";
import { randomBytes } from "node:crypto";
import fs9 from "node:fs";
import path12 from "node:path";
var ONENTRY, CHECKFS, CHECKFS2, PRUNECACHE, ISREUSABLE, MAKEFS, FILE2, DIRECTORY2, LINK, SYMLINK2, HARDLINK2, UNSUPPORTED, CHECKPATH, MKDIR, ONERROR, PENDING, PEND, UNPEND, ENDED3, MAYBECLOSE, SKIP, DOCHOWN, UID, GID, CHECKED_CWD, platform6, isWindows3, DEFAULT_MAX_DEPTH = 1024, unlinkFile = (path13, cb) => {
  if (!isWindows3) {
    return fs9.unlink(path13, cb);
  }
  const name2 = path13 + ".DELETE." + randomBytes(16).toString("hex");
  fs9.rename(path13, name2, (er) => {
    if (er) {
      return cb(er);
    }
    fs9.unlink(name2, cb);
  });
}, unlinkFileSync = (path13) => {
  if (!isWindows3) {
    return fs9.unlinkSync(path13);
  }
  const name2 = path13 + ".DELETE." + randomBytes(16).toString("hex");
  fs9.renameSync(path13, name2);
  fs9.unlinkSync(name2);
}, uint32 = (a2, b, c3) => a2 !== undefined && a2 === a2 >>> 0 ? a2 : b !== undefined && b === b >>> 0 ? b : c3, cacheKeyNormalize = (path13) => stripTrailingSlashes(normalizeWindowsPath(normalizeUnicode(path13))).toLowerCase(), pruneCache = (cache, abs) => {
  abs = cacheKeyNormalize(abs);
  for (const path13 of cache.keys()) {
    const pnorm = cacheKeyNormalize(path13);
    if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
      cache.delete(path13);
    }
  }
}, dropCache = (cache) => {
  for (const key of cache.keys()) {
    cache.delete(key);
  }
}, Unpack, callSync = (fn) => {
  try {
    return [null, fn()];
  } catch (er) {
    return [er, null];
  }
}, UnpackSync;
var init_unpack = __esm(() => {
  init_esm2();
  init_get_write_flag();
  init_mkdir();
  init_normalize_unicode();
  init_normalize_windows_path();
  init_parse();
  init_strip_absolute_path();
  init_winchars();
  init_path_reservations();
  ONENTRY = Symbol("onEntry");
  CHECKFS = Symbol("checkFs");
  CHECKFS2 = Symbol("checkFs2");
  PRUNECACHE = Symbol("pruneCache");
  ISREUSABLE = Symbol("isReusable");
  MAKEFS = Symbol("makeFs");
  FILE2 = Symbol("file");
  DIRECTORY2 = Symbol("directory");
  LINK = Symbol("link");
  SYMLINK2 = Symbol("symlink");
  HARDLINK2 = Symbol("hardlink");
  UNSUPPORTED = Symbol("unsupported");
  CHECKPATH = Symbol("checkPath");
  MKDIR = Symbol("mkdir");
  ONERROR = Symbol("onError");
  PENDING = Symbol("pending");
  PEND = Symbol("pend");
  UNPEND = Symbol("unpend");
  ENDED3 = Symbol("ended");
  MAYBECLOSE = Symbol("maybeClose");
  SKIP = Symbol("skip");
  DOCHOWN = Symbol("doChown");
  UID = Symbol("uid");
  GID = Symbol("gid");
  CHECKED_CWD = Symbol("checkedCwd");
  platform6 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  isWindows3 = platform6 === "win32";
  Unpack = class Unpack extends Parser {
    [ENDED3] = false;
    [CHECKED_CWD] = false;
    [PENDING] = 0;
    reservations = new PathReservations;
    transform;
    writable = true;
    readable = false;
    dirCache;
    uid;
    gid;
    setOwner;
    preserveOwner;
    processGid;
    processUid;
    maxDepth;
    forceChown;
    win32;
    newer;
    keep;
    noMtime;
    preservePaths;
    unlink;
    cwd;
    strip;
    processUmask;
    umask;
    dmode;
    fmode;
    chmod;
    constructor(opt = {}) {
      opt.ondone = () => {
        this[ENDED3] = true;
        this[MAYBECLOSE]();
      };
      super(opt);
      this.transform = opt.transform;
      this.dirCache = opt.dirCache || new Map;
      this.chmod = !!opt.chmod;
      if (typeof opt.uid === "number" || typeof opt.gid === "number") {
        if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
          throw new TypeError("cannot set owner without number uid and gid");
        }
        if (opt.preserveOwner) {
          throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
        }
        this.uid = opt.uid;
        this.gid = opt.gid;
        this.setOwner = true;
      } else {
        this.uid = undefined;
        this.gid = undefined;
        this.setOwner = false;
      }
      if (opt.preserveOwner === undefined && typeof opt.uid !== "number") {
        this.preserveOwner = !!(process.getuid && process.getuid() === 0);
      } else {
        this.preserveOwner = !!opt.preserveOwner;
      }
      this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : undefined;
      this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : undefined;
      this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
      this.forceChown = opt.forceChown === true;
      this.win32 = !!opt.win32 || isWindows3;
      this.newer = !!opt.newer;
      this.keep = !!opt.keep;
      this.noMtime = !!opt.noMtime;
      this.preservePaths = !!opt.preservePaths;
      this.unlink = !!opt.unlink;
      this.cwd = normalizeWindowsPath(path12.resolve(opt.cwd || process.cwd()));
      this.strip = Number(opt.strip) || 0;
      this.processUmask = !this.chmod ? 0 : typeof opt.processUmask === "number" ? opt.processUmask : process.umask();
      this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
      this.dmode = opt.dmode || 511 & ~this.umask;
      this.fmode = opt.fmode || 438 & ~this.umask;
      this.on("entry", (entry) => this[ONENTRY](entry));
    }
    warn(code2, msg, data = {}) {
      if (code2 === "TAR_BAD_ARCHIVE" || code2 === "TAR_ABORT") {
        data.recoverable = false;
      }
      return super.warn(code2, msg, data);
    }
    [MAYBECLOSE]() {
      if (this[ENDED3] && this[PENDING] === 0) {
        this.emit("prefinish");
        this.emit("finish");
        this.emit("end");
      }
    }
    [CHECKPATH](entry) {
      const p = normalizeWindowsPath(entry.path);
      const parts = p.split("/");
      if (this.strip) {
        if (parts.length < this.strip) {
          return false;
        }
        if (entry.type === "Link") {
          const linkparts = normalizeWindowsPath(String(entry.linkpath)).split("/");
          if (linkparts.length >= this.strip) {
            entry.linkpath = linkparts.slice(this.strip).join("/");
          } else {
            return false;
          }
        }
        parts.splice(0, this.strip);
        entry.path = parts.join("/");
      }
      if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
        this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
          entry,
          path: p,
          depth: parts.length,
          maxDepth: this.maxDepth
        });
        return false;
      }
      if (!this.preservePaths) {
        if (parts.includes("..") || isWindows3 && /^[a-z]:\.\.$/i.test(parts[0] ?? "")) {
          this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
            entry,
            path: p
          });
          return false;
        }
        const [root, stripped] = stripAbsolutePath(p);
        if (root) {
          entry.path = String(stripped);
          this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
            entry,
            path: p
          });
        }
      }
      if (path12.isAbsolute(entry.path)) {
        entry.absolute = normalizeWindowsPath(path12.resolve(entry.path));
      } else {
        entry.absolute = normalizeWindowsPath(path12.resolve(this.cwd, entry.path));
      }
      if (!this.preservePaths && typeof entry.absolute === "string" && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
        this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
          entry,
          path: normalizeWindowsPath(entry.path),
          resolvedPath: entry.absolute,
          cwd: this.cwd
        });
        return false;
      }
      if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
        return false;
      }
      if (this.win32) {
        const { root: aRoot } = path12.win32.parse(String(entry.absolute));
        entry.absolute = aRoot + encode2(String(entry.absolute).slice(aRoot.length));
        const { root: pRoot } = path12.win32.parse(entry.path);
        entry.path = pRoot + encode2(entry.path.slice(pRoot.length));
      }
      return true;
    }
    [ONENTRY](entry) {
      if (!this[CHECKPATH](entry)) {
        return entry.resume();
      }
      assert2.equal(typeof entry.absolute, "string");
      switch (entry.type) {
        case "Directory":
        case "GNUDumpDir":
          if (entry.mode) {
            entry.mode = entry.mode | 448;
          }
        case "File":
        case "OldFile":
        case "ContiguousFile":
        case "Link":
        case "SymbolicLink":
          return this[CHECKFS](entry);
        case "CharacterDevice":
        case "BlockDevice":
        case "FIFO":
        default:
          return this[UNSUPPORTED](entry);
      }
    }
    [ONERROR](er, entry) {
      if (er.name === "CwdError") {
        this.emit("error", er);
      } else {
        this.warn("TAR_ENTRY_ERROR", er, { entry });
        this[UNPEND]();
        entry.resume();
      }
    }
    [MKDIR](dir, mode, cb) {
      mkdir3(normalizeWindowsPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode
      }, cb);
    }
    [DOCHOWN](entry) {
      return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid;
    }
    [UID](entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
    [FILE2](entry, fullyDone) {
      const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.fmode;
      const stream = new WriteStream(String(entry.absolute), {
        flags: getWriteFlag(entry.size),
        mode,
        autoClose: false
      });
      stream.on("error", (er) => {
        if (stream.fd) {
          fs9.close(stream.fd, () => {
          });
        }
        stream.write = () => true;
        this[ONERROR](er, entry);
        fullyDone();
      });
      let actions = 1;
      const done = (er) => {
        if (er) {
          if (stream.fd) {
            fs9.close(stream.fd, () => {
            });
          }
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        if (--actions === 0) {
          if (stream.fd !== undefined) {
            fs9.close(stream.fd, (er2) => {
              if (er2) {
                this[ONERROR](er2, entry);
              } else {
                this[UNPEND]();
              }
              fullyDone();
            });
          }
        }
      };
      stream.on("finish", () => {
        const abs = String(entry.absolute);
        const fd = stream.fd;
        if (typeof fd === "number" && entry.mtime && !this.noMtime) {
          actions++;
          const atime = entry.atime || new Date;
          const mtime = entry.mtime;
          fs9.futimes(fd, atime, mtime, (er) => er ? fs9.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
        }
        if (typeof fd === "number" && this[DOCHOWN](entry)) {
          actions++;
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          if (typeof uid === "number" && typeof gid === "number") {
            fs9.fchown(fd, uid, gid, (er) => er ? fs9.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
        }
        done();
      });
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => {
          this[ONERROR](er, entry);
          fullyDone();
        });
        entry.pipe(tx);
      }
      tx.pipe(stream);
    }
    [DIRECTORY2](entry, fullyDone) {
      const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.dmode;
      this[MKDIR](String(entry.absolute), mode, (er) => {
        if (er) {
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        let actions = 1;
        const done = () => {
          if (--actions === 0) {
            fullyDone();
            this[UNPEND]();
            entry.resume();
          }
        };
        if (entry.mtime && !this.noMtime) {
          actions++;
          fs9.utimes(String(entry.absolute), entry.atime || new Date, entry.mtime, done);
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          fs9.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);
        }
        done();
      });
    }
    [UNSUPPORTED](entry) {
      entry.unsupported = true;
      this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
      entry.resume();
    }
    [SYMLINK2](entry, done) {
      this[LINK](entry, String(entry.linkpath), "symlink", done);
    }
    [HARDLINK2](entry, done) {
      const linkpath = normalizeWindowsPath(path12.resolve(this.cwd, String(entry.linkpath)));
      this[LINK](entry, linkpath, "link", done);
    }
    [PEND]() {
      this[PENDING]++;
    }
    [UNPEND]() {
      this[PENDING]--;
      this[MAYBECLOSE]();
    }
    [SKIP](entry) {
      this[UNPEND]();
      entry.resume();
    }
    [ISREUSABLE](entry, st) {
      return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows3;
    }
    [CHECKFS](entry) {
      this[PEND]();
      const paths = [entry.path];
      if (entry.linkpath) {
        paths.push(entry.linkpath);
      }
      this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
    }
    [PRUNECACHE](entry) {
      if (entry.type === "SymbolicLink") {
        dropCache(this.dirCache);
      } else if (entry.type !== "Directory") {
        pruneCache(this.dirCache, String(entry.absolute));
      }
    }
    [CHECKFS2](entry, fullyDone) {
      this[PRUNECACHE](entry);
      const done = (er) => {
        this[PRUNECACHE](entry);
        fullyDone(er);
      };
      const checkCwd2 = () => {
        this[MKDIR](this.cwd, this.dmode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            done();
            return;
          }
          this[CHECKED_CWD] = true;
          start();
        });
      };
      const start = () => {
        if (entry.absolute !== this.cwd) {
          const parent = normalizeWindowsPath(path12.dirname(String(entry.absolute)));
          if (parent !== this.cwd) {
            return this[MKDIR](parent, this.dmode, (er) => {
              if (er) {
                this[ONERROR](er, entry);
                done();
                return;
              }
              afterMakeParent();
            });
          }
        }
        afterMakeParent();
      };
      const afterMakeParent = () => {
        fs9.lstat(String(entry.absolute), (lstatEr, st) => {
          if (st && (this.keep || this.newer && st.mtime > (entry.mtime ?? st.mtime))) {
            this[SKIP](entry);
            done();
            return;
          }
          if (lstatEr || this[ISREUSABLE](entry, st)) {
            return this[MAKEFS](null, entry, done);
          }
          if (st.isDirectory()) {
            if (entry.type === "Directory") {
              const needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode;
              const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);
              if (!needChmod) {
                return afterChmod();
              }
              return fs9.chmod(String(entry.absolute), Number(entry.mode), afterChmod);
            }
            if (entry.absolute !== this.cwd) {
              return fs9.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
            }
          }
          if (entry.absolute === this.cwd) {
            return this[MAKEFS](null, entry, done);
          }
          unlinkFile(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
        });
      };
      if (this[CHECKED_CWD]) {
        start();
      } else {
        checkCwd2();
      }
    }
    [MAKEFS](er, entry, done) {
      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }
      switch (entry.type) {
        case "File":
        case "OldFile":
        case "ContiguousFile":
          return this[FILE2](entry, done);
        case "Link":
          return this[HARDLINK2](entry, done);
        case "SymbolicLink":
          return this[SYMLINK2](entry, done);
        case "Directory":
        case "GNUDumpDir":
          return this[DIRECTORY2](entry, done);
      }
    }
    [LINK](entry, linkpath, link, done) {
      fs9[link](linkpath, String(entry.absolute), (er) => {
        if (er) {
          this[ONERROR](er, entry);
        } else {
          this[UNPEND]();
          entry.resume();
        }
        done();
      });
    }
  };
  UnpackSync = class UnpackSync extends Unpack {
    sync = true;
    [MAKEFS](er, entry) {
      return super[MAKEFS](er, entry, () => {
      });
    }
    [CHECKFS](entry) {
      this[PRUNECACHE](entry);
      if (!this[CHECKED_CWD]) {
        const er2 = this[MKDIR](this.cwd, this.dmode);
        if (er2) {
          return this[ONERROR](er2, entry);
        }
        this[CHECKED_CWD] = true;
      }
      if (entry.absolute !== this.cwd) {
        const parent = normalizeWindowsPath(path12.dirname(String(entry.absolute)));
        if (parent !== this.cwd) {
          const mkParent = this[MKDIR](parent, this.dmode);
          if (mkParent) {
            return this[ONERROR](mkParent, entry);
          }
        }
      }
      const [lstatEr, st] = callSync(() => fs9.lstatSync(String(entry.absolute)));
      if (st && (this.keep || this.newer && st.mtime > (entry.mtime ?? st.mtime))) {
        return this[SKIP](entry);
      }
      if (lstatEr || this[ISREUSABLE](entry, st)) {
        return this[MAKEFS](null, entry);
      }
      if (st.isDirectory()) {
        if (entry.type === "Directory") {
          const needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode;
          const [er3] = needChmod ? callSync(() => {
            fs9.chmodSync(String(entry.absolute), Number(entry.mode));
          }) : [];
          return this[MAKEFS](er3, entry);
        }
        const [er2] = callSync(() => fs9.rmdirSync(String(entry.absolute)));
        this[MAKEFS](er2, entry);
      }
      const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(String(entry.absolute)));
      this[MAKEFS](er, entry);
    }
    [FILE2](entry, done) {
      const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.fmode;
      const oner = (er) => {
        let closeError;
        try {
          fs9.closeSync(fd);
        } catch (e2) {
          closeError = e2;
        }
        if (er || closeError) {
          this[ONERROR](er || closeError, entry);
        }
        done();
      };
      let fd;
      try {
        fd = fs9.openSync(String(entry.absolute), getWriteFlag(entry.size), mode);
      } catch (er) {
        return oner(er);
      }
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => this[ONERROR](er, entry));
        entry.pipe(tx);
      }
      tx.on("data", (chunk) => {
        try {
          fs9.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      });
      tx.on("end", () => {
        let er = null;
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || new Date;
          const mtime = entry.mtime;
          try {
            fs9.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs9.utimesSync(String(entry.absolute), atime, mtime);
            } catch (utimeser) {
              er = futimeser;
            }
          }
        }
        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          try {
            fs9.fchownSync(fd, Number(uid), Number(gid));
          } catch (fchowner) {
            try {
              fs9.chownSync(String(entry.absolute), Number(uid), Number(gid));
            } catch (chowner) {
              er = er || fchowner;
            }
          }
        }
        oner(er);
      });
    }
    [DIRECTORY2](entry, done) {
      const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.dmode;
      const er = this[MKDIR](String(entry.absolute), mode);
      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }
      if (entry.mtime && !this.noMtime) {
        try {
          fs9.utimesSync(String(entry.absolute), entry.atime || new Date, entry.mtime);
        } catch (er2) {
        }
      }
      if (this[DOCHOWN](entry)) {
        try {
          fs9.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));
        } catch (er2) {
        }
      }
      done();
      entry.resume();
    }
    [MKDIR](dir, mode) {
      try {
        return mkdirSync3(normalizeWindowsPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode
        });
      } catch (er) {
        return er;
      }
    }
    [LINK](entry, linkpath, link, done) {
      const ls = `${link}Sync`;
      try {
        fs9[ls](linkpath, String(entry.absolute));
        done();
        entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  };
});

// node_modules/tar/dist/esm/extract.js
import fs10 from "node:fs";
var extractFileSync = (opt) => {
  const u2 = new UnpackSync(opt);
  const file = opt.file;
  const stat3 = fs10.statSync(file);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const stream = new ReadStreamSync(file, {
    readSize,
    size: stat3.size
  });
  stream.pipe(u2);
}, extractFile = (opt, _) => {
  const u2 = new Unpack(opt);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const file = opt.file;
  const p = new Promise((resolve2, reject) => {
    u2.on("error", reject);
    u2.on("close", resolve2);
    fs10.stat(file, (er, stat3) => {
      if (er) {
        reject(er);
      } else {
        const stream = new ReadStream(file, {
          readSize,
          size: stat3.size
        });
        stream.on("error", reject);
        stream.pipe(u2);
      }
    });
  });
  return p;
}, extract;
var init_extract = __esm(() => {
  init_esm2();
  init_list();
  init_make_command();
  init_unpack();
  extract = makeCommand(extractFileSync, extractFile, (opt) => new UnpackSync(opt), (opt) => new Unpack(opt), (opt, files2) => {
    if (files2?.length)
      filesFilter(opt, files2);
  });
});

// node_modules/tar/dist/esm/replace.js
import fs11 from "node:fs";
import path13 from "node:path";
var replaceSync = (opt, files2) => {
  const p = new PackSync(opt);
  let threw = true;
  let fd;
  let position2;
  try {
    try {
      fd = fs11.openSync(opt.file, "r+");
    } catch (er) {
      if (er?.code === "ENOENT") {
        fd = fs11.openSync(opt.file, "w+");
      } else {
        throw er;
      }
    }
    const st = fs11.fstatSync(fd);
    const headBuf = Buffer.alloc(512);
    POSITION:
      for (position2 = 0;position2 < st.size; position2 += 512) {
        for (let bufPos = 0, bytes = 0;bufPos < 512; bufPos += bytes) {
          bytes = fs11.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position2 + bufPos);
          if (position2 === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            throw new Error("cannot append to compressed archives");
          }
          if (!bytes) {
            break POSITION;
          }
        }
        const h3 = new Header(headBuf);
        if (!h3.cksumValid) {
          break;
        }
        const entryBlockSize = 512 * Math.ceil((h3.size || 0) / 512);
        if (position2 + entryBlockSize + 512 > st.size) {
          break;
        }
        position2 += entryBlockSize;
        if (opt.mtimeCache && h3.mtime) {
          opt.mtimeCache.set(String(h3.path), h3.mtime);
        }
      }
    threw = false;
    streamSync(opt, p, position2, fd, files2);
  } finally {
    if (threw) {
      try {
        fs11.closeSync(fd);
      } catch (er) {
      }
    }
  }
}, streamSync = (opt, p, position2, fd, files2) => {
  const stream = new WriteStreamSync(opt.file, {
    fd,
    start: position2
  });
  p.pipe(stream);
  addFilesSync2(p, files2);
}, replaceAsync = (opt, files2) => {
  files2 = Array.from(files2);
  const p = new Pack(opt);
  const getPos = (fd, size, cb_) => {
    const cb = (er, pos2) => {
      if (er) {
        fs11.close(fd, (_) => cb_(er));
      } else {
        cb_(null, pos2);
      }
    };
    let position2 = 0;
    if (size === 0) {
      return cb(null, 0);
    }
    let bufPos = 0;
    const headBuf = Buffer.alloc(512);
    const onread = (er, bytes) => {
      if (er || typeof bytes === "undefined") {
        return cb(er);
      }
      bufPos += bytes;
      if (bufPos < 512 && bytes) {
        return fs11.read(fd, headBuf, bufPos, headBuf.length - bufPos, position2 + bufPos, onread);
      }
      if (position2 === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
        return cb(new Error("cannot append to compressed archives"));
      }
      if (bufPos < 512) {
        return cb(null, position2);
      }
      const h3 = new Header(headBuf);
      if (!h3.cksumValid) {
        return cb(null, position2);
      }
      const entryBlockSize = 512 * Math.ceil((h3.size ?? 0) / 512);
      if (position2 + entryBlockSize + 512 > size) {
        return cb(null, position2);
      }
      position2 += entryBlockSize + 512;
      if (position2 >= size) {
        return cb(null, position2);
      }
      if (opt.mtimeCache && h3.mtime) {
        opt.mtimeCache.set(String(h3.path), h3.mtime);
      }
      bufPos = 0;
      fs11.read(fd, headBuf, 0, 512, position2, onread);
    };
    fs11.read(fd, headBuf, 0, 512, position2, onread);
  };
  const promise = new Promise((resolve2, reject) => {
    p.on("error", reject);
    let flag = "r+";
    const onopen = (er, fd) => {
      if (er && er.code === "ENOENT" && flag === "r+") {
        flag = "w+";
        return fs11.open(opt.file, flag, onopen);
      }
      if (er || !fd) {
        return reject(er);
      }
      fs11.fstat(fd, (er2, st) => {
        if (er2) {
          return fs11.close(fd, () => reject(er2));
        }
        getPos(fd, st.size, (er3, position2) => {
          if (er3) {
            return reject(er3);
          }
          const stream = new WriteStream(opt.file, {
            fd,
            start: position2
          });
          p.pipe(stream);
          stream.on("error", reject);
          stream.on("close", resolve2);
          addFilesAsync2(p, files2);
        });
      });
    };
    fs11.open(opt.file, flag, onopen);
  });
  return promise;
}, addFilesSync2 = (p, files2) => {
  files2.forEach((file) => {
    if (file.charAt(0) === "@") {
      list({
        file: path13.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onReadEntry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  });
  p.end();
}, addFilesAsync2 = async (p, files2) => {
  for (let i3 = 0;i3 < files2.length; i3++) {
    const file = String(files2[i3]);
    if (file.charAt(0) === "@") {
      await list({
        file: path13.resolve(String(p.cwd), file.slice(1)),
        noResume: true,
        onReadEntry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  }
  p.end();
}, replace;
var init_replace = __esm(() => {
  init_esm2();
  init_header();
  init_list();
  init_make_command();
  init_options2();
  init_pack();
  replace = makeCommand(replaceSync, replaceAsync, () => {
    throw new TypeError("file is required");
  }, () => {
    throw new TypeError("file is required");
  }, (opt, entries) => {
    if (!isFile(opt)) {
      throw new TypeError("file is required");
    }
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
      throw new TypeError("cannot append to compressed archives");
    }
    if (!entries?.length) {
      throw new TypeError("no paths specified to add/replace");
    }
  });
});

// node_modules/tar/dist/esm/update.js
var update, mtimeFilter = (opt) => {
  const filter = opt.filter;
  if (!opt.mtimeCache) {
    opt.mtimeCache = new Map;
  }
  opt.filter = filter ? (path14, stat3) => filter(path14, stat3) && !((opt.mtimeCache?.get(path14) ?? stat3.mtime ?? 0) > (stat3.mtime ?? 0)) : (path14, stat3) => !((opt.mtimeCache?.get(path14) ?? stat3.mtime ?? 0) > (stat3.mtime ?? 0));
};
var init_update = __esm(() => {
  init_make_command();
  init_replace();
  update = makeCommand(replace.syncFile, replace.asyncFile, replace.syncNoFile, replace.asyncNoFile, (opt, entries = []) => {
    replace.validate?.(opt, entries);
    mtimeFilter(opt);
  });
});

// node_modules/tar/dist/esm/index.js
var init_esm8 = __esm(() => {
  init_create2();
  init_create2();
  init_extract();
  init_extract();
  init_header();
  init_list();
  init_list();
  init_pack();
  init_parse();
  init_pax();
  init_read_entry();
  init_replace();
  init_replace();
  init_types();
  init_unpack();
  init_update();
  init_update();
  init_write_entry();
});

// src/provisioning/bin.ts
import * as crypto2 from "crypto";
import * as fs12 from "fs";
import * as os2 from "os";
import * as path14 from "path";
import * as process11 from "process";
import readline from "readline";
import { fileURLToPath as fileURLToPath3 } from "url";

class Bin {
  _subProcess;
  binPath;
  cliVersion;
  cacheDir = path14.join(`${process11.env.XDG_CACHE_HOME?.trim() || envPaths("", { suffix: "" }).cache}`, "dagger");
  DAGGER_CLI_BIN_PREFIX = "dagger";
  constructor(binPath, cliVersion) {
    this.binPath = binPath;
    this.cliVersion = cliVersion;
  }
  Addr() {
    return "http://dagger";
  }
  get subProcess() {
    return this._subProcess;
  }
  async Connect(opts) {
    if (!this.binPath) {
      if (opts.LogOutput) {
        opts.LogOutput.write("Downloading CLI... ");
      }
      this.binPath = await this.downloadCLI();
      if (opts.LogOutput) {
        opts.LogOutput.write(`OK!
`);
      }
    }
    return this.runEngineSession(this.binPath, opts);
  }
  async downloadCLI() {
    if (!this.cliVersion) {
      throw new Error("cliVersion is not set");
    }
    const binPath = this.buildBinPath();
    this.createCacheDir();
    const tmpBinDownloadDir = fs12.mkdtempSync(path14.join(this.cacheDir, `temp-${this.getRandomId()}`));
    const tmpBinPath = this.buildOsExePath(tmpBinDownloadDir, this.DAGGER_CLI_BIN_PREFIX);
    try {
      const actualChecksum = await this.extractArchive(tmpBinDownloadDir, this.normalizedOS());
      const expectedChecksum = await this.expectedChecksum();
      if (actualChecksum !== expectedChecksum) {
        throw new Error(`checksum mismatch: expected ${expectedChecksum}, got ${actualChecksum}`);
      }
      fs12.chmodSync(tmpBinPath, 448);
      fs12.renameSync(tmpBinPath, binPath);
      fs12.rmSync(tmpBinDownloadDir, { recursive: true });
    } catch (e2) {
      fs12.rmSync(tmpBinDownloadDir, { recursive: true });
      throw new InitEngineSessionBinaryError(`failed to download dagger cli binary: ${e2}`, {
        cause: e2
      });
    }
    try {
      const files2 = fs12.readdirSync(this.cacheDir);
      files2.forEach((file) => {
        const filePath = path14.join(this.cacheDir, file);
        if (filePath === binPath || !file.startsWith(this.DAGGER_CLI_BIN_PREFIX)) {
          return;
        }
        fs12.unlinkSync(filePath);
      });
    } catch {
      console.error("could not clean up temporary binary files");
    }
    return binPath;
  }
  getSDKVersion() {
    const currentFileUrl = import.meta.url;
    const currentFilePath = fileURLToPath3(currentFileUrl);
    let currentPath = path14.dirname(currentFilePath);
    while (currentPath !== path14.parse(currentPath).root) {
      const packageJsonPath = path14.join(currentPath, "package.json");
      if (fs12.existsSync(packageJsonPath)) {
        try {
          const packageJsonContent = fs12.readFileSync(packageJsonPath, "utf8");
          const packageJson = JSON.parse(packageJsonContent);
          return packageJson.version;
        } catch {
          return "n/a";
        }
      } else {
        currentPath = path14.join(currentPath, "..");
      }
    }
  }
  async runEngineSession(binPath, opts) {
    const args = ["session"];
    const sdkVersion = this.getSDKVersion();
    const flagsAndValues = [
      { flag: "--workdir", value: opts.Workdir },
      { flag: "--project", value: opts.Project },
      { flag: "--label", value: "dagger.io/sdk.name:nodejs" },
      { flag: "--label", value: `dagger.io/sdk.version:${sdkVersion}` }
    ];
    flagsAndValues.forEach((pair) => {
      if (pair.value) {
        args.push(pair.flag, pair.value);
      }
    });
    if (opts.LogOutput) {
      opts.LogOutput.write("Creating new Engine session... ");
    }
    this._subProcess = execa(binPath, args, {
      stdio: "pipe",
      reject: true,
      cleanup: true,
      forceKillAfterDelay: 300000
    });
    if (opts.LogOutput) {
      this._subProcess.stderr?.pipe(opts.LogOutput);
    }
    const stdoutReader = readline.createInterface({
      input: this._subProcess?.stdout
    });
    const timeOutDuration = 300000;
    if (opts.LogOutput) {
      opts.LogOutput.write(`OK!
Establishing connection to Engine... `);
    }
    const connectParams = await Promise.race([
      this.readConnectParams(stdoutReader),
      new Promise((_, reject) => {
        setTimeout(() => {
          reject(new EngineSessionConnectionTimeoutError("Engine connection timeout", {
            timeOutDuration
          }));
        }, timeOutDuration).unref();
      })
    ]);
    if (opts.LogOutput) {
      opts.LogOutput.write(`OK!
`);
    }
    return createGQLClient(connectParams.port, connectParams.session_token);
  }
  async readConnectParams(stdoutReader) {
    for await (const line of stdoutReader) {
      const connectParams = JSON.parse(line);
      if (connectParams.port && connectParams.session_token) {
        return connectParams;
      }
      throw new EngineSessionConnectParamsParseError(`invalid connect params: ${line}`, {
        parsedLine: line
      });
    }
    try {
      await this.subProcess;
    } catch {
      this.subProcess?.catch((e2) => {
        throw new EngineSessionError(e2.stderr);
      });
    }
  }
  async Close() {
    if (this.subProcess?.pid) {
      this.subProcess.kill("SIGTERM");
    }
  }
  createCacheDir() {
    fs12.mkdirSync(this.cacheDir, { mode: 448, recursive: true });
  }
  buildBinPath() {
    return this.buildOsExePath(this.cacheDir, `${this.DAGGER_CLI_BIN_PREFIX}-${this.cliVersion}`);
  }
  buildOsExePath(destinationDir, filename) {
    const binPath = path14.join(destinationDir, filename);
    switch (this.normalizedOS()) {
      case "windows":
        return `${binPath}.exe`;
      default:
        return binPath;
    }
  }
  normalizedArch() {
    switch (os2.arch()) {
      case "x64":
        return "amd64";
      default:
        return os2.arch();
    }
  }
  normalizedOS() {
    switch (os2.platform()) {
      case "win32":
        return "windows";
      default:
        return os2.platform();
    }
  }
  cliArchiveName() {
    if (OVERRIDE_CLI_URL && OVERRIDE_CLI_URL != "") {
      return path14.basename(new URL(OVERRIDE_CLI_URL).pathname);
    }
    let ext = "tar.gz";
    if (this.normalizedOS() === "windows") {
      ext = "zip";
    }
    return `dagger_v${this.cliVersion}_${this.normalizedOS()}_${this.normalizedArch()}.${ext}`;
  }
  cliArchiveURL() {
    if (OVERRIDE_CLI_URL && OVERRIDE_CLI_URL != "") {
      return OVERRIDE_CLI_URL;
    }
    return `https://${CLI_HOST}/dagger/releases/${this.cliVersion}/${this.cliArchiveName()}`;
  }
  cliChecksumURL() {
    if (OVERRIDE_CHECKSUMS_URL && OVERRIDE_CHECKSUMS_URL != "") {
      return OVERRIDE_CHECKSUMS_URL;
    }
    return `https://${CLI_HOST}/dagger/releases/${this.cliVersion}/checksums.txt`;
  }
  async checksumMap() {
    const checksums = await fetch2(this.cliChecksumURL());
    if (!checksums.ok) {
      throw new Error(`failed to download checksums.txt from ${this.cliChecksumURL()}`);
    }
    const checksumsText = await checksums.text();
    const checksumMap = new Map;
    for (const line of checksumsText.split(`
`)) {
      const [checksum, filename] = line.split(/\s+/);
      checksumMap.set(filename, checksum);
    }
    return checksumMap;
  }
  async expectedChecksum() {
    const checksumMap = await this.checksumMap();
    const expectedChecksum = checksumMap.get(this.cliArchiveName());
    if (!expectedChecksum) {
      throw new Error(`failed to find checksum for ${this.cliArchiveName()} in checksums.txt`);
    }
    return expectedChecksum;
  }
  async extractArchive(destDir, os3) {
    const archiveResp = await fetch2(this.cliArchiveURL());
    if (!archiveResp.ok) {
      throw new Error(`failed to download dagger cli archive from ${this.cliArchiveURL()}`);
    }
    if (!archiveResp.body) {
      throw new Error("archive response body is null");
    }
    const archivePath = path14.join(destDir, os3 === "windows" ? "dagger.zip" : "dagger.tar.gz");
    const archiveFile = fs12.createWriteStream(archivePath);
    await new Promise((resolve2, reject) => {
      archiveResp.body?.pipe(archiveFile);
      archiveResp.body?.on("error", reject);
      archiveFile.on("finish", () => resolve2(undefined));
    });
    const actualChecksum = crypto2.createHash("sha256").update(fs12.readFileSync(archivePath)).digest("hex");
    if (os3 === "windows") {
      const zip2 = new import_adm_zip.default(archivePath);
      zip2.extractEntryTo("dagger.exe", destDir, false, true);
    } else {
      extract({
        cwd: destDir,
        file: archivePath,
        sync: true
      });
    }
    return actualChecksum;
  }
  getRandomId() {
    return process11.hrtime.bigint().toString();
  }
}
var import_adm_zip, OVERRIDE_CLI_URL = "", OVERRIDE_CHECKSUMS_URL = "", CLI_HOST = "dl.dagger.io";
var init_bin = __esm(() => {
  import_adm_zip = __toESM(require_adm_zip(), 1);
  init_env_paths();
  init_execa();
  init_src();
  init_esm8();
  init_errors();
  init_client();
});

// src/provisioning/default.ts
var CLI_VERSION = "0.18.12";

// src/provisioning/index.ts
var exports_provisioning = {};
__export(exports_provisioning, {
  withEngineSession: () => withEngineSession
});
async function withEngineSession(connectOpts, cb) {
  const cliBin = process.env["_EXPERIMENTAL_DAGGER_CLI_BIN"];
  const engineConn = new Bin(cliBin, CLI_VERSION);
  const gqlClient = await engineConn.Connect(connectOpts);
  try {
    const res = await cb(gqlClient);
    return res;
  } finally {
    await engineConn.Close();
  }
}
var init_provisioning = __esm(() => {
  init_bin();
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS(() => {
  /*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Reflect2;
  (function(Reflect3) {
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect !== "undefined") {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter, root);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect3;
      }
      function makeExporter(target, previous) {
        return function(key, value) {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
          if (previous)
            previous(key, value);
        };
      }
      function functionThis() {
        try {
          return Function("return this;")();
        } catch (_) {
        }
      }
      function indirectEvalThis() {
        try {
          return (undefined, eval)("(function() { return this; })()");
        } catch (_) {
        }
      }
      function sloppyModeThis() {
        return functionThis() || indirectEvalThis();
      }
    })(function(exporter, root) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        create: supportsCreate ? function() {
          return MakeDictionary(Object.create(null));
        } : supportsProto ? function() {
          return MakeDictionary({ __proto__: null });
        } : function() {
          return MakeDictionary({});
        },
        has: downLevel ? function(map, key) {
          return hasOwn.call(map, key);
        } : function(map, key) {
          return key in map;
        },
        get: downLevel ? function(map, key) {
          return hasOwn.call(map, key) ? map[key] : undefined;
        } : function(map, key) {
          return map[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : undefined;
      var metadataRegistry = GetOrCreateMetadataRegistry();
      var metadataProvider = CreateMetadataProvider(metadataRegistry);
      function decorate(decorators2, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators2))
            throw new TypeError;
          if (!IsObject(target))
            throw new TypeError;
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
            throw new TypeError;
          if (IsNull(attributes))
            attributes = undefined;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators2, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators2))
            throw new TypeError;
          if (!IsConstructor(target))
            throw new TypeError;
          return DecorateConstructor(decorators2, target);
        }
      }
      exporter("decorate", decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator2(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError;
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
            throw new TypeError;
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator2;
      }
      exporter("metadata", metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        var provider = GetMetadataProvider(target, propertyKey, false);
        if (IsUndefined(provider))
          return false;
        return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators2, target) {
        for (var i3 = decorators2.length - 1;i3 >= 0; --i3) {
          var decorator2 = decorators2[i3];
          var decorated = decorator2(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated))
              throw new TypeError;
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators2, target, propertyKey, descriptor) {
        for (var i3 = decorators2.length - 1;i3 >= 0; --i3) {
          var decorator2 = decorators2[i3];
          var decorated = decorator2(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated))
              throw new TypeError;
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider))
          return false;
        return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryGetMetadata(MetadataKey, parent, P);
        return;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider))
          return;
        return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var provider = GetMetadataProvider(O, P, true);
        provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
      }
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
          return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
          return ownKeys;
        if (ownKeys.length <= 0)
          return parentKeys;
        var set = new _Set;
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys;_i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys;_a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (!provider) {
          return [];
        }
        return provider.OrdinaryOwnMetadataKeys(O, P);
      }
      function Type(x2) {
        if (x2 === null)
          return 1;
        switch (typeof x2) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return x2 === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x2) {
        return x2 === undefined;
      }
      function IsNull(x2) {
        return x2 === null;
      }
      function IsSymbol(x2) {
        return typeof x2 === "symbol";
      }
      function IsObject(x2) {
        return typeof x2 === "object" ? x2 !== null : typeof x2 === "function";
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result))
            throw new TypeError;
          return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result))
              return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
        } else {
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject(result))
              return result;
          }
        }
        throw new TypeError;
      }
      function ToBoolean(argument2) {
        return !!argument2;
      }
      function ToString(argument2) {
        return "" + argument2;
      }
      function ToPropertyKey(argument2) {
        var key = ToPrimitive(argument2, 3);
        if (IsSymbol(key))
          return key;
        return ToString(key);
      }
      function IsArray(argument2) {
        return Array.isArray ? Array.isArray(argument2) : argument2 instanceof Object ? argument2 instanceof Array : Object.prototype.toString.call(argument2) === "[object Array]";
      }
      function IsCallable(argument2) {
        return typeof argument2 === "function";
      }
      function IsConstructor(argument2) {
        return typeof argument2 === "function";
      }
      function IsPropertyKey(argument2) {
        switch (Type(argument2)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function SameValueZero(x2, y) {
        return x2 === y || x2 !== x2 && y !== y;
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
          return;
        if (!IsCallable(func))
          throw new TypeError;
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
          throw new TypeError;
        var iterator = method.call(obj);
        if (!IsObject(iterator))
          throw new TypeError;
        return iterator;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator) {
        var f3 = iterator["return"];
        if (f3)
          f3.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
          return proto;
        if (proto !== functionPrototype)
          return proto;
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
          return proto;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
          return proto;
        if (constructor === O)
          return proto;
        return constructor;
      }
      function CreateMetadataRegistry() {
        var fallback;
        if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
          fallback = CreateFallbackProvider(root.Reflect);
        }
        var first;
        var second;
        var rest;
        var targetProviderMap = new _WeakMap;
        var registry = {
          registerProvider,
          getProvider,
          setProvider
        };
        return registry;
        function registerProvider(provider) {
          if (!Object.isExtensible(registry)) {
            throw new Error("Cannot add provider to a frozen registry.");
          }
          switch (true) {
            case fallback === provider:
              break;
            case IsUndefined(first):
              first = provider;
              break;
            case first === provider:
              break;
            case IsUndefined(second):
              second = provider;
              break;
            case second === provider:
              break;
            default:
              if (rest === undefined)
                rest = new _Set;
              rest.add(provider);
              break;
          }
        }
        function getProviderNoCache(O, P) {
          if (!IsUndefined(first)) {
            if (first.isProviderFor(O, P))
              return first;
            if (!IsUndefined(second)) {
              if (second.isProviderFor(O, P))
                return first;
              if (!IsUndefined(rest)) {
                var iterator = GetIterator(rest);
                while (true) {
                  var next = IteratorStep(iterator);
                  if (!next) {
                    return;
                  }
                  var provider = IteratorValue(next);
                  if (provider.isProviderFor(O, P)) {
                    IteratorClose(iterator);
                    return provider;
                  }
                }
              }
            }
          }
          if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
            return fallback;
          }
          return;
        }
        function getProvider(O, P) {
          var providerMap = targetProviderMap.get(O);
          var provider;
          if (!IsUndefined(providerMap)) {
            provider = providerMap.get(P);
          }
          if (!IsUndefined(provider)) {
            return provider;
          }
          provider = getProviderNoCache(O, P);
          if (!IsUndefined(provider)) {
            if (IsUndefined(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return provider;
        }
        function hasProvider(provider) {
          if (IsUndefined(provider))
            throw new TypeError;
          return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
        }
        function setProvider(O, P, provider) {
          if (!hasProvider(provider)) {
            throw new Error("Metadata provider not registered.");
          }
          var existingProvider = getProvider(O, P);
          if (existingProvider !== provider) {
            if (!IsUndefined(existingProvider)) {
              return false;
            }
            var providerMap = targetProviderMap.get(O);
            if (IsUndefined(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return true;
        }
      }
      function GetOrCreateMetadataRegistry() {
        var metadataRegistry2;
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          metadataRegistry2 = root.Reflect[registrySymbol];
        }
        if (IsUndefined(metadataRegistry2)) {
          metadataRegistry2 = CreateMetadataRegistry();
        }
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          Object.defineProperty(root.Reflect, registrySymbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: metadataRegistry2
          });
        }
        return metadataRegistry2;
      }
      function CreateMetadataProvider(registry) {
        var metadata2 = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var targetMetadata = metadata2.get(O);
            if (IsUndefined(targetMetadata))
              return false;
            return targetMetadata.has(P);
          },
          OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
          OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
          OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
          OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
          OrdinaryDeleteMetadata
        };
        metadataRegistry.registerProvider(provider);
        return provider;
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = metadata2.get(O);
          var createdTargetMetadata = false;
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return;
            targetMetadata = new _Map;
            metadata2.set(O, targetMetadata);
            createdTargetMetadata = true;
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return;
            metadataMap = new _Map;
            targetMetadata.set(P, metadataMap);
            if (!registry.setProvider(O, P, provider)) {
              targetMetadata.delete(P);
              if (createdTargetMetadata) {
                metadata2.delete(O);
              }
              throw new Error("Wrong provider for target.");
            }
          }
          return metadataMap;
        }
        function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryOwnMetadataKeys2(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e2) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e2;
              }
            }
            k++;
          }
        }
        function OrdinaryDeleteMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(MetadataKey))
            return false;
          if (metadataMap.size === 0) {
            var targetMetadata = metadata2.get(O);
            if (!IsUndefined(targetMetadata)) {
              targetMetadata.delete(P);
              if (targetMetadata.size === 0) {
                metadata2.delete(targetMetadata);
              }
            }
          }
          return true;
        }
      }
      function CreateFallbackProvider(reflect) {
        var { defineMetadata: defineMetadata2, hasOwnMetadata: hasOwnMetadata2, getOwnMetadata: getOwnMetadata2, getOwnMetadataKeys: getOwnMetadataKeys2, deleteMetadata: deleteMetadata2 } = reflect;
        var metadataOwner = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var metadataPropertySet = metadataOwner.get(O);
            if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
              return true;
            }
            if (getOwnMetadataKeys2(O, P).length) {
              if (IsUndefined(metadataPropertySet)) {
                metadataPropertySet = new _Set;
                metadataOwner.set(O, metadataPropertySet);
              }
              metadataPropertySet.add(P);
              return true;
            }
            return false;
          },
          OrdinaryDefineOwnMetadata: defineMetadata2,
          OrdinaryHasOwnMetadata: hasOwnMetadata2,
          OrdinaryGetOwnMetadata: getOwnMetadata2,
          OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
          OrdinaryDeleteMetadata: deleteMetadata2
        };
        return provider;
      }
      function GetMetadataProvider(O, P, Create) {
        var registeredProvider = metadataRegistry.getProvider(O, P);
        if (!IsUndefined(registeredProvider)) {
          return registeredProvider;
        }
        if (Create) {
          if (metadataRegistry.setProvider(O, P, metadataProvider)) {
            return metadataProvider;
          }
          throw new Error("Illegal state.");
        }
        return;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: undefined, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }();
        var Map2 = function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(key, false) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(key, false);
            return index >= 0 ? this._values[index] : undefined;
          };
          Map3.prototype.set = function(key, value) {
            var index = this._find(key, true);
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(key, false);
            if (index >= 0) {
              var size = this._keys.length;
              for (var i3 = index + 1;i3 < size; i3++) {
                this._keys[i3 - 1] = this._keys[i3];
                this._values[i3 - 1] = this._values[i3];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i3 = 0;i3 < this._keys.length; i3++) {
                if (SameValueZero(this._keys[i3], key)) {
                  this._cacheIndex = i3;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(undefined);
            }
            return this._cacheIndex;
          };
          return Map3;
        }();
        return Map2;
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        var Set2 = function() {
          function Set3() {
            this._map = new _Map;
          }
          Object.defineProperty(Set3.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set3.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set3.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }();
        return Set2;
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.get(table, this._key) : undefined;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(target, true);
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }();
        function CreateUniqueKey() {
          var key;
          do
            key = "@@WeakMap@@" + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create3) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create3)
              return;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i3 = 0;i3 < size; ++i3)
            buffer[i3] = Math.random() * 255 | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            var array = new Uint8Array(size);
            if (typeof crypto !== "undefined") {
              crypto.getRandomValues(array);
            } else if (typeof msCrypto !== "undefined") {
              msCrypto.getRandomValues(array);
            } else {
              FillRandomBytes(array, size);
            }
            return array;
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = data[6] & 79 | 64;
          data[8] = data[8] & 191 | 128;
          var result = "";
          for (var offset = 0;offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8)
              result += "-";
            if (byte < 16)
              result += "0";
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));
});

// src/index.ts
init_main();

// src/telemetry/telemetry.ts
var opentelemetry2 = __toESM(require_src(), 1);

// src/telemetry/init.ts
var import_core = __toESM(require_src3(), 1);
var import_sdk_node = __toESM(require_src32(), 1);
var SERVICE_NAME = "dagger-typescript-sdk";
function otelConfigured() {
  return Object.keys(process.env).some((key) => key.startsWith("OTEL_"));
}

class DaggerOtelConfigurator {
  is_configured = false;
  sdk;
  initialize() {
    if (this.is_configured) {
      return;
    }
    this.configure();
    this.is_configured = true;
  }
  configure() {
    if (!otelConfigured()) {
      return;
    }
    if (import_core.getBooleanFromEnv("OTEL_SDK_DISABLED") ?? true) {
      return;
    }
    this.setupEnv();
    this.sdk = new import_sdk_node.NodeSDK({
      serviceName: SERVICE_NAME
    });
    this.sdk.start();
  }
  async close() {
    if (this.sdk) {
      this.sdk.shutdown();
    }
  }
  setupEnv() {
    Object.entries(process.env).forEach(([key, value]) => {
      if (key.startsWith("OTEL_") && key.endsWith("_ENDPOINT") && value?.startsWith("http://")) {
        const insecure = key.replace(/_ENDPOINT$/, "_INSECURE");
        if (process.env[insecure] === undefined) {
          process.env[insecure] = "true";
        }
      }
    });
  }
}

// src/telemetry/tracer.ts
var opentelemetry = __toESM(require_src(), 1);

class Tracer {
  tracer;
  constructor(name) {
    this.tracer = opentelemetry.trace.getTracer(name);
  }
  startSpan(name, attributes) {
    return this.tracer.startSpan(name, { attributes });
  }
  async startActiveSpan(name, fn, attributes) {
    return this.tracer.startActiveSpan(name, { attributes }, async (span) => {
      try {
        return await fn(span);
      } catch (e) {
        if (e instanceof Error) {
          span.recordException(e);
          span.setStatus({
            code: opentelemetry.SpanStatusCode.ERROR,
            message: e.message
          });
        }
        throw e;
      } finally {
        span.end();
      }
    });
  }
}

// src/telemetry/telemetry.ts
var DAGGER_TRACER_NAME = "dagger.io/sdk.typescript";
var configurator = new DaggerOtelConfigurator;
function initialize() {
  configurator.initialize();
}
async function close() {
  await configurator.close();
}
function getTracer(name = DAGGER_TRACER_NAME) {
  initialize();
  return new Tracer(name);
}
function getContext() {
  const ctx = opentelemetry2.context.active();
  const spanCtx = opentelemetry2.trace.getSpanContext(ctx);
  if (spanCtx && opentelemetry2.trace.isSpanContextValid(spanCtx)) {
    return ctx;
  }
  const parentID = process.env.TRACEPARENT;
  if (parentID) {
    return opentelemetry2.propagation.extract(ctx, {
      traceparent: parentID
    });
  }
  return ctx;
}
// src/common/graphql/compute_query.ts
init_main();
init_errors();
function buildArgs(args) {
  const metadata = args.__metadata || {};
  const formatValue = (key, value) => {
    if (metadata[key]?.is_enum) {
      return JSON.stringify(value).replace(/['"]+/g, "");
    }
    return JSON.stringify(value).replace(/\{"[a-zA-Z]+":|,"[a-zA-Z]+":/gi, (str) => {
      return str.replace(/"/g, "");
    });
  };
  if (args === undefined || args === null) {
    return "";
  }
  const formattedArgs = Object.entries(args).reduce((acc, [key, value]) => {
    if (key === "__metadata") {
      return acc;
    }
    if (value !== undefined && value !== null) {
      acc.push(`${key}: ${formatValue(key, value)}`);
    }
    return acc;
  }, []);
  if (formattedArgs.length === 0) {
    return "";
  }
  return `(${formattedArgs})`;
}
async function computeNestedQuery(query, client) {
  const isQueryTree = (value) => value["_ctx"] !== undefined;
  const isArrayQueryTree = (value) => value.every((v) => v instanceof Object && isQueryTree(v));
  const computeQueryTree = async (value) => {
    for (const op of value["_ctx"]["_queryTree"]) {
      await computeNestedQuery([op], client);
    }
    return buildQuery([
      ...value["_ctx"]["_queryTree"],
      {
        operation: "id"
      }
    ]);
  };
  const queryToExec = query.filter((q) => !!q.args);
  for (const q of queryToExec) {
    await Promise.all(Object.entries(q.args).map(async ([key, value]) => {
      if (value instanceof Object && isQueryTree(value)) {
        const getQueryTree = await computeQueryTree(value);
        q.args[key] = await compute(getQueryTree, client);
      }
      if (Array.isArray(value) && isArrayQueryTree(value)) {
        const tmp = q.args[key];
        for (let i = 0;i < value.length; i++) {
          const getQueryTree = await computeQueryTree(value[i]);
          tmp[i] = await compute(getQueryTree, client);
        }
        q.args[key] = tmp;
      }
    }));
  }
}
function buildQuery(q) {
  const query = q.reduce((acc, { operation, args }, i) => {
    const qLen = q.length;
    acc += ` ${operation} ${args ? `${buildArgs(args)}` : ""} ${qLen - 1 !== i ? "{" : "}".repeat(qLen - 1)}`;
    return acc;
  }, "");
  return `{${query} }`;
}
async function computeQuery(q, client) {
  await computeNestedQuery(q, client);
  const query = buildQuery(q);
  return await compute(query, client);
}
function queryFlatten(response) {
  if (!(response instanceof Object) || Array.isArray(response)) {
    return response;
  }
  const keys = Object.keys(response);
  if (keys.length != 1) {
    throw new TooManyNestedObjectsError("Too many nested objects inside graphql response", {
      response
    });
  }
  const nestedKey = keys[0];
  return queryFlatten(response[nestedKey]);
}
async function compute(query, client) {
  let computeQuery2;
  try {
    computeQuery2 = await client.request(gql`
      ${query}
    `);
  } catch (e) {
    if (e instanceof ClientError) {
      const msg = e.response.errors?.[0]?.message ?? `API Error`;
      const ext = e.response.errors?.[0]?.extensions;
      if (ext?._type === "EXEC_ERROR") {
        throw new ExecError(msg, {
          cmd: ext.cmd ?? [],
          exitCode: ext.exitCode ?? -1,
          stdout: ext.stdout ?? "",
          stderr: ext.stderr ?? "",
          extensions: ext
        });
      }
      throw new GraphQLRequestError(msg, {
        error: e,
        cause: e
      });
    }
    if (e.errno === "ECONNREFUSED") {
      throw new NotAwaitedRequestError("Encountered an error while requesting data via graphql through a synchronous call. Make sure the function called is awaited.", { cause: e });
    }
    throw new UnknownDaggerError("Encountered an unknown error while requesting data via graphql", {
      cause: e
    });
  }
  return queryFlatten(computeQuery2);
}

// src/common/graphql/connection.ts
class Connection {
  _gqlClient;
  constructor(_gqlClient) {
    this._gqlClient = _gqlClient;
  }
  resetClient() {
    this._gqlClient = undefined;
  }
  setGQLClient(gqlClient) {
    this._gqlClient = gqlClient;
  }
  getGQLClient() {
    if (!this._gqlClient) {
      throw new Error("GraphQL client is not set");
    }
    return this._gqlClient;
  }
}
var globalConnection = new Connection;

// src/common/context.ts
class Context {
  _queryTree;
  _connection;
  constructor(_queryTree = [], _connection = globalConnection) {
    this._queryTree = _queryTree;
    this._connection = _connection;
  }
  getGQLClient() {
    return this._connection.getGQLClient();
  }
  copy() {
    return new Context([], this._connection);
  }
  select(operation, args) {
    return new Context([...this._queryTree, { operation, args }], this._connection);
  }
  execute() {
    return computeQuery(this._queryTree, this._connection.getGQLClient());
  }
}

// src/api/client.gen.ts
class BaseClient {
  _ctx;
  constructor(_ctx = new Context) {
    this._ctx = _ctx;
  }
}
var CacheSharingMode;
((CacheSharingMode2) => {
  CacheSharingMode2["Locked"] = "LOCKED";
  CacheSharingMode2["Private"] = "PRIVATE";
  CacheSharingMode2["Shared"] = "SHARED";
})(CacheSharingMode ||= {});
var ImageLayerCompression;
((ImageLayerCompression2) => {
  ImageLayerCompression2["Estargz"] = "EStarGZ";
  ImageLayerCompression2["Gzip"] = "Gzip";
  ImageLayerCompression2["Uncompressed"] = "Uncompressed";
  ImageLayerCompression2["Zstd"] = "Zstd";
})(ImageLayerCompression ||= {});
var ImageMediaTypes;
((ImageMediaTypes2) => {
  ImageMediaTypes2["Docker"] = "DOCKER";
  ImageMediaTypes2["Dockermediatypes"] = "DockerMediaTypes";
  ImageMediaTypes2["Oci"] = "OCI";
  ImageMediaTypes2["Ocimediatypes"] = "OCIMediaTypes";
})(ImageMediaTypes ||= {});
var ModuleSourceKind;
((ModuleSourceKind2) => {
  ModuleSourceKind2["Dir"] = "DIR";
  ModuleSourceKind2["DirSource"] = "DIR_SOURCE";
  ModuleSourceKind2["Git"] = "GIT";
  ModuleSourceKind2["GitSource"] = "GIT_SOURCE";
  ModuleSourceKind2["Local"] = "LOCAL";
  ModuleSourceKind2["LocalSource"] = "LOCAL_SOURCE";
})(ModuleSourceKind ||= {});
var NetworkProtocol;
((NetworkProtocol2) => {
  NetworkProtocol2["Tcp"] = "TCP";
  NetworkProtocol2["Udp"] = "UDP";
})(NetworkProtocol ||= {});
var ReturnType;
((ReturnType2) => {
  ReturnType2["Any"] = "ANY";
  ReturnType2["Failure"] = "FAILURE";
  ReturnType2["Success"] = "SUCCESS";
})(ReturnType ||= {});
var TypeDefKind;
((TypeDefKind2) => {
  TypeDefKind2["Boolean"] = "BOOLEAN";
  TypeDefKind2["BooleanKind"] = "BOOLEAN_KIND";
  TypeDefKind2["Enum"] = "ENUM";
  TypeDefKind2["EnumKind"] = "ENUM_KIND";
  TypeDefKind2["Float"] = "FLOAT";
  TypeDefKind2["FloatKind"] = "FLOAT_KIND";
  TypeDefKind2["Input"] = "INPUT";
  TypeDefKind2["InputKind"] = "INPUT_KIND";
  TypeDefKind2["Integer"] = "INTEGER";
  TypeDefKind2["IntegerKind"] = "INTEGER_KIND";
  TypeDefKind2["Interface"] = "INTERFACE";
  TypeDefKind2["InterfaceKind"] = "INTERFACE_KIND";
  TypeDefKind2["List"] = "LIST";
  TypeDefKind2["ListKind"] = "LIST_KIND";
  TypeDefKind2["Object"] = "OBJECT";
  TypeDefKind2["ObjectKind"] = "OBJECT_KIND";
  TypeDefKind2["Scalar"] = "SCALAR";
  TypeDefKind2["ScalarKind"] = "SCALAR_KIND";
  TypeDefKind2["String"] = "STRING";
  TypeDefKind2["StringKind"] = "STRING_KIND";
  TypeDefKind2["Void"] = "VOID";
  TypeDefKind2["VoidKind"] = "VOID_KIND";
})(TypeDefKind ||= {});

class Binding extends BaseClient {
  _id = undefined;
  _asString = undefined;
  _digest = undefined;
  _isNull = undefined;
  _name = undefined;
  _typeName = undefined;
  constructor(ctx, _id, _asString, _digest, _isNull, _name, _typeName) {
    super(ctx);
    this._id = _id;
    this._asString = _asString;
    this._digest = _digest;
    this._isNull = _isNull;
    this._name = _name;
    this._typeName = _typeName;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  asCacheVolume = () => {
    const ctx = this._ctx.select("asCacheVolume");
    return new CacheVolume(ctx);
  };
  asCloud = () => {
    const ctx = this._ctx.select("asCloud");
    return new Cloud(ctx);
  };
  asContainer = () => {
    const ctx = this._ctx.select("asContainer");
    return new Container(ctx);
  };
  asDirectory = () => {
    const ctx = this._ctx.select("asDirectory");
    return new Directory(ctx);
  };
  asEnv = () => {
    const ctx = this._ctx.select("asEnv");
    return new Env(ctx);
  };
  asFile = () => {
    const ctx = this._ctx.select("asFile");
    return new File(ctx);
  };
  asGitRef = () => {
    const ctx = this._ctx.select("asGitRef");
    return new GitRef(ctx);
  };
  asGitRepository = () => {
    const ctx = this._ctx.select("asGitRepository");
    return new GitRepository(ctx);
  };
  asLLM = () => {
    const ctx = this._ctx.select("asLLM");
    return new LLM(ctx);
  };
  asModule = () => {
    const ctx = this._ctx.select("asModule");
    return new Module_(ctx);
  };
  asModuleConfigClient = () => {
    const ctx = this._ctx.select("asModuleConfigClient");
    return new ModuleConfigClient(ctx);
  };
  asModuleSource = () => {
    const ctx = this._ctx.select("asModuleSource");
    return new ModuleSource(ctx);
  };
  asSecret = () => {
    const ctx = this._ctx.select("asSecret");
    return new Secret(ctx);
  };
  asService = () => {
    const ctx = this._ctx.select("asService");
    return new Service(ctx);
  };
  asSocket = () => {
    const ctx = this._ctx.select("asSocket");
    return new Socket(ctx);
  };
  asString = async () => {
    if (this._asString) {
      return this._asString;
    }
    const ctx = this._ctx.select("asString");
    const response = await ctx.execute();
    return response;
  };
  digest = async () => {
    if (this._digest) {
      return this._digest;
    }
    const ctx = this._ctx.select("digest");
    const response = await ctx.execute();
    return response;
  };
  isNull = async () => {
    if (this._isNull) {
      return this._isNull;
    }
    const ctx = this._ctx.select("isNull");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  typeName = async () => {
    if (this._typeName) {
      return this._typeName;
    }
    const ctx = this._ctx.select("typeName");
    const response = await ctx.execute();
    return response;
  };
}

class CacheVolume extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
}

class Cloud extends BaseClient {
  _id = undefined;
  _traceURL = undefined;
  constructor(ctx, _id, _traceURL) {
    super(ctx);
    this._id = _id;
    this._traceURL = _traceURL;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  traceURL = async () => {
    if (this._traceURL) {
      return this._traceURL;
    }
    const ctx = this._ctx.select("traceURL");
    const response = await ctx.execute();
    return response;
  };
}

class Container extends BaseClient {
  _id = undefined;
  _envVariable = undefined;
  _exitCode = undefined;
  _export = undefined;
  _imageRef = undefined;
  _label = undefined;
  _platform = undefined;
  _publish = undefined;
  _stderr = undefined;
  _stdout = undefined;
  _sync = undefined;
  _up = undefined;
  _user = undefined;
  _workdir = undefined;
  constructor(ctx, _id, _envVariable, _exitCode, _export, _imageRef, _label, _platform, _publish, _stderr, _stdout, _sync, _up, _user, _workdir) {
    super(ctx);
    this._id = _id;
    this._envVariable = _envVariable;
    this._exitCode = _exitCode;
    this._export = _export;
    this._imageRef = _imageRef;
    this._label = _label;
    this._platform = _platform;
    this._publish = _publish;
    this._stderr = _stderr;
    this._stdout = _stdout;
    this._sync = _sync;
    this._up = _up;
    this._user = _user;
    this._workdir = _workdir;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  asService = (opts) => {
    const ctx = this._ctx.select("asService", { ...opts });
    return new Service(ctx);
  };
  asTarball = (opts) => {
    const metadata = {
      forcedCompression: { is_enum: true },
      mediaTypes: { is_enum: true }
    };
    const ctx = this._ctx.select("asTarball", { ...opts, __metadata: metadata });
    return new File(ctx);
  };
  build = (context2, opts) => {
    const ctx = this._ctx.select("build", { context: context2, ...opts });
    return new Container(ctx);
  };
  defaultArgs = async () => {
    const ctx = this._ctx.select("defaultArgs");
    const response = await ctx.execute();
    return response;
  };
  directory = (path, opts) => {
    const ctx = this._ctx.select("directory", { path, ...opts });
    return new Directory(ctx);
  };
  entrypoint = async () => {
    const ctx = this._ctx.select("entrypoint");
    const response = await ctx.execute();
    return response;
  };
  envVariable = async (name) => {
    if (this._envVariable) {
      return this._envVariable;
    }
    const ctx = this._ctx.select("envVariable", { name });
    const response = await ctx.execute();
    return response;
  };
  envVariables = async () => {
    const ctx = this._ctx.select("envVariables").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadEnvVariableFromID(r.id));
  };
  exitCode = async () => {
    if (this._exitCode) {
      return this._exitCode;
    }
    const ctx = this._ctx.select("exitCode");
    const response = await ctx.execute();
    return response;
  };
  experimentalWithAllGPUs = () => {
    const ctx = this._ctx.select("experimentalWithAllGPUs");
    return new Container(ctx);
  };
  experimentalWithGPU = (devices) => {
    const ctx = this._ctx.select("experimentalWithGPU", { devices });
    return new Container(ctx);
  };
  export = async (path, opts) => {
    if (this._export) {
      return this._export;
    }
    const metadata = {
      forcedCompression: { is_enum: true },
      mediaTypes: { is_enum: true }
    };
    const ctx = this._ctx.select("export", {
      path,
      ...opts,
      __metadata: metadata
    });
    const response = await ctx.execute();
    return response;
  };
  exposedPorts = async () => {
    const ctx = this._ctx.select("exposedPorts").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadPortFromID(r.id));
  };
  file = (path, opts) => {
    const ctx = this._ctx.select("file", { path, ...opts });
    return new File(ctx);
  };
  from = (address) => {
    const ctx = this._ctx.select("from", { address });
    return new Container(ctx);
  };
  imageRef = async () => {
    if (this._imageRef) {
      return this._imageRef;
    }
    const ctx = this._ctx.select("imageRef");
    const response = await ctx.execute();
    return response;
  };
  import_ = (source, opts) => {
    const ctx = this._ctx.select("import", { source, ...opts });
    return new Container(ctx);
  };
  label = async (name) => {
    if (this._label) {
      return this._label;
    }
    const ctx = this._ctx.select("label", { name });
    const response = await ctx.execute();
    return response;
  };
  labels = async () => {
    const ctx = this._ctx.select("labels").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadLabelFromID(r.id));
  };
  mounts = async () => {
    const ctx = this._ctx.select("mounts");
    const response = await ctx.execute();
    return response;
  };
  platform = async () => {
    if (this._platform) {
      return this._platform;
    }
    const ctx = this._ctx.select("platform");
    const response = await ctx.execute();
    return response;
  };
  publish = async (address, opts) => {
    if (this._publish) {
      return this._publish;
    }
    const metadata = {
      forcedCompression: { is_enum: true },
      mediaTypes: { is_enum: true }
    };
    const ctx = this._ctx.select("publish", {
      address,
      ...opts,
      __metadata: metadata
    });
    const response = await ctx.execute();
    return response;
  };
  rootfs = () => {
    const ctx = this._ctx.select("rootfs");
    return new Directory(ctx);
  };
  stderr = async () => {
    if (this._stderr) {
      return this._stderr;
    }
    const ctx = this._ctx.select("stderr");
    const response = await ctx.execute();
    return response;
  };
  stdout = async () => {
    if (this._stdout) {
      return this._stdout;
    }
    const ctx = this._ctx.select("stdout");
    const response = await ctx.execute();
    return response;
  };
  sync = async () => {
    const ctx = this._ctx.select("sync");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadContainerFromID(response);
  };
  terminal = (opts) => {
    const ctx = this._ctx.select("terminal", { ...opts });
    return new Container(ctx);
  };
  up = async (opts) => {
    if (this._up) {
      return;
    }
    const ctx = this._ctx.select("up", { ...opts });
    await ctx.execute();
  };
  user = async () => {
    if (this._user) {
      return this._user;
    }
    const ctx = this._ctx.select("user");
    const response = await ctx.execute();
    return response;
  };
  withAnnotation = (name, value) => {
    const ctx = this._ctx.select("withAnnotation", { name, value });
    return new Container(ctx);
  };
  withDefaultArgs = (args) => {
    const ctx = this._ctx.select("withDefaultArgs", { args });
    return new Container(ctx);
  };
  withDefaultTerminalCmd = (args, opts) => {
    const ctx = this._ctx.select("withDefaultTerminalCmd", { args, ...opts });
    return new Container(ctx);
  };
  withDirectory = (path, directory, opts) => {
    const ctx = this._ctx.select("withDirectory", { path, directory, ...opts });
    return new Container(ctx);
  };
  withEntrypoint = (args, opts) => {
    const ctx = this._ctx.select("withEntrypoint", { args, ...opts });
    return new Container(ctx);
  };
  withEnvVariable = (name, value, opts) => {
    const ctx = this._ctx.select("withEnvVariable", { name, value, ...opts });
    return new Container(ctx);
  };
  withExec = (args, opts) => {
    const metadata = {
      expect: { is_enum: true }
    };
    const ctx = this._ctx.select("withExec", {
      args,
      ...opts,
      __metadata: metadata
    });
    return new Container(ctx);
  };
  withExposedPort = (port, opts) => {
    const metadata = {
      protocol: { is_enum: true }
    };
    const ctx = this._ctx.select("withExposedPort", {
      port,
      ...opts,
      __metadata: metadata
    });
    return new Container(ctx);
  };
  withFile = (path, source, opts) => {
    const ctx = this._ctx.select("withFile", { path, source, ...opts });
    return new Container(ctx);
  };
  withFiles = (path, sources, opts) => {
    const ctx = this._ctx.select("withFiles", { path, sources, ...opts });
    return new Container(ctx);
  };
  withLabel = (name, value) => {
    const ctx = this._ctx.select("withLabel", { name, value });
    return new Container(ctx);
  };
  withMountedCache = (path, cache, opts) => {
    const metadata = {
      sharing: { is_enum: true }
    };
    const ctx = this._ctx.select("withMountedCache", {
      path,
      cache,
      ...opts,
      __metadata: metadata
    });
    return new Container(ctx);
  };
  withMountedDirectory = (path, source, opts) => {
    const ctx = this._ctx.select("withMountedDirectory", {
      path,
      source,
      ...opts
    });
    return new Container(ctx);
  };
  withMountedFile = (path, source, opts) => {
    const ctx = this._ctx.select("withMountedFile", { path, source, ...opts });
    return new Container(ctx);
  };
  withMountedSecret = (path, source, opts) => {
    const ctx = this._ctx.select("withMountedSecret", { path, source, ...opts });
    return new Container(ctx);
  };
  withMountedTemp = (path, opts) => {
    const ctx = this._ctx.select("withMountedTemp", { path, ...opts });
    return new Container(ctx);
  };
  withNewFile = (path, contents, opts) => {
    const ctx = this._ctx.select("withNewFile", { path, contents, ...opts });
    return new Container(ctx);
  };
  withRegistryAuth = (address, username, secret) => {
    const ctx = this._ctx.select("withRegistryAuth", {
      address,
      username,
      secret
    });
    return new Container(ctx);
  };
  withRootfs = (directory) => {
    const ctx = this._ctx.select("withRootfs", { directory });
    return new Container(ctx);
  };
  withSecretVariable = (name, secret) => {
    const ctx = this._ctx.select("withSecretVariable", { name, secret });
    return new Container(ctx);
  };
  withServiceBinding = (alias, service) => {
    const ctx = this._ctx.select("withServiceBinding", { alias, service });
    return new Container(ctx);
  };
  withSymlink = (target, linkName, opts) => {
    const ctx = this._ctx.select("withSymlink", { target, linkName, ...opts });
    return new Container(ctx);
  };
  withUnixSocket = (path, source, opts) => {
    const ctx = this._ctx.select("withUnixSocket", { path, source, ...opts });
    return new Container(ctx);
  };
  withUser = (name) => {
    const ctx = this._ctx.select("withUser", { name });
    return new Container(ctx);
  };
  withWorkdir = (path, opts) => {
    const ctx = this._ctx.select("withWorkdir", { path, ...opts });
    return new Container(ctx);
  };
  withoutAnnotation = (name) => {
    const ctx = this._ctx.select("withoutAnnotation", { name });
    return new Container(ctx);
  };
  withoutDefaultArgs = () => {
    const ctx = this._ctx.select("withoutDefaultArgs");
    return new Container(ctx);
  };
  withoutDirectory = (path, opts) => {
    const ctx = this._ctx.select("withoutDirectory", { path, ...opts });
    return new Container(ctx);
  };
  withoutEntrypoint = (opts) => {
    const ctx = this._ctx.select("withoutEntrypoint", { ...opts });
    return new Container(ctx);
  };
  withoutEnvVariable = (name) => {
    const ctx = this._ctx.select("withoutEnvVariable", { name });
    return new Container(ctx);
  };
  withoutExposedPort = (port, opts) => {
    const metadata = {
      protocol: { is_enum: true }
    };
    const ctx = this._ctx.select("withoutExposedPort", {
      port,
      ...opts,
      __metadata: metadata
    });
    return new Container(ctx);
  };
  withoutFile = (path, opts) => {
    const ctx = this._ctx.select("withoutFile", { path, ...opts });
    return new Container(ctx);
  };
  withoutFiles = (paths, opts) => {
    const ctx = this._ctx.select("withoutFiles", { paths, ...opts });
    return new Container(ctx);
  };
  withoutLabel = (name) => {
    const ctx = this._ctx.select("withoutLabel", { name });
    return new Container(ctx);
  };
  withoutMount = (path, opts) => {
    const ctx = this._ctx.select("withoutMount", { path, ...opts });
    return new Container(ctx);
  };
  withoutRegistryAuth = (address) => {
    const ctx = this._ctx.select("withoutRegistryAuth", { address });
    return new Container(ctx);
  };
  withoutSecretVariable = (name) => {
    const ctx = this._ctx.select("withoutSecretVariable", { name });
    return new Container(ctx);
  };
  withoutUnixSocket = (path, opts) => {
    const ctx = this._ctx.select("withoutUnixSocket", { path, ...opts });
    return new Container(ctx);
  };
  withoutUser = () => {
    const ctx = this._ctx.select("withoutUser");
    return new Container(ctx);
  };
  withoutWorkdir = () => {
    const ctx = this._ctx.select("withoutWorkdir");
    return new Container(ctx);
  };
  workdir = async () => {
    if (this._workdir) {
      return this._workdir;
    }
    const ctx = this._ctx.select("workdir");
    const response = await ctx.execute();
    return response;
  };
  with = (arg) => {
    return arg(this);
  };
}

class CurrentModule extends BaseClient {
  _id = undefined;
  _name = undefined;
  constructor(ctx, _id, _name) {
    super(ctx);
    this._id = _id;
    this._name = _name;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  source = () => {
    const ctx = this._ctx.select("source");
    return new Directory(ctx);
  };
  workdir = (path, opts) => {
    const ctx = this._ctx.select("workdir", { path, ...opts });
    return new Directory(ctx);
  };
  workdirFile = (path) => {
    const ctx = this._ctx.select("workdirFile", { path });
    return new File(ctx);
  };
}

class Directory extends BaseClient {
  _id = undefined;
  _digest = undefined;
  _export = undefined;
  _name = undefined;
  _sync = undefined;
  constructor(ctx, _id, _digest, _export, _name, _sync) {
    super(ctx);
    this._id = _id;
    this._digest = _digest;
    this._export = _export;
    this._name = _name;
    this._sync = _sync;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  asGit = () => {
    const ctx = this._ctx.select("asGit");
    return new GitRepository(ctx);
  };
  asModule = (opts) => {
    const ctx = this._ctx.select("asModule", { ...opts });
    return new Module_(ctx);
  };
  asModuleSource = (opts) => {
    const ctx = this._ctx.select("asModuleSource", { ...opts });
    return new ModuleSource(ctx);
  };
  diff = (other) => {
    const ctx = this._ctx.select("diff", { other });
    return new Directory(ctx);
  };
  digest = async () => {
    if (this._digest) {
      return this._digest;
    }
    const ctx = this._ctx.select("digest");
    const response = await ctx.execute();
    return response;
  };
  directory = (path) => {
    const ctx = this._ctx.select("directory", { path });
    return new Directory(ctx);
  };
  dockerBuild = (opts) => {
    const ctx = this._ctx.select("dockerBuild", { ...opts });
    return new Container(ctx);
  };
  entries = async (opts) => {
    const ctx = this._ctx.select("entries", { ...opts });
    const response = await ctx.execute();
    return response;
  };
  export = async (path, opts) => {
    if (this._export) {
      return this._export;
    }
    const ctx = this._ctx.select("export", { path, ...opts });
    const response = await ctx.execute();
    return response;
  };
  file = (path) => {
    const ctx = this._ctx.select("file", { path });
    return new File(ctx);
  };
  filter = (opts) => {
    const ctx = this._ctx.select("filter", { ...opts });
    return new Directory(ctx);
  };
  glob = async (pattern) => {
    const ctx = this._ctx.select("glob", { pattern });
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sync = async () => {
    const ctx = this._ctx.select("sync");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadDirectoryFromID(response);
  };
  terminal = (opts) => {
    const ctx = this._ctx.select("terminal", { ...opts });
    return new Directory(ctx);
  };
  withDirectory = (path, directory, opts) => {
    const ctx = this._ctx.select("withDirectory", { path, directory, ...opts });
    return new Directory(ctx);
  };
  withFile = (path, source, opts) => {
    const ctx = this._ctx.select("withFile", { path, source, ...opts });
    return new Directory(ctx);
  };
  withFiles = (path, sources, opts) => {
    const ctx = this._ctx.select("withFiles", { path, sources, ...opts });
    return new Directory(ctx);
  };
  withNewDirectory = (path, opts) => {
    const ctx = this._ctx.select("withNewDirectory", { path, ...opts });
    return new Directory(ctx);
  };
  withNewFile = (path, contents, opts) => {
    const ctx = this._ctx.select("withNewFile", { path, contents, ...opts });
    return new Directory(ctx);
  };
  withSymlink = (target, linkName) => {
    const ctx = this._ctx.select("withSymlink", { target, linkName });
    return new Directory(ctx);
  };
  withTimestamps = (timestamp) => {
    const ctx = this._ctx.select("withTimestamps", { timestamp });
    return new Directory(ctx);
  };
  withoutDirectory = (path) => {
    const ctx = this._ctx.select("withoutDirectory", { path });
    return new Directory(ctx);
  };
  withoutFile = (path) => {
    const ctx = this._ctx.select("withoutFile", { path });
    return new Directory(ctx);
  };
  withoutFiles = (paths) => {
    const ctx = this._ctx.select("withoutFiles", { paths });
    return new Directory(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class Engine extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  localCache = () => {
    const ctx = this._ctx.select("localCache");
    return new EngineCache(ctx);
  };
}

class EngineCache extends BaseClient {
  _id = undefined;
  _keepBytes = undefined;
  _maxUsedSpace = undefined;
  _minFreeSpace = undefined;
  _prune = undefined;
  _reservedSpace = undefined;
  _targetSpace = undefined;
  constructor(ctx, _id, _keepBytes, _maxUsedSpace, _minFreeSpace, _prune, _reservedSpace, _targetSpace) {
    super(ctx);
    this._id = _id;
    this._keepBytes = _keepBytes;
    this._maxUsedSpace = _maxUsedSpace;
    this._minFreeSpace = _minFreeSpace;
    this._prune = _prune;
    this._reservedSpace = _reservedSpace;
    this._targetSpace = _targetSpace;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  entrySet = (opts) => {
    const ctx = this._ctx.select("entrySet", { ...opts });
    return new EngineCacheEntrySet(ctx);
  };
  keepBytes = async () => {
    if (this._keepBytes) {
      return this._keepBytes;
    }
    const ctx = this._ctx.select("keepBytes");
    const response = await ctx.execute();
    return response;
  };
  maxUsedSpace = async () => {
    if (this._maxUsedSpace) {
      return this._maxUsedSpace;
    }
    const ctx = this._ctx.select("maxUsedSpace");
    const response = await ctx.execute();
    return response;
  };
  minFreeSpace = async () => {
    if (this._minFreeSpace) {
      return this._minFreeSpace;
    }
    const ctx = this._ctx.select("minFreeSpace");
    const response = await ctx.execute();
    return response;
  };
  prune = async (opts) => {
    if (this._prune) {
      return;
    }
    const ctx = this._ctx.select("prune", { ...opts });
    await ctx.execute();
  };
  reservedSpace = async () => {
    if (this._reservedSpace) {
      return this._reservedSpace;
    }
    const ctx = this._ctx.select("reservedSpace");
    const response = await ctx.execute();
    return response;
  };
  targetSpace = async () => {
    if (this._targetSpace) {
      return this._targetSpace;
    }
    const ctx = this._ctx.select("targetSpace");
    const response = await ctx.execute();
    return response;
  };
}

class EngineCacheEntry extends BaseClient {
  _id = undefined;
  _activelyUsed = undefined;
  _createdTimeUnixNano = undefined;
  _description = undefined;
  _diskSpaceBytes = undefined;
  _mostRecentUseTimeUnixNano = undefined;
  constructor(ctx, _id, _activelyUsed, _createdTimeUnixNano, _description, _diskSpaceBytes, _mostRecentUseTimeUnixNano) {
    super(ctx);
    this._id = _id;
    this._activelyUsed = _activelyUsed;
    this._createdTimeUnixNano = _createdTimeUnixNano;
    this._description = _description;
    this._diskSpaceBytes = _diskSpaceBytes;
    this._mostRecentUseTimeUnixNano = _mostRecentUseTimeUnixNano;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  activelyUsed = async () => {
    if (this._activelyUsed) {
      return this._activelyUsed;
    }
    const ctx = this._ctx.select("activelyUsed");
    const response = await ctx.execute();
    return response;
  };
  createdTimeUnixNano = async () => {
    if (this._createdTimeUnixNano) {
      return this._createdTimeUnixNano;
    }
    const ctx = this._ctx.select("createdTimeUnixNano");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  diskSpaceBytes = async () => {
    if (this._diskSpaceBytes) {
      return this._diskSpaceBytes;
    }
    const ctx = this._ctx.select("diskSpaceBytes");
    const response = await ctx.execute();
    return response;
  };
  mostRecentUseTimeUnixNano = async () => {
    if (this._mostRecentUseTimeUnixNano) {
      return this._mostRecentUseTimeUnixNano;
    }
    const ctx = this._ctx.select("mostRecentUseTimeUnixNano");
    const response = await ctx.execute();
    return response;
  };
}

class EngineCacheEntrySet extends BaseClient {
  _id = undefined;
  _diskSpaceBytes = undefined;
  _entryCount = undefined;
  constructor(ctx, _id, _diskSpaceBytes, _entryCount) {
    super(ctx);
    this._id = _id;
    this._diskSpaceBytes = _diskSpaceBytes;
    this._entryCount = _entryCount;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  diskSpaceBytes = async () => {
    if (this._diskSpaceBytes) {
      return this._diskSpaceBytes;
    }
    const ctx = this._ctx.select("diskSpaceBytes");
    const response = await ctx.execute();
    return response;
  };
  entries = async () => {
    const ctx = this._ctx.select("entries").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadEngineCacheEntryFromID(r.id));
  };
  entryCount = async () => {
    if (this._entryCount) {
      return this._entryCount;
    }
    const ctx = this._ctx.select("entryCount");
    const response = await ctx.execute();
    return response;
  };
}

class EnumTypeDef extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  _sourceModuleName = undefined;
  constructor(ctx, _id, _description, _name, _sourceModuleName) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
    this._sourceModuleName = _sourceModuleName;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  members = async () => {
    const ctx = this._ctx.select("members").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadEnumValueTypeDefFromID(r.id));
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sourceMap = () => {
    const ctx = this._ctx.select("sourceMap");
    return new SourceMap(ctx);
  };
  sourceModuleName = async () => {
    if (this._sourceModuleName) {
      return this._sourceModuleName;
    }
    const ctx = this._ctx.select("sourceModuleName");
    const response = await ctx.execute();
    return response;
  };
  values = async () => {
    const ctx = this._ctx.select("values").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadEnumValueTypeDefFromID(r.id));
  };
}

class EnumValueTypeDef extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  _value = undefined;
  constructor(ctx, _id, _description, _name, _value) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
    this._value = _value;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sourceMap = () => {
    const ctx = this._ctx.select("sourceMap");
    return new SourceMap(ctx);
  };
  value = async () => {
    if (this._value) {
      return this._value;
    }
    const ctx = this._ctx.select("value");
    const response = await ctx.execute();
    return response;
  };
}

class Env extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  input = (name) => {
    const ctx = this._ctx.select("input", { name });
    return new Binding(ctx);
  };
  inputs = async () => {
    const ctx = this._ctx.select("inputs").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadBindingFromID(r.id));
  };
  output = (name) => {
    const ctx = this._ctx.select("output", { name });
    return new Binding(ctx);
  };
  outputs = async () => {
    const ctx = this._ctx.select("outputs").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadBindingFromID(r.id));
  };
  withCacheVolumeInput = (name, value, description) => {
    const ctx = this._ctx.select("withCacheVolumeInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withCacheVolumeOutput = (name, description) => {
    const ctx = this._ctx.select("withCacheVolumeOutput", { name, description });
    return new Env(ctx);
  };
  withCloudInput = (name, value, description) => {
    const ctx = this._ctx.select("withCloudInput", { name, value, description });
    return new Env(ctx);
  };
  withCloudOutput = (name, description) => {
    const ctx = this._ctx.select("withCloudOutput", { name, description });
    return new Env(ctx);
  };
  withContainerInput = (name, value, description) => {
    const ctx = this._ctx.select("withContainerInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withContainerOutput = (name, description) => {
    const ctx = this._ctx.select("withContainerOutput", { name, description });
    return new Env(ctx);
  };
  withDirectoryInput = (name, value, description) => {
    const ctx = this._ctx.select("withDirectoryInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withDirectoryOutput = (name, description) => {
    const ctx = this._ctx.select("withDirectoryOutput", { name, description });
    return new Env(ctx);
  };
  withEnvInput = (name, value, description) => {
    const ctx = this._ctx.select("withEnvInput", { name, value, description });
    return new Env(ctx);
  };
  withEnvOutput = (name, description) => {
    const ctx = this._ctx.select("withEnvOutput", { name, description });
    return new Env(ctx);
  };
  withFileInput = (name, value, description) => {
    const ctx = this._ctx.select("withFileInput", { name, value, description });
    return new Env(ctx);
  };
  withFileOutput = (name, description) => {
    const ctx = this._ctx.select("withFileOutput", { name, description });
    return new Env(ctx);
  };
  withGitRefInput = (name, value, description) => {
    const ctx = this._ctx.select("withGitRefInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withGitRefOutput = (name, description) => {
    const ctx = this._ctx.select("withGitRefOutput", { name, description });
    return new Env(ctx);
  };
  withGitRepositoryInput = (name, value, description) => {
    const ctx = this._ctx.select("withGitRepositoryInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withGitRepositoryOutput = (name, description) => {
    const ctx = this._ctx.select("withGitRepositoryOutput", {
      name,
      description
    });
    return new Env(ctx);
  };
  withLLMInput = (name, value, description) => {
    const ctx = this._ctx.select("withLLMInput", { name, value, description });
    return new Env(ctx);
  };
  withLLMOutput = (name, description) => {
    const ctx = this._ctx.select("withLLMOutput", { name, description });
    return new Env(ctx);
  };
  withModuleConfigClientInput = (name, value, description) => {
    const ctx = this._ctx.select("withModuleConfigClientInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withModuleConfigClientOutput = (name, description) => {
    const ctx = this._ctx.select("withModuleConfigClientOutput", {
      name,
      description
    });
    return new Env(ctx);
  };
  withModuleInput = (name, value, description) => {
    const ctx = this._ctx.select("withModuleInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withModuleOutput = (name, description) => {
    const ctx = this._ctx.select("withModuleOutput", { name, description });
    return new Env(ctx);
  };
  withModuleSourceInput = (name, value, description) => {
    const ctx = this._ctx.select("withModuleSourceInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withModuleSourceOutput = (name, description) => {
    const ctx = this._ctx.select("withModuleSourceOutput", {
      name,
      description
    });
    return new Env(ctx);
  };
  withSecretInput = (name, value, description) => {
    const ctx = this._ctx.select("withSecretInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withSecretOutput = (name, description) => {
    const ctx = this._ctx.select("withSecretOutput", { name, description });
    return new Env(ctx);
  };
  withServiceInput = (name, value, description) => {
    const ctx = this._ctx.select("withServiceInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withServiceOutput = (name, description) => {
    const ctx = this._ctx.select("withServiceOutput", { name, description });
    return new Env(ctx);
  };
  withSocketInput = (name, value, description) => {
    const ctx = this._ctx.select("withSocketInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withSocketOutput = (name, description) => {
    const ctx = this._ctx.select("withSocketOutput", { name, description });
    return new Env(ctx);
  };
  withStringInput = (name, value, description) => {
    const ctx = this._ctx.select("withStringInput", {
      name,
      value,
      description
    });
    return new Env(ctx);
  };
  withStringOutput = (name, description) => {
    const ctx = this._ctx.select("withStringOutput", { name, description });
    return new Env(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class EnvVariable extends BaseClient {
  _id = undefined;
  _name = undefined;
  _value = undefined;
  constructor(ctx, _id, _name, _value) {
    super(ctx);
    this._id = _id;
    this._name = _name;
    this._value = _value;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  value = async () => {
    if (this._value) {
      return this._value;
    }
    const ctx = this._ctx.select("value");
    const response = await ctx.execute();
    return response;
  };
}

class Error2 extends BaseClient {
  _id = undefined;
  _message = undefined;
  constructor(ctx, _id, _message) {
    super(ctx);
    this._id = _id;
    this._message = _message;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  message = async () => {
    if (this._message) {
      return this._message;
    }
    const ctx = this._ctx.select("message");
    const response = await ctx.execute();
    return response;
  };
  values = async () => {
    const ctx = this._ctx.select("values").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadErrorValueFromID(r.id));
  };
  withValue = (name, value) => {
    const ctx = this._ctx.select("withValue", { name, value });
    return new Error2(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class ErrorValue extends BaseClient {
  _id = undefined;
  _name = undefined;
  _value = undefined;
  constructor(ctx, _id, _name, _value) {
    super(ctx);
    this._id = _id;
    this._name = _name;
    this._value = _value;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  value = async () => {
    if (this._value) {
      return this._value;
    }
    const ctx = this._ctx.select("value");
    const response = await ctx.execute();
    return response;
  };
}

class FieldTypeDef extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  constructor(ctx, _id, _description, _name) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sourceMap = () => {
    const ctx = this._ctx.select("sourceMap");
    return new SourceMap(ctx);
  };
  typeDef = () => {
    const ctx = this._ctx.select("typeDef");
    return new TypeDef(ctx);
  };
}

class File extends BaseClient {
  _id = undefined;
  _contents = undefined;
  _digest = undefined;
  _export = undefined;
  _name = undefined;
  _size = undefined;
  _sync = undefined;
  constructor(ctx, _id, _contents, _digest, _export, _name, _size, _sync) {
    super(ctx);
    this._id = _id;
    this._contents = _contents;
    this._digest = _digest;
    this._export = _export;
    this._name = _name;
    this._size = _size;
    this._sync = _sync;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  contents = async () => {
    if (this._contents) {
      return this._contents;
    }
    const ctx = this._ctx.select("contents");
    const response = await ctx.execute();
    return response;
  };
  digest = async (opts) => {
    if (this._digest) {
      return this._digest;
    }
    const ctx = this._ctx.select("digest", { ...opts });
    const response = await ctx.execute();
    return response;
  };
  export = async (path, opts) => {
    if (this._export) {
      return this._export;
    }
    const ctx = this._ctx.select("export", { path, ...opts });
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  size = async () => {
    if (this._size) {
      return this._size;
    }
    const ctx = this._ctx.select("size");
    const response = await ctx.execute();
    return response;
  };
  sync = async () => {
    const ctx = this._ctx.select("sync");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadFileFromID(response);
  };
  withName = (name) => {
    const ctx = this._ctx.select("withName", { name });
    return new File(ctx);
  };
  withTimestamps = (timestamp) => {
    const ctx = this._ctx.select("withTimestamps", { timestamp });
    return new File(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class Function_ extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  constructor(ctx, _id, _description, _name) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  args = async () => {
    const ctx = this._ctx.select("args").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadFunctionArgFromID(r.id));
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  returnType = () => {
    const ctx = this._ctx.select("returnType");
    return new TypeDef(ctx);
  };
  sourceMap = () => {
    const ctx = this._ctx.select("sourceMap");
    return new SourceMap(ctx);
  };
  withArg = (name, typeDef, opts) => {
    const ctx = this._ctx.select("withArg", { name, typeDef, ...opts });
    return new Function_(ctx);
  };
  withDescription = (description) => {
    const ctx = this._ctx.select("withDescription", { description });
    return new Function_(ctx);
  };
  withSourceMap = (sourceMap) => {
    const ctx = this._ctx.select("withSourceMap", { sourceMap });
    return new Function_(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class FunctionArg extends BaseClient {
  _id = undefined;
  _defaultPath = undefined;
  _defaultValue = undefined;
  _description = undefined;
  _name = undefined;
  constructor(ctx, _id, _defaultPath, _defaultValue, _description, _name) {
    super(ctx);
    this._id = _id;
    this._defaultPath = _defaultPath;
    this._defaultValue = _defaultValue;
    this._description = _description;
    this._name = _name;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  defaultPath = async () => {
    if (this._defaultPath) {
      return this._defaultPath;
    }
    const ctx = this._ctx.select("defaultPath");
    const response = await ctx.execute();
    return response;
  };
  defaultValue = async () => {
    if (this._defaultValue) {
      return this._defaultValue;
    }
    const ctx = this._ctx.select("defaultValue");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  ignore = async () => {
    const ctx = this._ctx.select("ignore");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sourceMap = () => {
    const ctx = this._ctx.select("sourceMap");
    return new SourceMap(ctx);
  };
  typeDef = () => {
    const ctx = this._ctx.select("typeDef");
    return new TypeDef(ctx);
  };
}

class FunctionCall extends BaseClient {
  _id = undefined;
  _name = undefined;
  _parent = undefined;
  _parentName = undefined;
  _returnError = undefined;
  _returnValue = undefined;
  constructor(ctx, _id, _name, _parent, _parentName, _returnError, _returnValue) {
    super(ctx);
    this._id = _id;
    this._name = _name;
    this._parent = _parent;
    this._parentName = _parentName;
    this._returnError = _returnError;
    this._returnValue = _returnValue;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  inputArgs = async () => {
    const ctx = this._ctx.select("inputArgs").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadFunctionCallArgValueFromID(r.id));
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  parent = async () => {
    if (this._parent) {
      return this._parent;
    }
    const ctx = this._ctx.select("parent");
    const response = await ctx.execute();
    return response;
  };
  parentName = async () => {
    if (this._parentName) {
      return this._parentName;
    }
    const ctx = this._ctx.select("parentName");
    const response = await ctx.execute();
    return response;
  };
  returnError = async (error) => {
    if (this._returnError) {
      return;
    }
    const ctx = this._ctx.select("returnError", { error });
    await ctx.execute();
  };
  returnValue = async (value) => {
    if (this._returnValue) {
      return;
    }
    const ctx = this._ctx.select("returnValue", { value });
    await ctx.execute();
  };
}

class FunctionCallArgValue extends BaseClient {
  _id = undefined;
  _name = undefined;
  _value = undefined;
  constructor(ctx, _id, _name, _value) {
    super(ctx);
    this._id = _id;
    this._name = _name;
    this._value = _value;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  value = async () => {
    if (this._value) {
      return this._value;
    }
    const ctx = this._ctx.select("value");
    const response = await ctx.execute();
    return response;
  };
}

class GeneratedCode extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  code = () => {
    const ctx = this._ctx.select("code");
    return new Directory(ctx);
  };
  vcsGeneratedPaths = async () => {
    const ctx = this._ctx.select("vcsGeneratedPaths");
    const response = await ctx.execute();
    return response;
  };
  vcsIgnoredPaths = async () => {
    const ctx = this._ctx.select("vcsIgnoredPaths");
    const response = await ctx.execute();
    return response;
  };
  withVCSGeneratedPaths = (paths) => {
    const ctx = this._ctx.select("withVCSGeneratedPaths", { paths });
    return new GeneratedCode(ctx);
  };
  withVCSIgnoredPaths = (paths) => {
    const ctx = this._ctx.select("withVCSIgnoredPaths", { paths });
    return new GeneratedCode(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class GitRef extends BaseClient {
  _id = undefined;
  _commit = undefined;
  _ref = undefined;
  constructor(ctx, _id, _commit, _ref) {
    super(ctx);
    this._id = _id;
    this._commit = _commit;
    this._ref = _ref;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  commit = async () => {
    if (this._commit) {
      return this._commit;
    }
    const ctx = this._ctx.select("commit");
    const response = await ctx.execute();
    return response;
  };
  ref = async () => {
    if (this._ref) {
      return this._ref;
    }
    const ctx = this._ctx.select("ref");
    const response = await ctx.execute();
    return response;
  };
  tree = (opts) => {
    const ctx = this._ctx.select("tree", { ...opts });
    return new Directory(ctx);
  };
}

class GitRepository extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  branch = (name) => {
    const ctx = this._ctx.select("branch", { name });
    return new GitRef(ctx);
  };
  branches = async (opts) => {
    const ctx = this._ctx.select("branches", { ...opts });
    const response = await ctx.execute();
    return response;
  };
  commit = (id) => {
    const ctx = this._ctx.select("commit", { id });
    return new GitRef(ctx);
  };
  head = () => {
    const ctx = this._ctx.select("head");
    return new GitRef(ctx);
  };
  ref = (name) => {
    const ctx = this._ctx.select("ref", { name });
    return new GitRef(ctx);
  };
  tag = (name) => {
    const ctx = this._ctx.select("tag", { name });
    return new GitRef(ctx);
  };
  tags = async (opts) => {
    const ctx = this._ctx.select("tags", { ...opts });
    const response = await ctx.execute();
    return response;
  };
  withAuthHeader = (header) => {
    const ctx = this._ctx.select("withAuthHeader", { header });
    return new GitRepository(ctx);
  };
  withAuthToken = (token) => {
    const ctx = this._ctx.select("withAuthToken", { token });
    return new GitRepository(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class Host extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  directory = (path, opts) => {
    const ctx = this._ctx.select("directory", { path, ...opts });
    return new Directory(ctx);
  };
  file = (path, opts) => {
    const ctx = this._ctx.select("file", { path, ...opts });
    return new File(ctx);
  };
  service = (ports, opts) => {
    const ctx = this._ctx.select("service", { ports, ...opts });
    return new Service(ctx);
  };
  setSecretFile = (name, path) => {
    const ctx = this._ctx.select("setSecretFile", { name, path });
    return new Secret(ctx);
  };
  tunnel = (service, opts) => {
    const ctx = this._ctx.select("tunnel", { service, ...opts });
    return new Service(ctx);
  };
  unixSocket = (path) => {
    const ctx = this._ctx.select("unixSocket", { path });
    return new Socket(ctx);
  };
}

class InputTypeDef extends BaseClient {
  _id = undefined;
  _name = undefined;
  constructor(ctx, _id, _name) {
    super(ctx);
    this._id = _id;
    this._name = _name;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  fields = async () => {
    const ctx = this._ctx.select("fields").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadFieldTypeDefFromID(r.id));
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
}

class InterfaceTypeDef extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  _sourceModuleName = undefined;
  constructor(ctx, _id, _description, _name, _sourceModuleName) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
    this._sourceModuleName = _sourceModuleName;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  functions = async () => {
    const ctx = this._ctx.select("functions").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadFunctionFromID(r.id));
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sourceMap = () => {
    const ctx = this._ctx.select("sourceMap");
    return new SourceMap(ctx);
  };
  sourceModuleName = async () => {
    if (this._sourceModuleName) {
      return this._sourceModuleName;
    }
    const ctx = this._ctx.select("sourceModuleName");
    const response = await ctx.execute();
    return response;
  };
}

class LLM extends BaseClient {
  _id = undefined;
  _historyJSON = undefined;
  _lastReply = undefined;
  _model = undefined;
  _provider = undefined;
  _sync = undefined;
  _tools = undefined;
  constructor(ctx, _id, _historyJSON, _lastReply, _model, _provider, _sync, _tools) {
    super(ctx);
    this._id = _id;
    this._historyJSON = _historyJSON;
    this._lastReply = _lastReply;
    this._model = _model;
    this._provider = _provider;
    this._sync = _sync;
    this._tools = _tools;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  attempt = (number_) => {
    const ctx = this._ctx.select("attempt", {
      number: number_
    });
    return new LLM(ctx);
  };
  bindResult = (name) => {
    const ctx = this._ctx.select("bindResult", { name });
    return new Binding(ctx);
  };
  env = () => {
    const ctx = this._ctx.select("env");
    return new Env(ctx);
  };
  history = async () => {
    const ctx = this._ctx.select("history");
    const response = await ctx.execute();
    return response;
  };
  historyJSON = async () => {
    if (this._historyJSON) {
      return this._historyJSON;
    }
    const ctx = this._ctx.select("historyJSON");
    const response = await ctx.execute();
    return response;
  };
  lastReply = async () => {
    if (this._lastReply) {
      return this._lastReply;
    }
    const ctx = this._ctx.select("lastReply");
    const response = await ctx.execute();
    return response;
  };
  loop = () => {
    const ctx = this._ctx.select("loop");
    return new LLM(ctx);
  };
  model = async () => {
    if (this._model) {
      return this._model;
    }
    const ctx = this._ctx.select("model");
    const response = await ctx.execute();
    return response;
  };
  provider = async () => {
    if (this._provider) {
      return this._provider;
    }
    const ctx = this._ctx.select("provider");
    const response = await ctx.execute();
    return response;
  };
  sync = async () => {
    const ctx = this._ctx.select("sync");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadLLMFromID(response);
  };
  tokenUsage = () => {
    const ctx = this._ctx.select("tokenUsage");
    return new LLMTokenUsage(ctx);
  };
  tools = async () => {
    if (this._tools) {
      return this._tools;
    }
    const ctx = this._ctx.select("tools");
    const response = await ctx.execute();
    return response;
  };
  withEnv = (env) => {
    const ctx = this._ctx.select("withEnv", { env });
    return new LLM(ctx);
  };
  withModel = (model) => {
    const ctx = this._ctx.select("withModel", { model });
    return new LLM(ctx);
  };
  withPrompt = (prompt) => {
    const ctx = this._ctx.select("withPrompt", { prompt });
    return new LLM(ctx);
  };
  withPromptFile = (file) => {
    const ctx = this._ctx.select("withPromptFile", { file });
    return new LLM(ctx);
  };
  withSystemPrompt = (prompt) => {
    const ctx = this._ctx.select("withSystemPrompt", { prompt });
    return new LLM(ctx);
  };
  withoutDefaultSystemPrompt = () => {
    const ctx = this._ctx.select("withoutDefaultSystemPrompt");
    return new LLM(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class LLMTokenUsage extends BaseClient {
  _id = undefined;
  _cachedTokenReads = undefined;
  _cachedTokenWrites = undefined;
  _inputTokens = undefined;
  _outputTokens = undefined;
  _totalTokens = undefined;
  constructor(ctx, _id, _cachedTokenReads, _cachedTokenWrites, _inputTokens, _outputTokens, _totalTokens) {
    super(ctx);
    this._id = _id;
    this._cachedTokenReads = _cachedTokenReads;
    this._cachedTokenWrites = _cachedTokenWrites;
    this._inputTokens = _inputTokens;
    this._outputTokens = _outputTokens;
    this._totalTokens = _totalTokens;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  cachedTokenReads = async () => {
    if (this._cachedTokenReads) {
      return this._cachedTokenReads;
    }
    const ctx = this._ctx.select("cachedTokenReads");
    const response = await ctx.execute();
    return response;
  };
  cachedTokenWrites = async () => {
    if (this._cachedTokenWrites) {
      return this._cachedTokenWrites;
    }
    const ctx = this._ctx.select("cachedTokenWrites");
    const response = await ctx.execute();
    return response;
  };
  inputTokens = async () => {
    if (this._inputTokens) {
      return this._inputTokens;
    }
    const ctx = this._ctx.select("inputTokens");
    const response = await ctx.execute();
    return response;
  };
  outputTokens = async () => {
    if (this._outputTokens) {
      return this._outputTokens;
    }
    const ctx = this._ctx.select("outputTokens");
    const response = await ctx.execute();
    return response;
  };
  totalTokens = async () => {
    if (this._totalTokens) {
      return this._totalTokens;
    }
    const ctx = this._ctx.select("totalTokens");
    const response = await ctx.execute();
    return response;
  };
}

class Label extends BaseClient {
  _id = undefined;
  _name = undefined;
  _value = undefined;
  constructor(ctx, _id, _name, _value) {
    super(ctx);
    this._id = _id;
    this._name = _name;
    this._value = _value;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  value = async () => {
    if (this._value) {
      return this._value;
    }
    const ctx = this._ctx.select("value");
    const response = await ctx.execute();
    return response;
  };
}

class ListTypeDef extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  elementTypeDef = () => {
    const ctx = this._ctx.select("elementTypeDef");
    return new TypeDef(ctx);
  };
}

class Module_ extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  _serve = undefined;
  _sync = undefined;
  constructor(ctx, _id, _description, _name, _serve, _sync) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
    this._serve = _serve;
    this._sync = _sync;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  dependencies = async () => {
    const ctx = this._ctx.select("dependencies").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadModuleFromID(r.id));
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  enums = async () => {
    const ctx = this._ctx.select("enums").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadTypeDefFromID(r.id));
  };
  generatedContextDirectory = () => {
    const ctx = this._ctx.select("generatedContextDirectory");
    return new Directory(ctx);
  };
  interfaces = async () => {
    const ctx = this._ctx.select("interfaces").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadTypeDefFromID(r.id));
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  objects = async () => {
    const ctx = this._ctx.select("objects").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadTypeDefFromID(r.id));
  };
  runtime = () => {
    const ctx = this._ctx.select("runtime");
    return new Container(ctx);
  };
  sdk = () => {
    const ctx = this._ctx.select("sdk");
    return new SDKConfig(ctx);
  };
  serve = async (opts) => {
    if (this._serve) {
      return;
    }
    const ctx = this._ctx.select("serve", { ...opts });
    await ctx.execute();
  };
  source = () => {
    const ctx = this._ctx.select("source");
    return new ModuleSource(ctx);
  };
  sync = async () => {
    const ctx = this._ctx.select("sync");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadModuleFromID(response);
  };
  withDescription = (description) => {
    const ctx = this._ctx.select("withDescription", { description });
    return new Module_(ctx);
  };
  withEnum = (enum_) => {
    const ctx = this._ctx.select("withEnum", {
      enum: enum_
    });
    return new Module_(ctx);
  };
  withInterface = (iface) => {
    const ctx = this._ctx.select("withInterface", { iface });
    return new Module_(ctx);
  };
  withObject = (object) => {
    const ctx = this._ctx.select("withObject", { object });
    return new Module_(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class ModuleConfigClient extends BaseClient {
  _id = undefined;
  _directory = undefined;
  _generator = undefined;
  constructor(ctx, _id, _directory, _generator) {
    super(ctx);
    this._id = _id;
    this._directory = _directory;
    this._generator = _generator;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  directory = async () => {
    if (this._directory) {
      return this._directory;
    }
    const ctx = this._ctx.select("directory");
    const response = await ctx.execute();
    return response;
  };
  generator = async () => {
    if (this._generator) {
      return this._generator;
    }
    const ctx = this._ctx.select("generator");
    const response = await ctx.execute();
    return response;
  };
}

class ModuleSource extends BaseClient {
  _id = undefined;
  _asString = undefined;
  _cloneRef = undefined;
  _commit = undefined;
  _configExists = undefined;
  _digest = undefined;
  _engineVersion = undefined;
  _htmlRepoURL = undefined;
  _htmlURL = undefined;
  _kind = undefined;
  _localContextDirectoryPath = undefined;
  _moduleName = undefined;
  _moduleOriginalName = undefined;
  _originalSubpath = undefined;
  _pin = undefined;
  _repoRootPath = undefined;
  _sourceRootSubpath = undefined;
  _sourceSubpath = undefined;
  _sync = undefined;
  _version = undefined;
  constructor(ctx, _id, _asString, _cloneRef, _commit, _configExists, _digest, _engineVersion, _htmlRepoURL, _htmlURL, _kind, _localContextDirectoryPath, _moduleName, _moduleOriginalName, _originalSubpath, _pin, _repoRootPath, _sourceRootSubpath, _sourceSubpath, _sync, _version) {
    super(ctx);
    this._id = _id;
    this._asString = _asString;
    this._cloneRef = _cloneRef;
    this._commit = _commit;
    this._configExists = _configExists;
    this._digest = _digest;
    this._engineVersion = _engineVersion;
    this._htmlRepoURL = _htmlRepoURL;
    this._htmlURL = _htmlURL;
    this._kind = _kind;
    this._localContextDirectoryPath = _localContextDirectoryPath;
    this._moduleName = _moduleName;
    this._moduleOriginalName = _moduleOriginalName;
    this._originalSubpath = _originalSubpath;
    this._pin = _pin;
    this._repoRootPath = _repoRootPath;
    this._sourceRootSubpath = _sourceRootSubpath;
    this._sourceSubpath = _sourceSubpath;
    this._sync = _sync;
    this._version = _version;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  asModule = () => {
    const ctx = this._ctx.select("asModule");
    return new Module_(ctx);
  };
  asString = async () => {
    if (this._asString) {
      return this._asString;
    }
    const ctx = this._ctx.select("asString");
    const response = await ctx.execute();
    return response;
  };
  cloneRef = async () => {
    if (this._cloneRef) {
      return this._cloneRef;
    }
    const ctx = this._ctx.select("cloneRef");
    const response = await ctx.execute();
    return response;
  };
  commit = async () => {
    if (this._commit) {
      return this._commit;
    }
    const ctx = this._ctx.select("commit");
    const response = await ctx.execute();
    return response;
  };
  configClients = async () => {
    const ctx = this._ctx.select("configClients").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadModuleConfigClientFromID(r.id));
  };
  configExists = async () => {
    if (this._configExists) {
      return this._configExists;
    }
    const ctx = this._ctx.select("configExists");
    const response = await ctx.execute();
    return response;
  };
  contextDirectory = () => {
    const ctx = this._ctx.select("contextDirectory");
    return new Directory(ctx);
  };
  dependencies = async () => {
    const ctx = this._ctx.select("dependencies").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadModuleSourceFromID(r.id));
  };
  digest = async () => {
    if (this._digest) {
      return this._digest;
    }
    const ctx = this._ctx.select("digest");
    const response = await ctx.execute();
    return response;
  };
  directory = (path) => {
    const ctx = this._ctx.select("directory", { path });
    return new Directory(ctx);
  };
  engineVersion = async () => {
    if (this._engineVersion) {
      return this._engineVersion;
    }
    const ctx = this._ctx.select("engineVersion");
    const response = await ctx.execute();
    return response;
  };
  generatedContextDirectory = () => {
    const ctx = this._ctx.select("generatedContextDirectory");
    return new Directory(ctx);
  };
  htmlRepoURL = async () => {
    if (this._htmlRepoURL) {
      return this._htmlRepoURL;
    }
    const ctx = this._ctx.select("htmlRepoURL");
    const response = await ctx.execute();
    return response;
  };
  htmlURL = async () => {
    if (this._htmlURL) {
      return this._htmlURL;
    }
    const ctx = this._ctx.select("htmlURL");
    const response = await ctx.execute();
    return response;
  };
  kind = async () => {
    if (this._kind) {
      return this._kind;
    }
    const ctx = this._ctx.select("kind");
    const response = await ctx.execute();
    return response;
  };
  localContextDirectoryPath = async () => {
    if (this._localContextDirectoryPath) {
      return this._localContextDirectoryPath;
    }
    const ctx = this._ctx.select("localContextDirectoryPath");
    const response = await ctx.execute();
    return response;
  };
  moduleName = async () => {
    if (this._moduleName) {
      return this._moduleName;
    }
    const ctx = this._ctx.select("moduleName");
    const response = await ctx.execute();
    return response;
  };
  moduleOriginalName = async () => {
    if (this._moduleOriginalName) {
      return this._moduleOriginalName;
    }
    const ctx = this._ctx.select("moduleOriginalName");
    const response = await ctx.execute();
    return response;
  };
  originalSubpath = async () => {
    if (this._originalSubpath) {
      return this._originalSubpath;
    }
    const ctx = this._ctx.select("originalSubpath");
    const response = await ctx.execute();
    return response;
  };
  pin = async () => {
    if (this._pin) {
      return this._pin;
    }
    const ctx = this._ctx.select("pin");
    const response = await ctx.execute();
    return response;
  };
  repoRootPath = async () => {
    if (this._repoRootPath) {
      return this._repoRootPath;
    }
    const ctx = this._ctx.select("repoRootPath");
    const response = await ctx.execute();
    return response;
  };
  sdk = () => {
    const ctx = this._ctx.select("sdk");
    return new SDKConfig(ctx);
  };
  sourceRootSubpath = async () => {
    if (this._sourceRootSubpath) {
      return this._sourceRootSubpath;
    }
    const ctx = this._ctx.select("sourceRootSubpath");
    const response = await ctx.execute();
    return response;
  };
  sourceSubpath = async () => {
    if (this._sourceSubpath) {
      return this._sourceSubpath;
    }
    const ctx = this._ctx.select("sourceSubpath");
    const response = await ctx.execute();
    return response;
  };
  sync = async () => {
    const ctx = this._ctx.select("sync");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadModuleSourceFromID(response);
  };
  version = async () => {
    if (this._version) {
      return this._version;
    }
    const ctx = this._ctx.select("version");
    const response = await ctx.execute();
    return response;
  };
  withClient = (generator, outputDir) => {
    const ctx = this._ctx.select("withClient", { generator, outputDir });
    return new ModuleSource(ctx);
  };
  withDependencies = (dependencies) => {
    const ctx = this._ctx.select("withDependencies", { dependencies });
    return new ModuleSource(ctx);
  };
  withEngineVersion = (version) => {
    const ctx = this._ctx.select("withEngineVersion", { version });
    return new ModuleSource(ctx);
  };
  withIncludes = (patterns) => {
    const ctx = this._ctx.select("withIncludes", { patterns });
    return new ModuleSource(ctx);
  };
  withName = (name) => {
    const ctx = this._ctx.select("withName", { name });
    return new ModuleSource(ctx);
  };
  withSDK = (source) => {
    const ctx = this._ctx.select("withSDK", { source });
    return new ModuleSource(ctx);
  };
  withSourceSubpath = (path) => {
    const ctx = this._ctx.select("withSourceSubpath", { path });
    return new ModuleSource(ctx);
  };
  withUpdateDependencies = (dependencies) => {
    const ctx = this._ctx.select("withUpdateDependencies", { dependencies });
    return new ModuleSource(ctx);
  };
  withoutClient = (path) => {
    const ctx = this._ctx.select("withoutClient", { path });
    return new ModuleSource(ctx);
  };
  withoutDependencies = (dependencies) => {
    const ctx = this._ctx.select("withoutDependencies", { dependencies });
    return new ModuleSource(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class ObjectTypeDef extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  _sourceModuleName = undefined;
  constructor(ctx, _id, _description, _name, _sourceModuleName) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
    this._sourceModuleName = _sourceModuleName;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  constructor_ = () => {
    const ctx = this._ctx.select("constructor");
    return new Function_(ctx);
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  fields = async () => {
    const ctx = this._ctx.select("fields").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadFieldTypeDefFromID(r.id));
  };
  functions = async () => {
    const ctx = this._ctx.select("functions").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadFunctionFromID(r.id));
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sourceMap = () => {
    const ctx = this._ctx.select("sourceMap");
    return new SourceMap(ctx);
  };
  sourceModuleName = async () => {
    if (this._sourceModuleName) {
      return this._sourceModuleName;
    }
    const ctx = this._ctx.select("sourceModuleName");
    const response = await ctx.execute();
    return response;
  };
}

class Port extends BaseClient {
  _id = undefined;
  _description = undefined;
  _experimentalSkipHealthcheck = undefined;
  _port = undefined;
  _protocol = undefined;
  constructor(ctx, _id, _description, _experimentalSkipHealthcheck, _port, _protocol) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._experimentalSkipHealthcheck = _experimentalSkipHealthcheck;
    this._port = _port;
    this._protocol = _protocol;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  experimentalSkipHealthcheck = async () => {
    if (this._experimentalSkipHealthcheck) {
      return this._experimentalSkipHealthcheck;
    }
    const ctx = this._ctx.select("experimentalSkipHealthcheck");
    const response = await ctx.execute();
    return response;
  };
  port = async () => {
    if (this._port) {
      return this._port;
    }
    const ctx = this._ctx.select("port");
    const response = await ctx.execute();
    return response;
  };
  protocol = async () => {
    if (this._protocol) {
      return this._protocol;
    }
    const ctx = this._ctx.select("protocol");
    const response = await ctx.execute();
    return response;
  };
}

class Client extends BaseClient {
  _defaultPlatform = undefined;
  _version = undefined;
  constructor(ctx, _defaultPlatform, _version) {
    super(ctx);
    this._defaultPlatform = _defaultPlatform;
    this._version = _version;
  }
  getGQLClient() {
    return this._ctx.getGQLClient();
  }
  cacheVolume = (key) => {
    const ctx = this._ctx.select("cacheVolume", { key });
    return new CacheVolume(ctx);
  };
  cloud = () => {
    const ctx = this._ctx.select("cloud");
    return new Cloud(ctx);
  };
  container = (opts) => {
    const ctx = this._ctx.select("container", { ...opts });
    return new Container(ctx);
  };
  currentFunctionCall = () => {
    const ctx = this._ctx.select("currentFunctionCall");
    return new FunctionCall(ctx);
  };
  currentModule = () => {
    const ctx = this._ctx.select("currentModule");
    return new CurrentModule(ctx);
  };
  currentTypeDefs = async () => {
    const ctx = this._ctx.select("currentTypeDefs").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadTypeDefFromID(r.id));
  };
  defaultPlatform = async () => {
    const ctx = this._ctx.select("defaultPlatform");
    const response = await ctx.execute();
    return response;
  };
  directory = () => {
    const ctx = this._ctx.select("directory");
    return new Directory(ctx);
  };
  engine = () => {
    const ctx = this._ctx.select("engine");
    return new Engine(ctx);
  };
  env = (opts) => {
    const ctx = this._ctx.select("env", { ...opts });
    return new Env(ctx);
  };
  error = (message) => {
    const ctx = this._ctx.select("error", { message });
    return new Error2(ctx);
  };
  file = (name, contents, opts) => {
    const ctx = this._ctx.select("file", { name, contents, ...opts });
    return new File(ctx);
  };
  function_ = (name, returnType) => {
    const ctx = this._ctx.select("function", { name, returnType });
    return new Function_(ctx);
  };
  generatedCode = (code) => {
    const ctx = this._ctx.select("generatedCode", { code });
    return new GeneratedCode(ctx);
  };
  git = (url, opts) => {
    const ctx = this._ctx.select("git", { url, ...opts });
    return new GitRepository(ctx);
  };
  host = () => {
    const ctx = this._ctx.select("host");
    return new Host(ctx);
  };
  http = (url, opts) => {
    const ctx = this._ctx.select("http", { url, ...opts });
    return new File(ctx);
  };
  llm = (opts) => {
    const ctx = this._ctx.select("llm", { ...opts });
    return new LLM(ctx);
  };
  loadBindingFromID = (id) => {
    const ctx = this._ctx.select("loadBindingFromID", { id });
    return new Binding(ctx);
  };
  loadCacheVolumeFromID = (id) => {
    const ctx = this._ctx.select("loadCacheVolumeFromID", { id });
    return new CacheVolume(ctx);
  };
  loadCloudFromID = (id) => {
    const ctx = this._ctx.select("loadCloudFromID", { id });
    return new Cloud(ctx);
  };
  loadContainerFromID = (id) => {
    const ctx = this._ctx.select("loadContainerFromID", { id });
    return new Container(ctx);
  };
  loadCurrentModuleFromID = (id) => {
    const ctx = this._ctx.select("loadCurrentModuleFromID", { id });
    return new CurrentModule(ctx);
  };
  loadDirectoryFromID = (id) => {
    const ctx = this._ctx.select("loadDirectoryFromID", { id });
    return new Directory(ctx);
  };
  loadEngineCacheEntryFromID = (id) => {
    const ctx = this._ctx.select("loadEngineCacheEntryFromID", { id });
    return new EngineCacheEntry(ctx);
  };
  loadEngineCacheEntrySetFromID = (id) => {
    const ctx = this._ctx.select("loadEngineCacheEntrySetFromID", { id });
    return new EngineCacheEntrySet(ctx);
  };
  loadEngineCacheFromID = (id) => {
    const ctx = this._ctx.select("loadEngineCacheFromID", { id });
    return new EngineCache(ctx);
  };
  loadEngineFromID = (id) => {
    const ctx = this._ctx.select("loadEngineFromID", { id });
    return new Engine(ctx);
  };
  loadEnumTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadEnumTypeDefFromID", { id });
    return new EnumTypeDef(ctx);
  };
  loadEnumValueTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadEnumValueTypeDefFromID", { id });
    return new EnumValueTypeDef(ctx);
  };
  loadEnvFromID = (id) => {
    const ctx = this._ctx.select("loadEnvFromID", { id });
    return new Env(ctx);
  };
  loadEnvVariableFromID = (id) => {
    const ctx = this._ctx.select("loadEnvVariableFromID", { id });
    return new EnvVariable(ctx);
  };
  loadErrorFromID = (id) => {
    const ctx = this._ctx.select("loadErrorFromID", { id });
    return new Error2(ctx);
  };
  loadErrorValueFromID = (id) => {
    const ctx = this._ctx.select("loadErrorValueFromID", { id });
    return new ErrorValue(ctx);
  };
  loadFieldTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadFieldTypeDefFromID", { id });
    return new FieldTypeDef(ctx);
  };
  loadFileFromID = (id) => {
    const ctx = this._ctx.select("loadFileFromID", { id });
    return new File(ctx);
  };
  loadFunctionArgFromID = (id) => {
    const ctx = this._ctx.select("loadFunctionArgFromID", { id });
    return new FunctionArg(ctx);
  };
  loadFunctionCallArgValueFromID = (id) => {
    const ctx = this._ctx.select("loadFunctionCallArgValueFromID", { id });
    return new FunctionCallArgValue(ctx);
  };
  loadFunctionCallFromID = (id) => {
    const ctx = this._ctx.select("loadFunctionCallFromID", { id });
    return new FunctionCall(ctx);
  };
  loadFunctionFromID = (id) => {
    const ctx = this._ctx.select("loadFunctionFromID", { id });
    return new Function_(ctx);
  };
  loadGeneratedCodeFromID = (id) => {
    const ctx = this._ctx.select("loadGeneratedCodeFromID", { id });
    return new GeneratedCode(ctx);
  };
  loadGitRefFromID = (id) => {
    const ctx = this._ctx.select("loadGitRefFromID", { id });
    return new GitRef(ctx);
  };
  loadGitRepositoryFromID = (id) => {
    const ctx = this._ctx.select("loadGitRepositoryFromID", { id });
    return new GitRepository(ctx);
  };
  loadHostFromID = (id) => {
    const ctx = this._ctx.select("loadHostFromID", { id });
    return new Host(ctx);
  };
  loadInputTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadInputTypeDefFromID", { id });
    return new InputTypeDef(ctx);
  };
  loadInterfaceTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadInterfaceTypeDefFromID", { id });
    return new InterfaceTypeDef(ctx);
  };
  loadLLMFromID = (id) => {
    const ctx = this._ctx.select("loadLLMFromID", { id });
    return new LLM(ctx);
  };
  loadLLMTokenUsageFromID = (id) => {
    const ctx = this._ctx.select("loadLLMTokenUsageFromID", { id });
    return new LLMTokenUsage(ctx);
  };
  loadLabelFromID = (id) => {
    const ctx = this._ctx.select("loadLabelFromID", { id });
    return new Label(ctx);
  };
  loadListTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadListTypeDefFromID", { id });
    return new ListTypeDef(ctx);
  };
  loadModuleConfigClientFromID = (id) => {
    const ctx = this._ctx.select("loadModuleConfigClientFromID", { id });
    return new ModuleConfigClient(ctx);
  };
  loadModuleFromID = (id) => {
    const ctx = this._ctx.select("loadModuleFromID", { id });
    return new Module_(ctx);
  };
  loadModuleSourceFromID = (id) => {
    const ctx = this._ctx.select("loadModuleSourceFromID", { id });
    return new ModuleSource(ctx);
  };
  loadObjectTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadObjectTypeDefFromID", { id });
    return new ObjectTypeDef(ctx);
  };
  loadPortFromID = (id) => {
    const ctx = this._ctx.select("loadPortFromID", { id });
    return new Port(ctx);
  };
  loadSDKConfigFromID = (id) => {
    const ctx = this._ctx.select("loadSDKConfigFromID", { id });
    return new SDKConfig(ctx);
  };
  loadScalarTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadScalarTypeDefFromID", { id });
    return new ScalarTypeDef(ctx);
  };
  loadSecretFromID = (id) => {
    const ctx = this._ctx.select("loadSecretFromID", { id });
    return new Secret(ctx);
  };
  loadServiceFromID = (id) => {
    const ctx = this._ctx.select("loadServiceFromID", { id });
    return new Service(ctx);
  };
  loadSocketFromID = (id) => {
    const ctx = this._ctx.select("loadSocketFromID", { id });
    return new Socket(ctx);
  };
  loadSourceMapFromID = (id) => {
    const ctx = this._ctx.select("loadSourceMapFromID", { id });
    return new SourceMap(ctx);
  };
  loadTerminalFromID = (id) => {
    const ctx = this._ctx.select("loadTerminalFromID", { id });
    return new Terminal(ctx);
  };
  loadTypeDefFromID = (id) => {
    const ctx = this._ctx.select("loadTypeDefFromID", { id });
    return new TypeDef(ctx);
  };
  module_ = () => {
    const ctx = this._ctx.select("module");
    return new Module_(ctx);
  };
  moduleSource = (refString, opts) => {
    const metadata = {
      requireKind: { is_enum: true }
    };
    const ctx = this._ctx.select("moduleSource", {
      refString,
      ...opts,
      __metadata: metadata
    });
    return new ModuleSource(ctx);
  };
  secret = (uri, opts) => {
    const ctx = this._ctx.select("secret", { uri, ...opts });
    return new Secret(ctx);
  };
  setSecret = (name, plaintext) => {
    const ctx = this._ctx.select("setSecret", { name, plaintext });
    return new Secret(ctx);
  };
  sourceMap = (filename, line, column) => {
    const ctx = this._ctx.select("sourceMap", { filename, line, column });
    return new SourceMap(ctx);
  };
  typeDef = () => {
    const ctx = this._ctx.select("typeDef");
    return new TypeDef(ctx);
  };
  version = async () => {
    const ctx = this._ctx.select("version");
    const response = await ctx.execute();
    return response;
  };
}

class SDKConfig extends BaseClient {
  _id = undefined;
  _source = undefined;
  constructor(ctx, _id, _source) {
    super(ctx);
    this._id = _id;
    this._source = _source;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  source = async () => {
    if (this._source) {
      return this._source;
    }
    const ctx = this._ctx.select("source");
    const response = await ctx.execute();
    return response;
  };
}

class ScalarTypeDef extends BaseClient {
  _id = undefined;
  _description = undefined;
  _name = undefined;
  _sourceModuleName = undefined;
  constructor(ctx, _id, _description, _name, _sourceModuleName) {
    super(ctx);
    this._id = _id;
    this._description = _description;
    this._name = _name;
    this._sourceModuleName = _sourceModuleName;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  description = async () => {
    if (this._description) {
      return this._description;
    }
    const ctx = this._ctx.select("description");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  sourceModuleName = async () => {
    if (this._sourceModuleName) {
      return this._sourceModuleName;
    }
    const ctx = this._ctx.select("sourceModuleName");
    const response = await ctx.execute();
    return response;
  };
}

class Secret extends BaseClient {
  _id = undefined;
  _name = undefined;
  _plaintext = undefined;
  _uri = undefined;
  constructor(ctx, _id, _name, _plaintext, _uri) {
    super(ctx);
    this._id = _id;
    this._name = _name;
    this._plaintext = _plaintext;
    this._uri = _uri;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  name = async () => {
    if (this._name) {
      return this._name;
    }
    const ctx = this._ctx.select("name");
    const response = await ctx.execute();
    return response;
  };
  plaintext = async () => {
    if (this._plaintext) {
      return this._plaintext;
    }
    const ctx = this._ctx.select("plaintext");
    const response = await ctx.execute();
    return response;
  };
  uri = async () => {
    if (this._uri) {
      return this._uri;
    }
    const ctx = this._ctx.select("uri");
    const response = await ctx.execute();
    return response;
  };
}

class Service extends BaseClient {
  _id = undefined;
  _endpoint = undefined;
  _hostname = undefined;
  _start = undefined;
  _stop = undefined;
  _up = undefined;
  constructor(ctx, _id, _endpoint, _hostname, _start, _stop, _up) {
    super(ctx);
    this._id = _id;
    this._endpoint = _endpoint;
    this._hostname = _hostname;
    this._start = _start;
    this._stop = _stop;
    this._up = _up;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  endpoint = async (opts) => {
    if (this._endpoint) {
      return this._endpoint;
    }
    const ctx = this._ctx.select("endpoint", { ...opts });
    const response = await ctx.execute();
    return response;
  };
  hostname = async () => {
    if (this._hostname) {
      return this._hostname;
    }
    const ctx = this._ctx.select("hostname");
    const response = await ctx.execute();
    return response;
  };
  ports = async () => {
    const ctx = this._ctx.select("ports").select("id");
    const response = await ctx.execute();
    return response.map((r) => new Client(ctx.copy()).loadPortFromID(r.id));
  };
  start = async () => {
    const ctx = this._ctx.select("start");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadServiceFromID(response);
  };
  stop = async (opts) => {
    const ctx = this._ctx.select("stop", { ...opts });
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadServiceFromID(response);
  };
  up = async (opts) => {
    if (this._up) {
      return;
    }
    const ctx = this._ctx.select("up", { ...opts });
    await ctx.execute();
  };
  withHostname = (hostname) => {
    const ctx = this._ctx.select("withHostname", { hostname });
    return new Service(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}

class Socket extends BaseClient {
  _id = undefined;
  constructor(ctx, _id) {
    super(ctx);
    this._id = _id;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
}

class SourceMap extends BaseClient {
  _id = undefined;
  _column = undefined;
  _filename = undefined;
  _line = undefined;
  _module = undefined;
  constructor(ctx, _id, _column, _filename, _line, _module) {
    super(ctx);
    this._id = _id;
    this._column = _column;
    this._filename = _filename;
    this._line = _line;
    this._module = _module;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  column = async () => {
    if (this._column) {
      return this._column;
    }
    const ctx = this._ctx.select("column");
    const response = await ctx.execute();
    return response;
  };
  filename = async () => {
    if (this._filename) {
      return this._filename;
    }
    const ctx = this._ctx.select("filename");
    const response = await ctx.execute();
    return response;
  };
  line = async () => {
    if (this._line) {
      return this._line;
    }
    const ctx = this._ctx.select("line");
    const response = await ctx.execute();
    return response;
  };
  module_ = async () => {
    if (this._module) {
      return this._module;
    }
    const ctx = this._ctx.select("module");
    const response = await ctx.execute();
    return response;
  };
}

class Terminal extends BaseClient {
  _id = undefined;
  _sync = undefined;
  constructor(ctx, _id, _sync) {
    super(ctx);
    this._id = _id;
    this._sync = _sync;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  sync = async () => {
    const ctx = this._ctx.select("sync");
    const response = await ctx.execute();
    return new Client(ctx.copy()).loadTerminalFromID(response);
  };
}

class TypeDef extends BaseClient {
  _id = undefined;
  _kind = undefined;
  _optional = undefined;
  constructor(ctx, _id, _kind, _optional) {
    super(ctx);
    this._id = _id;
    this._kind = _kind;
    this._optional = _optional;
  }
  id = async () => {
    if (this._id) {
      return this._id;
    }
    const ctx = this._ctx.select("id");
    const response = await ctx.execute();
    return response;
  };
  asEnum = () => {
    const ctx = this._ctx.select("asEnum");
    return new EnumTypeDef(ctx);
  };
  asInput = () => {
    const ctx = this._ctx.select("asInput");
    return new InputTypeDef(ctx);
  };
  asInterface = () => {
    const ctx = this._ctx.select("asInterface");
    return new InterfaceTypeDef(ctx);
  };
  asList = () => {
    const ctx = this._ctx.select("asList");
    return new ListTypeDef(ctx);
  };
  asObject = () => {
    const ctx = this._ctx.select("asObject");
    return new ObjectTypeDef(ctx);
  };
  asScalar = () => {
    const ctx = this._ctx.select("asScalar");
    return new ScalarTypeDef(ctx);
  };
  kind = async () => {
    if (this._kind) {
      return this._kind;
    }
    const ctx = this._ctx.select("kind");
    const response = await ctx.execute();
    return response;
  };
  optional = async () => {
    if (this._optional) {
      return this._optional;
    }
    const ctx = this._ctx.select("optional");
    const response = await ctx.execute();
    return response;
  };
  withConstructor = (function_) => {
    const ctx = this._ctx.select("withConstructor", {
      function: function_
    });
    return new TypeDef(ctx);
  };
  withEnum = (name, opts) => {
    const ctx = this._ctx.select("withEnum", { name, ...opts });
    return new TypeDef(ctx);
  };
  withEnumMember = (name, opts) => {
    const ctx = this._ctx.select("withEnumMember", { name, ...opts });
    return new TypeDef(ctx);
  };
  withEnumValue = (value, opts) => {
    const ctx = this._ctx.select("withEnumValue", { value, ...opts });
    return new TypeDef(ctx);
  };
  withField = (name, typeDef, opts) => {
    const ctx = this._ctx.select("withField", { name, typeDef, ...opts });
    return new TypeDef(ctx);
  };
  withFunction = (function_) => {
    const ctx = this._ctx.select("withFunction", {
      function: function_
    });
    return new TypeDef(ctx);
  };
  withInterface = (name, opts) => {
    const ctx = this._ctx.select("withInterface", { name, ...opts });
    return new TypeDef(ctx);
  };
  withKind = (kind2) => {
    const metadata = {
      kind: { is_enum: true }
    };
    const ctx = this._ctx.select("withKind", { kind: kind2, __metadata: metadata });
    return new TypeDef(ctx);
  };
  withListOf = (elementType) => {
    const ctx = this._ctx.select("withListOf", { elementType });
    return new TypeDef(ctx);
  };
  withObject = (name, opts) => {
    const ctx = this._ctx.select("withObject", { name, ...opts });
    return new TypeDef(ctx);
  };
  withOptional = (optional) => {
    const ctx = this._ctx.select("withOptional", { optional });
    return new TypeDef(ctx);
  };
  withScalar = (name, opts) => {
    const ctx = this._ctx.select("withScalar", { name, ...opts });
    return new TypeDef(ctx);
  };
  with = (arg) => {
    return arg(this);
  };
}
var dag = new Client;

// src/index.ts
init_errors();

// src/connect.ts
var opentelemetry4 = __toESM(require_src(), 1);

// src/common/graphql/connect.ts
init_client();
async function withGQLClient(connectOpts, cb) {
  if (process.env["DAGGER_SESSION_PORT"]) {
    const port = process.env["DAGGER_SESSION_PORT"];
    if (!process.env["DAGGER_SESSION_TOKEN"]) {
      throw new Error("DAGGER_SESSION_TOKEN must be set if DAGGER_SESSION_PORT is set");
    }
    const token = process.env["DAGGER_SESSION_TOKEN"];
    return await cb(createGQLClient(Number(port), token));
  }
  try {
    const provisioning = await Promise.resolve().then(() => (init_provisioning(), exports_provisioning));
    return await provisioning.withEngineSession(connectOpts, cb);
  } catch (e2) {
    throw new Error(`failed to execute function with automatic provisioning: ${e2}`);
  }
}

// src/connect.ts
async function connection(fct, cfg = {}) {
  try {
    initialize();
    await opentelemetry4.context.with(getContext(), async () => {
      try {
        await withGQLClient(cfg, async (gqlClient) => {
          globalConnection.setGQLClient(gqlClient);
          await fct();
        });
      } finally {
        globalConnection.resetClient();
      }
    });
  } finally {
    await close();
  }
}
async function connect(cb, config = {}) {
  await withGQLClient(config, async (gqlClient) => {
    const connection2 = new Connection(gqlClient);
    const ctx = new Context([], connection2);
    const client = new Client(ctx);
    try {
      await client.version();
    } catch (e2) {
      console.error("failed to check version compatibility:", e2);
    }
    return await cb(client);
  });
}
// src/module/registry.ts
var import_reflect_metadata = __toESM(require_Reflect(), 1);
init_errors();

class Registry {
  object = () => {
    return (constructor) => {
      Reflect.defineMetadata(constructor.name, { class_: constructor }, this);
      return constructor;
    };
  };
  enumType = () => {
    return (constructor) => {
      return constructor;
    };
  };
  field = (alias) => {
    return (target, propertyKey) => {
    };
  };
  func = (alias) => {
    return (target, propertyKey, descriptor) => {
    };
  };
  argument = (opts) => {
    return (target, propertyKey, parameterIndex) => {
    };
  };
  buildClass(object, state) {
    const resolver = Reflect.getMetadata(object, this);
    if (!resolver) {
      return object;
    }
    let r2 = Object.create(resolver.class_.prototype);
    r2 = Object.assign(r2, state);
    return r2;
  }
  async getResult(object, method, state, inputs) {
    const resolver = Reflect.getMetadata(object, this);
    if (!resolver) {
      throw new UnknownDaggerError(`${object} is not register as a resolver`, {});
    }
    if (method === "") {
      return new resolver.class_(...Object.values(inputs));
    }
    let r2 = Object.create(resolver.class_.prototype);
    if (!r2[method]) {
      throw new UnknownDaggerError(`${method} is not registered in the resolver ${object}`, {});
    }
    r2 = Object.assign(r2, state);
    return await r2[method](...Object.values(inputs));
  }
}
var registry = new Registry;

// src/module/decorators.ts
var object = registry.object;
var func = registry.func;
var field = registry.field;
var enumType = registry.enumType;
var argument2 = registry.argument;
// src/module/entrypoint/entrypoint.ts
init_ExecError();
init_GraphQLRequestError();

// src/module/executor.ts
init_errors();
class Executor {
  modules;
  daggerModule;
  constructor(modules, daggerModule) {
    this.modules = modules;
    this.daggerModule = daggerModule;
  }
  getExportedObject(object2) {
    const key = object2;
    const module = this.modules.find((m2) => m2[key] !== undefined);
    if (!module) {
      throw new FunctionNotFound(`Object ${object2} not found`);
    }
    return module[key];
  }
  buildClass(object2, state) {
    const daggerObject = this.daggerModule.objects[object2];
    if (!daggerObject) {
      throw new FunctionNotFound(`Object ${object2} not found in the module`);
    }
    switch (daggerObject.kind()) {
      case "class": {
        const obj = this.getExportedObject(object2);
        const instanciatedClass = Object.create(obj.prototype);
        Object.assign(instanciatedClass, state);
        return instanciatedClass;
      }
      case "object": {
        return state;
      }
    }
  }
  buildInterface(iface, id) {
    const interfaceObject = this.daggerModule.interfaces[iface];
    if (!interfaceObject) {
      throw new Error(`Interface ${iface} not found in the module`);
    }
    const ifaceImpl = new InterfaceWrapper(this, this.daggerModule, `${this.daggerModule.name}${iface}`, id, interfaceObject.functions);
    return ifaceImpl;
  }
  async getResult(object2, method, state, inputs) {
    const obj = this.getExportedObject(object2);
    if (method === "") {
      return new obj(...Object.values(inputs));
    }
    const builtObj = this.buildClass(object2, state);
    if (!builtObj[method]) {
      throw new FunctionNotFound(`Method ${method} not found`);
    }
    return await builtObj[method](...Object.values(inputs));
  }
}

class InterfaceWrapper {
  executor;
  module;
  ifaceName;
  ifaceId;
  fcts;
  _ctx;
  constructor(executor, module, ifaceName, ifaceId, fcts) {
    this.executor = executor;
    this.module = module;
    this.ifaceName = ifaceName;
    this.ifaceId = ifaceId;
    this.fcts = fcts;
    this._ctx = new Context([], new Connection(dag.getGQLClient()));
    this._ctx = this._ctx.select(`load${ifaceName}FromID`, { id: ifaceId });
    Object.entries(fcts).forEach(([name2, fct]) => {
      const argKeys = Object.keys(fct.arguments);
      this[name2] = async (...args) => {
        const argsPayload = {};
        for (let i3 = 0;i3 < argKeys.length; i3++) {
          if (args[i3] !== undefined) {
            argsPayload[argKeys[i3]] = args[i3];
          }
        }
        this._ctx = this._ctx.select(name2, argsPayload);
        if (fct.returnType.kind === "INTERFACE_KIND" /* InterfaceKind */ || fct.returnType.kind === "OBJECT_KIND" /* ObjectKind */) {
          return this;
        }
        if (fct.returnType.kind === "LIST_KIND" /* ListKind */) {
          const listTypeDef = fct.returnType.typeDef;
          if (listTypeDef.kind === "OBJECT_KIND" /* ObjectKind */ || listTypeDef.kind === "INTERFACE_KIND" /* InterfaceKind */) {
            const typedef = listTypeDef;
            const ids = await this._ctx.select("id").execute();
            if (this.module.interfaces[typedef.name]) {
              return await Promise.all(ids.map(({ id }) => new InterfaceWrapper(this.executor, module, `${this.module.name}${typedef.name}`, id, this.module.interfaces[typedef.name].functions)));
            }
            return await Promise.all(ids.map(({ id }) => dag[`load${listTypeDef.name}FromID`](id)));
          }
        }
        return await this._ctx.execute();
      };
    });
  }
  async id() {
    const ctx = this._ctx.select("id");
    return await ctx.execute();
  }
}

// src/module/introspector/index.ts
init_errors();

// src/module/introspector/dagger_module/argument.ts
init_errors();
import ts3 from "typescript";

// src/module/introspector/typescript_module/ast.ts
import * as path15 from "path";
import ts2 from "typescript";
init_errors();

// src/module/introspector/typescript_module/declarations.ts
import ts from "typescript";
var isDeclarationOf = {
  [ts.SyntaxKind.ClassDeclaration]: ts.isClassDeclaration,
  [ts.SyntaxKind.MethodDeclaration]: ts.isMethodDeclaration,
  [ts.SyntaxKind.PropertyDeclaration]: ts.isPropertyDeclaration,
  [ts.SyntaxKind.FunctionDeclaration]: ts.isFunctionDeclaration,
  [ts.SyntaxKind.EnumDeclaration]: ts.isEnumDeclaration,
  [ts.SyntaxKind.InterfaceDeclaration]: ts.isInterfaceDeclaration,
  [ts.SyntaxKind.TypeAliasDeclaration]: ts.isTypeAliasDeclaration
};

// src/module/introspector/typescript_module/explorer.ts
function findModuleByExportedName(name2, modules) {
  for (const module of modules) {
    if (module[name2]) {
      return module;
    }
  }
}
function getValueByExportedName(name2, modules) {
  for (const module of modules) {
    if (module[name2]) {
      return module[name2];
    }
  }
  return;
}

// src/module/introspector/typescript_module/ast.ts
var CLIENT_GEN_FILE = "client.gen.ts";

class AST {
  files;
  userModule;
  checker;
  sourceFiles;
  constructor(files2, userModule2) {
    this.files = files2;
    this.userModule = userModule2;
    const program = ts2.createProgram(files2, {
      experimentalDecorators: true,
      moduleResolution: ts2.ModuleResolutionKind.Node10,
      target: ts2.ScriptTarget.ES2022
    });
    this.checker = program.getTypeChecker();
    this.sourceFiles = program.getSourceFiles().filter((file) => !file.isDeclarationFile);
  }
  findResolvedNodeByName(name2, kind2) {
    let result;
    for (const sourceFile of this.sourceFiles) {
      ts2.forEachChild(sourceFile, (node2) => {
        if (result !== undefined)
          return;
        if (!sourceFile.fileName.endsWith(CLIENT_GEN_FILE) && !this.files.includes(sourceFile.fileName)) {
          return;
        }
        if (kind2 !== undefined && node2.kind === kind2) {
          const isDeclarationValid = isDeclarationOf[kind2](node2);
          if (!isDeclarationValid)
            return;
          const convertedNode = node2;
          if (!convertedNode.name || convertedNode.name.getText() !== name2) {
            return;
          }
          const symbol = this.checker.getSymbolAtLocation(convertedNode.name);
          if (!symbol) {
            console.debug(`missing symbol for ${name2} at ${sourceFile.fileName}:${node2.pos}`);
            return;
          }
          result = {
            type: kind2,
            node: convertedNode,
            symbol,
            file: sourceFile
          };
        }
      });
    }
    return result;
  }
  getTypeFromTypeAlias(typeAlias) {
    const symbol = this.getSymbolOrThrow(typeAlias.name);
    return this.checker.getDeclaredTypeOfSymbol(symbol);
  }
  static getNodePosition(node2) {
    const sourceFile = node2.getSourceFile();
    const position2 = ts2.getLineAndCharacterOfPosition(sourceFile, node2.getStart());
    return `${sourceFile.fileName}:${position2.line}:${position2.character}`;
  }
  static getNodeLocation(node2) {
    const sourceFile = node2.getSourceFile();
    const targetNode = node2.name ?? node2;
    const position2 = ts2.getLineAndCharacterOfPosition(sourceFile, targetNode.getStart(sourceFile));
    const pathParts = sourceFile.fileName.split(path15.sep);
    const srcIndex = pathParts.indexOf("src", 2);
    return {
      filepath: pathParts.slice(srcIndex).join(path15.sep),
      line: position2.line + 1,
      column: position2.character + 1
    };
  }
  getDocFromSymbol(symbol) {
    return ts2.displayPartsToString(symbol.getDocumentationComment(this.checker));
  }
  getSymbolOrThrow(node2) {
    const symbol = this.getSymbol(node2);
    if (!symbol) {
      throw new IntrospectionError(`could not find symbol at ${AST.getNodePosition(node2)}`);
    }
    return symbol;
  }
  getSignatureFromFunctionOrThrow(node2) {
    const signature = this.checker.getSignatureFromDeclaration(node2);
    if (!signature) {
      throw new IntrospectionError(`could not find signature at ${AST.getNodePosition(node2)}`);
    }
    return signature;
  }
  getSymbol(node2) {
    return this.checker.getSymbolAtLocation(node2);
  }
  isNodeDecoratedWith(node2, daggerDecorator2) {
    const decorators2 = ts2.getDecorators(node2);
    if (!decorators2) {
      return false;
    }
    const decorator2 = decorators2.find((d) => d.expression.getText().startsWith(daggerDecorator2));
    if (!decorator2) {
      return false;
    }
    if (!ts2.isCallExpression(decorator2.expression)) {
      throw new IntrospectionError(`decorator at ${AST.getNodePosition(node2)} should be a call expression, please use ${daggerDecorator2}() instead.`);
    }
    return true;
  }
  getDecoratorArgument(node, daggerDecorator, type, position = 0) {
    const decorators = ts2.getDecorators(node);
    if (!decorators) {
      return;
    }
    const decorator = decorators.find((d) => d.expression.getText().startsWith(daggerDecorator));
    if (!decorator) {
      return;
    }
    const argument = decorator.expression.arguments[position];
    if (!argument) {
      return;
    }
    switch (type) {
      case "string":
        return argument.getText();
      case "object":
        return eval(`(${argument.getText()})`);
    }
  }
  unwrapTypeStringFromPromise(type2) {
    if (type2.startsWith("Promise<")) {
      return type2.slice("Promise<".length, -">".length);
    }
    if (type2.startsWith("Awaited<")) {
      return type2.slice("Awaited<".length, -">".length);
    }
    return type2;
  }
  unwrapTypeStringFromArray(type2) {
    if (type2.endsWith("[]")) {
      return type2.replace("[]", "");
    }
    if (type2.startsWith("Array<")) {
      return type2.slice("Array<".length, -">".length);
    }
    return type2;
  }
  stringTypeToUnwrappedType(type2) {
    type2 = this.unwrapTypeStringFromPromise(type2);
    const extractedTypeFromArray = this.unwrapTypeStringFromArray(type2);
    if (extractedTypeFromArray !== type2) {
      return this.stringTypeToUnwrappedType(extractedTypeFromArray);
    }
    return type2;
  }
  typeToStringType(type2) {
    const stringType = this.checker.typeToString(type2);
    return this.stringTypeToUnwrappedType(stringType);
  }
  tsTypeToTypeDef(node2, type2) {
    if (type2.flags & ts2.TypeFlags.String)
      return { kind: "STRING_KIND" /* StringKind */ };
    if (type2.flags & ts2.TypeFlags.Number) {
      if (node2.getText().includes("float")) {
        return { kind: "FLOAT_KIND" /* FloatKind */ };
      }
      return { kind: "INTEGER_KIND" /* IntegerKind */ };
    }
    if (type2.flags & ts2.TypeFlags.Boolean)
      return { kind: "BOOLEAN_KIND" /* BooleanKind */ };
    if (type2.flags & ts2.TypeFlags.Void)
      return { kind: "VOID_KIND" /* VoidKind */ };
    if (type2.flags & ts2.TypeFlags.Object) {
      const objectType = type2;
      if (objectType.objectFlags & ts2.ObjectFlags.Reference) {
        const typeArguments = this.checker.getTypeArguments(type2);
        switch (typeArguments.length) {
          case 0:
            break;
          case 1: {
            const typeArgument = typeArguments[0];
            if (type2.symbol.getName() === "Promise") {
              return this.tsTypeToTypeDef(node2, typeArgument);
            }
            if (type2.symbol.getName() === "Array") {
              return {
                kind: "LIST_KIND" /* ListKind */,
                typeDef: this.tsTypeToTypeDef(node2, typeArgument)
              };
            }
            return;
          }
          default: {
            throw new IntrospectionError(`could not resolve type ${type2.symbol.getName()} at ${AST.getNodePosition(node2)}, dagger does not support generics with argument yet.`);
          }
        }
      }
    }
  }
  resolveParameterDefaultValueTypeReference(expression2, value) {
    const type2 = typeof value;
    switch (type2) {
      case "string":
      case "number":
      case "bigint":
      case "boolean":
      case "object":
        return value;
      default:
        return;
    }
  }
  resolveParameterDefaultValue(expression) {
    const kind = expression.kind;
    switch (kind) {
      case ts2.SyntaxKind.StringLiteral:
        return `${eval(expression.getText())}`;
      case ts2.SyntaxKind.NumericLiteral:
        return parseInt(expression.getText());
      case ts2.SyntaxKind.TrueKeyword:
        return true;
      case ts2.SyntaxKind.FalseKeyword:
        return false;
      case ts2.SyntaxKind.NullKeyword:
        return null;
      case ts2.SyntaxKind.ArrayLiteralExpression:
        return eval(expression.getText());
      case ts2.SyntaxKind.Identifier: {
        const value = getValueByExportedName(expression.getText(), this.userModule);
        if (value === undefined) {
          throw new IntrospectionError(`could not resolve default value reference to the variable: '${expression.getText()}' from ${AST.getNodePosition(expression)}. Is it exported by the module?`);
        }
        return this.resolveParameterDefaultValueTypeReference(expression, value);
      }
      case ts2.SyntaxKind.PropertyAccessExpression: {
        const accessors = expression.getText().split(".");
        let value = getValueByExportedName(accessors[0], this.userModule);
        for (let i3 = 1;i3 < accessors.length; i3++) {
          value = value[accessors[i3]];
        }
        return this.resolveParameterDefaultValueTypeReference(expression, value);
      }
      default: {
        console.warn(`default value '${expression.getText()}' at ${AST.getNodePosition(expression)} cannot be resolved, dagger does not support object or function as default value. 
          The value will be ignored by the introspection and resolve at the runtime.`);
      }
    }
  }
}
// src/module/introspector/typescript_module/typedef_utils.ts
init_errors();
function isTypeDefResolved(typeDef) {
  if (typeDef.kind !== "LIST_KIND" /* ListKind */) {
    return true;
  }
  const arrayTypeDef = typeDef;
  if (arrayTypeDef.typeDef === undefined) {
    return false;
  }
  if (arrayTypeDef.typeDef.kind === "LIST_KIND" /* ListKind */) {
    return isTypeDefResolved(arrayTypeDef.typeDef);
  }
  return true;
}
function resolveTypeDef(typeDef, reference) {
  if (typeDef === undefined) {
    return reference;
  }
  if (typeDef.kind === "LIST_KIND" /* ListKind */) {
    const listTypeDef = typeDef;
    listTypeDef.typeDef = resolveTypeDef(listTypeDef.typeDef, reference);
    return listTypeDef;
  }
  throw new IntrospectionError(`type ${JSON.stringify(typeDef)} has already been resolved, it should not be overwritten ; reference: ${JSON.stringify(reference)}`);
}
// src/module/introspector/dagger_module/decorator.ts
var OBJECT_DECORATOR = object.name;
var FUNCTION_DECORATOR = func.name;
var FIELD_DECORATOR = field.name;
var ARGUMENT_DECORATOR = argument2.name;
var ENUM_DECORATOR = enumType.name;

// src/module/introspector/dagger_module/locatable.ts
class Locatable {
  __node;
  constructor(__node) {
    this.__node = __node;
  }
  getLocation() {
    return AST.getNodeLocation(this.__node);
  }
}

// src/module/introspector/dagger_module/argument.ts
class DaggerArgument extends Locatable {
  node;
  ast;
  name;
  description;
  _typeRef;
  type;
  isVariadic;
  isNullable;
  isOptional;
  defaultPath;
  ignore;
  defaultValue;
  symbol;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    this.symbol = this.ast.getSymbolOrThrow(node2.name);
    this.name = this.node.name.getText();
    this.description = this.ast.getDocFromSymbol(this.symbol);
    this.defaultValue = this.getDefaultValue();
    this.isVariadic = this.node.dotDotDotToken !== undefined;
    this.isNullable = this.getIsNullable();
    this.isOptional = this.isVariadic || this.defaultValue === undefined && this.node.initializer !== undefined || this.isNullable || this.node.questionToken !== undefined;
    const decoratorArguments = this.ast.getDecoratorArgument(this.node, ARGUMENT_DECORATOR, "object");
    if (decoratorArguments) {
      this.ignore = decoratorArguments.ignore;
      this.defaultPath = decoratorArguments.defaultPath;
    }
    this.type = this.getType();
  }
  getType() {
    const type2 = this.ast.checker.getTypeAtLocation(this.node);
    const typedef = this.ast.tsTypeToTypeDef(this.node, type2);
    if (typedef === undefined || !isTypeDefResolved(typedef)) {
      this._typeRef = this.ast.typeToStringType(type2);
    }
    return typedef;
  }
  getIsNullable() {
    if (!this.node.type) {
      return false;
    }
    if (ts3.isUnionTypeNode(this.node.type)) {
      for (const _type of this.node.type.types) {
        if (_type.getText() === "null") {
          return true;
        }
      }
    }
    return false;
  }
  getDefaultValue() {
    const initializer = this.node.initializer;
    if (!initializer) {
      return;
    }
    return this.ast.resolveParameterDefaultValue(initializer);
  }
  getReference() {
    if (this._typeRef && (this.type === undefined || !isTypeDefResolved(this.type))) {
      return this._typeRef;
    }
    return;
  }
  propagateReferences(references) {
    if (!this._typeRef) {
      return;
    }
    if (this.type && isTypeDefResolved(this.type)) {
      return;
    }
    const typeDef = references[this._typeRef];
    if (!typeDef) {
      throw new IntrospectionError(`could not find type reference for ${this._typeRef} at ${AST.getNodePosition(this.node)}.`);
    }
    this.type = resolveTypeDef(this.type, typeDef);
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      type: this.type,
      isVariadic: this.isVariadic,
      isNullable: this.isNullable,
      isOptional: this.isOptional,
      defaultValue: this.defaultValue,
      defaultPath: this.defaultPath,
      ignore: this.ignore
    };
  }
}

// src/module/introspector/dagger_module/constructor.ts
class DaggerConstructor {
  node;
  ast;
  name = "";
  arguments = {};
  constructor(node2, ast2) {
    this.node = node2;
    this.ast = ast2;
    const parameters = this.node.parameters;
    for (const parameter of parameters) {
      this.arguments[parameter.name.getText()] = new DaggerArgument(parameter, this.ast);
    }
  }
  getArgsOrder() {
    return Object.keys(this.arguments);
  }
  getReferences() {
    const references = [];
    for (const argument3 of Object.values(this.arguments)) {
      const ref = argument3.getReference();
      if (ref) {
        references.push(ref);
      }
    }
    return references;
  }
  propagateReferences(references) {
    for (const argument3 of Object.values(this.arguments)) {
      argument3.propagateReferences(references);
    }
  }
  toJSON() {
    return {
      arguments: this.arguments
    };
  }
}
// src/module/introspector/dagger_module/enum.ts
init_errors();
class DaggerEnumValue extends Locatable {
  node;
  ast;
  name;
  value;
  description;
  symbol;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.name = this.node.name.getText();
    this.description = this.ast.getDocFromSymbol(this.symbol);
    const initializer = this.node.initializer;
    if (!initializer) {
      throw new IntrospectionError(`enum ${this.name} at ${AST.getNodePosition(this.node)} has no value set to its member.`);
    }
    this.value = this.ast.resolveParameterDefaultValue(initializer);
  }
  toJSON() {
    return {
      name: this.value,
      description: this.description
    };
  }
}

class DaggerEnum extends Locatable {
  node;
  ast;
  name;
  description;
  values = {};
  symbol;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    this.name = this.node.name.getText();
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    const members = this.node.members;
    for (const member of members) {
      const value = new DaggerEnumValue(member, this.ast);
      this.values[value.name] = value;
    }
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      values: this.values
    };
  }
}
// src/module/introspector/dagger_module/enumClass.ts
init_errors();
import ts4 from "typescript";
class DaggerEnumClassValue extends Locatable {
  node;
  ast;
  name;
  value;
  description;
  symbol;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    this.name = this.node.name.getText();
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    const initializer = this.node.initializer;
    if (!initializer) {
      throw new Error("Dagger enum value has no value set");
    }
    this.value = this.ast.resolveParameterDefaultValue(initializer);
  }
  toJSON() {
    return {
      name: this.value,
      description: this.description
    };
  }
}

class DaggerEnumClass extends Locatable {
  node;
  ast;
  name;
  description;
  values = {};
  symbol;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    if (!this.node.name) {
      throw new IntrospectionError(`could not resolve name of enum at ${AST.getNodePosition(node2)}.`);
    }
    this.name = this.node.name.getText();
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    const properties = this.node.members;
    for (const property of properties) {
      if (ts4.isPropertyDeclaration(property)) {
        const value = new DaggerEnumClassValue(property, this.ast);
        this.values[value.name] = value;
      }
    }
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      values: this.values
    };
  }
}
// src/module/introspector/dagger_module/function.ts
init_errors();
class DaggerFunction extends Locatable {
  node;
  ast;
  name;
  description;
  _returnTypeRef;
  returnType;
  alias;
  arguments = {};
  signature;
  symbol;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    this.symbol = this.ast.getSymbolOrThrow(node2.name);
    this.signature = this.ast.getSignatureFromFunctionOrThrow(node2);
    this.name = this.node.name.getText();
    this.description = this.ast.getDocFromSymbol(this.symbol);
    for (const parameter of this.node.parameters) {
      this.arguments[parameter.name.getText()] = new DaggerArgument(parameter, this.ast);
    }
    this.returnType = this.getReturnType();
    this.alias = this.getAlias();
  }
  getReturnType() {
    const type2 = this.signature.getReturnType();
    const typedef = this.ast.tsTypeToTypeDef(this.node, type2);
    if (typedef === undefined || !isTypeDefResolved(typedef)) {
      this._returnTypeRef = this.ast.typeToStringType(type2);
    }
    return typedef;
  }
  getAlias() {
    const alias = this.ast.getDecoratorArgument(this.node, FUNCTION_DECORATOR, "string");
    if (!alias) {
      return;
    }
    return JSON.parse(alias.replace(/'/g, '"'));
  }
  getArgsOrder() {
    return Object.keys(this.arguments);
  }
  getReferences() {
    const references = [];
    if (this._returnTypeRef && (this.returnType === undefined || !isTypeDefResolved(this.returnType))) {
      references.push(this._returnTypeRef);
    }
    for (const argument3 of Object.values(this.arguments)) {
      const reference = argument3.getReference();
      if (reference) {
        references.push(reference);
      }
    }
    return references;
  }
  propagateReferences(references) {
    for (const argument3 of Object.values(this.arguments)) {
      argument3.propagateReferences(references);
    }
    if (!this._returnTypeRef) {
      return;
    }
    if (this.returnType && isTypeDefResolved(this.returnType)) {
      return;
    }
    const typeDef = references[this._returnTypeRef];
    if (!typeDef) {
      throw new IntrospectionError(`could not find type reference for ${this._returnTypeRef} at ${AST.getNodePosition(this.node)}.`);
    }
    this.returnType = resolveTypeDef(this.returnType, typeDef);
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      alias: this.alias,
      arguments: this.arguments,
      returnType: this.returnType
    };
  }
}
// src/module/introspector/dagger_module/module.ts
import ts9 from "typescript";
init_errors();

// src/module/introspector/dagger_module/interface.ts
init_errors();
import ts6 from "typescript";

// src/module/introspector/dagger_module/interfaceFunction.ts
init_errors();
import ts5 from "typescript";
class DaggerInterfaceFunction extends Locatable {
  node;
  ast;
  name;
  description;
  _returnTypeRef;
  returnType;
  arguments = {};
  alias;
  symbol;
  signature;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    if (!this.node.name) {
      throw new IntrospectionError(`could not resolve name of interface function at ${AST.getNodePosition(node2)}`);
    }
    this.name = this.node.name.getText();
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    const nodeType = this.node.type && ts5.isFunctionTypeNode(this.node.type) ? this.node.type : this.node;
    const signature = this.ast.getSignatureFromFunctionOrThrow(nodeType);
    for (const parameter of nodeType.parameters) {
      this.arguments[parameter.name.getText()] = new DaggerArgument(parameter, this.ast);
    }
    const signatureReturnType = signature.getReturnType();
    const typedef = this.ast.tsTypeToTypeDef(this.node, signatureReturnType);
    if (typedef === undefined || !isTypeDefResolved(typedef)) {
      this._returnTypeRef = this.ast.typeToStringType(signatureReturnType);
    }
    this.returnType = typedef;
  }
  getReferences() {
    const references = [];
    if (this._returnTypeRef && (this.returnType === undefined || !isTypeDefResolved(this.returnType))) {
      references.push(this._returnTypeRef);
    }
    for (const argument3 of Object.values(this.arguments)) {
      const reference = argument3.getReference();
      if (reference) {
        references.push(reference);
      }
    }
    return references;
  }
  propagateReferences(references) {
    for (const argument3 of Object.values(this.arguments)) {
      argument3.propagateReferences(references);
    }
    if (!this._returnTypeRef) {
      return;
    }
    if (this.returnType && isTypeDefResolved(this.returnType)) {
      return;
    }
    const typeDef = references[this._returnTypeRef];
    if (!typeDef) {
      throw new IntrospectionError(`could not find type reference for ${this._returnTypeRef} at ${AST.getNodePosition(this.node)}.`);
    }
    this.returnType = resolveTypeDef(this.returnType, typeDef);
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      arguments: this.arguments,
      returnType: this.returnType
    };
  }
}

// src/module/introspector/dagger_module/interface.ts
class DaggerInterface extends Locatable {
  node;
  ast;
  name;
  description;
  functions = {};
  symbol;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    if (!this.node.name) {
      throw new IntrospectionError(`could not resolve name of interface at ${AST.getNodePosition(node2)}`);
    }
    this.name = this.node.name.getText();
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    for (const member of this.node.members) {
      if (!ts6.isPropertySignature(member) && !ts6.isMethodSignature(member)) {
        continue;
      }
      if (member.type && ts6.isFunctionTypeNode(member.type) || ts6.isMethodSignature(member)) {
        const daggerInterfaceFunction = new DaggerInterfaceFunction(member, this.ast);
        this.functions[daggerInterfaceFunction.name] = daggerInterfaceFunction;
        continue;
      }
    }
  }
  getReferences() {
    const references = [];
    for (const fn of Object.values(this.functions)) {
      references.push(...fn.getReferences());
    }
    return references.filter((v, i3, arr) => arr.indexOf(v) === i3);
  }
  propagateReferences(references) {
    for (const fn of Object.values(this.functions)) {
      fn.propagateReferences(references);
    }
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      functions: this.functions
    };
  }
}

// src/module/introspector/dagger_module/object.ts
init_errors();
import ts7 from "typescript";

// src/module/introspector/dagger_module/property.ts
init_errors();
class DaggerProperty extends Locatable {
  node;
  ast;
  name;
  description;
  alias;
  isExposed;
  symbol;
  _typeRef;
  type;
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    if (!this.node.name) {
      throw new IntrospectionError(`could not resolve name of class at ${AST.getNodePosition(node2)}.`);
    }
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.name = this.node.name.getText();
    this.isExposed = this.ast.isNodeDecoratedWith(this.node, FUNCTION_DECORATOR) || this.ast.isNodeDecoratedWith(this.node, FIELD_DECORATOR);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    this.alias = this.getAlias();
    this.type = this.getType();
  }
  getAlias() {
    let alias = this.ast.getDecoratorArgument(this.node, FUNCTION_DECORATOR, "string");
    if (alias) {
      return JSON.parse(alias.replace(/'/g, '"'));
    }
    alias = this.ast.getDecoratorArgument(this.node, FIELD_DECORATOR, "string");
    if (alias) {
      return JSON.parse(alias.replace(/'/g, '"'));
    }
  }
  getType() {
    const type2 = this.ast.checker.getTypeAtLocation(this.node);
    const typedef = this.ast.tsTypeToTypeDef(this.node, type2);
    if (typedef === undefined || !isTypeDefResolved(typedef)) {
      this._typeRef = this.ast.typeToStringType(type2);
    }
    return typedef;
  }
  getReference() {
    if (this._typeRef && (this.type === undefined || !isTypeDefResolved(this.type))) {
      return this._typeRef;
    }
    return;
  }
  propagateReferences(references) {
    if (!this._typeRef) {
      return;
    }
    if (this.type && isTypeDefResolved(this.type)) {
      return;
    }
    const typeDef = references[this._typeRef];
    if (!typeDef) {
      throw new IntrospectionError(`could not find type reference for ${this._typeRef} at ${AST.getNodePosition(this.node)}.`);
    }
    this.type = resolveTypeDef(this.type, typeDef);
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      alias: this.alias,
      type: this.type,
      isExposed: this.isExposed
    };
  }
}

// src/module/introspector/dagger_module/object.ts
class DaggerObject extends Locatable {
  node;
  ast;
  name;
  description;
  _constructor = undefined;
  methods = {};
  properties = {};
  symbol;
  kind() {
    return "class";
  }
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    if (!this.node.name) {
      throw new IntrospectionError(`could not resolve name of class at ${AST.getNodePosition(node2)}.`);
    }
    this.name = this.node.name.getText();
    if (!this.ast.isNodeDecoratedWith(node2, OBJECT_DECORATOR)) {
      throw new IntrospectionError(`class ${this.name} at ${AST.getNodePosition(node2)} is used by the module but not exposed with a dagger decorator.`);
    }
    const modifiers = ts7.getCombinedModifierFlags(this.node);
    if (!(modifiers & ts7.ModifierFlags.Export)) {
      console.warn(`missing export in class ${this.name} at ${AST.getNodePosition(node2)} but it's used by the module.`);
    }
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    for (const member of this.node.members) {
      if (ts7.isPropertyDeclaration(member)) {
        const property = new DaggerProperty(member, this.ast);
        this.properties[property.alias ?? property.name] = property;
        continue;
      }
      if (ts7.isConstructorDeclaration(member)) {
        this._constructor = new DaggerConstructor(member, this.ast);
        continue;
      }
      if (ts7.isMethodDeclaration(member) && this.ast.isNodeDecoratedWith(member, FUNCTION_DECORATOR)) {
        const daggerFunction = new DaggerFunction(member, this.ast);
        this.methods[daggerFunction.alias ?? daggerFunction.name] = daggerFunction;
        continue;
      }
    }
  }
  getLocation() {
    return AST.getNodeLocation(this.node);
  }
  getReferences() {
    const references = [];
    if (this._constructor) {
      references.push(...this._constructor.getReferences());
    }
    for (const property of Object.values(this.properties)) {
      const ref = property.getReference();
      if (ref) {
        references.push(ref);
      }
    }
    for (const fn of Object.values(this.methods)) {
      references.push(...fn.getReferences());
    }
    return references.filter((v, i3, arr) => arr.indexOf(v) === i3);
  }
  propagateReferences(references) {
    if (this._constructor) {
      this._constructor.propagateReferences(references);
    }
    for (const property of Object.values(this.properties)) {
      property.propagateReferences(references);
    }
    for (const fn of Object.values(this.methods)) {
      fn.propagateReferences(references);
    }
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      constructor: this._constructor,
      methods: this.methods,
      properties: this.properties
    };
  }
}

// src/module/introspector/dagger_module/typeObject.ts
init_errors();
import ts8 from "typescript";

// src/module/introspector/dagger_module/typeObjectProperty.ts
init_errors();
class DaggerObjectTypeProperty extends Locatable {
  node;
  symbol;
  ast;
  name;
  description;
  alias = undefined;
  isExposed = true;
  _typeRef;
  type;
  constructor(node2, symbol, ast2) {
    super(node2);
    this.node = node2;
    this.symbol = symbol;
    this.ast = ast2;
    this.name = symbol.name;
    this.description = this.ast.getDocFromSymbol(this.symbol);
    const type2 = this.ast.checker.getTypeOfSymbolAtLocation(this.symbol, this.node);
    this.type = this.ast.tsTypeToTypeDef(this.node, type2);
    if (this.type === undefined || !isTypeDefResolved(this.type)) {
      this._typeRef = this.ast.typeToStringType(type2);
    }
  }
  getReference() {
    if (this._typeRef && (this.type === undefined || !isTypeDefResolved(this.type))) {
      return this._typeRef;
    }
    return;
  }
  propagateReferences(references) {
    if (!this._typeRef) {
      return;
    }
    if (this.type && isTypeDefResolved(this.type)) {
      return;
    }
    const typeDef = references[this._typeRef];
    if (!typeDef) {
      throw new IntrospectionError(`could not find type reference for ${this._typeRef}.`);
    }
    this.type = resolveTypeDef(this.type, typeDef);
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      alias: this.alias,
      type: this.type,
      isExposed: this.isExposed
    };
  }
}

// src/module/introspector/dagger_module/typeObject.ts
class DaggerTypeObject extends Locatable {
  node;
  ast;
  name;
  description;
  _constructor = undefined;
  methods = {};
  properties = {};
  symbol;
  kind() {
    return "object";
  }
  constructor(node2, ast2) {
    super(node2);
    this.node = node2;
    this.ast = ast2;
    if (!this.node.name) {
      throw new IntrospectionError(`could not resolve name of enum at ${AST.getNodePosition(node2)}.`);
    }
    this.name = this.node.name.getText();
    this.symbol = this.ast.getSymbolOrThrow(this.node.name);
    this.description = this.ast.getDocFromSymbol(this.symbol);
    const type2 = this.ast.getTypeFromTypeAlias(this.node);
    if (type2.flags & ts8.TypeFlags.Object) {
      const objectType = type2;
      const properties = objectType.getProperties();
      for (const property of properties) {
        const daggerProperty = new DaggerObjectTypeProperty(this.node, property, this.ast);
        this.properties[daggerProperty.name] = daggerProperty;
      }
    }
  }
  getLocation() {
    return AST.getNodeLocation(this.node);
  }
  getReferences() {
    const references = [];
    for (const property of Object.values(this.properties)) {
      const ref = property.getReference();
      if (ref) {
        references.push(ref);
      }
    }
    return references.filter((v, i3, arr) => arr.indexOf(v) === i3);
  }
  propagateReferences(references) {
    for (const property of Object.values(this.properties)) {
      property.propagateReferences(references);
    }
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      properties: this.properties
    };
  }
}

// src/module/introspector/dagger_module/module.ts
class DaggerModule {
  name;
  userModule;
  ast;
  objects = {};
  enums = {};
  interfaces = {};
  description;
  references = {
    float: { kind: "FLOAT_KIND" /* FloatKind */ }
  };
  constructor(name2, userModule2, ast2) {
    this.name = name2;
    this.userModule = userModule2;
    this.ast = ast2;
    const mainModule = findModuleByExportedName(this.name, this.userModule);
    if (!mainModule) {
      console.warn(`could not find module entrypoint: class ${this.name} from import. Class should be exported to benefit from all features.`);
    }
    const mainObjectNode = this.ast.findResolvedNodeByName(this.name, ts9.SyntaxKind.ClassDeclaration);
    if (!mainObjectNode) {
      throw new IntrospectionError(`could not find main object ${this.name} in module ${JSON.stringify(mainModule, null, 2) ?? ""} located at ${this.ast.files}`);
    }
    const mainFileContent = mainObjectNode.file.getFullText();
    this.description = this.getDescription(mainFileContent);
    const mainDaggerObject = new DaggerObject(mainObjectNode.node, this.ast);
    this.objects[this.name] = mainDaggerObject;
    this.references[this.name] = {
      kind: "OBJECT_KIND" /* ObjectKind */,
      name: this.name
    };
    this.resolveReferences(mainDaggerObject.getReferences());
    this.propagateReferences();
  }
  resolveReferences(references) {
    if (references.length === 0) {
      return;
    }
    for (const reference of references) {
      if (this.references[reference]) {
        continue;
      }
      const classRef = this.ast.findResolvedNodeByName(reference, ts9.SyntaxKind.ClassDeclaration);
      if (classRef) {
        if (classRef.file.fileName.endsWith(CLIENT_GEN_FILE)) {
          this.references[reference] = {
            kind: "OBJECT_KIND" /* ObjectKind */,
            name: reference
          };
          continue;
        }
        if (this.ast.isNodeDecoratedWith(classRef.node, OBJECT_DECORATOR)) {
          const daggerObject = new DaggerObject(classRef.node, this.ast);
          this.objects[daggerObject.name] = daggerObject;
          this.references[daggerObject.name] = {
            kind: "OBJECT_KIND" /* ObjectKind */,
            name: daggerObject.name
          };
          this.resolveReferences(daggerObject.getReferences());
          continue;
        }
        if (this.ast.isNodeDecoratedWith(classRef.node, ENUM_DECORATOR)) {
          const daggerEnum = new DaggerEnumClass(classRef.node, this.ast);
          this.enums[daggerEnum.name] = daggerEnum;
          this.references[daggerEnum.name] = {
            kind: "ENUM_KIND" /* EnumKind */,
            name: daggerEnum.name
          };
          continue;
        }
        throw new IntrospectionError(`class ${reference} in ${AST.getNodePosition(classRef.node)} is used by the module but not exposed with a dagger decorator.`);
      }
      const enumRef = this.ast.findResolvedNodeByName(reference, ts9.SyntaxKind.EnumDeclaration);
      if (enumRef) {
        if (enumRef.file.fileName.endsWith(CLIENT_GEN_FILE)) {
          this.references[reference] = {
            kind: "ENUM_KIND" /* EnumKind */,
            name: reference
          };
          continue;
        }
        const daggerEnum = new DaggerEnum(enumRef.node, this.ast);
        this.enums[daggerEnum.name] = daggerEnum;
        this.references[daggerEnum.name] = {
          kind: "ENUM_KIND" /* EnumKind */,
          name: daggerEnum.name
        };
        continue;
      }
      const interfaceRef = this.ast.findResolvedNodeByName(reference, ts9.SyntaxKind.InterfaceDeclaration);
      if (interfaceRef) {
        const daggerInterface = new DaggerInterface(interfaceRef.node, this.ast);
        this.interfaces[daggerInterface.name] = daggerInterface;
        this.references[daggerInterface.name] = {
          kind: "INTERFACE_KIND" /* InterfaceKind */,
          name: daggerInterface.name
        };
        this.resolveReferences(daggerInterface.getReferences());
        continue;
      }
      const typeAliasRef = this.ast.findResolvedNodeByName(reference, ts9.SyntaxKind.TypeAliasDeclaration);
      if (typeAliasRef) {
        this.resolveTypeAlias(reference, typeAliasRef);
        continue;
      }
      if (reference === "String") {
        throw new IntrospectionError(`Use of primitive 'String' type detected, please use 'string' instead.`);
      }
      if (reference === "Boolean") {
        throw new IntrospectionError(`Use of primitive 'Boolean' type detected, please use 'boolean' instead.`);
      }
      if (reference === "Number") {
        throw new IntrospectionError(`Use of primitive 'Number' type detected, please use 'number' instead.`);
      }
      throw new IntrospectionError(`could not resolve type reference for ${reference}.`);
    }
  }
  resolveTypeAlias(reference, typeAlias) {
    const type2 = this.ast.getTypeFromTypeAlias(typeAlias.node);
    if (type2.flags & ts9.TypeFlags.String) {
      this.references[reference] = { kind: "STRING_KIND" /* StringKind */ };
      return;
    }
    if (type2.flags & ts9.TypeFlags.Number) {
      this.references[reference] = { kind: "INTEGER_KIND" /* IntegerKind */ };
      return;
    }
    if (type2.flags & ts9.TypeFlags.Boolean) {
      this.references[reference] = { kind: "BOOLEAN_KIND" /* BooleanKind */ };
      return;
    }
    if (type2.flags & ts9.TypeFlags.Void) {
      this.references[reference] = { kind: "VOID_KIND" /* VoidKind */ };
      return;
    }
    if (type2.flags & ts9.TypeFlags.Intersection || type2.flags & ts9.TypeFlags.Union) {
      this.references[reference] = {
        kind: "SCALAR_KIND" /* ScalarKind */,
        name: reference
      };
      return;
    }
    if (type2.flags & ts9.TypeFlags.Object) {
      if (typeAlias.file.fileName.endsWith(CLIENT_GEN_FILE)) {
        this.references[reference] = {
          kind: "OBJECT_KIND" /* ObjectKind */,
          name: reference
        };
        return;
      }
      const daggerObject = new DaggerTypeObject(typeAlias.node, this.ast);
      this.objects[daggerObject.name] = daggerObject;
      this.references[daggerObject.name] = {
        kind: "OBJECT_KIND" /* ObjectKind */,
        name: daggerObject.name
      };
      this.resolveReferences(daggerObject.getReferences());
      return;
    }
    throw new IntrospectionError(`could not resolve type reference for ${reference} at ${AST.getNodePosition(typeAlias.node)}`);
  }
  propagateReferences() {
    for (const object2 of Object.values(this.objects)) {
      object2.propagateReferences(this.references);
    }
    for (const interface_ of Object.values(this.interfaces)) {
      interface_.propagateReferences(this.references);
    }
  }
  getDescription(sourceFileContent) {
    const regex = /^(?!.*import)[\s]*\/\*\*([\s\S]*?)\*\//;
    const match = sourceFileContent.match(regex);
    if (!match) {
      return;
    }
    const comment = match[1].split(`
`).map((line) => line.replace(/^\s*\*\s?/, "")).join(`
`);
    return comment.trim();
  }
  toJSON() {
    return {
      name: this.name,
      description: this.description,
      objects: this.objects,
      enums: this.enums,
      interfaces: this.interfaces
    };
  }
}
// src/module/entrypoint/load.ts
async function load2(files2) {
  return await Promise.all(files2.map(async (f3) => await import(f3)));
}
function loadInvokedObject(module2, parentName) {
  return module2.objects[parentName];
}
function loadInvokedMethod(object3, ctx) {
  if (ctx.fnName === "") {
    return object3._constructor;
  }
  return object3.methods[ctx.fnName];
}
async function loadArgs(executor, method, ctx) {
  const args = {};
  for (const argName of method.getArgsOrder()) {
    const argument4 = method.arguments[argName];
    if (!argument4) {
      throw new Error(`could not find argument ${argName}`);
    }
    if (!argument4.type) {
      throw new Error(`could not find type for argument ${argName}`);
    }
    const loadedArg = await loadValue(executor, ctx.fnArgs[argName], argument4.type);
    if (argument4.isVariadic) {
      for (const [i3, arg] of (loadedArg ?? []).entries()) {
        args[`${argName}${i3}`] = arg;
      }
      continue;
    }
    if (argument4.isNullable && loadedArg === undefined && !argument4.defaultValue) {
      args[argName] = null;
      continue;
    }
    args[argName] = loadedArg;
  }
  return args;
}
async function loadParentState(executor, object3, ctx) {
  const parentState = {};
  for (const [key, value] of Object.entries(ctx.parentArgs)) {
    const property = object3.properties[key];
    if (!property) {
      throw new Error(`could not find parent property ${key}`);
    }
    if (!property.type) {
      throw new Error(`could not find type for parent property ${key}`);
    }
    parentState[property.name] = await loadValue(executor, value, property.type);
  }
  return parentState;
}
async function loadValue(executor, value, type2) {
  if (value === undefined) {
    return value;
  }
  switch (type2.kind) {
    case "LIST_KIND" /* ListKind */:
      return Promise.all(value.map(async (v) => await loadValue(executor, v, type2.typeDef)));
    case "OBJECT_KIND" /* ObjectKind */: {
      const objectType = type2.name;
      if (dag[`load${objectType}FromID`]) {
        return dag[`load${objectType}FromID`](value);
      }
      return executor.buildClass(objectType, value);
    }
    case "INTERFACE_KIND" /* InterfaceKind */: {
      const interfaceType = type2.name;
      return executor.buildInterface(interfaceType, value);
    }
    case "STRING_KIND" /* StringKind */:
    case "INTEGER_KIND" /* IntegerKind */:
    case "BOOLEAN_KIND" /* BooleanKind */:
    case "FLOAT_KIND" /* FloatKind */:
    case "VOID_KIND" /* VoidKind */:
    case "SCALAR_KIND" /* ScalarKind */:
    case "ENUM_KIND" /* EnumKind */:
      return value;
    default:
      throw new Error(`unsupported type ${type2.kind}`);
  }
}
function loadObjectReturnType(module2, object3, method) {
  const retType = method.returnType;
  if (!retType) {
    throw new Error(`could not find return type for ${method.name}`);
  }
  switch (retType.kind) {
    case "LIST_KIND" /* ListKind */: {
      let listType = retType;
      while (listType.kind === "LIST_KIND" /* ListKind */) {
        listType = listType.typeDef;
      }
      return module2.objects[listType.name];
    }
    case "OBJECT_KIND" /* ObjectKind */:
      return module2.objects[retType.name];
    case "ENUM_KIND" /* EnumKind */:
      return module2.enums[retType.name];
    default:
      return object3;
  }
}
async function loadResult(result, module2, object3) {
  if (result && typeof result?.id === "function") {
    return await result.id();
  }
  if (Array.isArray(result)) {
    result = await Promise.all(result.map(async (r2) => await loadResult(r2, module2, object3)));
    return result;
  }
  if (typeof result === "object" && (object3 instanceof DaggerObject || object3 instanceof DaggerTypeObject)) {
    const state = {};
    for (const [key, value] of Object.entries(result)) {
      const property = Object.values(object3.properties).find((p) => p.name === key);
      if (!property) {
        throw new Error(`could not find result property ${key}`);
      }
      if (!property.type) {
        throw new Error(`could not find type for result property ${key}`);
      }
      let referencedObject = undefined;
      if (property.type.kind === "OBJECT_KIND" /* ObjectKind */) {
        referencedObject = module2.objects[property.type.name];
      }
      if (property.type.kind === "LIST_KIND" /* ListKind */) {
        let _property = property.type;
        while (_property.kind === "LIST_KIND" /* ListKind */) {
          _property = _property.typeDef;
        }
        if (_property.kind === "OBJECT_KIND" /* ObjectKind */) {
          referencedObject = module2.objects[_property.name];
        }
      }
      if (!referencedObject) {
        referencedObject = object3;
      }
      state[property.alias ?? property.name] = await loadResult(value, module2, referencedObject);
    }
    return state;
  }
  if (typeof result === "object" && object3 instanceof DaggerEnum) {
    return result;
  }
  return result;
}

// src/module/introspector/case_convertor.ts
function convertToPascalCase(input) {
  if (!input) {
    return "";
  }
  const words = input.split(/(?=[A-Z0-9])|[^a-zA-Z0-9]|(?<=[a-zA-Z])(?=\d)|(?<=\d)(?=[a-zA-Z])/g).filter((word) => word.length > 0);
  const pascalCase = words.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join("");
  return pascalCase;
}

// src/module/introspector/index.ts
async function scan(files2, moduleName2 = "") {
  if (files2.length === 0) {
    throw new IntrospectionError("no files to introspect found");
  }
  const formattedModuleName = convertToPascalCase(moduleName2);
  const userModule2 = await load2(files2);
  const ast2 = new AST(files2, userModule2);
  const module2 = new DaggerModule(formattedModuleName, userModule2, ast2);
  return module2;
}

// src/module/entrypoint/invoke.ts
init_errors();
function isConstructor(method) {
  return method.name === "";
}
function isFloat(num) {
  return num % 1 !== 0;
}
async function invoke(executor, module2, ctx) {
  const object3 = loadInvokedObject(module2, ctx.parentName);
  if (!object3) {
    throw new Error(`could not find object ${ctx.parentName}`);
  }
  const method = loadInvokedMethod(object3, ctx);
  if (!method) {
    throw new Error(`could not find method ${ctx.fnName}`);
  }
  const args = await loadArgs(executor, method, ctx);
  const parentState = await loadParentState(executor, object3, ctx);
  let result = {};
  try {
    result = await executor.getResult(object3.name, method.name, parentState, args);
  } catch (e2) {
    if (e2 instanceof FunctionNotFound) {
      result = await registry.getResult(object3.name, method.name, parentState, args);
    } else {
      throw e2;
    }
  }
  if (result) {
    let returnType;
    if (!isConstructor(method)) {
      if (method.returnType.kind === "INTEGER_KIND" /* IntegerKind */ && isFloat(result)) {
        throw new Error(`cannot return float '${result}' if return type is 'number' (integer), please use 'float' as return type instead`);
      }
      returnType = loadObjectReturnType(module2, object3, method);
    } else {
      returnType = object3;
    }
    result = await loadResult(result, module2, returnType);
  }
  return result;
}

// src/module/entrypoint/register.ts
async function register(files2, module2) {
  let mod2 = dag.module_();
  if (module2.description) {
    mod2 = mod2.withDescription(module2.description);
  }
  Object.values(module2.objects).forEach((object3) => {
    let typeDef = dag.typeDef().withObject(object3.name, {
      description: object3.description,
      sourceMap: addSourceMap(object3)
    });
    Object.values(object3.methods).forEach((method) => {
      typeDef = typeDef.withFunction(addFunction(method));
    });
    Object.values(object3.properties).forEach((field2) => {
      if (field2.isExposed) {
        typeDef = typeDef.withField(field2.alias ?? field2.name, addTypeDef(field2.type), {
          description: field2.description,
          sourceMap: addSourceMap(field2)
        });
      }
    });
    if (object3._constructor) {
      typeDef = typeDef.withConstructor(addConstructor(object3._constructor, typeDef));
    }
    mod2 = mod2.withObject(typeDef);
  });
  Object.values(module2.enums).forEach((enum_) => {
    let typeDef = dag.typeDef().withEnum(enum_.name, {
      description: enum_.description,
      sourceMap: addSourceMap(enum_)
    });
    Object.values(enum_.values).forEach((value) => {
      typeDef = typeDef.withEnumValue(value.value, {
        description: value.description,
        sourceMap: addSourceMap(value)
      });
    });
    mod2 = mod2.withEnum(typeDef);
  });
  Object.values(module2.interfaces).forEach((interface_) => {
    let typeDef = dag.typeDef().withInterface(interface_.name, {
      description: interface_.description
    });
    Object.values(interface_.functions).forEach((function_) => {
      typeDef = typeDef.withFunction(addFunction(function_));
    });
    mod2 = mod2.withInterface(typeDef);
  });
  return await mod2.id();
}
function addConstructor(constructor2, owner) {
  return dag.function_("", owner).with(addArg(constructor2.arguments));
}
function addFunction(fct) {
  return dag.function_(fct.alias ?? fct.name, addTypeDef(fct.returnType)).withDescription(fct.description).withSourceMap(addSourceMap(fct)).with(addArg(fct.arguments));
}
function addArg(args) {
  return function(fct) {
    Object.values(args).forEach((arg) => {
      const opts = {
        description: arg.description,
        sourceMap: addSourceMap(arg)
      };
      let typeDef = addTypeDef(arg.type);
      if (arg.isOptional) {
        typeDef = typeDef.withOptional(true);
      }
      if (arg.defaultValue && arg.defaultPath) {
        throw new Error("cannot set both default value and default path from context");
      }
      if (arg.defaultValue !== undefined) {
        if (isPrimitiveType(arg.type)) {
          opts.defaultValue = JSON.stringify(arg.defaultValue);
        } else {
          typeDef = typeDef.withOptional(true);
        }
      }
      if (arg.defaultPath) {
        opts.defaultPath = arg.defaultPath;
      }
      if (arg.ignore) {
        opts.ignore = arg.ignore;
      }
      fct = fct.withArg(arg.name, typeDef, opts);
    });
    return fct;
  };
}
function addTypeDef(type2) {
  switch (type2.kind) {
    case "SCALAR_KIND" /* ScalarKind */:
      return dag.typeDef().withScalar(type2.name);
    case "OBJECT_KIND" /* ObjectKind */:
      return dag.typeDef().withObject(type2.name);
    case "LIST_KIND" /* ListKind */:
      return dag.typeDef().withListOf(addTypeDef(type2.typeDef));
    case "VOID_KIND" /* VoidKind */:
      return dag.typeDef().withKind(type2.kind).withOptional(true);
    case "ENUM_KIND" /* EnumKind */:
      return dag.typeDef().withEnum(type2.name);
    case "INTERFACE_KIND" /* InterfaceKind */:
      return dag.typeDef().withInterface(type2.name);
    default:
      return dag.typeDef().withKind(type2.kind);
  }
}
function addSourceMap(object3) {
  const { filepath, line, column } = object3.getLocation();
  return dag.sourceMap(filepath, line, column);
}
function isPrimitiveType(type2) {
  return type2.kind === "BOOLEAN_KIND" /* BooleanKind */ || type2.kind === "INTEGER_KIND" /* IntegerKind */ || type2.kind === "STRING_KIND" /* StringKind */ || type2.kind === "FLOAT_KIND" /* FloatKind */ || type2.kind === "ENUM_KIND" /* EnumKind */;
}

// src/module/entrypoint/entrypoint.ts
async function entrypoint(files2) {
  await connection(async () => {
    const fnCall = dag.currentFunctionCall();
    const moduleName2 = await dag.currentModule().name();
    const parentName = await fnCall.parentName();
    const scanResult = await scan(files2, moduleName2);
    let result;
    if (parentName === "") {
      result = await register(files2, scanResult);
    } else {
      const fnName = await fnCall.name();
      const parentJson = JSON.parse(await fnCall.parent());
      const fnArgs = await fnCall.inputArgs();
      const args = {};
      const parentArgs = parentJson ?? {};
      for (const arg of fnArgs) {
        args[await arg.name()] = JSON.parse(await arg.value());
      }
      const modules = await load2(files2);
      const executor = new Executor(modules, scanResult);
      try {
        result = await invoke(executor, scanResult, {
          parentName,
          fnName,
          parentArgs,
          fnArgs: args
        });
      } catch (e2) {
        await fnCall.returnError(formatError(e2));
        process.exit(1);
      }
    }
    if (result !== undefined && result !== null) {
      result = JSON.stringify(result);
    } else {
      result = "null";
    }
    await fnCall.returnValue(result);
  }, { LogOutput: process.stdout });
}
function formatError(e2) {
  if (e2 instanceof Error) {
    let error = dag.error(e2.message);
    if (e2 instanceof ExecError || e2 instanceof GraphQLRequestError) {
      Object.entries(e2.extensions ?? []).forEach(([key, value]) => {
        if (value !== "" && value !== undefined && value !== null) {
          error = error.withValue(key, JSON.stringify(value));
        }
      });
    }
    return error;
  }
  try {
    return dag.error(JSON.stringify(e2));
  } catch {
    return dag.error(String(e2));
  }
}
export {
  object,
  getTracer,
  func,
  field,
  enumType,
  entrypoint,
  dag,
  connection,
  connect,
  argument2 as argument,
  UnknownDaggerError,
  TypeDefKind,
  TypeDef,
  TooManyNestedObjectsError,
  Terminal,
  SourceMap,
  Socket,
  Service,
  Secret,
  ScalarTypeDef,
  SDKConfig,
  ReturnType,
  Port,
  ObjectTypeDef,
  NotAwaitedRequestError,
  NetworkProtocol,
  Module_,
  ModuleSourceKind,
  ModuleSource,
  ModuleConfigClient,
  ListTypeDef,
  Label,
  LLMTokenUsage,
  LLM,
  IntrospectionError,
  InterfaceTypeDef,
  InputTypeDef,
  InitEngineSessionBinaryError,
  ImageMediaTypes,
  ImageLayerCompression,
  Host,
  GraphQLRequestError,
  GraphQLClient,
  GitRepository,
  GitRef,
  GeneratedCode,
  Function_,
  FunctionNotFound,
  FunctionCallArgValue,
  FunctionCall,
  FunctionArg,
  File,
  FieldTypeDef,
  ExecError,
  ErrorValue,
  Error2 as Error,
  EnvVariable,
  Env,
  EnumValueTypeDef,
  EnumTypeDef,
  EngineSessionError,
  EngineSessionConnectionTimeoutError,
  EngineSessionConnectParamsParseError,
  EngineCacheEntrySet,
  EngineCacheEntry,
  EngineCache,
  Engine,
  ERROR_CODES,
  DockerImageRefValidationError,
  Directory,
  DaggerSDKError,
  CurrentModule,
  Context,
  Container,
  Cloud,
  Client,
  CacheVolume,
  CacheSharingMode,
  Binding
};
